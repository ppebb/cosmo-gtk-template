#include "glib.h"
#include "gio/gio.h"

#ifndef SYMS_GIO_H
#define SYMS_GIO_H

struct gio_syms {
    void *lib;
    // SYMS_gio_HERE
    const gchar * (*action_get_name)(GAction *action);
    const GVariantType * (*action_get_parameter_type)(GAction *action);
    const GVariantType * (*action_get_state_type)(GAction *action);
    GVariant * (*action_get_state_hint)(GAction *action);
    gboolean (*action_get_enabled)(GAction *action);
    GVariant * (*action_get_state)(GAction *action);
    void (*action_change_state)(GAction *action, GVariant *value);
    void (*action_activate)(GAction *action, GVariant *parameter);
    gboolean (*action_name_is_valid)(const gchar *action_name);
    gboolean (*action_parse_detailed_name)(const gchar *detailed_name, gchar **action_name, GVariant **target_value, GError **error);
    gchar * (*action_print_detailed_name)(const gchar *action_name, GVariant *target_value);
    GType (*action_get_type)(void);
    gboolean (*action_group_has_action)(GActionGroup *action_group, const gchar *action_name);
    gchar ** (*action_group_list_actions)(GActionGroup *action_group);
    const GVariantType * (*action_group_get_action_parameter_type)(GActionGroup *action_group, const gchar *action_name);
    const GVariantType * (*action_group_get_action_state_type)(GActionGroup *action_group, const gchar *action_name);
    GVariant * (*action_group_get_action_state_hint)(GActionGroup *action_group, const gchar *action_name);
    gboolean (*action_group_get_action_enabled)(GActionGroup *action_group, const gchar *action_name);
    GVariant * (*action_group_get_action_state)(GActionGroup *action_group, const gchar *action_name);
    void (*action_group_change_action_state)(GActionGroup *action_group, const gchar *action_name, GVariant *value);
    void (*action_group_activate_action)(GActionGroup *action_group, const gchar *action_name, GVariant *parameter);
    void (*action_group_action_added)(GActionGroup *action_group, const gchar *action_name);
    void (*action_group_action_removed)(GActionGroup *action_group, const gchar *action_name);
    void (*action_group_action_enabled_changed)(GActionGroup *action_group, const gchar *action_name, gboolean enabled);
    void (*action_group_action_state_changed)(GActionGroup *action_group, const gchar *action_name, GVariant *state);
    gboolean (*action_group_query_action)(GActionGroup *action_group, const gchar *action_name, gboolean *enabled, const GVariantType **parameter_type, const GVariantType **state_type, GVariant **state_hint, GVariant **state);
    GType (*action_group_get_type)(void);
    void (*dbus_connection_unexport_action_group)(GDBusConnection *connection, guint export_id);
    guint (*dbus_connection_export_action_group)(GDBusConnection *connection, const gchar *object_path, GActionGroup *action_group, GError **error);
    GAction * (*action_map_lookup_action)(GActionMap *action_map, const gchar *action_name);
    void (*action_map_add_action)(GActionMap *action_map, GAction *action);
    void (*action_map_remove_action)(GActionMap *action_map, const gchar *action_name);
    void (*action_map_add_action_entries)(GActionMap *action_map, const GActionEntry *entries, gint n_entries, gpointer user_data);
    void (*action_map_remove_action_entries)(GActionMap *action_map, const GActionEntry *entries, gint n_entries);
    GType (*action_map_get_type)(void);
    GAppInfo * (*app_info_create_from_commandline)(const char *commandline, const char *application_name, GAppInfoCreateFlags flags, GError **error);
    GAppInfo * (*app_info_dup)(GAppInfo *appinfo);
    gboolean (*app_info_equal)(GAppInfo *appinfo1, GAppInfo *appinfo2);
    const char* (*app_info_get_id)(GAppInfo *appinfo);
    const char* (*app_info_get_name)(GAppInfo *appinfo);
    const char* (*app_info_get_display_name)(GAppInfo *appinfo);
    const char* (*app_info_get_description)(GAppInfo *appinfo);
    const char* (*app_info_get_executable)(GAppInfo *appinfo);
    const char* (*app_info_get_commandline)(GAppInfo *appinfo);
    GIcon * (*app_info_get_icon)(GAppInfo *appinfo);
    gboolean (*app_info_launch)(GAppInfo *appinfo, GList *files, GAppLaunchContext *context, GError **error);
    gboolean (*app_info_supports_uris)(GAppInfo *appinfo);
    gboolean (*app_info_supports_files)(GAppInfo *appinfo);
    gboolean (*app_info_launch_uris)(GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GError **error);
    void (*app_info_launch_uris_async)(GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*app_info_launch_uris_finish)(GAppInfo *appinfo, GAsyncResult *result, GError **error);
    gboolean (*app_info_should_show)(GAppInfo *appinfo);
    gboolean (*app_info_set_as_default_for_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    gboolean (*app_info_set_as_default_for_extension)(GAppInfo *appinfo, const char *extension, GError **error);
    gboolean (*app_info_add_supports_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    gboolean (*app_info_can_remove_supports_type)(GAppInfo *appinfo);
    gboolean (*app_info_remove_supports_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    const char** (*app_info_get_supported_types)(GAppInfo *appinfo);
    gboolean (*app_info_can_delete)(GAppInfo *appinfo);
    gboolean (*app_info_delete)(GAppInfo *appinfo);
    gboolean (*app_info_set_as_last_used_for_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    GList * (*app_info_get_all)(void);
    GList * (*app_info_get_all_for_type)(const char *content_type);
    GList * (*app_info_get_recommended_for_type)(const gchar *content_type);
    GList * (*app_info_get_fallback_for_type)(const gchar *content_type);
    void (*app_info_reset_type_associations)(const char *content_type);
    GAppInfo* (*app_info_get_default_for_type)(const char *content_type, gboolean must_support_uris);
    void (*app_info_get_default_for_type_async)(const char *content_type, gboolean must_support_uris, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GAppInfo* (*app_info_get_default_for_type_finish)(GAsyncResult *result, GError **error);
    GAppInfo* (*app_info_get_default_for_uri_scheme)(const char *uri_scheme);
    void (*app_info_get_default_for_uri_scheme_async)(const char *uri_scheme, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GAppInfo* (*app_info_get_default_for_uri_scheme_finish)(GAsyncResult *result, GError **error);
    gboolean (*app_info_launch_default_for_uri)(const char *uri, GAppLaunchContext *context, GError **error);
    void (*app_info_launch_default_for_uri_async)(const char *uri, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*app_info_launch_default_for_uri_finish)(GAsyncResult *result, GError **error);
    GType (*app_launch_context_get_type)(void);
    GAppLaunchContext* (*app_launch_context_new)(void);
    void (*app_launch_context_setenv)(GAppLaunchContext *context, const char *variable, const char *value);
    void (*app_launch_context_unsetenv)(GAppLaunchContext *context, const char *variable);
    char ** (*app_launch_context_get_environment)(GAppLaunchContext *context);
    char * (*app_launch_context_get_display)(GAppLaunchContext *context, GAppInfo *info, GList *files);
    char * (*app_launch_context_get_startup_notify_id)(GAppLaunchContext *context, GAppInfo *info, GList *files);
    void (*app_launch_context_launch_failed)(GAppLaunchContext *context, const char * startup_notify_id);
    GType (*app_info_monitor_get_type)(void);
    GAppInfoMonitor * (*app_info_monitor_get)(void);
    GType (*app_info_get_type)(void);
    gboolean (*application_id_is_valid)(const gchar *application_id);
    GApplication * (*application_new)(const gchar *application_id, GApplicationFlags flags);
    const gchar * (*application_get_application_id)(GApplication *application);
    void (*application_set_application_id)(GApplication *application, const gchar *application_id);
    const gchar * (*application_get_version)(GApplication *application);
    void (*application_set_version)(GApplication *application, const gchar *version);
    GDBusConnection * (*application_get_dbus_connection)(GApplication *application);
    const gchar * (*application_get_dbus_object_path)(GApplication *application);
    guint (*application_get_inactivity_timeout)(GApplication *application);
    void (*application_set_inactivity_timeout)(GApplication *application, guint inactivity_timeout);
    GApplicationFlags (*application_get_flags)(GApplication *application);
    void (*application_set_flags)(GApplication *application, GApplicationFlags flags);
    const gchar * (*application_get_resource_base_path)(GApplication *application);
    void (*application_set_resource_base_path)(GApplication *application, const gchar *resource_path);
    void (*application_set_action_group)(GApplication *application, GActionGroup *action_group);
    void (*application_add_main_option_entries)(GApplication *application, const GOptionEntry *entries);
    void (*application_add_main_option)(GApplication *application, const char *long_name, char short_name, GOptionFlags flags, GOptionArg arg, const char *description, const char *arg_description);
    void (*application_add_option_group)(GApplication *application, GOptionGroup *group);
    void (*application_set_option_context_parameter_string)(GApplication *application, const gchar *parameter_string);
    void (*application_set_option_context_summary)(GApplication *application, const gchar *summary);
    void (*application_set_option_context_description)(GApplication *application, const gchar *description);
    gboolean (*application_get_is_registered)(GApplication *application);
    gboolean (*application_get_is_remote)(GApplication *application);
    gboolean (*application_register)(GApplication *application, GCancellable *cancellable, GError **error);
    void (*application_hold)(GApplication *application);
    void (*application_release)(GApplication *application);
    void (*application_activate)(GApplication *application);
    void (*application_open)(GApplication *application, GFile **files, gint n_files, const gchar *hint);
    int (*application_run)(GApplication *application, int argc, char **argv);
    void (*application_quit)(GApplication *application);
    GApplication * (*application_get_default)(void);
    void (*application_set_default)(GApplication *application);
    void (*application_mark_busy)(GApplication *application);
    void (*application_unmark_busy)(GApplication *application);
    gboolean (*application_get_is_busy)(GApplication *application);
    void (*application_send_notification)(GApplication *application, const gchar *id, GNotification *notification);
    void (*application_withdraw_notification)(GApplication *application, const gchar *id);
    void (*application_bind_busy_property)(GApplication *application, gpointer object, const gchar *property);
    void (*application_unbind_busy_property)(GApplication *application, gpointer object, const gchar *property);
    GType (*application_get_type)(void);
    gchar ** (*application_command_line_get_arguments)(GApplicationCommandLine *cmdline, int *argc);
    GVariantDict * (*application_command_line_get_options_dict)(GApplicationCommandLine *cmdline);
    GInputStream * (*application_command_line_get_stdin)(GApplicationCommandLine *cmdline);
    const gchar * const * (*application_command_line_get_environ)(GApplicationCommandLine *cmdline);
    const gchar * (*application_command_line_getenv)(GApplicationCommandLine *cmdline, const gchar *name);
    const gchar * (*application_command_line_get_cwd)(GApplicationCommandLine *cmdline);
    gboolean (*application_command_line_get_is_remote)(GApplicationCommandLine *cmdline);
    void (*application_command_line_print_literal)(GApplicationCommandLine *cmdline, const gchar *message);
    void (*application_command_line_printerr_literal)(GApplicationCommandLine *cmdline, const gchar *message);
    void (*application_command_line_print)(GApplicationCommandLine *cmdline, const gchar *format, ...);
    void (*application_command_line_printerr)(GApplicationCommandLine *cmdline, const gchar *format, ...);
    int (*application_command_line_get_exit_status)(GApplicationCommandLine *cmdline);
    void (*application_command_line_set_exit_status)(GApplicationCommandLine *cmdline, int exit_status);
    GVariant * (*application_command_line_get_platform_data)(GApplicationCommandLine *cmdline);
    GFile * (*application_command_line_create_file_for_arg)(GApplicationCommandLine *cmdline, const gchar *arg);
    void (*application_command_line_done)(GApplicationCommandLine *cmdline);
    GType (*application_command_line_get_type)(void);
    void (*async_initable_init_async)(GAsyncInitable *initable, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*async_initable_init_finish)(GAsyncInitable *initable, GAsyncResult *res, GError **error);
    void (*async_initable_new_async)(GType object_type, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data, const gchar *first_property_name, ...);
    GObject* (*async_initable_new_finish)(GAsyncInitable *initable, GAsyncResult *res, GError **error);
    GType (*async_initable_get_type)(void);
    gpointer (*async_result_get_user_data)(GAsyncResult *res);
    GObject* (*async_result_get_source_object)(GAsyncResult *res);
    gboolean (*async_result_legacy_propagate_error)(GAsyncResult *res, GError **error);
    gboolean (*async_result_is_tagged)(GAsyncResult *res, gpointer source_tag);
    GType (*async_result_get_type)(void);
    GInputStream* (*buffered_input_stream_new)(GInputStream *base_stream);
    GInputStream* (*buffered_input_stream_new_sized)(GInputStream *base_stream, gsize size);
    gsize (*buffered_input_stream_get_buffer_size)(GBufferedInputStream *stream);
    void (*buffered_input_stream_set_buffer_size)(GBufferedInputStream *stream, gsize size);
    gsize (*buffered_input_stream_get_available)(GBufferedInputStream *stream);
    gsize (*buffered_input_stream_peek)(GBufferedInputStream *stream, void *buffer, gsize offset, gsize count);
    const void* (*buffered_input_stream_peek_buffer)(GBufferedInputStream *stream, gsize *count);
    gssize (*buffered_input_stream_fill)(GBufferedInputStream *stream, gssize count, GCancellable *cancellable, GError **error);
    void (*buffered_input_stream_fill_async)(GBufferedInputStream *stream, gssize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*buffered_input_stream_fill_finish)(GBufferedInputStream *stream, GAsyncResult *result, GError **error);
    int (*buffered_input_stream_read_byte)(GBufferedInputStream *stream, GCancellable *cancellable, GError **error);
    GType (*buffered_input_stream_get_type)(void);
    GOutputStream* (*buffered_output_stream_new)(GOutputStream *base_stream);
    GOutputStream* (*buffered_output_stream_new_sized)(GOutputStream *base_stream, gsize size);
    gsize (*buffered_output_stream_get_buffer_size)(GBufferedOutputStream *stream);
    void (*buffered_output_stream_set_buffer_size)(GBufferedOutputStream *stream, gsize size);
    gboolean (*buffered_output_stream_get_auto_grow)(GBufferedOutputStream *stream);
    void (*buffered_output_stream_set_auto_grow)(GBufferedOutputStream *stream, gboolean auto_grow);
    GType (*buffered_output_stream_get_type)(void);
    GIcon * (*bytes_icon_new)(GBytes *bytes);
    GBytes * (*bytes_icon_get_bytes)(GBytesIcon *icon);
    GType (*bytes_icon_get_type)(void);
    GCancellable* (*cancellable_new)(void);
    gboolean (*cancellable_is_cancelled)(GCancellable *cancellable);
    gboolean (*cancellable_set_error_if_cancelled)(GCancellable *cancellable, GError **error);
    int (*cancellable_get_fd)(GCancellable *cancellable);
    gboolean (*cancellable_make_pollfd)(GCancellable *cancellable, GPollFD *pollfd);
    void (*cancellable_release_fd)(GCancellable *cancellable);
    GSource * (*cancellable_source_new)(GCancellable *cancellable);
    GCancellable* (*cancellable_get_current)(void);
    void (*cancellable_push_current)(GCancellable *cancellable);
    void (*cancellable_pop_current)(GCancellable *cancellable);
    void (*cancellable_reset)(GCancellable *cancellable);
    gulong (*cancellable_connect)(GCancellable *cancellable, GCallback callback, gpointer data, GDestroyNotify data_destroy_func);
    void (*cancellable_disconnect)(GCancellable *cancellable, gulong handler_id);
    void (*cancellable_cancel)(GCancellable *cancellable);
    GType (*cancellable_get_type)(void);
    GCharsetConverter* (*charset_converter_new)(const gchar *to_charset, const gchar *from_charset, GError **error);
    void (*charset_converter_set_use_fallback)(GCharsetConverter *converter, gboolean use_fallback);
    gboolean (*charset_converter_get_use_fallback)(GCharsetConverter *converter);
    guint (*charset_converter_get_num_fallbacks)(GCharsetConverter *converter);
    GType (*charset_converter_get_type)(void);
    gboolean (*content_type_is_a)(const gchar *type, const gchar *supertype);
    gboolean (*content_type_is_mime_type)(const gchar *type, const gchar *mime_type);
    gboolean (*content_type_is_unknown)(const gchar *type);
    gchar * (*content_type_get_description)(const gchar *type);
    gchar * (*content_type_get_mime_type)(const gchar *type);
    GIcon * (*content_type_get_icon)(const gchar *type);
    GIcon * (*content_type_get_symbolic_icon)(const gchar *type);
    gchar * (*content_type_get_generic_icon_name)(const gchar *type);
    gboolean (*content_type_can_be_executable)(const gchar *type);
    gchar * (*content_type_from_mime_type)(const gchar *mime_type);
    gchar * (*content_type_guess)(const gchar *filename, const guchar *data, gsize data_size, gboolean *result_uncertain);
    gchar ** (*content_type_guess_for_tree)(GFile *root);
    GList * (*content_types_get_registered)(void);
    const gchar * const* (*content_type_get_mime_dirs)(void);
    void (*content_type_set_mime_dirs)(const gchar * const *dirs);
    gboolean (*content_type_equals)(const gchar *type1, const gchar *type2);
    GConverterResult (*converter_convert)(GConverter *converter, const void *inbuf, gsize inbuf_size, void *outbuf, gsize outbuf_size, GConverterFlags flags, gsize *bytes_read, gsize *bytes_written, GError **error);
    void (*converter_reset)(GConverter *converter);
    GType (*converter_get_type)(void);
    GInputStream* (*converter_input_stream_new)(GInputStream *base_stream, GConverter *converter);
    GConverter* (*converter_input_stream_get_converter)(GConverterInputStream *converter_stream);
    GType (*converter_input_stream_get_type)(void);
    GOutputStream* (*converter_output_stream_new)(GOutputStream *base_stream, GConverter *converter);
    GConverter* (*converter_output_stream_get_converter)(GConverterOutputStream *converter_stream);
    GType (*converter_output_stream_get_type)(void);
    GCredentials* (*credentials_new)(void);
    gchar* (*credentials_to_string)(GCredentials *credentials);
    gpointer (*credentials_get_native)(GCredentials *credentials, GCredentialsType native_type);
    void (*credentials_set_native)(GCredentials *credentials, GCredentialsType native_type, gpointer native);
    gboolean (*credentials_is_same_user)(GCredentials *credentials, GCredentials *other_credentials, GError **error);
    pid_t (*credentials_get_unix_pid)(GCredentials *credentials, GError **error);
    uid_t (*credentials_get_unix_user)(GCredentials *credentials, GError **error);
    gboolean (*credentials_set_unix_user)(GCredentials *credentials, uid_t uid, GError **error);
    GType (*credentials_get_type)(void);
    gint (*datagram_based_receive_messages)(GDatagramBased *datagram_based, GInputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
    gint (*datagram_based_send_messages)(GDatagramBased *datagram_based, GOutputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
    GSource * (*datagram_based_create_source)(GDatagramBased *datagram_based, GIOCondition condition, GCancellable *cancellable);
    GIOCondition (*datagram_based_condition_check)(GDatagramBased *datagram_based, GIOCondition condition);
    gboolean (*datagram_based_condition_wait)(GDatagramBased *datagram_based, GIOCondition condition, gint64 timeout, GCancellable *cancellable, GError **error);
    GType (*datagram_based_get_type)(void);
    GDataInputStream * (*data_input_stream_new)(GInputStream *base_stream);
    void (*data_input_stream_set_byte_order)(GDataInputStream *stream, GDataStreamByteOrder order);
    GDataStreamByteOrder (*data_input_stream_get_byte_order)(GDataInputStream *stream);
    void (*data_input_stream_set_newline_type)(GDataInputStream *stream, GDataStreamNewlineType type);
    GDataStreamNewlineType (*data_input_stream_get_newline_type)(GDataInputStream *stream);
    guchar (*data_input_stream_read_byte)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    gint16 (*data_input_stream_read_int16)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    guint16 (*data_input_stream_read_uint16)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    gint32 (*data_input_stream_read_int32)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    guint32 (*data_input_stream_read_uint32)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    gint64 (*data_input_stream_read_int64)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    guint64 (*data_input_stream_read_uint64)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    char * (*data_input_stream_read_line)(GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
    char * (*data_input_stream_read_line_utf8)(GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
    void (*data_input_stream_read_line_async)(GDataInputStream *stream, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    char * (*data_input_stream_read_line_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    char * (*data_input_stream_read_line_finish_utf8)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    char * (*data_input_stream_read_until)(GDataInputStream *stream, const gchar *stop_chars, gsize *length, GCancellable *cancellable, GError **error);
    void (*data_input_stream_read_until_async)(GDataInputStream *stream, const gchar *stop_chars, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    char * (*data_input_stream_read_until_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    char * (*data_input_stream_read_upto)(GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gsize *length, GCancellable *cancellable, GError **error);
    void (*data_input_stream_read_upto_async)(GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    char * (*data_input_stream_read_upto_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    GType (*data_input_stream_get_type)(void);
    GDataOutputStream * (*data_output_stream_new)(GOutputStream *base_stream);
    void (*data_output_stream_set_byte_order)(GDataOutputStream *stream, GDataStreamByteOrder order);
    GDataStreamByteOrder (*data_output_stream_get_byte_order)(GDataOutputStream *stream);
    gboolean (*data_output_stream_put_byte)(GDataOutputStream *stream, guchar data, GCancellable *cancellable, GError **error);
    gboolean (*data_output_stream_put_int16)(GDataOutputStream *stream, gint16 data, GCancellable *cancellable, GError **error);
    gboolean (*data_output_stream_put_uint16)(GDataOutputStream *stream, guint16 data, GCancellable *cancellable, GError **error);
    gboolean (*data_output_stream_put_int32)(GDataOutputStream *stream, gint32 data, GCancellable *cancellable, GError **error);
    gboolean (*data_output_stream_put_uint32)(GDataOutputStream *stream, guint32 data, GCancellable *cancellable, GError **error);
    gboolean (*data_output_stream_put_int64)(GDataOutputStream *stream, gint64 data, GCancellable *cancellable, GError **error);
    gboolean (*data_output_stream_put_uint64)(GDataOutputStream *stream, guint64 data, GCancellable *cancellable, GError **error);
    gboolean (*data_output_stream_put_string)(GDataOutputStream *stream, const char *str, GCancellable *cancellable, GError **error);
    GType (*data_output_stream_get_type)(void);
    GDBusActionGroup * (*dbus_action_group_get)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
    GType (*dbus_action_group_get_type)(void);
    gboolean (*dbus_is_address)(const gchar *string);
    gboolean (*dbus_is_supported_address)(const gchar *string, GError **error);
    void (*dbus_address_get_stream)(const gchar *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GIOStream* (*dbus_address_get_stream_finish)(GAsyncResult *res, gchar **out_guid, GError **error);
    GIOStream* (*dbus_address_get_stream_sync)(const gchar *address, gchar **out_guid, GCancellable *cancellable, GError **error);
    gchar* (*dbus_address_get_for_bus_sync)(GBusType bus_type, GCancellable *cancellable, GError **error);
    gchar* (*dbus_address_escape_value)(const gchar *string);
    GDBusAuthObserver* (*dbus_auth_observer_new)(void);
    gboolean (*dbus_auth_observer_authorize_authenticated_peer)(GDBusAuthObserver *observer, GIOStream *stream, GCredentials *credentials);
    gboolean (*dbus_auth_observer_allow_mechanism)(GDBusAuthObserver *observer, const gchar *mechanism);
    GType (*dbus_auth_observer_get_type)(void);
    void (*bus_get)(GBusType bus_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusConnection* (*bus_get_finish)(GAsyncResult *res, GError **error);
    GDBusConnection* (*bus_get_sync)(GBusType bus_type, GCancellable *cancellable, GError **error);
    void (*dbus_connection_new)(GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusConnection* (*dbus_connection_new_finish)(GAsyncResult *res, GError **error);
    GDBusConnection* (*dbus_connection_new_sync)(GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
    void (*dbus_connection_new_for_address)(const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusConnection* (*dbus_connection_new_for_address_finish)(GAsyncResult *res, GError **error);
    GDBusConnection* (*dbus_connection_new_for_address_sync)(const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
    void (*dbus_connection_start_message_processing)(GDBusConnection *connection);
    gboolean (*dbus_connection_is_closed)(GDBusConnection *connection);
    GIOStream* (*dbus_connection_get_stream)(GDBusConnection *connection);
    const gchar* (*dbus_connection_get_guid)(GDBusConnection *connection);
    const gchar* (*dbus_connection_get_unique_name)(GDBusConnection *connection);
    GCredentials* (*dbus_connection_get_peer_credentials)(GDBusConnection *connection);
    guint32 (*dbus_connection_get_last_serial)(GDBusConnection *connection);
    gboolean (*dbus_connection_get_exit_on_close)(GDBusConnection *connection);
    void (*dbus_connection_set_exit_on_close)(GDBusConnection *connection, gboolean exit_on_close);
    GDBusCapabilityFlags (*dbus_connection_get_capabilities)(GDBusConnection *connection);
    GDBusConnectionFlags (*dbus_connection_get_flags)(GDBusConnection *connection);
    void (*dbus_connection_close)(GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*dbus_connection_close_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    gboolean (*dbus_connection_close_sync)(GDBusConnection *connection, GCancellable *cancellable, GError **error);
    void (*dbus_connection_flush)(GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*dbus_connection_flush_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    gboolean (*dbus_connection_flush_sync)(GDBusConnection *connection, GCancellable *cancellable, GError **error);
    gboolean (*dbus_connection_send_message)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, volatile guint32 *out_serial, GError **error);
    void (*dbus_connection_send_message_with_reply)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusMessage* (*dbus_connection_send_message_with_reply_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    GDBusMessage* (*dbus_connection_send_message_with_reply_sync)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GError **error);
    gboolean (*dbus_connection_emit_signal)(GDBusConnection *connection, const gchar *destination_bus_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, GError **error);
    void (*dbus_connection_call)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*dbus_connection_call_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    GVariant* (*dbus_connection_call_sync)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
    void (*dbus_connection_call_with_unix_fd_list)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*dbus_connection_call_with_unix_fd_list_finish)(GDBusConnection *connection, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
    GVariant* (*dbus_connection_call_with_unix_fd_list_sync)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
    guint (*dbus_connection_register_object)(GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, const GDBusInterfaceVTable *vtable, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
    guint (*dbus_connection_register_object_with_closures)(GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, GClosure *method_call_closure, GClosure *get_property_closure, GClosure *set_property_closure, GError **error);
    gboolean (*dbus_connection_unregister_object)(GDBusConnection *connection, guint registration_id);
    guint (*dbus_connection_register_subtree)(GDBusConnection *connection, const gchar *object_path, const GDBusSubtreeVTable *vtable, GDBusSubtreeFlags flags, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
    gboolean (*dbus_connection_unregister_subtree)(GDBusConnection *connection, guint registration_id);
    guint (*dbus_connection_signal_subscribe)(GDBusConnection *connection, const gchar *sender, const gchar *interface_name, const gchar *member, const gchar *object_path, const gchar *arg0, GDBusSignalFlags flags, GDBusSignalCallback callback, gpointer user_data, GDestroyNotify user_data_free_func);
    void (*dbus_connection_signal_unsubscribe)(GDBusConnection *connection, guint subscription_id);
    guint (*dbus_connection_add_filter)(GDBusConnection *connection, GDBusMessageFilterFunction filter_function, gpointer user_data, GDestroyNotify user_data_free_func);
    void (*dbus_connection_remove_filter)(GDBusConnection *connection, guint filter_id);
    GType (*dbus_connection_get_type)(void);
    gboolean (*dbus_error_is_remote_error)(const GError *error);
    gchar* (*dbus_error_get_remote_error)(const GError *error);
    gboolean (*dbus_error_strip_remote_error)(GError *error);
    gboolean (*dbus_error_register_error)(GQuark error_domain, gint error_code, const gchar *dbus_error_name);
    gboolean (*dbus_error_unregister_error)(GQuark error_domain, gint error_code, const gchar *dbus_error_name);
    void (*dbus_error_register_error_domain)(const gchar *error_domain_quark_name, volatile gsize *quark_volatile, const GDBusErrorEntry *entries, guint num_entries);
    GError* (*dbus_error_new_for_dbus_error)(const gchar *dbus_error_name, const gchar *dbus_error_message);
    void (*dbus_error_set_dbus_error)(GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, ...);
    void (*dbus_error_set_dbus_error_valist)(GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, va_list var_args);
    gchar* (*dbus_error_encode_gerror)(const GError *error);
    GQuark (*dbus_error_quark)(void);
    GDBusInterfaceInfo* (*dbus_interface_get_info)(GDBusInterface *interface_);
    GDBusObject* (*dbus_interface_get_object)(GDBusInterface *interface_);
    void (*dbus_interface_set_object)(GDBusInterface *interface_, GDBusObject *object);
    GDBusObject* (*dbus_interface_dup_object)(GDBusInterface *interface_);
    GType (*dbus_interface_get_type)(void);
    GDBusInterfaceSkeletonFlags (*dbus_interface_skeleton_get_flags)(GDBusInterfaceSkeleton *interface_);
    void (*dbus_interface_skeleton_set_flags)(GDBusInterfaceSkeleton *interface_, GDBusInterfaceSkeletonFlags flags);
    GDBusInterfaceInfo* (*dbus_interface_skeleton_get_info)(GDBusInterfaceSkeleton *interface_);
    GDBusInterfaceVTable* (*dbus_interface_skeleton_get_vtable)(GDBusInterfaceSkeleton *interface_);
    GVariant* (*dbus_interface_skeleton_get_properties)(GDBusInterfaceSkeleton *interface_);
    void (*dbus_interface_skeleton_flush)(GDBusInterfaceSkeleton *interface_);
    gboolean (*dbus_interface_skeleton_export)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection, const gchar *object_path, GError **error);
    void (*dbus_interface_skeleton_unexport)(GDBusInterfaceSkeleton *interface_);
    void (*dbus_interface_skeleton_unexport_from_connection)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
    GDBusConnection* (*dbus_interface_skeleton_get_connection)(GDBusInterfaceSkeleton *interface_);
    GList* (*dbus_interface_skeleton_get_connections)(GDBusInterfaceSkeleton *interface_);
    gboolean (*dbus_interface_skeleton_has_connection)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
    const gchar* (*dbus_interface_skeleton_get_object_path)(GDBusInterfaceSkeleton *interface_);
    GType (*dbus_interface_skeleton_get_type)(void);
    GDBusMethodInfo* (*dbus_interface_info_lookup_method)(GDBusInterfaceInfo *info, const gchar *name);
    GDBusSignalInfo* (*dbus_interface_info_lookup_signal)(GDBusInterfaceInfo *info, const gchar *name);
    GDBusPropertyInfo* (*dbus_interface_info_lookup_property)(GDBusInterfaceInfo *info, const gchar *name);
    void (*dbus_interface_info_cache_build)(GDBusInterfaceInfo *info);
    void (*dbus_interface_info_cache_release)(GDBusInterfaceInfo *info);
    void (*dbus_interface_info_generate_xml)(GDBusInterfaceInfo *info, guint indent, GString *string_builder);
    GDBusNodeInfo* (*dbus_node_info_new_for_xml)(const gchar *xml_data, GError **error);
    GDBusInterfaceInfo* (*dbus_node_info_lookup_interface)(GDBusNodeInfo *info, const gchar *name);
    void (*dbus_node_info_generate_xml)(GDBusNodeInfo *info, guint indent, GString *string_builder);
    GDBusNodeInfo* (*dbus_node_info_ref)(GDBusNodeInfo *info);
    GDBusInterfaceInfo* (*dbus_interface_info_ref)(GDBusInterfaceInfo *info);
    GDBusMethodInfo* (*dbus_method_info_ref)(GDBusMethodInfo *info);
    GDBusSignalInfo* (*dbus_signal_info_ref)(GDBusSignalInfo *info);
    GDBusPropertyInfo* (*dbus_property_info_ref)(GDBusPropertyInfo *info);
    GDBusArgInfo* (*dbus_arg_info_ref)(GDBusArgInfo *info);
    GDBusAnnotationInfo* (*dbus_annotation_info_ref)(GDBusAnnotationInfo *info);
    void (*dbus_node_info_unref)(GDBusNodeInfo *info);
    void (*dbus_interface_info_unref)(GDBusInterfaceInfo *info);
    void (*dbus_method_info_unref)(GDBusMethodInfo *info);
    void (*dbus_signal_info_unref)(GDBusSignalInfo *info);
    void (*dbus_property_info_unref)(GDBusPropertyInfo *info);
    void (*dbus_arg_info_unref)(GDBusArgInfo *info);
    void (*dbus_annotation_info_unref)(GDBusAnnotationInfo *info);
    GType (*dbus_node_info_get_type)(void);
    GType (*dbus_interface_info_get_type)(void);
    GType (*dbus_method_info_get_type)(void);
    GType (*dbus_signal_info_get_type)(void);
    GType (*dbus_property_info_get_type)(void);
    GType (*dbus_arg_info_get_type)(void);
    GType (*dbus_annotation_info_get_type)(void);
    const gchar* (*dbus_annotation_info_lookup)(GDBusAnnotationInfo **annotations, const gchar *name);
    GDBusMenuModel * (*dbus_menu_model_get)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
    GType (*dbus_menu_model_get_type)(void);
    GDBusMessage* (*dbus_message_new)(void);
    GDBusMessage* (*dbus_message_new_signal)(const gchar *path, const gchar *interface_, const gchar *signal);
    GDBusMessage* (*dbus_message_new_method_call)(const gchar *name, const gchar *path, const gchar *interface_, const gchar *method);
    GDBusMessage* (*dbus_message_new_method_reply)(GDBusMessage *method_call_message);
    GDBusMessage* (*dbus_message_new_method_error)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, ...);
    GDBusMessage* (*dbus_message_new_method_error_valist)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, va_list var_args);
    GDBusMessage* (*dbus_message_new_method_error_literal)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message);
    gchar* (*dbus_message_print)(GDBusMessage *message, guint indent);
    gboolean (*dbus_message_get_locked)(GDBusMessage *message);
    void (*dbus_message_lock)(GDBusMessage *message);
    GDBusMessage* (*dbus_message_copy)(GDBusMessage *message, GError **error);
    GDBusMessageByteOrder (*dbus_message_get_byte_order)(GDBusMessage *message);
    void (*dbus_message_set_byte_order)(GDBusMessage *message, GDBusMessageByteOrder byte_order);
    GDBusMessageType (*dbus_message_get_message_type)(GDBusMessage *message);
    void (*dbus_message_set_message_type)(GDBusMessage *message, GDBusMessageType type);
    GDBusMessageFlags (*dbus_message_get_flags)(GDBusMessage *message);
    void (*dbus_message_set_flags)(GDBusMessage *message, GDBusMessageFlags flags);
    guint32 (*dbus_message_get_serial)(GDBusMessage *message);
    void (*dbus_message_set_serial)(GDBusMessage *message, guint32 serial);
    GVariant* (*dbus_message_get_header)(GDBusMessage *message, GDBusMessageHeaderField header_field);
    void (*dbus_message_set_header)(GDBusMessage *message, GDBusMessageHeaderField header_field, GVariant *value);
    guchar* (*dbus_message_get_header_fields)(GDBusMessage *message);
    GVariant* (*dbus_message_get_body)(GDBusMessage *message);
    void (*dbus_message_set_body)(GDBusMessage *message, GVariant *body);
    GUnixFDList* (*dbus_message_get_unix_fd_list)(GDBusMessage *message);
    void (*dbus_message_set_unix_fd_list)(GDBusMessage *message, GUnixFDList *fd_list);
    guint32 (*dbus_message_get_reply_serial)(GDBusMessage *message);
    void (*dbus_message_set_reply_serial)(GDBusMessage *message, guint32 value);
    const gchar* (*dbus_message_get_interface)(GDBusMessage *message);
    void (*dbus_message_set_interface)(GDBusMessage *message, const gchar *value);
    const gchar* (*dbus_message_get_member)(GDBusMessage *message);
    void (*dbus_message_set_member)(GDBusMessage *message, const gchar *value);
    const gchar* (*dbus_message_get_path)(GDBusMessage *message);
    void (*dbus_message_set_path)(GDBusMessage *message, const gchar *value);
    const gchar* (*dbus_message_get_sender)(GDBusMessage *message);
    void (*dbus_message_set_sender)(GDBusMessage *message, const gchar *value);
    const gchar* (*dbus_message_get_destination)(GDBusMessage *message);
    void (*dbus_message_set_destination)(GDBusMessage *message, const gchar *value);
    const gchar* (*dbus_message_get_error_name)(GDBusMessage *message);
    void (*dbus_message_set_error_name)(GDBusMessage *message, const gchar *value);
    const gchar* (*dbus_message_get_signature)(GDBusMessage *message);
    void (*dbus_message_set_signature)(GDBusMessage *message, const gchar *value);
    guint32 (*dbus_message_get_num_unix_fds)(GDBusMessage *message);
    void (*dbus_message_set_num_unix_fds)(GDBusMessage *message, guint32 value);
    const gchar* (*dbus_message_get_arg0)(GDBusMessage *message);
    const gchar* (*dbus_message_get_arg0_path)(GDBusMessage *message);
    GDBusMessage* (*dbus_message_new_from_blob)(guchar *blob, gsize blob_len, GDBusCapabilityFlags capabilities, GError **error);
    gssize (*dbus_message_bytes_needed)(guchar *blob, gsize blob_len, GError **error);
    guchar* (*dbus_message_to_blob)(GDBusMessage *message, gsize *out_size, GDBusCapabilityFlags capabilities, GError **error);
    gboolean (*dbus_message_to_gerror)(GDBusMessage *message, GError **error);
    GType (*dbus_message_get_type)(void);
    const gchar* (*dbus_method_invocation_get_sender)(GDBusMethodInvocation *invocation);
    const gchar* (*dbus_method_invocation_get_object_path)(GDBusMethodInvocation *invocation);
    const gchar* (*dbus_method_invocation_get_interface_name)(GDBusMethodInvocation *invocation);
    const gchar* (*dbus_method_invocation_get_method_name)(GDBusMethodInvocation *invocation);
    const GDBusMethodInfo* (*dbus_method_invocation_get_method_info)(GDBusMethodInvocation *invocation);
    const GDBusPropertyInfo* (*dbus_method_invocation_get_property_info)(GDBusMethodInvocation *invocation);
    GDBusConnection* (*dbus_method_invocation_get_connection)(GDBusMethodInvocation *invocation);
    GDBusMessage* (*dbus_method_invocation_get_message)(GDBusMethodInvocation *invocation);
    GVariant* (*dbus_method_invocation_get_parameters)(GDBusMethodInvocation *invocation);
    gpointer (*dbus_method_invocation_get_user_data)(GDBusMethodInvocation *invocation);
    void (*dbus_method_invocation_return_value)(GDBusMethodInvocation *invocation, GVariant *parameters);
    void (*dbus_method_invocation_return_value_with_unix_fd_list)(GDBusMethodInvocation *invocation, GVariant *parameters, GUnixFDList *fd_list);
    void (*dbus_method_invocation_return_error)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, ...);
    void (*dbus_method_invocation_return_error_valist)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, va_list var_args);
    void (*dbus_method_invocation_return_error_literal)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *message);
    void (*dbus_method_invocation_return_gerror)(GDBusMethodInvocation *invocation, const GError *error);
    void (*dbus_method_invocation_take_error)(GDBusMethodInvocation *invocation, GError *error);
    void (*dbus_method_invocation_return_dbus_error)(GDBusMethodInvocation *invocation, const gchar *error_name, const gchar *error_message);
    GType (*dbus_method_invocation_get_type)(void);
    guint (*bus_own_name_on_connection)(GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    guint (*bus_own_name_with_closures)(GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GClosure *bus_acquired_closure, GClosure *name_acquired_closure, GClosure *name_lost_closure);
    guint (*bus_own_name_on_connection_with_closures)( GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GClosure *name_acquired_closure, GClosure *name_lost_closure);
    void (*bus_unown_name)(guint owner_id);
    guint (*bus_own_name)(GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GBusAcquiredCallback bus_acquired_handler, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    guint (*bus_watch_name_on_connection)(GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    guint (*bus_watch_name_with_closures)(GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
    guint (*bus_watch_name_on_connection_with_closures)( GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
    void (*bus_unwatch_name)(guint watcher_id);
    guint (*bus_watch_name)(GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    const gchar* (*dbus_object_get_object_path)(GDBusObject *object);
    GList* (*dbus_object_get_interfaces)(GDBusObject *object);
    GDBusInterface* (*dbus_object_get_interface)(GDBusObject *object, const gchar *interface_name);
    GType (*dbus_object_get_type)(void);
    const gchar* (*dbus_object_manager_get_object_path)(GDBusObjectManager *manager);
    GList* (*dbus_object_manager_get_objects)(GDBusObjectManager *manager);
    GDBusObject* (*dbus_object_manager_get_object)(GDBusObjectManager *manager, const gchar *object_path);
    GDBusInterface* (*dbus_object_manager_get_interface)(GDBusObjectManager *manager, const gchar *object_path, const gchar *interface_name);
    GType (*dbus_object_manager_get_type)(void);
    void (*dbus_object_manager_client_new)(GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusObjectManager* (*dbus_object_manager_client_new_finish)(GAsyncResult *res, GError **error);
    GDBusObjectManager* (*dbus_object_manager_client_new_sync)(GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
    void (*dbus_object_manager_client_new_for_bus)(GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusObjectManager* (*dbus_object_manager_client_new_for_bus_finish)(GAsyncResult *res, GError **error);
    GDBusObjectManager* (*dbus_object_manager_client_new_for_bus_sync)(GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
    GDBusConnection* (*dbus_object_manager_client_get_connection)(GDBusObjectManagerClient *manager);
    GDBusObjectManagerClientFlags (*dbus_object_manager_client_get_flags)(GDBusObjectManagerClient *manager);
    const gchar* (*dbus_object_manager_client_get_name)(GDBusObjectManagerClient *manager);
    gchar* (*dbus_object_manager_client_get_name_owner)(GDBusObjectManagerClient *manager);
    GType (*dbus_object_manager_client_get_type)(void);
    GDBusObjectManagerServer* (*dbus_object_manager_server_new)(const gchar *object_path);
    GDBusConnection* (*dbus_object_manager_server_get_connection)(GDBusObjectManagerServer *manager);
    void (*dbus_object_manager_server_set_connection)(GDBusObjectManagerServer *manager, GDBusConnection *connection);
    void (*dbus_object_manager_server_export)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
    void (*dbus_object_manager_server_export_uniquely)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
    gboolean (*dbus_object_manager_server_is_exported)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
    gboolean (*dbus_object_manager_server_unexport)(GDBusObjectManagerServer *manager, const gchar *object_path);
    GType (*dbus_object_manager_server_get_type)(void);
    GDBusObjectProxy* (*dbus_object_proxy_new)(GDBusConnection *connection, const gchar *object_path);
    GDBusConnection* (*dbus_object_proxy_get_connection)(GDBusObjectProxy *proxy);
    GType (*dbus_object_proxy_get_type)(void);
    GDBusObjectSkeleton* (*dbus_object_skeleton_new)(const gchar *object_path);
    void (*dbus_object_skeleton_flush)(GDBusObjectSkeleton *object);
    void (*dbus_object_skeleton_add_interface)(GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
    void (*dbus_object_skeleton_remove_interface)(GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
    void (*dbus_object_skeleton_remove_interface_by_name)(GDBusObjectSkeleton *object, const gchar *interface_name);
    void (*dbus_object_skeleton_set_object_path)(GDBusObjectSkeleton *object, const gchar *object_path);
    GType (*dbus_object_skeleton_get_type)(void);
    void (*dbus_proxy_new)(GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusProxy* (*dbus_proxy_new_finish)(GAsyncResult *res, GError **error);
    GDBusProxy* (*dbus_proxy_new_sync)(GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
    void (*dbus_proxy_new_for_bus)(GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusProxy* (*dbus_proxy_new_for_bus_finish)(GAsyncResult *res, GError **error);
    GDBusProxy* (*dbus_proxy_new_for_bus_sync)(GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
    GDBusConnection* (*dbus_proxy_get_connection)(GDBusProxy *proxy);
    GDBusProxyFlags (*dbus_proxy_get_flags)(GDBusProxy *proxy);
    const gchar* (*dbus_proxy_get_name)(GDBusProxy *proxy);
    gchar* (*dbus_proxy_get_name_owner)(GDBusProxy *proxy);
    const gchar* (*dbus_proxy_get_object_path)(GDBusProxy *proxy);
    const gchar* (*dbus_proxy_get_interface_name)(GDBusProxy *proxy);
    gint (*dbus_proxy_get_default_timeout)(GDBusProxy *proxy);
    void (*dbus_proxy_set_default_timeout)(GDBusProxy *proxy, gint timeout_msec);
    GDBusInterfaceInfo* (*dbus_proxy_get_interface_info)(GDBusProxy *proxy);
    void (*dbus_proxy_set_interface_info)(GDBusProxy *proxy, GDBusInterfaceInfo *info);
    GVariant* (*dbus_proxy_get_cached_property)(GDBusProxy *proxy, const gchar *property_name);
    void (*dbus_proxy_set_cached_property)(GDBusProxy *proxy, const gchar *property_name, GVariant *value);
    gchar** (*dbus_proxy_get_cached_property_names)(GDBusProxy *proxy);
    void (*dbus_proxy_call)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*dbus_proxy_call_finish)(GDBusProxy *proxy, GAsyncResult *res, GError **error);
    GVariant* (*dbus_proxy_call_sync)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
    void (*dbus_proxy_call_with_unix_fd_list)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*dbus_proxy_call_with_unix_fd_list_finish)(GDBusProxy *proxy, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
    GVariant* (*dbus_proxy_call_with_unix_fd_list_sync)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
    GType (*dbus_proxy_get_type)(void);
    GDBusServer* (*dbus_server_new_sync)(const gchar *address, GDBusServerFlags flags, const gchar *guid, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
    const gchar* (*dbus_server_get_client_address)(GDBusServer *server);
    const gchar* (*dbus_server_get_guid)(GDBusServer *server);
    GDBusServerFlags (*dbus_server_get_flags)(GDBusServer *server);
    void (*dbus_server_start)(GDBusServer *server);
    void (*dbus_server_stop)(GDBusServer *server);
    gboolean (*dbus_server_is_active)(GDBusServer *server);
    GType (*dbus_server_get_type)(void);
    gchar* (*dbus_generate_guid)(void);
    gboolean (*dbus_is_name)(const gchar *string);
    gboolean (*dbus_is_unique_name)(const gchar *string);
    gboolean (*dbus_is_member_name)(const gchar *string);
    gboolean (*dbus_is_interface_name)(const gchar *string);
    gboolean (*dbus_is_error_name)(const gchar *string);
    void (*dbus_gvariant_to_gvalue)(GVariant *value, GValue *out_gvalue);
    GVariant* (*dbus_gvalue_to_gvariant)(const GValue *gvalue, const GVariantType *type);
    gchar* (*dbus_escape_object_path_bytestring)(const guint8 *bytes);
    gchar* (*dbus_escape_object_path)(const gchar *s);
    guint8* (*dbus_unescape_object_path)(const gchar *s);
    gboolean (*dbus_is_guid)(const gchar *string);
    void (*debug_controller_set_debug_enabled)(GDebugController *self, gboolean debug_enabled);
    void (*debug_controller_dbus_stop)(GDebugControllerDBus *self);
    GDebugControllerDBus* (*debug_controller_dbus_new)(GDBusConnection *connection, GCancellable *cancellable, GError **error);
    char * (*drive_get_name)(GDrive *drive);
    GIcon * (*drive_get_icon)(GDrive *drive);
    GIcon * (*drive_get_symbolic_icon)(GDrive *drive);
    gboolean (*drive_has_volumes)(GDrive *drive);
    GList * (*drive_get_volumes)(GDrive *drive);
    gboolean (*drive_is_removable)(GDrive *drive);
    gboolean (*drive_is_media_removable)(GDrive *drive);
    gboolean (*drive_has_media)(GDrive *drive);
    gboolean (*drive_is_media_check_automatic)(GDrive *drive);
    gboolean (*drive_can_poll_for_media)(GDrive *drive);
    gboolean (*drive_can_eject)(GDrive *drive);
    void (*drive_eject)(GDrive *drive, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*drive_eject_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    void (*drive_poll_for_media)(GDrive *drive, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*drive_poll_for_media_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    char * (*drive_get_identifier)(GDrive *drive, const char *kind);
    char ** (*drive_enumerate_identifiers)(GDrive *drive);
    GDriveStartStopType (*drive_get_start_stop_type)(GDrive *drive);
    gboolean (*drive_can_start)(GDrive *drive);
    gboolean (*drive_can_start_degraded)(GDrive *drive);
    void (*drive_start)(GDrive *drive, GDriveStartFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*drive_start_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    gboolean (*drive_can_stop)(GDrive *drive);
    void (*drive_stop)(GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*drive_stop_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    void (*drive_eject_with_operation)(GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*drive_eject_with_operation_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    const gchar* (*drive_get_sort_key)(GDrive *drive);
    GType (*drive_get_type)(void);
    GDatagramBased* (*dtls_client_connection_new)(GDatagramBased *base_socket, GSocketConnectable *server_identity, GError **error);
    GTlsCertificateFlags (*dtls_client_connection_get_validation_flags)(GDtlsClientConnection *conn);
    void (*dtls_client_connection_set_validation_flags)(GDtlsClientConnection *conn, GTlsCertificateFlags flags);
    GSocketConnectable* (*dtls_client_connection_get_server_identity)(GDtlsClientConnection *conn);
    void (*dtls_client_connection_set_server_identity)(GDtlsClientConnection *conn, GSocketConnectable *identity);
    GList * (*dtls_client_connection_get_accepted_cas)(GDtlsClientConnection *conn);
    GType (*dtls_client_connection_get_type)(void);
    void (*dtls_connection_set_database)(GDtlsConnection *conn, GTlsDatabase *database);
    GTlsDatabase* (*dtls_connection_get_database)(GDtlsConnection *conn);
    void (*dtls_connection_set_certificate)(GDtlsConnection *conn, GTlsCertificate *certificate);
    GTlsCertificate* (*dtls_connection_get_certificate)(GDtlsConnection *conn);
    void (*dtls_connection_set_interaction)(GDtlsConnection *conn, GTlsInteraction *interaction);
    GTlsInteraction* (*dtls_connection_get_interaction)(GDtlsConnection *conn);
    GTlsCertificate* (*dtls_connection_get_peer_certificate)(GDtlsConnection *conn);
    GTlsCertificateFlags (*dtls_connection_get_peer_certificate_errors)(GDtlsConnection *conn);
    void (*dtls_connection_set_require_close_notify)(GDtlsConnection *conn, gboolean require_close_notify);
    gboolean (*dtls_connection_get_require_close_notify)(GDtlsConnection *conn);
    GTlsRehandshakeMode (*dtls_connection_get_rehandshake_mode)(GDtlsConnection *conn);
    void (*dtls_connection_handshake_async)(GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*dtls_connection_handshake_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error);
    gboolean (*dtls_connection_shutdown)(GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, GCancellable *cancellable, GError **error);
    void (*dtls_connection_shutdown_async)(GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*dtls_connection_shutdown_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error);
    gboolean (*dtls_connection_close)(GDtlsConnection *conn, GCancellable *cancellable, GError **error);
    void (*dtls_connection_close_async)(GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*dtls_connection_close_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error);
    gboolean (*dtls_connection_emit_accept_certificate)(GDtlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
    void (*dtls_connection_set_advertised_protocols)(GDtlsConnection *conn, const gchar * const *protocols);
    const gchar * (*dtls_connection_get_negotiated_protocol)(GDtlsConnection *conn);
    gchar * (*dtls_connection_get_ciphersuite_name)(GDtlsConnection *conn);
    GType (*dtls_connection_get_type)(void);
    GDatagramBased* (*dtls_server_connection_new)(GDatagramBased *base_socket, GTlsCertificate *certificate, GError **error);
    GType (*dtls_server_connection_get_type)(void);
    GEmblem* (*emblem_new)(GIcon *icon);
    GEmblem* (*emblem_new_with_origin)(GIcon *icon, GEmblemOrigin origin);
    GIcon* (*emblem_get_icon)(GEmblem *emblem);
    GEmblemOrigin (*emblem_get_origin)(GEmblem *emblem);
    GType (*emblem_get_type)(void);
    GIcon* (*emblemed_icon_new)(GIcon *icon, GEmblem *emblem);
    GIcon* (*emblemed_icon_get_icon)(GEmblemedIcon *emblemed);
    GList* (*emblemed_icon_get_emblems)(GEmblemedIcon *emblemed);
    void (*emblemed_icon_add_emblem)(GEmblemedIcon *emblemed, GEmblem *emblem);
    void (*emblemed_icon_clear_emblems)(GEmblemedIcon *emblemed);
    GType (*emblemed_icon_get_type)(void);
    GFile * (*file_new_for_path)(const char *path);
    GFile * (*file_new_for_uri)(const char *uri);
    GFile * (*file_new_for_commandline_arg)(const char *arg);
    GFile * (*file_new_for_commandline_arg_and_cwd)(const gchar *arg, const gchar *cwd);
    GFile * (*file_new_tmp)(const char *tmpl, GFileIOStream **iostream, GError **error);
    void (*file_new_tmp_async)(const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*file_new_tmp_finish)(GAsyncResult *result, GFileIOStream **iostream, GError **error);
    void (*file_new_tmp_dir_async)(const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*file_new_tmp_dir_finish)(GAsyncResult *result, GError **error);
    GFile * (*file_parse_name)(const char *parse_name);
    GFile * (*file_new_build_filename)(const gchar *first_element, ...);
    GFile * (*file_new_build_filenamev)(const gchar * const *args);
    GFile * (*file_dup)(GFile *file);
    guint (*file_hash)(gconstpointer file);
    gboolean (*file_equal)(GFile *file1, GFile *file2);
    char * (*file_get_basename)(GFile *file);
    char * (*file_get_path)(GFile *file);
    const char * (*file_peek_path)(GFile *file);
    char * (*file_get_uri)(GFile *file);
    char * (*file_get_parse_name)(GFile *file);
    GFile * (*file_get_parent)(GFile *file);
    gboolean (*file_has_parent)(GFile *file, GFile *parent);
    GFile * (*file_get_child)(GFile *file, const char *name);
    GFile * (*file_get_child_for_display_name)(GFile *file, const char *display_name, GError **error);
    gboolean (*file_has_prefix)(GFile *file, GFile *prefix);
    char * (*file_get_relative_path)(GFile *parent, GFile *descendant);
    GFile * (*file_resolve_relative_path)(GFile *file, const char *relative_path);
    gboolean (*file_is_native)(GFile *file);
    gboolean (*file_has_uri_scheme)(GFile *file, const char *uri_scheme);
    char * (*file_get_uri_scheme)(GFile *file);
    GFileInputStream * (*file_read)(GFile *file, GCancellable *cancellable, GError **error);
    void (*file_read_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInputStream * (*file_read_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileOutputStream * (*file_append_to)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    GFileOutputStream * (*file_create)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    GFileOutputStream * (*file_replace)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    void (*file_append_to_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileOutputStream * (*file_append_to_finish)(GFile *file, GAsyncResult *res, GError **error);
    void (*file_create_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileOutputStream * (*file_create_finish)(GFile *file, GAsyncResult *res, GError **error);
    void (*file_replace_async)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileOutputStream * (*file_replace_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileIOStream * (*file_open_readwrite)(GFile *file, GCancellable *cancellable, GError **error);
    void (*file_open_readwrite_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileIOStream * (*file_open_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileIOStream * (*file_create_readwrite)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    void (*file_create_readwrite_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileIOStream * (*file_create_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileIOStream * (*file_replace_readwrite)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    void (*file_replace_readwrite_async)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileIOStream * (*file_replace_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error);
    gboolean (*file_query_exists)(GFile *file, GCancellable *cancellable);
    GFileType (*file_query_file_type)(GFile *file, GFileQueryInfoFlags flags, GCancellable *cancellable);
    GFileInfo * (*file_query_info)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*file_query_info_async)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo * (*file_query_info_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileInfo * (*file_query_filesystem_info)(GFile *file, const char *attributes, GCancellable *cancellable, GError **error);
    void (*file_query_filesystem_info_async)(GFile *file, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo * (*file_query_filesystem_info_finish)(GFile *file, GAsyncResult *res, GError **error);
    GMount * (*file_find_enclosing_mount)(GFile *file, GCancellable *cancellable, GError **error);
    void (*file_find_enclosing_mount_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GMount * (*file_find_enclosing_mount_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileEnumerator * (*file_enumerate_children)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*file_enumerate_children_async)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileEnumerator * (*file_enumerate_children_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFile * (*file_set_display_name)(GFile *file, const char *display_name, GCancellable *cancellable, GError **error);
    void (*file_set_display_name_async)(GFile *file, const char *display_name, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*file_set_display_name_finish)(GFile *file, GAsyncResult *res, GError **error);
    gboolean (*file_delete)(GFile *file, GCancellable *cancellable, GError **error);
    void (*file_delete_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_delete_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*file_trash)(GFile *file, GCancellable *cancellable, GError **error);
    void (*file_trash_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_trash_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*file_copy)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
    void (*file_copy_async)(GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_copy_finish)(GFile *file, GAsyncResult *res, GError **error);
    gboolean (*file_move)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
    void (*file_move_async)(GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_move_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*file_make_directory)(GFile *file, GCancellable *cancellable, GError **error);
    void (*file_make_directory_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_make_directory_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*file_make_directory_with_parents)(GFile *file, GCancellable *cancellable, GError **error);
    gboolean (*file_make_symbolic_link)(GFile *file, const char *symlink_value, GCancellable *cancellable, GError **error);
    void (*file_make_symbolic_link_async)(GFile *file, const char *symlink_value, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_make_symbolic_link_finish)(GFile *file, GAsyncResult *result, GError **error);
    GFileAttributeInfoList* (*file_query_settable_attributes)(GFile *file, GCancellable *cancellable, GError **error);
    GFileAttributeInfoList* (*file_query_writable_namespaces)(GFile *file, GCancellable *cancellable, GError **error);
    gboolean (*file_set_attribute)(GFile *file, const char *attribute, GFileAttributeType type, gpointer value_p, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_set_attributes_from_info)(GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*file_set_attributes_async)(GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_set_attributes_finish)(GFile *file, GAsyncResult *result, GFileInfo **info, GError **error);
    gboolean (*file_set_attribute_string)(GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_set_attribute_byte_string)(GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_set_attribute_uint32)(GFile *file, const char *attribute, guint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_set_attribute_int32)(GFile *file, const char *attribute, gint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_set_attribute_uint64)(GFile *file, const char *attribute, guint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_set_attribute_int64)(GFile *file, const char *attribute, gint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*file_mount_enclosing_volume)(GFile *location, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_mount_enclosing_volume_finish)(GFile *location, GAsyncResult *result, GError **error);
    void (*file_mount_mountable)(GFile *file, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*file_mount_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*file_unmount_mountable)(GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_unmount_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*file_unmount_mountable_with_operation)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_unmount_mountable_with_operation_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*file_eject_mountable)(GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_eject_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*file_eject_mountable_with_operation)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_eject_mountable_with_operation_finish)(GFile *file, GAsyncResult *result, GError **error);
    char * (*file_build_attribute_list_for_copy)(GFile *file, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_copy_attributes)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
    GFileMonitor* (*file_monitor_directory)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
    GFileMonitor* (*file_monitor_file)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
    GFileMonitor* (*file_monitor)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*file_measure_disk_usage)(GFile *file, GFileMeasureFlags flags, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
    void (*file_measure_disk_usage_async)(GFile *file, GFileMeasureFlags flags, gint io_priority, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_measure_disk_usage_finish)(GFile *file, GAsyncResult *result, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
    void (*file_start_mountable)(GFile *file, GDriveStartFlags flags, GMountOperation *start_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_start_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*file_stop_mountable)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_stop_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*file_poll_mountable)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_poll_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    GAppInfo* (*file_query_default_handler)(GFile *file, GCancellable *cancellable, GError **error);
    void (*file_query_default_handler_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GAppInfo* (*file_query_default_handler_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*file_load_contents)(GFile *file, GCancellable *cancellable, char **contents, gsize *length, char **etag_out, GError **error);
    void (*file_load_contents_async)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_load_contents_finish)(GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
    void (*file_load_partial_contents_async)(GFile *file, GCancellable *cancellable, GFileReadMoreCallback read_more_callback, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_load_partial_contents_finish)(GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
    gboolean (*file_replace_contents)(GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, char **new_etag, GCancellable *cancellable, GError **error);
    void (*file_replace_contents_async)(GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    void (*file_replace_contents_bytes_async)(GFile *file, GBytes *contents, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_replace_contents_finish)(GFile *file, GAsyncResult *res, char **new_etag, GError **error);
    gboolean (*file_supports_thread_contexts)(GFile *file);
    GBytes* (*file_load_bytes)(GFile *file, GCancellable *cancellable, gchar **etag_out, GError **error);
    void (*file_load_bytes_async)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GBytes* (*file_load_bytes_finish)(GFile *file, GAsyncResult *result, gchar **etag_out, GError **error);
    GType (*file_get_type)(void);
    GFileAttributeInfoList * (*file_attribute_info_list_new)(void);
    GFileAttributeInfoList * (*file_attribute_info_list_ref)(GFileAttributeInfoList *list);
    void (*file_attribute_info_list_unref)(GFileAttributeInfoList *list);
    GFileAttributeInfoList * (*file_attribute_info_list_dup)(GFileAttributeInfoList *list);
    const GFileAttributeInfo* (*file_attribute_info_list_lookup)(GFileAttributeInfoList *list, const char *name);
    void (*file_attribute_info_list_add)(GFileAttributeInfoList *list, const char *name, GFileAttributeType type, GFileAttributeInfoFlags flags);
    GType (*file_attribute_info_list_get_type)(void);
    GFileInfo* (*file_enumerator_next_file)(GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
    gboolean (*file_enumerator_close)(GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
    void (*file_enumerator_next_files_async)(GFileEnumerator *enumerator, int num_files, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList * (*file_enumerator_next_files_finish)(GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
    void (*file_enumerator_close_async)(GFileEnumerator *enumerator, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*file_enumerator_close_finish)(GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
    gboolean (*file_enumerator_is_closed)(GFileEnumerator *enumerator);
    gboolean (*file_enumerator_has_pending)(GFileEnumerator *enumerator);
    void (*file_enumerator_set_pending)(GFileEnumerator *enumerator, gboolean pending);
    GFile * (*file_enumerator_get_container)(GFileEnumerator *enumerator);
    GFile * (*file_enumerator_get_child)(GFileEnumerator *enumerator, GFileInfo *info);
    gboolean (*file_enumerator_iterate)(GFileEnumerator *direnum, GFileInfo **out_info, GFile **out_child, GCancellable *cancellable, GError **error);
    GType (*file_enumerator_get_type)(void);
    GIcon * (*file_icon_new)(GFile *file);
    GFile * (*file_icon_get_file)(GFileIcon *icon);
    GType (*file_icon_get_type)(void);
    GFileInfo * (*file_info_new)(void);
    GFileInfo * (*file_info_dup)(GFileInfo *other);
    void (*file_info_copy_into)(GFileInfo *src_info, GFileInfo *dest_info);
    gboolean (*file_info_has_attribute)(GFileInfo *info, const char *attribute);
    gboolean (*file_info_has_namespace)(GFileInfo *info, const char *name_space);
    char ** (*file_info_list_attributes)(GFileInfo *info, const char *name_space);
    gboolean (*file_info_get_attribute_data)(GFileInfo *info, const char *attribute, GFileAttributeType *type, gpointer *value_pp, GFileAttributeStatus *status);
    GFileAttributeType (*file_info_get_attribute_type)(GFileInfo *info, const char *attribute);
    void (*file_info_remove_attribute)(GFileInfo *info, const char *attribute);
    GFileAttributeStatus (*file_info_get_attribute_status)(GFileInfo *info, const char *attribute);
    gboolean (*file_info_set_attribute_status)(GFileInfo *info, const char *attribute, GFileAttributeStatus status);
    char * (*file_info_get_attribute_as_string)(GFileInfo *info, const char *attribute);
    const char * (*file_info_get_attribute_string)(GFileInfo *info, const char *attribute);
    const char * (*file_info_get_attribute_byte_string)(GFileInfo *info, const char *attribute);
    gboolean (*file_info_get_attribute_boolean)(GFileInfo *info, const char *attribute);
    guint32 (*file_info_get_attribute_uint32)(GFileInfo *info, const char *attribute);
    gint32 (*file_info_get_attribute_int32)(GFileInfo *info, const char *attribute);
    guint64 (*file_info_get_attribute_uint64)(GFileInfo *info, const char *attribute);
    gint64 (*file_info_get_attribute_int64)(GFileInfo *info, const char *attribute);
    GObject * (*file_info_get_attribute_object)(GFileInfo *info, const char *attribute);
    char ** (*file_info_get_attribute_stringv)(GFileInfo *info, const char *attribute);
    const char * (*file_info_get_attribute_file_path)(GFileInfo *info, const char *attribute);
    void (*file_info_set_attribute)(GFileInfo *info, const char *attribute, GFileAttributeType type, gpointer value_p);
    void (*file_info_set_attribute_string)(GFileInfo *info, const char *attribute, const char *attr_value);
    void (*file_info_set_attribute_byte_string)(GFileInfo *info, const char *attribute, const char *attr_value);
    void (*file_info_set_attribute_boolean)(GFileInfo *info, const char *attribute, gboolean attr_value);
    void (*file_info_set_attribute_uint32)(GFileInfo *info, const char *attribute, guint32 attr_value);
    void (*file_info_set_attribute_int32)(GFileInfo *info, const char *attribute, gint32 attr_value);
    void (*file_info_set_attribute_uint64)(GFileInfo *info, const char *attribute, guint64 attr_value);
    void (*file_info_set_attribute_int64)(GFileInfo *info, const char *attribute, gint64 attr_value);
    void (*file_info_set_attribute_object)(GFileInfo *info, const char *attribute, GObject *attr_value);
    void (*file_info_set_attribute_stringv)(GFileInfo *info, const char *attribute, char **attr_value);
    void (*file_info_set_attribute_file_path)(GFileInfo *info, const char *attribute, const char *attr_value);
    void (*file_info_clear_status)(GFileInfo *info);
    GDateTime * (*file_info_get_deletion_date)(GFileInfo *info);
    GFileType (*file_info_get_file_type)(GFileInfo *info);
    gboolean (*file_info_get_is_hidden)(GFileInfo *info);
    gboolean (*file_info_get_is_backup)(GFileInfo *info);
    gboolean (*file_info_get_is_symlink)(GFileInfo *info);
    const char * (*file_info_get_name)(GFileInfo *info);
    const char * (*file_info_get_display_name)(GFileInfo *info);
    const char * (*file_info_get_edit_name)(GFileInfo *info);
    GIcon * (*file_info_get_icon)(GFileInfo *info);
    GIcon * (*file_info_get_symbolic_icon)(GFileInfo *info);
    const char * (*file_info_get_content_type)(GFileInfo *info);
    goffset (*file_info_get_size)(GFileInfo *info);
    GDateTime * (*file_info_get_access_date_time)(GFileInfo *info);
    GDateTime * (*file_info_get_creation_date_time)(GFileInfo *info);
    const char * (*file_info_get_symlink_target)(GFileInfo *info);
    const char * (*file_info_get_etag)(GFileInfo *info);
    gint32 (*file_info_get_sort_order)(GFileInfo *info);
    void (*file_info_set_attribute_mask)(GFileInfo *info, GFileAttributeMatcher *mask);
    void (*file_info_unset_attribute_mask)(GFileInfo *info);
    void (*file_info_set_file_type)(GFileInfo *info, GFileType type);
    void (*file_info_set_is_hidden)(GFileInfo *info, gboolean is_hidden);
    void (*file_info_set_is_symlink)(GFileInfo *info, gboolean is_symlink);
    void (*file_info_set_name)(GFileInfo *info, const char *name);
    void (*file_info_set_display_name)(GFileInfo *info, const char *display_name);
    void (*file_info_set_edit_name)(GFileInfo *info, const char *edit_name);
    void (*file_info_set_icon)(GFileInfo *info, GIcon *icon);
    void (*file_info_set_symbolic_icon)(GFileInfo *info, GIcon *icon);
    void (*file_info_set_content_type)(GFileInfo *info, const char *content_type);
    void (*file_info_set_size)(GFileInfo *info, goffset size);
    void (*file_info_set_access_date_time)(GFileInfo *info, GDateTime *atime);
    void (*file_info_set_creation_date_time)(GFileInfo *info, GDateTime *creation_time);
    void (*file_info_set_symlink_target)(GFileInfo *info, const char *symlink_target);
    void (*file_info_set_sort_order)(GFileInfo *info, gint32 sort_order);
    GType (*file_attribute_matcher_get_type)(void);
    GFileAttributeMatcher* (*file_attribute_matcher_new)(const char *attributes);
    GFileAttributeMatcher* (*file_attribute_matcher_ref)(GFileAttributeMatcher *matcher);
    void (*file_attribute_matcher_unref)(GFileAttributeMatcher *matcher);
    GFileAttributeMatcher* (*file_attribute_matcher_subtract)(GFileAttributeMatcher *matcher, GFileAttributeMatcher *subtract);
    gboolean (*file_attribute_matcher_matches)(GFileAttributeMatcher *matcher, const char *attribute);
    gboolean (*file_attribute_matcher_matches_only)(GFileAttributeMatcher *matcher, const char *attribute);
    gboolean (*file_attribute_matcher_enumerate_namespace)(GFileAttributeMatcher *matcher, const char *ns);
    const char * (*file_attribute_matcher_enumerate_next)(GFileAttributeMatcher *matcher);
    char * (*file_attribute_matcher_to_string)(GFileAttributeMatcher *matcher);
    GType (*file_info_get_type)(void);
    GFileInfo* (*file_input_stream_query_info)(GFileInputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
    void (*file_input_stream_query_info_async)(GFileInputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo* (*file_input_stream_query_info_finish)(GFileInputStream *stream, GAsyncResult *result, GError **error);
    GType (*file_input_stream_get_type)(void);
    GFileInfo* (*file_io_stream_query_info)(GFileIOStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
    void (*file_io_stream_query_info_async)(GFileIOStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo* (*file_io_stream_query_info_finish)(GFileIOStream *stream, GAsyncResult *result, GError **error);
    char * (*file_io_stream_get_etag)(GFileIOStream *stream);
    GType (*file_io_stream_get_type)(void);
    gboolean (*file_monitor_cancel)(GFileMonitor *monitor);
    gboolean (*file_monitor_is_cancelled)(GFileMonitor *monitor);
    void (*file_monitor_set_rate_limit)(GFileMonitor *monitor, gint limit_msecs);
    void (*file_monitor_emit_event)(GFileMonitor *monitor, GFile *child, GFile *other_file, GFileMonitorEvent event_type);
    GType (*file_monitor_get_type)(void);
    GFilenameCompleter* (*filename_completer_new)(void);
    char * (*filename_completer_get_completion_suffix)(GFilenameCompleter *completer, const char *initial_text);
    char ** (*filename_completer_get_completions)(GFilenameCompleter *completer, const char *initial_text);
    void (*filename_completer_set_dirs_only)(GFilenameCompleter *completer, gboolean dirs_only);
    GType (*filename_completer_get_type)(void);
    GFileInfo* (*file_output_stream_query_info)(GFileOutputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
    void (*file_output_stream_query_info_async)(GFileOutputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo* (*file_output_stream_query_info_finish)(GFileOutputStream *stream, GAsyncResult *result, GError **error);
    char * (*file_output_stream_get_etag)(GFileOutputStream *stream);
    GType (*file_output_stream_get_type)(void);
    GInputStream * (*filter_input_stream_get_base_stream)(GFilterInputStream *stream);
    gboolean (*filter_input_stream_get_close_base_stream)(GFilterInputStream *stream);
    void (*filter_input_stream_set_close_base_stream)(GFilterInputStream *stream, gboolean close_base);
    GType (*filter_input_stream_get_type)(void);
    GOutputStream * (*filter_output_stream_get_base_stream)(GFilterOutputStream *stream);
    gboolean (*filter_output_stream_get_close_base_stream)(GFilterOutputStream *stream);
    void (*filter_output_stream_set_close_base_stream)(GFilterOutputStream *stream, gboolean close_base);
    GType (*filter_output_stream_get_type)(void);
    guint (*icon_hash)(gconstpointer icon);
    gboolean (*icon_equal)(GIcon *icon1, GIcon *icon2);
    gchar* (*icon_to_string)(GIcon *icon);
    GIcon* (*icon_new_for_string)(const gchar *str, GError **error);
    GVariant * (*icon_serialize)(GIcon *icon);
    GIcon * (*icon_deserialize)(GVariant *value);
    GType (*icon_get_type)(void);
    GInetAddress * (*inet_address_new_from_string)(const gchar *string);
    GInetAddress * (*inet_address_new_from_bytes)(const guint8 *bytes, GSocketFamily family);
    GInetAddress * (*inet_address_new_loopback)(GSocketFamily family);
    GInetAddress * (*inet_address_new_any)(GSocketFamily family);
    gboolean (*inet_address_equal)(GInetAddress *address, GInetAddress *other_address);
    gchar * (*inet_address_to_string)(GInetAddress *address);
    const guint8 * (*inet_address_to_bytes)(GInetAddress *address);
    gsize (*inet_address_get_native_size)(GInetAddress *address);
    GSocketFamily (*inet_address_get_family)(GInetAddress *address);
    gboolean (*inet_address_get_is_any)(GInetAddress *address);
    gboolean (*inet_address_get_is_loopback)(GInetAddress *address);
    gboolean (*inet_address_get_is_link_local)(GInetAddress *address);
    gboolean (*inet_address_get_is_site_local)(GInetAddress *address);
    gboolean (*inet_address_get_is_multicast)(GInetAddress *address);
    gboolean (*inet_address_get_is_mc_global)(GInetAddress *address);
    gboolean (*inet_address_get_is_mc_link_local)(GInetAddress *address);
    gboolean (*inet_address_get_is_mc_node_local)(GInetAddress *address);
    gboolean (*inet_address_get_is_mc_org_local)(GInetAddress *address);
    gboolean (*inet_address_get_is_mc_site_local)(GInetAddress *address);
    GType (*inet_address_get_type)(void);
    GInetAddressMask* (*inet_address_mask_new)(GInetAddress *addr, guint length, GError **error);
    GInetAddressMask* (*inet_address_mask_new_from_string)(const gchar *mask_string, GError **error);
    gchar* (*inet_address_mask_to_string)(GInetAddressMask *mask);
    GSocketFamily (*inet_address_mask_get_family)(GInetAddressMask *mask);
    GInetAddress* (*inet_address_mask_get_address)(GInetAddressMask *mask);
    guint (*inet_address_mask_get_length)(GInetAddressMask *mask);
    gboolean (*inet_address_mask_matches)(GInetAddressMask *mask, GInetAddress *address);
    gboolean (*inet_address_mask_equal)(GInetAddressMask *mask, GInetAddressMask *mask2);
    GType (*inet_address_mask_get_type)(void);
    GSocketAddress* (*inet_socket_address_new)(GInetAddress *address, guint16 port);
    GSocketAddress* (*inet_socket_address_new_from_string)(const char *address, guint port);
    GInetAddress * (*inet_socket_address_get_address)(GInetSocketAddress *address);
    guint16 (*inet_socket_address_get_port)(GInetSocketAddress *address);
    guint32 (*inet_socket_address_get_flowinfo)(GInetSocketAddress *address);
    guint32 (*inet_socket_address_get_scope_id)(GInetSocketAddress *address);
    GType (*inet_socket_address_get_type)(void);
    gboolean (*initable_init)(GInitable *initable, GCancellable *cancellable, GError **error);
    gpointer (*initable_new)(GType object_type, GCancellable *cancellable, GError **error, const gchar *first_property_name, ...);
    GType (*initable_get_type)(void);
    gssize (*input_stream_read)(GInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
    gboolean (*input_stream_read_all)(GInputStream *stream, void *buffer, gsize count, gsize *bytes_read, GCancellable *cancellable, GError **error);
    GBytes* (*input_stream_read_bytes)(GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
    gssize (*input_stream_skip)(GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
    gboolean (*input_stream_close)(GInputStream *stream, GCancellable *cancellable, GError **error);
    void (*input_stream_read_async)(GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*input_stream_read_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    void (*input_stream_read_all_async)(GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*input_stream_read_all_finish)(GInputStream *stream, GAsyncResult *result, gsize *bytes_read, GError **error);
    void (*input_stream_read_bytes_async)(GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GBytes* (*input_stream_read_bytes_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    void (*input_stream_skip_async)(GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*input_stream_skip_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    void (*input_stream_close_async)(GInputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*input_stream_close_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    gboolean (*input_stream_is_closed)(GInputStream *stream);
    gboolean (*input_stream_has_pending)(GInputStream *stream);
    gboolean (*input_stream_set_pending)(GInputStream *stream, GError **error);
    void (*input_stream_clear_pending)(GInputStream *stream);
    GType (*input_stream_get_type)(void);
    GType (*converter_flags_get_type)(void);
    GType (*converter_result_get_type)(void);
    GType (*data_stream_byte_order_get_type)(void);
    GType (*data_stream_newline_type_get_type)(void);
    GType (*file_attribute_type_get_type)(void);
    GType (*file_attribute_info_flags_get_type)(void);
    GType (*file_attribute_status_get_type)(void);
    GType (*file_query_info_flags_get_type)(void);
    GType (*file_create_flags_get_type)(void);
    GType (*file_measure_flags_get_type)(void);
    GType (*mount_mount_flags_get_type)(void);
    GType (*mount_unmount_flags_get_type)(void);
    GType (*drive_start_flags_get_type)(void);
    GType (*drive_start_stop_type_get_type)(void);
    GType (*file_copy_flags_get_type)(void);
    GType (*file_monitor_flags_get_type)(void);
    GType (*file_type_get_type)(void);
    GType (*filesystem_preview_type_get_type)(void);
    GType (*file_monitor_event_get_type)(void);
    GType (*io_error_enum_get_type)(void);
    GType (*ask_password_flags_get_type)(void);
    GType (*password_save_get_type)(void);
    GType (*mount_operation_result_get_type)(void);
    GType (*output_stream_splice_flags_get_type)(void);
    GType (*io_stream_splice_flags_get_type)(void);
    GType (*emblem_origin_get_type)(void);
    GType (*resolver_error_get_type)(void);
    GType (*resolver_record_type_get_type)(void);
    GType (*resource_error_get_type)(void);
    GType (*resource_flags_get_type)(void);
    GType (*resource_lookup_flags_get_type)(void);
    GType (*socket_family_get_type)(void);
    GType (*socket_type_get_type)(void);
    GType (*socket_msg_flags_get_type)(void);
    GType (*socket_protocol_get_type)(void);
    GType (*zlib_compressor_format_get_type)(void);
    GType (*unix_socket_address_type_get_type)(void);
    GType (*bus_type_get_type)(void);
    GType (*bus_name_owner_flags_get_type)(void);
    GType (*bus_name_watcher_flags_get_type)(void);
    GType (*dbus_proxy_flags_get_type)(void);
    GType (*dbus_error_get_type)(void);
    GType (*dbus_connection_flags_get_type)(void);
    GType (*dbus_capability_flags_get_type)(void);
    GType (*dbus_call_flags_get_type)(void);
    GType (*dbus_message_type_get_type)(void);
    GType (*dbus_message_flags_get_type)(void);
    GType (*dbus_message_header_field_get_type)(void);
    GType (*dbus_property_info_flags_get_type)(void);
    GType (*dbus_subtree_flags_get_type)(void);
    GType (*dbus_server_flags_get_type)(void);
    GType (*dbus_signal_flags_get_type)(void);
    GType (*dbus_send_message_flags_get_type)(void);
    GType (*credentials_type_get_type)(void);
    GType (*dbus_message_byte_order_get_type)(void);
    GType (*application_flags_get_type)(void);
    GType (*tls_error_get_type)(void);
    GType (*tls_certificate_flags_get_type)(void);
    GType (*tls_authentication_mode_get_type)(void);
    GType (*tls_channel_binding_type_get_type)(void);
    GType (*tls_channel_binding_error_get_type)(void);
    GType (*tls_rehandshake_mode_get_type)(void);
    GType (*tls_password_flags_get_type)(void);
    GType (*tls_interaction_result_get_type)(void);
    GType (*dbus_interface_skeleton_flags_get_type)(void);
    GType (*dbus_object_manager_client_flags_get_type)(void);
    GType (*tls_database_verify_flags_get_type)(void);
    GType (*tls_database_lookup_flags_get_type)(void);
    GType (*tls_certificate_request_flags_get_type)(void);
    GType (*tls_protocol_version_get_type)(void);
    GType (*io_module_scope_flags_get_type)(void);
    GType (*socket_client_event_get_type)(void);
    GType (*socket_listener_event_get_type)(void);
    GType (*test_dbus_flags_get_type)(void);
    GType (*subprocess_flags_get_type)(void);
    GType (*notification_priority_get_type)(void);
    GType (*network_connectivity_get_type)(void);
    GType (*pollable_return_get_type)(void);
    GType (*memory_monitor_warning_level_get_type)(void);
    GType (*resolver_name_lookup_flags_get_type)(void);
    GType (*settings_bind_flags_get_type)(void);
    GType (*app_info_create_flags_get_type)(void);
    GIOErrorEnum (*io_error_from_errno)(gint err_no);
    GIOErrorEnum (*io_error_from_file_error)(GFileError file_error);
    GIOErrorEnum (*io_error_from_win32_error)(gint error_code);
    GQuark (*io_error_quark)(void);
    void (*io_module_scope_free)(GIOModuleScope *scope);
    void (*io_module_scope_block)(GIOModuleScope *scope, const gchar *basename);
    GType (*io_module_get_type)(void);
    GIOModule* (*io_module_new)(const gchar *filename);
    void (*io_modules_scan_all_in_directory)(const char *dirname);
    GList* (*io_modules_load_all_in_directory)(const gchar *dirname);
    void (*io_modules_scan_all_in_directory_with_scope)(const gchar *dirname, GIOModuleScope *scope);
    GList* (*io_modules_load_all_in_directory_with_scope)(const gchar *dirname, GIOModuleScope *scope);
    GIOExtensionPoint* (*io_extension_point_register)(const char *name);
    GIOExtensionPoint* (*io_extension_point_lookup)(const char *name);
    void (*io_extension_point_set_required_type)(GIOExtensionPoint *extension_point, GType type);
    GType (*io_extension_point_get_required_type)(GIOExtensionPoint *extension_point);
    GList* (*io_extension_point_get_extensions)(GIOExtensionPoint *extension_point);
    GIOExtension * (*io_extension_point_get_extension_by_name)(GIOExtensionPoint *extension_point, const char *name);
    GIOExtension * (*io_extension_point_implement)(const char *extension_point_name, GType type, const char *extension_name, gint priority);
    GType (*io_extension_get_type)(GIOExtension *extension);
    const char * (*io_extension_get_name)(GIOExtension *extension);
    gint (*io_extension_get_priority)(GIOExtension *extension);
    GTypeClass* (*io_extension_ref_class)(GIOExtension *extension);
    void (*io_module_load)(GIOModule *module);
    void (*io_module_unload)(GIOModule *module);
    char** (*io_module_query)(void);
    GIOModuleScope * (*io_module_scope_new)(GIOModuleScopeFlags flags);
    void (*io_scheduler_cancel_all_jobs)(void);
    gboolean (*io_scheduler_job_send_to_mainloop)(GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
    void (*io_scheduler_job_send_to_mainloop_async)(GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
    void (*io_scheduler_push_job)(GIOSchedulerJobFunc job_func, gpointer user_data, GDestroyNotify notify, gint io_priority, GCancellable *cancellable);
    GInputStream * (*io_stream_get_input_stream)(GIOStream *stream);
    GOutputStream* (*io_stream_get_output_stream)(GIOStream *stream);
    void (*io_stream_splice_async)(GIOStream *stream1, GIOStream *stream2, GIOStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*io_stream_splice_finish)(GAsyncResult *result, GError **error);
    gboolean (*io_stream_close)(GIOStream *stream, GCancellable *cancellable, GError **error);
    void (*io_stream_close_async)(GIOStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*io_stream_close_finish)(GIOStream *stream, GAsyncResult *result, GError **error);
    gboolean (*io_stream_is_closed)(GIOStream *stream);
    gboolean (*io_stream_has_pending)(GIOStream *stream);
    gboolean (*io_stream_set_pending)(GIOStream *stream, GError **error);
    void (*io_stream_clear_pending)(GIOStream *stream);
    GType (*io_stream_get_type)(void);
    guint (*list_model_get_n_items)(GListModel *list);
    gpointer (*list_model_get_item)(GListModel *list, guint position);
    GObject * (*list_model_get_object)(GListModel *list, guint position);
    void (*list_model_items_changed)(GListModel *list, guint position, guint removed, guint added);
    void (*list_store_insert)(GListStore *store, guint position, gpointer item);
    guint (*list_store_insert_sorted)(GListStore *store, gpointer item, GCompareDataFunc compare_func, gpointer user_data);
    void (*list_store_sort)(GListStore *store, GCompareDataFunc compare_func, gpointer user_data);
    void (*list_store_append)(GListStore *store, gpointer item);
    void (*list_store_remove)(GListStore *store, guint position);
    void (*list_store_remove_all)(GListStore *store);
    void (*list_store_splice)(GListStore *store, guint position, guint n_removals, gpointer *additions, guint n_additions);
    gboolean (*list_store_find)(GListStore *store, gpointer item, guint *position);
    gboolean (*list_store_find_with_equal_func)(GListStore *store, gpointer item, GEqualFunc equal_func, guint *position);
    gboolean (*list_store_find_with_equal_func_full)(GListStore *store, gpointer item, GEqualFuncFull equal_func, gpointer user_data, guint *position);
    GListStore * (*list_store_new)(GType item_type);
    GInputStream* (*loadable_icon_load)(GLoadableIcon *icon, int size, char **type, GCancellable *cancellable, GError **error);
    void (*loadable_icon_load_async)(GLoadableIcon *icon, int size, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GInputStream* (*loadable_icon_load_finish)(GLoadableIcon *icon, GAsyncResult *res, char **type, GError **error);
    GType (*loadable_icon_get_type)(void);
    GInputStream * (*memory_input_stream_new)(void);
    GInputStream * (*memory_input_stream_new_from_data)(const void *data, gssize len, GDestroyNotify destroy);
    GInputStream * (*memory_input_stream_new_from_bytes)(GBytes *bytes);
    void (*memory_input_stream_add_data)(GMemoryInputStream *stream, const void *data, gssize len, GDestroyNotify destroy);
    void (*memory_input_stream_add_bytes)(GMemoryInputStream *stream, GBytes *bytes);
    GType (*memory_input_stream_get_type)(void);
    GOutputStream* (*memory_output_stream_new)(gpointer data, gsize size, GReallocFunc realloc_function, GDestroyNotify destroy_function);
    GOutputStream* (*memory_output_stream_new_resizable)(void);
    gpointer (*memory_output_stream_get_data)(GMemoryOutputStream *ostream);
    gsize (*memory_output_stream_get_size)(GMemoryOutputStream *ostream);
    gsize (*memory_output_stream_get_data_size)(GMemoryOutputStream *ostream);
    gpointer (*memory_output_stream_steal_data)(GMemoryOutputStream *ostream);
    GBytes * (*memory_output_stream_steal_as_bytes)(GMemoryOutputStream *ostream);
    GType (*memory_output_stream_get_type)(void);
    GMenu * (*menu_new)(void);
    void (*menu_freeze)(GMenu *menu);
    void (*menu_insert_item)(GMenu *menu, gint position, GMenuItem *item);
    void (*menu_prepend_item)(GMenu *menu, GMenuItem *item);
    void (*menu_append_item)(GMenu *menu, GMenuItem *item);
    void (*menu_remove)(GMenu *menu, gint position);
    void (*menu_remove_all)(GMenu *menu);
    void (*menu_insert)(GMenu *menu, gint position, const gchar *label, const gchar *detailed_action);
    void (*menu_prepend)(GMenu *menu, const gchar *label, const gchar *detailed_action);
    void (*menu_append)(GMenu *menu, const gchar *label, const gchar *detailed_action);
    void (*menu_insert_section)(GMenu *menu, gint position, const gchar *label, GMenuModel *section);
    void (*menu_prepend_section)(GMenu *menu, const gchar *label, GMenuModel *section);
    void (*menu_append_section)(GMenu *menu, const gchar *label, GMenuModel *section);
    void (*menu_insert_submenu)(GMenu *menu, gint position, const gchar *label, GMenuModel *submenu);
    void (*menu_prepend_submenu)(GMenu *menu, const gchar *label, GMenuModel *submenu);
    void (*menu_append_submenu)(GMenu *menu, const gchar *label, GMenuModel *submenu);
    GType (*menu_item_get_type)(void);
    GMenuItem * (*menu_item_new)(const gchar *label, const gchar *detailed_action);
    GMenuItem * (*menu_item_new_from_model)(GMenuModel *model, gint item_index);
    GMenuItem * (*menu_item_new_submenu)(const gchar *label, GMenuModel *submenu);
    GMenuItem * (*menu_item_new_section)(const gchar *label, GMenuModel *section);
    GVariant * (*menu_item_get_attribute_value)(GMenuItem *menu_item, const gchar *attribute, const GVariantType *expected_type);
    gboolean (*menu_item_get_attribute)(GMenuItem *menu_item, const gchar *attribute, const gchar *format_string, ...);
    GMenuModel* (*menu_item_get_link)(GMenuItem *menu_item, const gchar *link);
    void (*menu_item_set_attribute_value)(GMenuItem *menu_item, const gchar *attribute, GVariant *value);
    void (*menu_item_set_attribute)(GMenuItem *menu_item, const gchar *attribute, const gchar *format_string, ...);
    void (*menu_item_set_link)(GMenuItem *menu_item, const gchar *link, GMenuModel *model);
    void (*menu_item_set_label)(GMenuItem *menu_item, const gchar *label);
    void (*menu_item_set_submenu)(GMenuItem *menu_item, GMenuModel *submenu);
    void (*menu_item_set_section)(GMenuItem *menu_item, GMenuModel *section);
    void (*menu_item_set_action_and_target_value)(GMenuItem *menu_item, const gchar *action, GVariant *target_value);
    void (*menu_item_set_action_and_target)(GMenuItem *menu_item, const gchar *action, const gchar *format_string, ...);
    void (*menu_item_set_detailed_action)(GMenuItem *menu_item, const gchar *detailed_action);
    void (*menu_item_set_icon)(GMenuItem *menu_item, GIcon *icon);
    GType (*menu_get_type)(void);
    void (*dbus_connection_unexport_menu_model)(GDBusConnection *connection, guint export_id);
    guint (*dbus_connection_export_menu_model)(GDBusConnection *connection, const gchar *object_path, GMenuModel *menu, GError **error);
    gboolean (*menu_model_is_mutable)(GMenuModel *model);
    gint (*menu_model_get_n_items)(GMenuModel *model);
    GMenuAttributeIter * (*menu_model_iterate_item_attributes)(GMenuModel *model, gint item_index);
    GVariant * (*menu_model_get_item_attribute_value)(GMenuModel *model, gint item_index, const gchar *attribute, const GVariantType *expected_type);
    gboolean (*menu_model_get_item_attribute)(GMenuModel *model, gint item_index, const gchar *attribute, const gchar *format_string, ...);
    GMenuLinkIter * (*menu_model_iterate_item_links)(GMenuModel *model, gint item_index);
    GMenuModel * (*menu_model_get_item_link)(GMenuModel *model, gint item_index, const gchar *link);
    void (*menu_model_items_changed)(GMenuModel *model, gint position, gint removed, gint added);
    GType (*menu_attribute_iter_get_type)(void);
    gboolean (*menu_attribute_iter_get_next)(GMenuAttributeIter *iter, const gchar **out_name, GVariant **value);
    gboolean (*menu_attribute_iter_next)(GMenuAttributeIter *iter);
    const gchar * (*menu_attribute_iter_get_name)(GMenuAttributeIter *iter);
    GVariant * (*menu_attribute_iter_get_value)(GMenuAttributeIter *iter);
    GType (*menu_link_iter_get_type)(void);
    gboolean (*menu_link_iter_get_next)(GMenuLinkIter *iter, const gchar **out_link, GMenuModel **value);
    gboolean (*menu_link_iter_next)(GMenuLinkIter *iter);
    const gchar * (*menu_link_iter_get_name)(GMenuLinkIter *iter);
    GMenuModel * (*menu_link_iter_get_value)(GMenuLinkIter *iter);
    GType (*menu_model_get_type)(void);
    GFile * (*mount_get_root)(GMount *mount);
    GFile * (*mount_get_default_location)(GMount *mount);
    char * (*mount_get_name)(GMount *mount);
    GIcon * (*mount_get_icon)(GMount *mount);
    GIcon * (*mount_get_symbolic_icon)(GMount *mount);
    char * (*mount_get_uuid)(GMount *mount);
    GVolume * (*mount_get_volume)(GMount *mount);
    GDrive * (*mount_get_drive)(GMount *mount);
    gboolean (*mount_can_unmount)(GMount *mount);
    gboolean (*mount_can_eject)(GMount *mount);
    void (*mount_unmount)(GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*mount_unmount_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*mount_eject)(GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*mount_eject_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*mount_remount)(GMount *mount, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*mount_remount_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*mount_guess_content_type)(GMount *mount, gboolean force_rescan, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gchar ** (*mount_guess_content_type_finish)(GMount *mount, GAsyncResult *result, GError **error);
    gchar ** (*mount_guess_content_type_sync)(GMount *mount, gboolean force_rescan, GCancellable *cancellable, GError **error);
    gboolean (*mount_is_shadowed)(GMount *mount);
    void (*mount_shadow)(GMount *mount);
    void (*mount_unshadow)(GMount *mount);
    void (*mount_unmount_with_operation)(GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*mount_unmount_with_operation_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*mount_eject_with_operation)(GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*mount_eject_with_operation_finish)(GMount *mount, GAsyncResult *result, GError **error);
    const gchar* (*mount_get_sort_key)(GMount *mount);
    GType (*mount_get_type)(void);
    GMountOperation * (*mount_operation_new)(void);
    const char * (*mount_operation_get_username)(GMountOperation *op);
    void (*mount_operation_set_username)(GMountOperation *op, const char *username);
    const char * (*mount_operation_get_password)(GMountOperation *op);
    void (*mount_operation_set_password)(GMountOperation *op, const char *password);
    gboolean (*mount_operation_get_anonymous)(GMountOperation *op);
    void (*mount_operation_set_anonymous)(GMountOperation *op, gboolean anonymous);
    const char * (*mount_operation_get_domain)(GMountOperation *op);
    void (*mount_operation_set_domain)(GMountOperation *op, const char *domain);
    GPasswordSave (*mount_operation_get_password_save)(GMountOperation *op);
    void (*mount_operation_set_password_save)(GMountOperation *op, GPasswordSave save);
    int (*mount_operation_get_choice)(GMountOperation *op);
    void (*mount_operation_set_choice)(GMountOperation *op, int choice);
    void (*mount_operation_reply)(GMountOperation *op, GMountOperationResult result);
    gboolean (*mount_operation_get_is_tcrypt_hidden_volume)(GMountOperation *op);
    void (*mount_operation_set_is_tcrypt_hidden_volume)(GMountOperation *op, gboolean hidden_volume);
    gboolean (*mount_operation_get_is_tcrypt_system_volume)(GMountOperation *op);
    void (*mount_operation_set_is_tcrypt_system_volume)(GMountOperation *op, gboolean system_volume);
    guint (*mount_operation_get_pim)(GMountOperation *op);
    void (*mount_operation_set_pim)(GMountOperation *op, guint pim);
    GType (*mount_operation_get_type)(void);
    GSocketAddress* (*native_socket_address_new)(gpointer native, gsize len);
    GType (*native_socket_address_get_type)(void);
    GType (*native_volume_monitor_get_type)(void);
    GSocketConnectable* (*network_address_new)(const gchar *hostname, guint16 port);
    GSocketConnectable* (*network_address_new_loopback)(guint16 port);
    GSocketConnectable* (*network_address_parse)(const gchar *host_and_port, guint16 default_port, GError **error);
    GSocketConnectable* (*network_address_parse_uri)(const gchar *uri, guint16 default_port, GError **error);
    const gchar* (*network_address_get_hostname)(GNetworkAddress *addr);
    guint16 (*network_address_get_port)(GNetworkAddress *addr);
    const gchar* (*network_address_get_scheme)(GNetworkAddress *addr);
    GType (*network_address_get_type)(void);
    void (*networking_init)(void);
    GNetworkMonitor* (*network_monitor_get_default)(void);
    gboolean (*network_monitor_get_network_available)(GNetworkMonitor *monitor);
    gboolean (*network_monitor_get_network_metered)(GNetworkMonitor *monitor);
    GNetworkConnectivity (*network_monitor_get_connectivity)(GNetworkMonitor *monitor);
    gboolean (*network_monitor_can_reach)(GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
    void (*network_monitor_can_reach_async)(GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*network_monitor_can_reach_finish)(GNetworkMonitor *monitor, GAsyncResult *result, GError **error);
    GType (*network_monitor_get_type)(void);
    GSocketConnectable* (*network_service_new)(const gchar *service, const gchar *protocol, const gchar *domain);
    const gchar* (*network_service_get_service)(GNetworkService *srv);
    const gchar* (*network_service_get_protocol)(GNetworkService *srv);
    const gchar* (*network_service_get_domain)(GNetworkService *srv);
    const gchar* (*network_service_get_scheme)(GNetworkService *srv);
    void (*network_service_set_scheme)(GNetworkService *srv, const gchar *scheme);
    GType (*network_service_get_type)(void);
    GNotification * (*notification_new)(const gchar *title);
    void (*notification_set_title)(GNotification *notification, const gchar *title);
    void (*notification_set_body)(GNotification *notification, const gchar *body);
    void (*notification_set_icon)(GNotification *notification, GIcon *icon);
    void (*notification_set_urgent)(GNotification *notification, gboolean urgent);
    void (*notification_set_priority)(GNotification *notification, GNotificationPriority priority);
    void (*notification_set_category)(GNotification *notification, const gchar *category);
    void (*notification_add_button)(GNotification *notification, const gchar *label, const gchar *detailed_action);
    void (*notification_add_button_with_target)(GNotification *notification, const gchar *label, const gchar *action, const gchar *target_format, ...);
    void (*notification_add_button_with_target_value)(GNotification *notification, const gchar *label, const gchar *action, GVariant *target);
    void (*notification_set_default_action)(GNotification *notification, const gchar *detailed_action);
    void (*notification_set_default_action_and_target)(GNotification *notification, const gchar *action, const gchar *target_format, ...);
    void (*notification_set_default_action_and_target_value)(GNotification *notification, const gchar *action, GVariant *target);
    GType (*notification_get_type)(void);
    gssize (*output_stream_write)(GOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
    gboolean (*output_stream_write_all)(GOutputStream *stream, const void *buffer, gsize count, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*output_stream_writev)(GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*output_stream_writev_all)(GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*output_stream_printf)(GOutputStream *stream, gsize *bytes_written, GCancellable *cancellable, GError **error, const gchar *format, ...);
    gboolean (*output_stream_vprintf)(GOutputStream *stream, gsize *bytes_written, GCancellable *cancellable, GError **error, const gchar *format, va_list args);
    gssize (*output_stream_write_bytes)(GOutputStream *stream, GBytes *bytes, GCancellable *cancellable, GError **error);
    gssize (*output_stream_splice)(GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*output_stream_flush)(GOutputStream *stream, GCancellable *cancellable, GError **error);
    gboolean (*output_stream_close)(GOutputStream *stream, GCancellable *cancellable, GError **error);
    void (*output_stream_write_async)(GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*output_stream_write_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*output_stream_write_all_async)(GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*output_stream_write_all_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
    void (*output_stream_writev_async)(GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*output_stream_writev_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
    void (*output_stream_writev_all_async)(GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*output_stream_writev_all_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
    void (*output_stream_write_bytes_async)(GOutputStream *stream, GBytes *bytes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*output_stream_write_bytes_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*output_stream_splice_async)(GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*output_stream_splice_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*output_stream_flush_async)(GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*output_stream_flush_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*output_stream_close_async)(GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*output_stream_close_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    gboolean (*output_stream_is_closed)(GOutputStream *stream);
    gboolean (*output_stream_is_closing)(GOutputStream *stream);
    gboolean (*output_stream_has_pending)(GOutputStream *stream);
    gboolean (*output_stream_set_pending)(GOutputStream *stream, GError **error);
    void (*output_stream_clear_pending)(GOutputStream *stream);
    GType (*output_stream_get_type)(void);
    gboolean (*permission_acquire)(GPermission *permission, GCancellable *cancellable, GError **error);
    void (*permission_acquire_async)(GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*permission_acquire_finish)(GPermission *permission, GAsyncResult *result, GError **error);
    gboolean (*permission_release)(GPermission *permission, GCancellable *cancellable, GError **error);
    void (*permission_release_async)(GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*permission_release_finish)(GPermission *permission, GAsyncResult *result, GError **error);
    gboolean (*permission_get_allowed)(GPermission *permission);
    gboolean (*permission_get_can_acquire)(GPermission *permission);
    gboolean (*permission_get_can_release)(GPermission *permission);
    void (*permission_impl_update)(GPermission *permission, gboolean allowed, gboolean can_acquire, gboolean can_release);
    GType (*permission_get_type)(void);
    gboolean (*pollable_input_stream_can_poll)(GPollableInputStream *stream);
    gboolean (*pollable_input_stream_is_readable)(GPollableInputStream *stream);
    GSource* (*pollable_input_stream_create_source)(GPollableInputStream *stream, GCancellable *cancellable);
    gssize (*pollable_input_stream_read_nonblocking)(GPollableInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
    GType (*pollable_input_stream_get_type)(void);
    gboolean (*pollable_output_stream_can_poll)(GPollableOutputStream *stream);
    gboolean (*pollable_output_stream_is_writable)(GPollableOutputStream *stream);
    GSource* (*pollable_output_stream_create_source)(GPollableOutputStream *stream, GCancellable *cancellable);
    gssize (*pollable_output_stream_write_nonblocking)(GPollableOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
    GPollableReturn (*pollable_output_stream_writev_nonblocking)(GPollableOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
    GType (*pollable_output_stream_get_type)(void);
    GSource* (*pollable_source_new_full)(gpointer pollable_stream, GSource *child_source, GCancellable *cancellable);
    gssize (*pollable_stream_read)(GInputStream *stream, void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
    gssize (*pollable_stream_write)(GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
    gboolean (*pollable_stream_write_all)(GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, gsize *bytes_written, GCancellable *cancellable, GError **error);
    GSource* (*pollable_source_new)(GObject *pollable_stream);
    gboolean (*power_profile_monitor_get_power_saver_enabled)(GPowerProfileMonitor *monitor);
    GPropertyAction * (*property_action_new)(const gchar *name, gpointer object, const gchar *property_name);
    GType (*property_action_get_type)(void);
    GProxy* (*proxy_get_default_for_protocol)(const gchar *protocol);
    GIOStream* (*proxy_connect)(GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GError **error);
    void (*proxy_connect_async)(GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GIOStream* (*proxy_connect_finish)(GProxy *proxy, GAsyncResult *result, GError **error);
    gboolean (*proxy_supports_hostname)(GProxy *proxy);
    GType (*proxy_get_type)(void);
    GSocketAddress* (*proxy_address_new)(GInetAddress *inetaddr, guint16 port, const gchar *protocol, const gchar *dest_hostname, guint16 dest_port, const gchar *username, const gchar *password);
    const gchar* (*proxy_address_get_protocol)(GProxyAddress *proxy);
    const gchar* (*proxy_address_get_destination_protocol)(GProxyAddress *proxy);
    const gchar* (*proxy_address_get_destination_hostname)(GProxyAddress *proxy);
    guint16 (*proxy_address_get_destination_port)(GProxyAddress *proxy);
    const gchar* (*proxy_address_get_username)(GProxyAddress *proxy);
    const gchar* (*proxy_address_get_password)(GProxyAddress *proxy);
    const gchar* (*proxy_address_get_uri)(GProxyAddress *proxy);
    GType (*proxy_address_get_type)(void);
    GType (*proxy_address_enumerator_get_type)(void);
    GProxyResolver* (*proxy_resolver_get_default)(void);
    gboolean (*proxy_resolver_is_supported)(GProxyResolver *resolver);
    gchar** (*proxy_resolver_lookup)(GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GError **error);
    void (*proxy_resolver_lookup_async)(GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gchar** (*proxy_resolver_lookup_finish)(GProxyResolver *resolver, GAsyncResult *result, GError **error);
    GType (*proxy_resolver_get_type)(void);
    void (*remote_action_group_activate_action_full)(GRemoteActionGroup *remote, const gchar *action_name, GVariant *parameter, GVariant *platform_data);
    void (*remote_action_group_change_action_state_full)(GRemoteActionGroup *remote, const gchar *action_name, GVariant *value, GVariant *platform_data);
    GType (*remote_action_group_get_type)(void);
    GResolver* (*resolver_get_default)(void);
    void (*resolver_set_default)(GResolver *resolver);
    GList* (*resolver_lookup_by_name)(GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GError **error);
    void (*resolver_lookup_by_name_async)(GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*resolver_lookup_by_name_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    void (*resolver_lookup_by_name_with_flags_async)(GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*resolver_lookup_by_name_with_flags_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    GList* (*resolver_lookup_by_name_with_flags)(GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*resolver_free_addresses)(GList *addresses);
    gchar* (*resolver_lookup_by_address)(GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GError **error);
    void (*resolver_lookup_by_address_async)(GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gchar* (*resolver_lookup_by_address_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    GList* (*resolver_lookup_service)(GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GError **error);
    void (*resolver_lookup_service_async)(GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*resolver_lookup_service_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    GList* (*resolver_lookup_records)(GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GError **error);
    void (*resolver_lookup_records_async)(GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*resolver_lookup_records_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    void (*resolver_free_targets)(GList *targets);
    unsigned (*resolver_get_timeout)(GResolver *resolver);
    void (*resolver_set_timeout)(GResolver *resolver, unsigned timeout_ms);
    GQuark (*resolver_error_quark)(void);
    GType (*resolver_get_type)(void);
    GType (*resource_get_type)(void);
    GResource * (*resource_new_from_data)(GBytes *data, GError **error);
    GResource * (*resource_ref)(GResource *resource);
    void (*resource_unref)(GResource *resource);
    GResource * (*resource_load)(const gchar *filename, GError **error);
    GInputStream* (*resource_open_stream)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
    GBytes * (*resource_lookup_data)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
    char ** (*resource_enumerate_children)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
    gboolean (*resource_get_info)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
    void (*resources_register)(GResource *resource);
    void (*resources_unregister)(GResource *resource);
    GInputStream* (*resources_open_stream)(const char *path, GResourceLookupFlags lookup_flags, GError **error);
    GBytes * (*resources_lookup_data)(const char *path, GResourceLookupFlags lookup_flags, GError **error);
    char ** (*resources_enumerate_children)(const char *path, GResourceLookupFlags lookup_flags, GError **error);
    gboolean (*resources_get_info)(const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
    void (*static_resource_init)(GStaticResource *static_resource);
    void (*static_resource_fini)(GStaticResource *static_resource);
    GResource* (*static_resource_get_resource)(GStaticResource *static_resource);
    GQuark (*resource_error_quark)(void);
    goffset (*seekable_tell)(GSeekable *seekable);
    gboolean (*seekable_can_seek)(GSeekable *seekable);
    gboolean (*seekable_seek)(GSeekable *seekable, goffset offset, GSeekType type, GCancellable *cancellable, GError **error);
    gboolean (*seekable_can_truncate)(GSeekable *seekable);
    gboolean (*seekable_truncate)(GSeekable *seekable, goffset offset, GCancellable *cancellable, GError **error);
    GType (*seekable_get_type)(void);
    const gchar * const * (*settings_list_schemas)(void);
    const gchar * const * (*settings_list_relocatable_schemas)(void);
    GSettings * (*settings_new)(const gchar *schema_id);
    GSettings * (*settings_new_with_path)(const gchar *schema_id, const gchar *path);
    GSettings * (*settings_new_with_backend)(const gchar *schema_id, GSettingsBackend *backend);
    GSettings * (*settings_new_with_backend_and_path)(const gchar *schema_id, GSettingsBackend *backend, const gchar *path);
    GSettings * (*settings_new_full)(GSettingsSchema *schema, GSettingsBackend *backend, const gchar *path);
    gchar ** (*settings_list_children)(GSettings *settings);
    gchar ** (*settings_list_keys)(GSettings *settings);
    GVariant * (*settings_get_range)(GSettings *settings, const gchar *key);
    gboolean (*settings_range_check)(GSettings *settings, const gchar *key, GVariant *value);
    gboolean (*settings_set_value)(GSettings *settings, const gchar *key, GVariant *value);
    GVariant * (*settings_get_value)(GSettings *settings, const gchar *key);
    GVariant * (*settings_get_user_value)(GSettings *settings, const gchar *key);
    GVariant * (*settings_get_default_value)(GSettings *settings, const gchar *key);
    gboolean (*settings_set)(GSettings *settings, const gchar *key, const gchar *format, ...);
    void (*settings_get)(GSettings *settings, const gchar *key, const gchar *format, ...);
    void (*settings_reset)(GSettings *settings, const gchar *key);
    gint (*settings_get_int)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_int)(GSettings *settings, const gchar *key, gint value);
    gint64 (*settings_get_int64)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_int64)(GSettings *settings, const gchar *key, gint64 value);
    guint (*settings_get_uint)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_uint)(GSettings *settings, const gchar *key, guint value);
    guint64 (*settings_get_uint64)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_uint64)(GSettings *settings, const gchar *key, guint64 value);
    gchar * (*settings_get_string)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_string)(GSettings *settings, const gchar *key, const gchar *value);
    gboolean (*settings_get_boolean)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_boolean)(GSettings *settings, const gchar *key, gboolean value);
    gdouble (*settings_get_double)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_double)(GSettings *settings, const gchar *key, gdouble value);
    gchar ** (*settings_get_strv)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_strv)(GSettings *settings, const gchar *key, const gchar *const *value);
    gint (*settings_get_enum)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_enum)(GSettings *settings, const gchar *key, gint value);
    guint (*settings_get_flags)(GSettings *settings, const gchar *key);
    gboolean (*settings_set_flags)(GSettings *settings, const gchar *key, guint value);
    GSettings * (*settings_get_child)(GSettings *settings, const gchar *name);
    gboolean (*settings_is_writable)(GSettings *settings, const gchar *name);
    void (*settings_delay)(GSettings *settings);
    void (*settings_apply)(GSettings *settings);
    void (*settings_revert)(GSettings *settings);
    gboolean (*settings_get_has_unapplied)(GSettings *settings);
    void (*settings_sync)(void);
    void (*settings_bind)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags);
    void (*settings_bind_with_mapping)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags, GSettingsBindGetMapping get_mapping, GSettingsBindSetMapping set_mapping, gpointer user_data, GDestroyNotify destroy);
    void (*settings_bind_writable)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, gboolean inverted);
    void (*settings_unbind)(gpointer object, const gchar *property);
    GAction * (*settings_create_action)(GSettings *settings, const gchar *key);
    gpointer (*settings_get_mapped)(GSettings *settings, const gchar *key, GSettingsGetMapping mapping, gpointer user_data);
    GType (*settings_get_type)(void);
    void (*settings_backend_changed)(GSettingsBackend *backend, const gchar *key, gpointer origin_tag);
    void (*settings_backend_path_changed)(GSettingsBackend *backend, const gchar *path, gpointer origin_tag);
    void (*settings_backend_flatten_tree)(GTree *tree, gchar **path, const gchar ***keys, GVariant ***values);
    void (*settings_backend_keys_changed)(GSettingsBackend *backend, const gchar *path, gchar const * const *items, gpointer origin_tag);
    void (*settings_backend_path_writable_changed)(GSettingsBackend *backend, const gchar *path);
    void (*settings_backend_writable_changed)(GSettingsBackend *backend, const gchar *key);
    void (*settings_backend_changed_tree)(GSettingsBackend *backend, GTree *tree, gpointer origin_tag);
    GSettingsBackend * (*settings_backend_get_default)(void);
    GSettingsBackend * (*keyfile_settings_backend_new)(const gchar *filename, const gchar *root_path, const gchar *root_group);
    GSettingsBackend * (*null_settings_backend_new)(void);
    GSettingsBackend * (*memory_settings_backend_new)(void);
    GType (*settings_backend_get_type)(void);
    GSettingsSchemaSource * (*settings_schema_source_get_default)(void);
    GSettingsSchemaSource * (*settings_schema_source_ref)(GSettingsSchemaSource *source);
    void (*settings_schema_source_unref)(GSettingsSchemaSource *source);
    GSettingsSchemaSource * (*settings_schema_source_new_from_directory)(const gchar *directory, GSettingsSchemaSource *parent, gboolean trusted, GError **error);
    GSettingsSchema * (*settings_schema_source_lookup)(GSettingsSchemaSource *source, const gchar *schema_id, gboolean recursive);
    void (*settings_schema_source_list_schemas)(GSettingsSchemaSource *source, gboolean recursive, gchar ***non_relocatable, gchar ***relocatable);
    GType (*settings_schema_get_type)(void);
    GSettingsSchema * (*settings_schema_ref)(GSettingsSchema *schema);
    void (*settings_schema_unref)(GSettingsSchema *schema);
    const gchar * (*settings_schema_get_id)(GSettingsSchema *schema);
    const gchar * (*settings_schema_get_path)(GSettingsSchema *schema);
    GSettingsSchemaKey * (*settings_schema_get_key)(GSettingsSchema *schema, const gchar *name);
    gboolean (*settings_schema_has_key)(GSettingsSchema *schema, const gchar *name);
    gchar** (*settings_schema_list_keys)(GSettingsSchema *schema);
    gchar ** (*settings_schema_list_children)(GSettingsSchema *schema);
    GType (*settings_schema_key_get_type)(void);
    GSettingsSchemaKey * (*settings_schema_key_ref)(GSettingsSchemaKey *key);
    void (*settings_schema_key_unref)(GSettingsSchemaKey *key);
    const GVariantType * (*settings_schema_key_get_value_type)(GSettingsSchemaKey *key);
    GVariant * (*settings_schema_key_get_default_value)(GSettingsSchemaKey *key);
    GVariant * (*settings_schema_key_get_range)(GSettingsSchemaKey *key);
    gboolean (*settings_schema_key_range_check)(GSettingsSchemaKey *key, GVariant *value);
    const gchar * (*settings_schema_key_get_name)(GSettingsSchemaKey *key);
    const gchar * (*settings_schema_key_get_summary)(GSettingsSchemaKey *key);
    const gchar * (*settings_schema_key_get_description)(GSettingsSchemaKey *key);
    GType (*settings_schema_source_get_type)(void);
    GSimpleAction * (*simple_action_new)(const gchar *name, const GVariantType *parameter_type);
    GSimpleAction * (*simple_action_new_stateful)(const gchar *name, const GVariantType *parameter_type, GVariant *state);
    void (*simple_action_set_enabled)(GSimpleAction *simple, gboolean enabled);
    void (*simple_action_set_state)(GSimpleAction *simple, GVariant *value);
    void (*simple_action_set_state_hint)(GSimpleAction *simple, GVariant *state_hint);
    GType (*simple_action_get_type)(void);
    GSimpleActionGroup * (*simple_action_group_new)(void);
    GAction * (*simple_action_group_lookup)(GSimpleActionGroup *simple, const gchar *action_name);
    void (*simple_action_group_insert)(GSimpleActionGroup *simple, GAction *action);
    void (*simple_action_group_remove)(GSimpleActionGroup *simple, const gchar *action_name);
    void (*simple_action_group_add_entries)(GSimpleActionGroup *simple, const GActionEntry *entries, gint n_entries, gpointer user_data);
    GType (*simple_action_group_get_type)(void);
    GSimpleAsyncResult* (*simple_async_result_new)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, gpointer source_tag);
    GSimpleAsyncResult* (*simple_async_result_new_error)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GQuark domain, gint code, const char *format, ...);
    GSimpleAsyncResult* (*simple_async_result_new_from_error)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
    GSimpleAsyncResult* (*simple_async_result_new_take_error)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
    void (*simple_async_result_set_op_res_gpointer)(GSimpleAsyncResult *simple, gpointer op_res, GDestroyNotify destroy_op_res);
    gpointer (*simple_async_result_get_op_res_gpointer)(GSimpleAsyncResult *simple);
    void (*simple_async_result_set_op_res_gssize)(GSimpleAsyncResult *simple, gssize op_res);
    gssize (*simple_async_result_get_op_res_gssize)(GSimpleAsyncResult *simple);
    void (*simple_async_result_set_op_res_gboolean)(GSimpleAsyncResult *simple, gboolean op_res);
    gboolean (*simple_async_result_get_op_res_gboolean)(GSimpleAsyncResult *simple);
    void (*simple_async_result_set_check_cancellable)(GSimpleAsyncResult *simple, GCancellable *check_cancellable);
    gpointer (*simple_async_result_get_source_tag)(GSimpleAsyncResult *simple);
    void (*simple_async_result_set_handle_cancellation)(GSimpleAsyncResult *simple, gboolean handle_cancellation);
    void (*simple_async_result_complete)(GSimpleAsyncResult *simple);
    void (*simple_async_result_complete_in_idle)(GSimpleAsyncResult *simple);
    void (*simple_async_result_run_in_thread)(GSimpleAsyncResult *simple, GSimpleAsyncThreadFunc func, int io_priority, GCancellable *cancellable);
    void (*simple_async_result_set_from_error)(GSimpleAsyncResult *simple, const GError *error);
    void (*simple_async_result_take_error)(GSimpleAsyncResult *simple, GError *error);
    gboolean (*simple_async_result_propagate_error)(GSimpleAsyncResult *simple, GError **dest);
    void (*simple_async_result_set_error)(GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, ...);
    void (*simple_async_result_set_error_va)(GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, va_list args);
    gboolean (*simple_async_result_is_valid)(GAsyncResult *result, GObject *source, gpointer source_tag);
    void (*simple_async_report_error_in_idle)(GObject *object, GAsyncReadyCallback callback, gpointer user_data, GQuark domain, gint code, const char *format, ...);
    void (*simple_async_report_gerror_in_idle)(GObject *object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
    void (*simple_async_report_take_gerror_in_idle)(GObject *object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
    GType (*simple_async_result_get_type)(void);
    GIOStream* (*simple_io_stream_new)(GInputStream *input_stream, GOutputStream *output_stream);
    GType (*simple_io_stream_get_type)(void);
    GPermission * (*simple_permission_new)(gboolean allowed);
    GType (*simple_permission_get_type)(void);
    GProxyResolver* (*simple_proxy_resolver_new)(const gchar *default_proxy, gchar **ignore_hosts);
    void (*simple_proxy_resolver_set_default_proxy)(GSimpleProxyResolver *resolver, const gchar *default_proxy);
    void (*simple_proxy_resolver_set_ignore_hosts)(GSimpleProxyResolver *resolver, gchar **ignore_hosts);
    void (*simple_proxy_resolver_set_uri_proxy)(GSimpleProxyResolver *resolver, const gchar *uri_scheme, const gchar *proxy);
    GType (*simple_proxy_resolver_get_type)(void);
    GSocket * (*socket_new)(GSocketFamily family, GSocketType type, GSocketProtocol protocol, GError **error);
    GSocket * (*socket_new_from_fd)(gint fd, GError **error);
    int (*socket_get_fd)(GSocket *socket);
    GSocketFamily (*socket_get_family)(GSocket *socket);
    GSocketType (*socket_get_socket_type)(GSocket *socket);
    GSocketProtocol (*socket_get_protocol)(GSocket *socket);
    GSocketAddress * (*socket_get_local_address)(GSocket *socket, GError **error);
    GSocketAddress * (*socket_get_remote_address)(GSocket *socket, GError **error);
    void (*socket_set_blocking)(GSocket *socket, gboolean blocking);
    gboolean (*socket_get_blocking)(GSocket *socket);
    void (*socket_set_keepalive)(GSocket *socket, gboolean keepalive);
    gboolean (*socket_get_keepalive)(GSocket *socket);
    gint (*socket_get_listen_backlog)(GSocket *socket);
    void (*socket_set_listen_backlog)(GSocket *socket, gint backlog);
    guint (*socket_get_timeout)(GSocket *socket);
    void (*socket_set_timeout)(GSocket *socket, guint timeout);
    guint (*socket_get_ttl)(GSocket *socket);
    void (*socket_set_ttl)(GSocket *socket, guint ttl);
    gboolean (*socket_get_broadcast)(GSocket *socket);
    void (*socket_set_broadcast)(GSocket *socket, gboolean broadcast);
    gboolean (*socket_get_multicast_loopback)(GSocket *socket);
    void (*socket_set_multicast_loopback)(GSocket *socket, gboolean loopback);
    guint (*socket_get_multicast_ttl)(GSocket *socket);
    void (*socket_set_multicast_ttl)(GSocket *socket, guint ttl);
    gboolean (*socket_is_connected)(GSocket *socket);
    gboolean (*socket_bind)(GSocket *socket, GSocketAddress *address, gboolean allow_reuse, GError **error);
    gboolean (*socket_join_multicast_group)(GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
    gboolean (*socket_leave_multicast_group)(GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
    gboolean (*socket_join_multicast_group_ssm)(GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
    gboolean (*socket_leave_multicast_group_ssm)(GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
    gboolean (*socket_connect)(GSocket *socket, GSocketAddress *address, GCancellable *cancellable, GError **error);
    gboolean (*socket_check_connect_result)(GSocket *socket, GError **error);
    gssize (*socket_get_available_bytes)(GSocket *socket);
    GIOCondition (*socket_condition_check)(GSocket *socket, GIOCondition condition);
    gboolean (*socket_condition_wait)(GSocket *socket, GIOCondition condition, GCancellable *cancellable, GError **error);
    gboolean (*socket_condition_timed_wait)(GSocket *socket, GIOCondition condition, gint64 timeout_us, GCancellable *cancellable, GError **error);
    GSocket * (*socket_accept)(GSocket *socket, GCancellable *cancellable, GError **error);
    gboolean (*socket_listen)(GSocket *socket, GError **error);
    gssize (*socket_receive)(GSocket *socket, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    GBytes * (*socket_receive_bytes)(GSocket *socket, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error);
    gssize (*socket_receive_from)(GSocket *socket, GSocketAddress **address, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    GBytes * (*socket_receive_bytes_from)(GSocket *socket, GSocketAddress **address, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error);
    gssize (*socket_send)(GSocket *socket, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    gssize (*socket_send_to)(GSocket *socket, GSocketAddress *address, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    gssize (*socket_receive_message)(GSocket *socket, GSocketAddress **address, GInputVector *vectors, gint num_vectors, GSocketControlMessage ***messages, gint *num_messages, gint *flags, GCancellable *cancellable, GError **error);
    gssize (*socket_send_message)(GSocket *socket, GSocketAddress *address, GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, GCancellable *cancellable, GError **error);
    gint (*socket_receive_messages)(GSocket *socket, GInputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
    gint (*socket_send_messages)(GSocket *socket, GOutputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
    gboolean (*socket_close)(GSocket *socket, GError **error);
    gboolean (*socket_shutdown)(GSocket *socket, gboolean shutdown_read, gboolean shutdown_write, GError **error);
    gboolean (*socket_is_closed)(GSocket *socket);
    GSource * (*socket_create_source)(GSocket *socket, GIOCondition condition, GCancellable *cancellable);
    gboolean (*socket_speaks_ipv4)(GSocket *socket);
    GCredentials* (*socket_get_credentials)(GSocket *socket, GError **error);
    gssize (*socket_receive_with_blocking)(GSocket *socket, gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
    gssize (*socket_send_with_blocking)(GSocket *socket, const gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
    GPollableReturn (*socket_send_message_with_timeout)(GSocket *socket, GSocketAddress *address, const GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, gint64 timeout_us, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*socket_get_option)(GSocket *socket, gint level, gint optname, gint *value, GError **error);
    gboolean (*socket_set_option)(GSocket *socket, gint level, gint optname, gint value, GError **error);
    GType (*socket_get_type)(void);
    GSocketFamily (*socket_address_get_family)(GSocketAddress *address);
    GSocketAddress * (*socket_address_new_from_native)(gpointer native, gsize len);
    gboolean (*socket_address_to_native)(GSocketAddress *address, gpointer dest, gsize destlen, GError **error);
    gssize (*socket_address_get_native_size)(GSocketAddress *address);
    GType (*socket_address_get_type)(void);
    GSocketAddress* (*socket_address_enumerator_next)(GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GError **error);
    void (*socket_address_enumerator_next_async)(GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketAddress* (*socket_address_enumerator_next_finish)(GSocketAddressEnumerator *enumerator, GAsyncResult *result, GError **error);
    GType (*socket_address_enumerator_get_type)(void);
    GSocketClient* (*socket_client_new)(void);
    GSocketFamily (*socket_client_get_family)(GSocketClient *client);
    void (*socket_client_set_family)(GSocketClient *client, GSocketFamily family);
    GSocketType (*socket_client_get_socket_type)(GSocketClient *client);
    void (*socket_client_set_socket_type)(GSocketClient *client, GSocketType type);
    GSocketProtocol (*socket_client_get_protocol)(GSocketClient *client);
    void (*socket_client_set_protocol)(GSocketClient *client, GSocketProtocol protocol);
    GSocketAddress* (*socket_client_get_local_address)(GSocketClient *client);
    void (*socket_client_set_local_address)(GSocketClient *client, GSocketAddress *address);
    guint (*socket_client_get_timeout)(GSocketClient *client);
    void (*socket_client_set_timeout)(GSocketClient *client, guint timeout);
    gboolean (*socket_client_get_enable_proxy)(GSocketClient *client);
    void (*socket_client_set_enable_proxy)(GSocketClient *client, gboolean enable);
    gboolean (*socket_client_get_tls)(GSocketClient *client);
    void (*socket_client_set_tls)(GSocketClient *client, gboolean tls);
    GTlsCertificateFlags (*socket_client_get_tls_validation_flags)(GSocketClient *client);
    void (*socket_client_set_tls_validation_flags)(GSocketClient *client, GTlsCertificateFlags flags);
    GProxyResolver* (*socket_client_get_proxy_resolver)(GSocketClient *client);
    void (*socket_client_set_proxy_resolver)(GSocketClient *client, GProxyResolver *proxy_resolver);
    GSocketConnection * (*socket_client_connect)(GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
    GSocketConnection * (*socket_client_connect_to_host)(GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GError **error);
    GSocketConnection * (*socket_client_connect_to_service)(GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GError **error);
    GSocketConnection * (*socket_client_connect_to_uri)(GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GError **error);
    void (*socket_client_connect_async)(GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*socket_client_connect_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*socket_client_connect_to_host_async)(GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*socket_client_connect_to_host_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*socket_client_connect_to_service_async)(GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*socket_client_connect_to_service_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*socket_client_connect_to_uri_async)(GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*socket_client_connect_to_uri_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*socket_client_add_application_proxy)(GSocketClient *client, const gchar *protocol);
    GType (*socket_client_get_type)(void);
    GSocketAddressEnumerator* (*socket_connectable_enumerate)(GSocketConnectable *connectable);
    GSocketAddressEnumerator* (*socket_connectable_proxy_enumerate)(GSocketConnectable *connectable);
    gchar* (*socket_connectable_to_string)(GSocketConnectable *connectable);
    GType (*socket_connectable_get_type)(void);
    gboolean (*socket_connection_is_connected)(GSocketConnection *connection);
    gboolean (*socket_connection_connect)(GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GError **error);
    void (*socket_connection_connect_async)(GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*socket_connection_connect_finish)(GSocketConnection *connection, GAsyncResult *result, GError **error);
    GSocket* (*socket_connection_get_socket)(GSocketConnection *connection);
    GSocketAddress* (*socket_connection_get_local_address)(GSocketConnection *connection, GError **error);
    GSocketAddress* (*socket_connection_get_remote_address)(GSocketConnection *connection, GError **error);
    void (*socket_connection_factory_register_type)(GType g_type, GSocketFamily family, GSocketType type, gint protocol);
    GType (*socket_connection_factory_lookup_type)(GSocketFamily family, GSocketType type, gint protocol_id);
    GSocketConnection* (*socket_connection_factory_create_connection)(GSocket *socket);
    GType (*socket_connection_get_type)(void);
    gsize (*socket_control_message_get_size)(GSocketControlMessage *message);
    int (*socket_control_message_get_level)(GSocketControlMessage *message);
    int (*socket_control_message_get_msg_type)(GSocketControlMessage *message);
    void (*socket_control_message_serialize)(GSocketControlMessage *message, gpointer data);
    GSocketControlMessage* (*socket_control_message_deserialize)(int level, int type, gsize size, gpointer data);
    GType (*socket_control_message_get_type)(void);
    GSocketListener * (*socket_listener_new)(void);
    void (*socket_listener_set_backlog)(GSocketListener *listener, int listen_backlog);
    gboolean (*socket_listener_add_socket)(GSocketListener *listener, GSocket *socket, GObject *source_object, GError **error);
    gboolean (*socket_listener_add_address)(GSocketListener *listener, GSocketAddress *address, GSocketType type, GSocketProtocol protocol, GObject *source_object, GSocketAddress **effective_address, GError **error);
    gboolean (*socket_listener_add_inet_port)(GSocketListener *listener, guint16 port, GObject *source_object, GError **error);
    guint16 (*socket_listener_add_any_inet_port)(GSocketListener *listener, GObject *source_object, GError **error);
    GSocket * (*socket_listener_accept_socket)(GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
    void (*socket_listener_accept_socket_async)(GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocket * (*socket_listener_accept_socket_finish)(GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
    GSocketConnection * (*socket_listener_accept)(GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
    void (*socket_listener_accept_async)(GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*socket_listener_accept_finish)(GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
    void (*socket_listener_close)(GSocketListener *listener);
    GType (*socket_listener_get_type)(void);
    GSocketService* (*socket_service_new)(void);
    void (*socket_service_start)(GSocketService *service);
    void (*socket_service_stop)(GSocketService *service);
    gboolean (*socket_service_is_active)(GSocketService *service);
    GType (*socket_service_get_type)(void);
    GSrvTarget* (*srv_target_new)(const gchar *hostname, guint16 port, guint16 priority, guint16 weight);
    GSrvTarget* (*srv_target_copy)(GSrvTarget *target);
    void (*srv_target_free)(GSrvTarget *target);
    const gchar* (*srv_target_get_hostname)(GSrvTarget *target);
    guint16 (*srv_target_get_port)(GSrvTarget *target);
    guint16 (*srv_target_get_priority)(GSrvTarget *target);
    guint16 (*srv_target_get_weight)(GSrvTarget *target);
    GList* (*srv_target_list_sort)(GList *targets);
    GType (*srv_target_get_type)(void);
    GSubprocess * (*subprocess_new)(GSubprocessFlags flags, GError **error, const gchar *argv0, ...);
    GSubprocess * (*subprocess_newv)(const gchar * const *argv, GSubprocessFlags flags, GError **error);
    GOutputStream * (*subprocess_get_stdin_pipe)(GSubprocess *subprocess);
    GInputStream * (*subprocess_get_stdout_pipe)(GSubprocess *subprocess);
    GInputStream * (*subprocess_get_stderr_pipe)(GSubprocess *subprocess);
    const gchar * (*subprocess_get_identifier)(GSubprocess *subprocess);
    void (*subprocess_send_signal)(GSubprocess *subprocess, gint signal_num);
    void (*subprocess_force_exit)(GSubprocess *subprocess);
    gboolean (*subprocess_wait)(GSubprocess *subprocess, GCancellable *cancellable, GError **error);
    void (*subprocess_wait_async)(GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*subprocess_wait_finish)(GSubprocess *subprocess, GAsyncResult *result, GError **error);
    gboolean (*subprocess_wait_check)(GSubprocess *subprocess, GCancellable *cancellable, GError **error);
    void (*subprocess_wait_check_async)(GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*subprocess_wait_check_finish)(GSubprocess *subprocess, GAsyncResult *result, GError **error);
    gint (*subprocess_get_status)(GSubprocess *subprocess);
    gboolean (*subprocess_get_successful)(GSubprocess *subprocess);
    gboolean (*subprocess_get_if_exited)(GSubprocess *subprocess);
    gint (*subprocess_get_exit_status)(GSubprocess *subprocess);
    gboolean (*subprocess_get_if_signaled)(GSubprocess *subprocess);
    gint (*subprocess_get_term_sig)(GSubprocess *subprocess);
    gboolean (*subprocess_communicate)(GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
    void (*subprocess_communicate_async)(GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*subprocess_communicate_finish)(GSubprocess *subprocess, GAsyncResult *result, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
    gboolean (*subprocess_communicate_utf8)(GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, char **stdout_buf, char **stderr_buf, GError **error);
    void (*subprocess_communicate_utf8_async)(GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*subprocess_communicate_utf8_finish)(GSubprocess *subprocess, GAsyncResult *result, char **stdout_buf, char **stderr_buf, GError **error);
    GType (*subprocess_get_type)(void);
    GSubprocessLauncher * (*subprocess_launcher_new)(GSubprocessFlags flags);
    GSubprocess * (*subprocess_launcher_spawn)(GSubprocessLauncher *self, GError **error, const gchar *argv0, ...);
    GSubprocess * (*subprocess_launcher_spawnv)(GSubprocessLauncher *self, const gchar * const *argv, GError **error);
    void (*subprocess_launcher_set_environ)(GSubprocessLauncher *self, gchar **env);
    void (*subprocess_launcher_setenv)(GSubprocessLauncher *self, const gchar *variable, const gchar *value, gboolean overwrite);
    void (*subprocess_launcher_unsetenv)(GSubprocessLauncher *self, const gchar *variable);
    const gchar * (*subprocess_launcher_getenv)(GSubprocessLauncher *self, const gchar *variable);
    void (*subprocess_launcher_set_cwd)(GSubprocessLauncher *self, const gchar *cwd);
    void (*subprocess_launcher_set_flags)(GSubprocessLauncher *self, GSubprocessFlags flags);
    void (*subprocess_launcher_set_stdin_file_path)(GSubprocessLauncher *self, const gchar *path);
    void (*subprocess_launcher_take_stdin_fd)(GSubprocessLauncher *self, gint fd);
    void (*subprocess_launcher_set_stdout_file_path)(GSubprocessLauncher *self, const gchar *path);
    void (*subprocess_launcher_take_stdout_fd)(GSubprocessLauncher *self, gint fd);
    void (*subprocess_launcher_set_stderr_file_path)(GSubprocessLauncher *self, const gchar *path);
    void (*subprocess_launcher_take_stderr_fd)(GSubprocessLauncher *self, gint fd);
    void (*subprocess_launcher_take_fd)(GSubprocessLauncher *self, gint source_fd, gint target_fd);
    void (*subprocess_launcher_close)(GSubprocessLauncher *self);
    void (*subprocess_launcher_set_child_setup)(GSubprocessLauncher *self, GSpawnChildSetupFunc child_setup, gpointer user_data, GDestroyNotify destroy_notify);
    GType (*subprocess_launcher_get_type)(void);
    GTask* (*task_new)(gpointer source_object, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer callback_data);
    void (*task_report_error)(gpointer source_object, GAsyncReadyCallback callback, gpointer callback_data, gpointer source_tag, GError *error);
    void (*task_report_new_error)(gpointer source_object, GAsyncReadyCallback callback, gpointer callback_data, gpointer source_tag, GQuark domain, gint code, const char *format, ...);
    void (*task_set_task_data)(GTask *task, gpointer task_data, GDestroyNotify task_data_destroy);
    void (*task_set_priority)(GTask *task, gint priority);
    void (*task_set_check_cancellable)(GTask *task, gboolean check_cancellable);
    void (*task_set_source_tag)(GTask *task, gpointer source_tag);
    void (*task_set_name)(GTask *task, const gchar *name);
    void (*task_set_static_name)(GTask *task, const gchar *name);
    gpointer (*task_get_source_object)(GTask *task);
    gpointer (*task_get_task_data)(GTask *task);
    gint (*task_get_priority)(GTask *task);
    GMainContext* (*task_get_context)(GTask *task);
    GCancellable* (*task_get_cancellable)(GTask *task);
    gboolean (*task_get_check_cancellable)(GTask *task);
    gpointer (*task_get_source_tag)(GTask *task);
    const gchar* (*task_get_name)(GTask *task);
    gboolean (*task_is_valid)(gpointer result, gpointer source_object);
    void (*task_run_in_thread)(GTask *task, GTaskThreadFunc task_func);
    void (*task_run_in_thread_sync)(GTask *task, GTaskThreadFunc task_func);
    gboolean (*task_set_return_on_cancel)(GTask *task, gboolean return_on_cancel);
    gboolean (*task_get_return_on_cancel)(GTask *task);
    void (*task_attach_source)(GTask *task, GSource *source, GSourceFunc callback);
    void (*task_return_pointer)(GTask *task, gpointer result, GDestroyNotify result_destroy);
    void (*task_return_boolean)(GTask *task, gboolean result);
    void (*task_return_int)(GTask *task, gssize result);
    void (*task_return_error)(GTask *task, GError *error);
    void (*task_return_prefixed_error)(GTask *task, GError *error, const char *format, ...);
    void (*task_return_new_error)(GTask *task, GQuark domain, gint code, const char *format, ...);
    void (*task_return_new_error_literal)(GTask *task, GQuark domain, gint code, const char *message);
    void (*task_return_value)(GTask *task, GValue *result);
    gboolean (*task_return_error_if_cancelled)(GTask *task);
    gpointer (*task_propagate_pointer)(GTask *task, GError **error);
    gboolean (*task_propagate_boolean)(GTask *task, GError **error);
    gssize (*task_propagate_int)(GTask *task, GError **error);
    gboolean (*task_propagate_value)(GTask *task, GValue *value, GError **error);
    gboolean (*task_had_error)(GTask *task);
    gboolean (*task_get_completed)(GTask *task);
    void (*task_print_alive_tasks)(void);
    GType (*task_get_type)(void);
    void (*tcp_connection_set_graceful_disconnect)(GTcpConnection *connection, gboolean graceful_disconnect);
    gboolean (*tcp_connection_get_graceful_disconnect)(GTcpConnection *connection);
    GType (*tcp_connection_get_type)(void);
    GSocketConnection* (*tcp_wrapper_connection_new)(GIOStream *base_io_stream, GSocket *socket);
    GIOStream* (*tcp_wrapper_connection_get_base_io_stream)(GTcpWrapperConnection *conn);
    GType (*tcp_wrapper_connection_get_type)(void);
    GTestDBus * (*test_dbus_new)(GTestDBusFlags flags);
    GTestDBusFlags (*test_dbus_get_flags)(GTestDBus *self);
    const gchar * (*test_dbus_get_bus_address)(GTestDBus *self);
    void (*test_dbus_add_service_dir)(GTestDBus *self, const gchar *path);
    void (*test_dbus_up)(GTestDBus *self);
    void (*test_dbus_stop)(GTestDBus *self);
    void (*test_dbus_down)(GTestDBus *self);
    void (*test_dbus_unset)(void);
    GType (*test_dbus_get_type)(void);
    GIcon* (*themed_icon_new)(const char *iconname);
    GIcon* (*themed_icon_new_with_default_fallbacks)(const char *iconname);
    GIcon* (*themed_icon_new_from_names)(char **iconnames, int len);
    void (*themed_icon_prepend_name)(GThemedIcon *icon, const char *iconname);
    void (*themed_icon_append_name)(GThemedIcon *icon, const char *iconname);
    const gchar* const * (*themed_icon_get_names)(GThemedIcon *icon);
    GType (*themed_icon_get_type)(void);
    GSocketService * (*threaded_socket_service_new)(int max_threads);
    GType (*threaded_socket_service_get_type)(void);
    GTlsBackend * (*tls_backend_get_default)(void);
    GTlsDatabase * (*tls_backend_get_default_database)(GTlsBackend *backend);
    void (*tls_backend_set_default_database)(GTlsBackend *backend, GTlsDatabase *database);
    gboolean (*tls_backend_supports_tls)(GTlsBackend *backend);
    gboolean (*tls_backend_supports_dtls)(GTlsBackend *backend);
    GType (*tls_backend_get_certificate_type)(GTlsBackend *backend);
    GType (*tls_backend_get_client_connection_type)(GTlsBackend *backend);
    GType (*tls_backend_get_server_connection_type)(GTlsBackend *backend);
    GType (*tls_backend_get_file_database_type)(GTlsBackend *backend);
    GType (*tls_backend_get_dtls_client_connection_type)(GTlsBackend *backend);
    GType (*tls_backend_get_dtls_server_connection_type)(GTlsBackend *backend);
    GType (*tls_backend_get_type)(void);
    GTlsCertificate* (*tls_certificate_new_from_pem)(const gchar *data, gssize length, GError **error);
    GTlsCertificate* (*tls_certificate_new_from_pkcs12)(const guint8 *data, gsize length, const gchar *password, GError **error);
    GTlsCertificate* (*tls_certificate_new_from_file_with_password)(const gchar *file, const gchar *password, GError **error);
    GTlsCertificate* (*tls_certificate_new_from_file)(const gchar *file, GError **error);
    GTlsCertificate* (*tls_certificate_new_from_files)(const gchar *cert_file, const gchar *key_file, GError **error);
    GTlsCertificate* (*tls_certificate_new_from_pkcs11_uris)(const gchar *pkcs11_uri, const gchar *private_key_pkcs11_uri, GError **error);
    GList* (*tls_certificate_list_new_from_file)(const gchar *file, GError **error);
    GTlsCertificate* (*tls_certificate_get_issuer)(GTlsCertificate *cert);
    GTlsCertificateFlags (*tls_certificate_verify)(GTlsCertificate *cert, GSocketConnectable *identity, GTlsCertificate *trusted_ca);
    gboolean (*tls_certificate_is_same)(GTlsCertificate *cert_one, GTlsCertificate *cert_two);
    GDateTime* (*tls_certificate_get_not_valid_before)(GTlsCertificate *cert);
    GDateTime* (*tls_certificate_get_not_valid_after)(GTlsCertificate *cert);
    gchar* (*tls_certificate_get_subject_name)(GTlsCertificate *cert);
    gchar* (*tls_certificate_get_issuer_name)(GTlsCertificate *cert);
    GPtrArray* (*tls_certificate_get_dns_names)(GTlsCertificate *cert);
    GPtrArray* (*tls_certificate_get_ip_addresses)(GTlsCertificate *cert);
    GType (*tls_certificate_get_type)(void);
    GIOStream * (*tls_client_connection_new)(GIOStream *base_io_stream, GSocketConnectable *server_identity, GError **error);
    GTlsCertificateFlags (*tls_client_connection_get_validation_flags)(GTlsClientConnection *conn);
    void (*tls_client_connection_set_validation_flags)(GTlsClientConnection *conn, GTlsCertificateFlags flags);
    GSocketConnectable* (*tls_client_connection_get_server_identity)(GTlsClientConnection *conn);
    void (*tls_client_connection_set_server_identity)(GTlsClientConnection *conn, GSocketConnectable *identity);
    gboolean (*tls_client_connection_get_use_ssl3)(GTlsClientConnection *conn);
    void (*tls_client_connection_set_use_ssl3)(GTlsClientConnection *conn, gboolean use_ssl3);
    GList * (*tls_client_connection_get_accepted_cas)(GTlsClientConnection *conn);
    void (*tls_client_connection_copy_session_state)(GTlsClientConnection *conn, GTlsClientConnection *source);
    GType (*tls_client_connection_get_type)(void);
    void (*tls_connection_set_use_system_certdb)(GTlsConnection *conn, gboolean use_system_certdb);
    gboolean (*tls_connection_get_use_system_certdb)(GTlsConnection *conn);
    void (*tls_connection_set_database)(GTlsConnection *conn, GTlsDatabase *database);
    GTlsDatabase * (*tls_connection_get_database)(GTlsConnection *conn);
    void (*tls_connection_set_certificate)(GTlsConnection *conn, GTlsCertificate *certificate);
    GTlsCertificate* (*tls_connection_get_certificate)(GTlsConnection *conn);
    void (*tls_connection_set_interaction)(GTlsConnection *conn, GTlsInteraction *interaction);
    GTlsInteraction * (*tls_connection_get_interaction)(GTlsConnection *conn);
    GTlsCertificate* (*tls_connection_get_peer_certificate)(GTlsConnection *conn);
    GTlsCertificateFlags (*tls_connection_get_peer_certificate_errors)(GTlsConnection *conn);
    void (*tls_connection_set_require_close_notify)(GTlsConnection *conn, gboolean require_close_notify);
    gboolean (*tls_connection_get_require_close_notify)(GTlsConnection *conn);
    GTlsRehandshakeMode (*tls_connection_get_rehandshake_mode)(GTlsConnection *conn);
    const gchar * (*tls_connection_get_negotiated_protocol)(GTlsConnection *conn);
    void (*tls_connection_handshake_async)(GTlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*tls_connection_handshake_finish)(GTlsConnection *conn, GAsyncResult *result, GError **error);
    GTlsProtocolVersion (*tls_connection_get_protocol_version)(GTlsConnection *conn);
    gchar * (*tls_connection_get_ciphersuite_name)(GTlsConnection *conn);
    GQuark (*tls_error_quark)(void);
    GQuark (*tls_channel_binding_error_quark)(void);
    gboolean (*tls_connection_emit_accept_certificate)(GTlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
    GType (*tls_connection_get_type)(void);
    GTlsCertificateFlags (*tls_database_verify_chain)(GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GError **error);
    void (*tls_database_verify_chain_async)(GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsCertificateFlags (*tls_database_verify_chain_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    gchar* (*tls_database_create_certificate_handle)(GTlsDatabase *self, GTlsCertificate *certificate);
    GTlsCertificate* (*tls_database_lookup_certificate_for_handle)(GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*tls_database_lookup_certificate_for_handle_async)(GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsCertificate* (*tls_database_lookup_certificate_for_handle_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    GTlsCertificate* (*tls_database_lookup_certificate_issuer)(GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*tls_database_lookup_certificate_issuer_async)(GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsCertificate* (*tls_database_lookup_certificate_issuer_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    GList* (*tls_database_lookup_certificates_issued_by)(GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*tls_database_lookup_certificates_issued_by_async)(GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*tls_database_lookup_certificates_issued_by_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    GType (*tls_database_get_type)(void);
    GTlsDatabase* (*tls_file_database_new)(const gchar *anchors, GError **error);
    GType (*tls_file_database_get_type)(void);
    GTlsInteractionResult (*tls_interaction_invoke_ask_password)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
    GTlsInteractionResult (*tls_interaction_ask_password)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
    void (*tls_interaction_ask_password_async)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsInteractionResult (*tls_interaction_ask_password_finish)(GTlsInteraction *interaction, GAsyncResult *result, GError **error);
    GTlsInteractionResult (*tls_interaction_invoke_request_certificate)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
    GTlsInteractionResult (*tls_interaction_request_certificate)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
    void (*tls_interaction_request_certificate_async)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsInteractionResult (*tls_interaction_request_certificate_finish)(GTlsInteraction *interaction, GAsyncResult *result, GError **error);
    GType (*tls_interaction_get_type)(void);
    GTlsPassword * (*tls_password_new)(GTlsPasswordFlags flags, const gchar *description);
    const guchar * (*tls_password_get_value)(GTlsPassword *password, gsize *length);
    void (*tls_password_set_value)(GTlsPassword *password, const guchar *value, gssize length);
    void (*tls_password_set_value_full)(GTlsPassword *password, guchar *value, gssize length, GDestroyNotify destroy);
    GTlsPasswordFlags (*tls_password_get_flags)(GTlsPassword *password);
    void (*tls_password_set_flags)(GTlsPassword *password, GTlsPasswordFlags flags);
    const gchar* (*tls_password_get_description)(GTlsPassword *password);
    void (*tls_password_set_description)(GTlsPassword *password, const gchar *description);
    const gchar * (*tls_password_get_warning)(GTlsPassword *password);
    void (*tls_password_set_warning)(GTlsPassword *password, const gchar *warning);
    GType (*tls_password_get_type)(void);
    GIOStream * (*tls_server_connection_new)(GIOStream *base_io_stream, GTlsCertificate *certificate, GError **error);
    GType (*tls_server_connection_get_type)(void);
    gboolean (*unix_connection_send_fd)(GUnixConnection *connection, gint fd, GCancellable *cancellable, GError **error);
    gint (*unix_connection_receive_fd)(GUnixConnection *connection, GCancellable *cancellable, GError **error);
    gboolean (*unix_connection_send_credentials)(GUnixConnection *connection, GCancellable *cancellable, GError **error);
    void (*unix_connection_send_credentials_async)(GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*unix_connection_send_credentials_finish)(GUnixConnection *connection, GAsyncResult *result, GError **error);
    GCredentials* (*unix_connection_receive_credentials)(GUnixConnection *connection, GCancellable *cancellable, GError **error);
    void (*unix_connection_receive_credentials_async)(GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GCredentials* (*unix_connection_receive_credentials_finish)(GUnixConnection *connection, GAsyncResult *result, GError **error);
    GSocketControlMessage* (*unix_credentials_message_new)(void);
    GSocketControlMessage* (*unix_credentials_message_new_with_credentials)(GCredentials *credentials);
    GCredentials* (*unix_credentials_message_get_credentials)(GUnixCredentialsMessage *message);
    gboolean (*unix_credentials_message_is_supported)(void);
    GUnixFDList * (*unix_fd_list_new)(void);
    GUnixFDList * (*unix_fd_list_new_from_array)(const gint *fds, gint n_fds);
    gint (*unix_fd_list_append)(GUnixFDList *list, gint fd, GError **error);
    gint (*unix_fd_list_get_length)(GUnixFDList *list);
    gint (*unix_fd_list_get)(GUnixFDList *list, gint index_, GError **error);
    const gint * (*unix_fd_list_peek_fds)(GUnixFDList *list, gint *length);
    gint * (*unix_fd_list_steal_fds)(GUnixFDList *list, gint *length);
    GSocketAddress* (*unix_socket_address_new)(const gchar *path);
    GSocketAddress* (*unix_socket_address_new_abstract)(const gchar *path, gint path_len);
    GSocketAddress* (*unix_socket_address_new_with_type)(const gchar *path, gint path_len, GUnixSocketAddressType type);
    const char * (*unix_socket_address_get_path)(GUnixSocketAddress *address);
    gsize (*unix_socket_address_get_path_len)(GUnixSocketAddress *address);
    GUnixSocketAddressType (*unix_socket_address_get_address_type)(GUnixSocketAddress *address);
    gboolean (*unix_socket_address_get_is_abstract)(GUnixSocketAddress *address);
    gboolean (*unix_socket_address_abstract_names_supported)(void);
    gboolean (*vfs_is_active)(GVfs *vfs);
    GFile * (*vfs_get_file_for_path)(GVfs *vfs, const char *path);
    GFile * (*vfs_get_file_for_uri)(GVfs *vfs, const char *uri);
    const gchar* const * (*vfs_get_supported_uri_schemes)(GVfs *vfs);
    GFile * (*vfs_parse_name)(GVfs *vfs, const char *parse_name);
    GVfs * (*vfs_get_default)(void);
    GVfs * (*vfs_get_local)(void);
    gboolean (*vfs_register_uri_scheme)(GVfs *vfs, const char *scheme, GVfsFileLookupFunc uri_func, gpointer uri_data, GDestroyNotify uri_destroy, GVfsFileLookupFunc parse_name_func, gpointer parse_name_data, GDestroyNotify parse_name_destroy);
    gboolean (*vfs_unregister_uri_scheme)(GVfs *vfs, const char *scheme);
    GType (*vfs_get_type)(void);
    char * (*volume_get_name)(GVolume *volume);
    GIcon * (*volume_get_icon)(GVolume *volume);
    GIcon * (*volume_get_symbolic_icon)(GVolume *volume);
    char * (*volume_get_uuid)(GVolume *volume);
    GDrive * (*volume_get_drive)(GVolume *volume);
    GMount * (*volume_get_mount)(GVolume *volume);
    gboolean (*volume_can_mount)(GVolume *volume);
    gboolean (*volume_can_eject)(GVolume *volume);
    gboolean (*volume_should_automount)(GVolume *volume);
    void (*volume_mount)(GVolume *volume, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*volume_mount_finish)(GVolume *volume, GAsyncResult *result, GError **error);
    void (*volume_eject)(GVolume *volume, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*volume_eject_finish)(GVolume *volume, GAsyncResult *result, GError **error);
    char * (*volume_get_identifier)(GVolume *volume, const char *kind);
    char ** (*volume_enumerate_identifiers)(GVolume *volume);
    GFile * (*volume_get_activation_root)(GVolume *volume);
    void (*volume_eject_with_operation)(GVolume *volume, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*volume_eject_with_operation_finish)(GVolume *volume, GAsyncResult *result, GError **error);
    const gchar* (*volume_get_sort_key)(GVolume *volume);
    GType (*volume_get_type)(void);
    GVolumeMonitor* (*volume_monitor_get)(void);
    GList * (*volume_monitor_get_connected_drives)(GVolumeMonitor *volume_monitor);
    GList * (*volume_monitor_get_volumes)(GVolumeMonitor *volume_monitor);
    GList * (*volume_monitor_get_mounts)(GVolumeMonitor *volume_monitor);
    GVolume * (*volume_monitor_get_volume_for_uuid)(GVolumeMonitor *volume_monitor, const char *uuid);
    GMount * (*volume_monitor_get_mount_for_uuid)(GVolumeMonitor *volume_monitor, const char *uuid);
    GVolume * (*volume_monitor_adopt_orphan_mount)(GMount *mount);
    GType (*volume_monitor_get_type)(void);
    GZlibCompressor* (*zlib_compressor_new)(GZlibCompressorFormat format, int level);
    GFileInfo* (*zlib_compressor_get_file_info)(GZlibCompressor *compressor);
    void (*zlib_compressor_set_file_info)(GZlibCompressor *compressor, GFileInfo *file_info);
    GType (*zlib_compressor_get_type)(void);
    GZlibDecompressor* (*zlib_decompressor_new)(GZlibCompressorFormat format);
    GFileInfo* (*zlib_decompressor_get_file_info)(GZlibDecompressor *decompressor);
    GType (*zlib_decompressor_get_type)(void);
};

// DEFINE_STRUCT_HERE


extern struct gio_syms *gio;
// DEFINE_STRUCT_VAR_HERE
#endif

void initialize_gio(void);
void close_gio(void);
