#include "glib_stub.h"
#include "../stub.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#define _COMSO_SOURCE
#include <libc/dlopen/dlfcn.h>

static struct glibFuncs {
    // Header /usr/include/glib-2.0/glib/deprecated/gallocator.h
    void (*ptr_g_mem_chunk_destroy)(GMemChunk *mem_chunk);
    gpointer (*ptr_g_mem_chunk_alloc)(GMemChunk *mem_chunk);
    gpointer (*ptr_g_mem_chunk_alloc0)(GMemChunk *mem_chunk);
    void (*ptr_g_mem_chunk_free)(GMemChunk *mem_chunk, gpointer mem);
    void (*ptr_g_mem_chunk_clean)(GMemChunk *mem_chunk);
    void (*ptr_g_mem_chunk_reset)(GMemChunk *mem_chunk);
    void (*ptr_g_mem_chunk_print)(GMemChunk *mem_chunk);
    void (*ptr_g_mem_chunk_info)(void);
    void (*ptr_g_blow_chunks)(void);
    GMemChunk * (*ptr_g_mem_chunk_new)(const gchar *name, gint atom_size, gsize area_size, gint type);
    // Header /usr/include/glib-2.0/glib/deprecated/gcache.h
    void (*ptr_g_cache_destroy)(GCache *cache);
    gpointer (*ptr_g_cache_insert)(GCache *cache, gpointer key);
    void (*ptr_g_cache_remove)(GCache *cache, gconstpointer value);
    void (*ptr_g_cache_key_foreach)(GCache *cache, GHFunc func, gpointer user_data);
    void (*ptr_g_cache_value_foreach)(GCache *cache, GHFunc func, gpointer user_data);
    // Header /usr/include/glib-2.0/glib/deprecated/gcompletion.h
    void (*ptr_g_completion_add_items)(GCompletion* cmp, GList* items);
    void (*ptr_g_completion_remove_items)(GCompletion* cmp, GList* items);
    void (*ptr_g_completion_clear_items)(GCompletion* cmp);
    GList* (*ptr_g_completion_complete)(GCompletion* cmp, const gchar* prefix, gchar** new_prefix);
    GList* (*ptr_g_completion_complete_utf8)(GCompletion *cmp, const gchar* prefix, gchar** new_prefix);
    void (*ptr_g_completion_set_compare)(GCompletion *cmp, GCompletionStrncmpFunc strncmp_func);
    void (*ptr_g_completion_free)(GCompletion* cmp);
    GCompletion* (*ptr_g_completion_new)(GCompletionFunc func);
    // Header /usr/include/glib-2.0/glib/deprecated/gmain.h
    // Header /usr/include/glib-2.0/glib/deprecated/grel.h
    void (*ptr_g_relation_destroy)(GRelation *relation);
    void (*ptr_g_relation_index)(GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func);
    gint (*ptr_g_relation_delete)(GRelation *relation, gconstpointer key, gint field);
    GTuples* (*ptr_g_relation_select)(GRelation *relation, gconstpointer key, gint field);
    gint (*ptr_g_relation_count)(GRelation *relation, gconstpointer key, gint field);
    void (*ptr_g_relation_print)(GRelation *relation);
    void (*ptr_g_tuples_destroy)(GTuples *tuples);
    gpointer (*ptr_g_tuples_index)(GTuples *tuples, gint index_, gint field);
    GRelation* (*ptr_g_relation_new)(gint fields);
    // Header /usr/include/glib-2.0/glib/deprecated/gthread.h
    GThread* (*ptr_g_thread_create)(GThreadFunc func, gpointer data, gboolean joinable, GError **error);
    GThread* (*ptr_g_thread_create_full)(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error);
    void (*ptr_g_thread_set_priority)(GThread *thread, GThreadPriority priority);
    void (*ptr_g_thread_foreach)(GFunc thread_func, gpointer user_data);
    GPrivate * (*ptr_g_private_new)(GDestroyNotify notify);
    gboolean (*ptr_g_once_init_enter_impl)(volatile gsize *location);
    void (*ptr_g_thread_init)(gpointer vtable);
    void (*ptr_g_thread_init_with_errorcheck_mutexes)(gpointer vtable);
    gboolean (*ptr_g_thread_get_initialized)(void);
    GMutex * (*ptr_g_mutex_new)(void);
    void (*ptr_g_mutex_free)(GMutex *mutex);
    GCond * (*ptr_g_cond_new)(void);
    void (*ptr_g_cond_free)(GCond *cond);
    gboolean (*ptr_g_cond_timed_wait)(GCond *cond, GMutex *mutex, GTimeVal *abs_time);
    // Header /usr/include/glib-2.0/glib/galloca.h
    // Header /usr/include/glib-2.0/glib/garray.h
    GArray* (*ptr_g_array_new_take)(gpointer data, gsize len, gboolean clear, gsize element_size);
    GArray* (*ptr_g_array_new_take_zero_terminated)(gpointer data, gboolean clear, gsize element_size);
    gpointer (*ptr_g_array_steal)(GArray *array, gsize *len);
    GArray* (*ptr_g_array_sized_new)(gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size);
    GArray* (*ptr_g_array_copy)(GArray *array);
    gchar* (*ptr_g_array_free)(GArray *array, gboolean free_segment);
    GArray* (*ptr_g_array_ref)(GArray *array);
    void (*ptr_g_array_unref)(GArray *array);
    guint (*ptr_g_array_get_element_size)(GArray *array);
    GArray* (*ptr_g_array_append_vals)(GArray *array, gconstpointer data, guint len);
    GArray* (*ptr_g_array_prepend_vals)(GArray *array, gconstpointer data, guint len);
    GArray* (*ptr_g_array_insert_vals)(GArray *array, guint index_, gconstpointer data, guint len);
    GArray* (*ptr_g_array_set_size)(GArray *array, guint length);
    GArray* (*ptr_g_array_remove_index)(GArray *array, guint index_);
    GArray* (*ptr_g_array_remove_index_fast)(GArray *array, guint index_);
    GArray* (*ptr_g_array_remove_range)(GArray *array, guint index_, guint length);
    void (*ptr_g_array_sort)(GArray *array, GCompareFunc compare_func);
    void (*ptr_g_array_sort_with_data)(GArray *array, GCompareDataFunc compare_func, gpointer user_data);
    gboolean (*ptr_g_array_binary_search)(GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index);
    void (*ptr_g_array_set_clear_func)(GArray *array, GDestroyNotify clear_func);
    GPtrArray* (*ptr_g_ptr_array_new)(void);
    GPtrArray* (*ptr_g_ptr_array_new_with_free_func)(GDestroyNotify element_free_func);
    GPtrArray* (*ptr_g_ptr_array_new_take)(gpointer *data, gsize len, GDestroyNotify element_free_func);
    GPtrArray* (*ptr_g_ptr_array_new_from_array)(gpointer *data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func);
    gpointer* (*ptr_g_ptr_array_steal)(GPtrArray *array, gsize *len);
    GPtrArray* (*ptr_g_ptr_array_copy)(GPtrArray *array, GCopyFunc func, gpointer user_data);
    GPtrArray* (*ptr_g_ptr_array_sized_new)(guint reserved_size);
    GPtrArray* (*ptr_g_ptr_array_new_full)(guint reserved_size, GDestroyNotify element_free_func);
    GPtrArray* (*ptr_g_ptr_array_new_null_terminated)(guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated);
    GPtrArray* (*ptr_g_ptr_array_new_take_null_terminated)(gpointer *data, GDestroyNotify element_free_func);
    GPtrArray* (*ptr_g_ptr_array_new_from_null_terminated_array)(gpointer *data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func);
    gpointer* (*ptr_g_ptr_array_free)(GPtrArray *array, gboolean free_seg);
    GPtrArray* (*ptr_g_ptr_array_ref)(GPtrArray *array);
    void (*ptr_g_ptr_array_unref)(GPtrArray *array);
    void (*ptr_g_ptr_array_set_free_func)(GPtrArray *array, GDestroyNotify element_free_func);
    void (*ptr_g_ptr_array_set_size)(GPtrArray *array, gint length);
    gpointer (*ptr_g_ptr_array_remove_index)(GPtrArray *array, guint index_);
    gpointer (*ptr_g_ptr_array_remove_index_fast)(GPtrArray *array, guint index_);
    gpointer (*ptr_g_ptr_array_steal_index)(GPtrArray *array, guint index_);
    gpointer (*ptr_g_ptr_array_steal_index_fast)(GPtrArray *array, guint index_);
    gboolean (*ptr_g_ptr_array_remove)(GPtrArray *array, gpointer data);
    gboolean (*ptr_g_ptr_array_remove_fast)(GPtrArray *array, gpointer data);
    GPtrArray* (*ptr_g_ptr_array_remove_range)(GPtrArray *array, guint index_, guint length);
    void (*ptr_g_ptr_array_add)(GPtrArray *array, gpointer data);
    void (*ptr_g_ptr_array_extend)(GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data);
    void (*ptr_g_ptr_array_extend_and_steal)(GPtrArray *array_to_extend, GPtrArray *array);
    void (*ptr_g_ptr_array_insert)(GPtrArray *array, gint index_, gpointer data);
    void (*ptr_g_ptr_array_sort)(GPtrArray *array, GCompareFunc compare_func);
    void (*ptr_g_ptr_array_sort_with_data)(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data);
    void (*ptr_g_ptr_array_sort_values)(GPtrArray *array, GCompareFunc compare_func);
    void (*ptr_g_ptr_array_sort_values_with_data)(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data);
    void (*ptr_g_ptr_array_foreach)(GPtrArray *array, GFunc func, gpointer user_data);
    gboolean (*ptr_g_ptr_array_find)(GPtrArray *haystack, gconstpointer needle, guint *index_);
    gboolean (*ptr_g_ptr_array_find_with_equal_func)(GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_);
    gboolean (*ptr_g_ptr_array_is_null_terminated)(GPtrArray *array);
    GByteArray* (*ptr_g_byte_array_new)(void);
    GByteArray* (*ptr_g_byte_array_new_take)(guint8 *data, gsize len);
    guint8* (*ptr_g_byte_array_steal)(GByteArray *array, gsize *len);
    GByteArray* (*ptr_g_byte_array_sized_new)(guint reserved_size);
    guint8* (*ptr_g_byte_array_free)(GByteArray *array, gboolean free_segment);
    GBytes* (*ptr_g_byte_array_free_to_bytes)(GByteArray *array);
    GByteArray* (*ptr_g_byte_array_ref)(GByteArray *array);
    void (*ptr_g_byte_array_unref)(GByteArray *array);
    GByteArray* (*ptr_g_byte_array_append)(GByteArray *array, const guint8 *data, guint len);
    GByteArray* (*ptr_g_byte_array_prepend)(GByteArray *array, const guint8 *data, guint len);
    GByteArray* (*ptr_g_byte_array_set_size)(GByteArray *array, guint length);
    GByteArray* (*ptr_g_byte_array_remove_index)(GByteArray *array, guint index_);
    GByteArray* (*ptr_g_byte_array_remove_index_fast)(GByteArray *array, guint index_);
    GByteArray* (*ptr_g_byte_array_remove_range)(GByteArray *array, guint index_, guint length);
    void (*ptr_g_byte_array_sort)(GByteArray *array, GCompareFunc compare_func);
    void (*ptr_g_byte_array_sort_with_data)(GByteArray *array, GCompareDataFunc compare_func, gpointer user_data);
    GArray* (*ptr_g_array_new)(gboolean zero_terminated, gboolean clear_, guint element_size);
    // Header /usr/include/glib-2.0/glib/gasyncqueue.h
    GAsyncQueue* (*ptr_g_async_queue_new_full)(GDestroyNotify item_free_func);
    void (*ptr_g_async_queue_lock)(GAsyncQueue *queue);
    void (*ptr_g_async_queue_unlock)(GAsyncQueue *queue);
    GAsyncQueue* (*ptr_g_async_queue_ref)(GAsyncQueue *queue);
    void (*ptr_g_async_queue_unref)(GAsyncQueue *queue);
    void (*ptr_g_async_queue_ref_unlocked)(GAsyncQueue *queue);
    void (*ptr_g_async_queue_unref_and_unlock)(GAsyncQueue *queue);
    void (*ptr_g_async_queue_push)(GAsyncQueue *queue, gpointer data);
    void (*ptr_g_async_queue_push_unlocked)(GAsyncQueue *queue, gpointer data);
    void (*ptr_g_async_queue_push_sorted)(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
    void (*ptr_g_async_queue_push_sorted_unlocked)(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
    gpointer (*ptr_g_async_queue_pop)(GAsyncQueue *queue);
    gpointer (*ptr_g_async_queue_pop_unlocked)(GAsyncQueue *queue);
    gpointer (*ptr_g_async_queue_try_pop)(GAsyncQueue *queue);
    gpointer (*ptr_g_async_queue_try_pop_unlocked)(GAsyncQueue *queue);
    gpointer (*ptr_g_async_queue_timeout_pop)(GAsyncQueue *queue, guint64 timeout);
    gpointer (*ptr_g_async_queue_timeout_pop_unlocked)(GAsyncQueue *queue, guint64 timeout);
    gint (*ptr_g_async_queue_length)(GAsyncQueue *queue);
    gint (*ptr_g_async_queue_length_unlocked)(GAsyncQueue *queue);
    void (*ptr_g_async_queue_sort)(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
    void (*ptr_g_async_queue_sort_unlocked)(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
    gboolean (*ptr_g_async_queue_remove)(GAsyncQueue *queue, gpointer item);
    gboolean (*ptr_g_async_queue_remove_unlocked)(GAsyncQueue *queue, gpointer item);
    void (*ptr_g_async_queue_push_front)(GAsyncQueue *queue, gpointer item);
    void (*ptr_g_async_queue_push_front_unlocked)(GAsyncQueue *queue, gpointer item);
    gpointer (*ptr_g_async_queue_timed_pop_unlocked)(GAsyncQueue *queue, GTimeVal *end_time);
    GAsyncQueue* (*ptr_g_async_queue_new)(void);
    // Header /usr/include/glib-2.0/glib/gatomic.h
    void (*ptr_g_atomic_int_set)(volatile gint *atomic, gint newval);
    void (*ptr_g_atomic_int_inc)(volatile gint *atomic);
    gboolean (*ptr_g_atomic_int_dec_and_test)(volatile gint *atomic);
    gboolean (*ptr_g_atomic_int_compare_and_exchange)(volatile gint *atomic, gint oldval, gint newval);
    gboolean (*ptr_g_atomic_int_compare_and_exchange_full)(gint *atomic, gint oldval, gint newval, gint *preval);
    gint (*ptr_g_atomic_int_exchange)(gint *atomic, gint newval);
    gint (*ptr_g_atomic_int_add)(volatile gint *atomic, gint val);
    guint (*ptr_g_atomic_int_and)(volatile guint *atomic, guint val);
    guint (*ptr_g_atomic_int_or)(volatile guint *atomic, guint val);
    guint (*ptr_g_atomic_int_xor)(volatile guint *atomic, guint val);
    gpointer (*ptr_g_atomic_pointer_get)(const volatile void *atomic);
    void (*ptr_g_atomic_pointer_set)(volatile void *atomic, gpointer newval);
    gboolean (*ptr_g_atomic_pointer_compare_and_exchange)(volatile void *atomic, gpointer oldval, gpointer newval);
    gboolean (*ptr_g_atomic_pointer_compare_and_exchange_full)(void *atomic, gpointer oldval, gpointer newval, void *preval);
    gpointer (*ptr_g_atomic_pointer_exchange)(void *atomic, gpointer newval);
    gintptr (*ptr_g_atomic_pointer_add)(volatile void *atomic, gssize val);
    guintptr (*ptr_g_atomic_pointer_and)(volatile void *atomic, gsize val);
    guintptr (*ptr_g_atomic_pointer_or)(volatile void *atomic, gsize val);
    guintptr (*ptr_g_atomic_pointer_xor)(volatile void *atomic, gsize val);
    gint (*ptr_g_atomic_int_exchange_and_add)(volatile gint *atomic, gint val);
    gint (*ptr_g_atomic_int_get)(const volatile gint *atomic);
    // Header /usr/include/glib-2.0/glib/gbacktrace.h
    void (*ptr_g_on_error_stack_trace)(const gchar *prg_name);
    void (*ptr_g_on_error_query)(const gchar *prg_name);
    // Header /usr/include/glib-2.0/glib/gbase64.h
    gsize (*ptr_g_base64_encode_close)(gboolean break_lines, gchar *out, gint *state, gint *save);
    gchar* (*ptr_g_base64_encode)(const guchar *data, gsize len);
    gsize (*ptr_g_base64_decode_step)(const gchar *in, gsize len, guchar *out, gint *state, guint *save);
    guchar* (*ptr_g_base64_decode)(const gchar *text, gsize *out_len);
    guchar* (*ptr_g_base64_decode_inplace)(gchar *text, gsize *out_len);
    gsize (*ptr_g_base64_encode_step)(const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save);
    // Header /usr/include/glib-2.0/glib/gbitlock.h
    gboolean (*ptr_g_bit_trylock)(volatile gint *address, gint lock_bit);
    void (*ptr_g_bit_unlock)(volatile gint *address, gint lock_bit);
    void (*ptr_g_pointer_bit_lock)(volatile void *address, gint lock_bit);
    void (*ptr_g_pointer_bit_lock_and_get)(gpointer address, guint lock_bit, guintptr *out_ptr);
    gboolean (*ptr_g_pointer_bit_trylock)(volatile void *address, gint lock_bit);
    void (*ptr_g_pointer_bit_unlock)(volatile void *address, gint lock_bit);
    gpointer (*ptr_g_pointer_bit_lock_mask_ptr)(gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr);
    void (*ptr_g_pointer_bit_unlock_and_set)(void *address, guint lock_bit, gpointer ptr, guintptr preserve_mask);
    void (*ptr_g_bit_lock)(volatile gint *address, gint lock_bit);
    // Header /usr/include/glib-2.0/glib/gbookmarkfile.h
    GBookmarkFile* (*ptr_g_bookmark_file_new)(void);
    void (*ptr_g_bookmark_file_free)(GBookmarkFile *bookmark);
    GBookmarkFile* (*ptr_g_bookmark_file_copy)(GBookmarkFile *bookmark);
    gboolean (*ptr_g_bookmark_file_load_from_file)(GBookmarkFile *bookmark, const gchar *filename, GError **error);
    gboolean (*ptr_g_bookmark_file_load_from_data)(GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error);
    gboolean (*ptr_g_bookmark_file_load_from_data_dirs)(GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error);
    gchar * (*ptr_g_bookmark_file_to_data)(GBookmarkFile *bookmark, gsize *length, GError **error);
    gboolean (*ptr_g_bookmark_file_to_file)(GBookmarkFile *bookmark, const gchar *filename, GError **error);
    void (*ptr_g_bookmark_file_set_title)(GBookmarkFile *bookmark, const gchar *uri, const gchar *title);
    gchar * (*ptr_g_bookmark_file_get_title)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    void (*ptr_g_bookmark_file_set_description)(GBookmarkFile *bookmark, const gchar *uri, const gchar *description);
    gchar * (*ptr_g_bookmark_file_get_description)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    void (*ptr_g_bookmark_file_set_mime_type)(GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type);
    gchar * (*ptr_g_bookmark_file_get_mime_type)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    void (*ptr_g_bookmark_file_set_groups)(GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length);
    void (*ptr_g_bookmark_file_add_group)(GBookmarkFile *bookmark, const gchar *uri, const gchar *group);
    gboolean (*ptr_g_bookmark_file_has_group)(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
    gchar ** (*ptr_g_bookmark_file_get_groups)(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error);
    void (*ptr_g_bookmark_file_add_application)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec);
    gboolean (*ptr_g_bookmark_file_has_application)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
    gchar ** (*ptr_g_bookmark_file_get_applications)(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error);
    gboolean (*ptr_g_bookmark_file_set_app_info)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error);
    gboolean (*ptr_g_bookmark_file_set_application_info)(GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error);
    gboolean (*ptr_g_bookmark_file_get_app_info)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error);
    gboolean (*ptr_g_bookmark_file_get_application_info)(GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error);
    void (*ptr_g_bookmark_file_set_is_private)(GBookmarkFile *bookmark, const gchar *uri, gboolean is_private);
    gboolean (*ptr_g_bookmark_file_get_is_private)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    void (*ptr_g_bookmark_file_set_icon)(GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type);
    gboolean (*ptr_g_bookmark_file_get_icon)(GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error);
    void (*ptr_g_bookmark_file_set_added)(GBookmarkFile *bookmark, const gchar *uri, time_t added);
    void (*ptr_g_bookmark_file_set_added_date_time)(GBookmarkFile *bookmark, const char *uri, GDateTime *added);
    time_t (*ptr_g_bookmark_file_get_added)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    GDateTime* (*ptr_g_bookmark_file_get_added_date_time)(GBookmarkFile *bookmark, const char *uri, GError **error);
    void (*ptr_g_bookmark_file_set_modified)(GBookmarkFile *bookmark, const gchar *uri, time_t modified);
    void (*ptr_g_bookmark_file_set_modified_date_time)(GBookmarkFile *bookmark, const char *uri, GDateTime *modified);
    time_t (*ptr_g_bookmark_file_get_modified)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    GDateTime* (*ptr_g_bookmark_file_get_modified_date_time)(GBookmarkFile *bookmark, const char *uri, GError **error);
    void (*ptr_g_bookmark_file_set_visited)(GBookmarkFile *bookmark, const gchar *uri, time_t visited);
    void (*ptr_g_bookmark_file_set_visited_date_time)(GBookmarkFile *bookmark, const char *uri, GDateTime *visited);
    time_t (*ptr_g_bookmark_file_get_visited)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    GDateTime* (*ptr_g_bookmark_file_get_visited_date_time)(GBookmarkFile *bookmark, const char *uri, GError **error);
    gboolean (*ptr_g_bookmark_file_has_item)(GBookmarkFile *bookmark, const gchar *uri);
    gint (*ptr_g_bookmark_file_get_size)(GBookmarkFile *bookmark);
    gchar ** (*ptr_g_bookmark_file_get_uris)(GBookmarkFile *bookmark, gsize *length);
    gboolean (*ptr_g_bookmark_file_remove_group)(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
    gboolean (*ptr_g_bookmark_file_remove_application)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
    gboolean (*ptr_g_bookmark_file_remove_item)(GBookmarkFile *bookmark, const gchar *uri, GError **error);
    gboolean (*ptr_g_bookmark_file_move_item)(GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error);
    GQuark (*ptr_g_bookmark_file_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gbytes.h
    GBytes * (*ptr_g_bytes_new_take)(gpointer data, gsize size);
    GBytes * (*ptr_g_bytes_new_static)(gconstpointer data, gsize size);
    GBytes * (*ptr_g_bytes_new_with_free_func)(gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data);
    GBytes * (*ptr_g_bytes_new_from_bytes)(GBytes *bytes, gsize offset, gsize length);
    gconstpointer (*ptr_g_bytes_get_data)(GBytes *bytes, gsize *size);
    gsize (*ptr_g_bytes_get_size)(GBytes *bytes);
    GBytes * (*ptr_g_bytes_ref)(GBytes *bytes);
    void (*ptr_g_bytes_unref)(GBytes *bytes);
    gpointer (*ptr_g_bytes_unref_to_data)(GBytes *bytes, gsize *size);
    GByteArray * (*ptr_g_bytes_unref_to_array)(GBytes *bytes);
    guint (*ptr_g_bytes_hash)(gconstpointer bytes);
    gboolean (*ptr_g_bytes_equal)(gconstpointer bytes1, gconstpointer bytes2);
    gint (*ptr_g_bytes_compare)(gconstpointer bytes1, gconstpointer bytes2);
    gconstpointer (*ptr_g_bytes_get_region)(GBytes *bytes, gsize element_size, gsize offset, gsize n_elements);
    GBytes * (*ptr_g_bytes_new)(gconstpointer data, gsize size);
    // Header /usr/include/glib-2.0/glib/gcharset.h
    gchar * (*ptr_g_get_codeset)(void);
    gboolean (*ptr_g_get_console_charset)(const char **charset);
    const gchar * const * (*ptr_g_get_language_names)(void);
    const gchar * const * (*ptr_g_get_language_names_with_category)(const gchar *category_name);
    gchar ** (*ptr_g_get_locale_variants)(const gchar *locale);
    gboolean (*ptr_g_get_charset)(const char **charset);
    // Header /usr/include/glib-2.0/glib/gchecksum.h
    GChecksum * (*ptr_g_checksum_new)(GChecksumType checksum_type);
    void (*ptr_g_checksum_reset)(GChecksum *checksum);
    GChecksum * (*ptr_g_checksum_copy)(const GChecksum *checksum);
    void (*ptr_g_checksum_free)(GChecksum *checksum);
    void (*ptr_g_checksum_update)(GChecksum *checksum, const guchar *data, gssize length);
    const gchar * (*ptr_g_checksum_get_string)(GChecksum *checksum);
    void (*ptr_g_checksum_get_digest)(GChecksum *checksum, guint8 *buffer, gsize *digest_len);
    gchar* (*ptr_g_compute_checksum_for_data)(GChecksumType checksum_type, const guchar *data, gsize length);
    gchar* (*ptr_g_compute_checksum_for_string)(GChecksumType checksum_type, const gchar *str, gssize length);
    gchar* (*ptr_g_compute_checksum_for_bytes)(GChecksumType checksum_type, GBytes *data);
    gssize (*ptr_g_checksum_type_get_length)(GChecksumType checksum_type);
    // Header /usr/include/glib-2.0/glib/gconvert.h
    GIConv (*ptr_g_iconv_open)(const gchar *to_codeset, const gchar *from_codeset);
    gsize (*ptr_g_iconv)(GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left);
    gint (*ptr_g_iconv_close)(GIConv converter);
    gchar* (*ptr_g_convert)(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error);
    gchar* (*ptr_g_convert_with_iconv)(const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error);
    gchar* (*ptr_g_convert_with_fallback)(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error);
    gchar* (*ptr_g_locale_to_utf8)(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);
    gchar* (*ptr_g_locale_from_utf8)(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);
    gchar* (*ptr_g_filename_to_utf8)(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);
    gchar* (*ptr_g_filename_from_utf8)(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);
    gchar* (*ptr_g_filename_from_uri)(const gchar *uri, gchar **hostname, GError **error);
    gchar* (*ptr_g_filename_to_uri)(const gchar *filename, const gchar *hostname, GError **error);
    gchar* (*ptr_g_filename_display_name)(const gchar *filename);
    gboolean (*ptr_g_get_filename_charsets)(const gchar ***filename_charsets);
    gchar* (*ptr_g_filename_display_basename)(const gchar *filename);
    gchar** (*ptr_g_uri_list_extract_uris)(const gchar *uri_list);
    GQuark (*ptr_g_convert_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gdataset.h
    void (*ptr_g_datalist_clear)(GData **datalist);
    gpointer (*ptr_g_datalist_id_get_data)(GData **datalist, GQuark key_id);
    void (*ptr_g_datalist_id_set_data_full)(GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
    void (*ptr_g_datalist_id_remove_multiple)(GData **datalist, GQuark *keys, gsize n_keys);
    gpointer (*ptr_g_datalist_id_dup_data)(GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data);
    gboolean (*ptr_g_datalist_id_replace_data)(GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
    gpointer (*ptr_g_datalist_id_remove_no_notify)(GData **datalist, GQuark key_id);
    void (*ptr_g_datalist_foreach)(GData **datalist, GDataForeachFunc func, gpointer user_data);
    void (*ptr_g_datalist_set_flags)(GData **datalist, guint flags);
    void (*ptr_g_datalist_unset_flags)(GData **datalist, guint flags);
    guint (*ptr_g_datalist_get_flags)(GData **datalist);
    void (*ptr_g_dataset_destroy)(gconstpointer dataset_location);
    gpointer (*ptr_g_dataset_id_get_data)(gconstpointer dataset_location, GQuark key_id);
    gpointer (*ptr_g_datalist_get_data)(GData **datalist, const gchar *key);
    void (*ptr_g_dataset_id_set_data_full)(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
    gpointer (*ptr_g_dataset_id_remove_no_notify)(gconstpointer dataset_location, GQuark key_id);
    void (*ptr_g_dataset_foreach)(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data);
    void (*ptr_g_datalist_init)(GData **datalist);
    // Header /usr/include/glib-2.0/glib/gdate.h
    GDate* (*ptr_g_date_new_dmy)(GDateDay day, GDateMonth month, GDateYear year);
    GDate* (*ptr_g_date_new_julian)(guint32 julian_day);
    void (*ptr_g_date_free)(GDate *date);
    GDate* (*ptr_g_date_copy)(const GDate *date);
    gboolean (*ptr_g_date_valid)(const GDate *date);
    gboolean (*ptr_g_date_valid_day)(GDateDay day);
    gboolean (*ptr_g_date_valid_month)(GDateMonth month);
    gboolean (*ptr_g_date_valid_year)(GDateYear year);
    gboolean (*ptr_g_date_valid_weekday)(GDateWeekday weekday);
    gboolean (*ptr_g_date_valid_julian)(guint32 julian_date);
    gboolean (*ptr_g_date_valid_dmy)(GDateDay day, GDateMonth month, GDateYear year);
    GDateWeekday (*ptr_g_date_get_weekday)(const GDate *date);
    GDateMonth (*ptr_g_date_get_month)(const GDate *date);
    GDateYear (*ptr_g_date_get_year)(const GDate *date);
    GDateDay (*ptr_g_date_get_day)(const GDate *date);
    guint32 (*ptr_g_date_get_julian)(const GDate *date);
    guint (*ptr_g_date_get_day_of_year)(const GDate *date);
    guint (*ptr_g_date_get_monday_week_of_year)(const GDate *date);
    guint (*ptr_g_date_get_sunday_week_of_year)(const GDate *date);
    guint (*ptr_g_date_get_iso8601_week_of_year)(const GDate *date);
    void (*ptr_g_date_clear)(GDate *date, guint n_dates);
    void (*ptr_g_date_set_parse)(GDate *date, const gchar *str);
    void (*ptr_g_date_set_time_t)(GDate *date, time_t timet);
    void (*ptr_g_date_set_time)(GDate *date, GTime time_);
    void (*ptr_g_date_set_day)(GDate *date, GDateDay day);
    void (*ptr_g_date_set_year)(GDate *date, GDateYear year);
    void (*ptr_g_date_set_dmy)(GDate *date, GDateDay day, GDateMonth month, GDateYear y);
    void (*ptr_g_date_set_julian)(GDate *date, guint32 julian_date);
    gboolean (*ptr_g_date_is_first_of_month)(const GDate *date);
    gboolean (*ptr_g_date_is_last_of_month)(const GDate *date);
    void (*ptr_g_date_add_days)(GDate *date, guint n_days);
    void (*ptr_g_date_subtract_days)(GDate *date, guint n_days);
    void (*ptr_g_date_add_months)(GDate *date, guint n_months);
    void (*ptr_g_date_subtract_months)(GDate *date, guint n_months);
    void (*ptr_g_date_add_years)(GDate *date, guint n_years);
    void (*ptr_g_date_subtract_years)(GDate *date, guint n_years);
    gboolean (*ptr_g_date_is_leap_year)(GDateYear year);
    guint8 (*ptr_g_date_get_days_in_month)(GDateMonth month, GDateYear year);
    guint8 (*ptr_g_date_get_monday_weeks_in_year)(GDateYear year);
    guint8 (*ptr_g_date_get_sunday_weeks_in_year)(GDateYear year);
    gint (*ptr_g_date_days_between)(const GDate *date1, const GDate *date2);
    gint (*ptr_g_date_compare)(const GDate *lhs, const GDate *rhs);
    void (*ptr_g_date_to_struct_tm)(const GDate *date, struct tm *tm);
    void (*ptr_g_date_clamp)(GDate *date, const GDate *min_date, const GDate *max_date);
    void (*ptr_g_date_order)(GDate *date1, GDate *date2);
    gsize (*ptr_g_date_strftime)(gchar *s, gsize slen, const gchar *format, const GDate *date);
    GDate* (*ptr_g_date_new)(void);
    // Header /usr/include/glib-2.0/glib/gdatetime.h
    GDateTime * (*ptr_g_date_time_ref)(GDateTime *datetime);
    GDateTime * (*ptr_g_date_time_new_now)(GTimeZone *tz);
    GDateTime * (*ptr_g_date_time_new_now_local)(void);
    GDateTime * (*ptr_g_date_time_new_now_utc)(void);
    GDateTime * (*ptr_g_date_time_new_from_unix_local)(gint64 t);
    GDateTime * (*ptr_g_date_time_new_from_unix_utc)(gint64 t);
    GDateTime * (*ptr_g_date_time_new_from_unix_local_usec)(gint64 usecs);
    GDateTime * (*ptr_g_date_time_new_from_unix_utc_usec)(gint64 usecs);
    GDateTime * (*ptr_g_date_time_new_from_timeval_utc)(const GTimeVal *tv);
    GDateTime * (*ptr_g_date_time_new)(GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
    GDateTime * (*ptr_g_date_time_new_local)(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
    GDateTime * (*ptr_g_date_time_new_utc)(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
    GDateTime * (*ptr_g_date_time_add)(GDateTime *datetime, GTimeSpan timespan);
    GDateTime * (*ptr_g_date_time_add_years)(GDateTime *datetime, gint years);
    GDateTime * (*ptr_g_date_time_add_months)(GDateTime *datetime, gint months);
    GDateTime * (*ptr_g_date_time_add_weeks)(GDateTime *datetime, gint weeks);
    GDateTime * (*ptr_g_date_time_add_days)(GDateTime *datetime, gint days);
    GDateTime * (*ptr_g_date_time_add_hours)(GDateTime *datetime, gint hours);
    GDateTime * (*ptr_g_date_time_add_minutes)(GDateTime *datetime, gint minutes);
    GDateTime * (*ptr_g_date_time_add_seconds)(GDateTime *datetime, gdouble seconds);
    GDateTime * (*ptr_g_date_time_add_full)(GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds);
    gint (*ptr_g_date_time_compare)(gconstpointer dt1, gconstpointer dt2);
    GTimeSpan (*ptr_g_date_time_difference)(GDateTime *end, GDateTime *begin);
    guint (*ptr_g_date_time_hash)(gconstpointer datetime);
    gboolean (*ptr_g_date_time_equal)(gconstpointer dt1, gconstpointer dt2);
    void (*ptr_g_date_time_get_ymd)(GDateTime *datetime, gint *year, gint *month, gint *day);
    gint (*ptr_g_date_time_get_year)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_month)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_day_of_month)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_week_numbering_year)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_week_of_year)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_day_of_week)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_day_of_year)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_hour)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_minute)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_second)(GDateTime *datetime);
    gint (*ptr_g_date_time_get_microsecond)(GDateTime *datetime);
    gdouble (*ptr_g_date_time_get_seconds)(GDateTime *datetime);
    gint64 (*ptr_g_date_time_to_unix)(GDateTime *datetime);
    gint64 (*ptr_g_date_time_to_unix_usec)(GDateTime *datetime);
    GTimeZone * (*ptr_g_date_time_get_timezone)(GDateTime *datetime);
    const gchar * (*ptr_g_date_time_get_timezone_abbreviation)(GDateTime *datetime);
    gboolean (*ptr_g_date_time_is_daylight_savings)(GDateTime *datetime);
    GDateTime * (*ptr_g_date_time_to_timezone)(GDateTime *datetime, GTimeZone *tz);
    GDateTime * (*ptr_g_date_time_to_local)(GDateTime *datetime);
    GDateTime * (*ptr_g_date_time_to_utc)(GDateTime *datetime);
    gchar * (*ptr_g_date_time_format)(GDateTime *datetime, const gchar *format);
    gchar * (*ptr_g_date_time_format_iso8601)(GDateTime *datetime);
    void (*ptr_g_date_time_unref)(GDateTime *datetime);
    // Header /usr/include/glib-2.0/glib/gdir.h
    const gchar * (*ptr_g_dir_read_name)(GDir *dir);
    void (*ptr_g_dir_rewind)(GDir *dir);
    void (*ptr_g_dir_close)(GDir *dir);
    GDir * (*ptr_g_dir_ref)(GDir *dir);
    void (*ptr_g_dir_unref)(GDir *dir);
    GDir * (*ptr_g_dir_open)(const gchar *path, guint flags, GError **error);
    // Header /usr/include/glib-2.0/glib/genviron.h
    gboolean (*ptr_g_setenv)(const gchar *variable, const gchar *value, gboolean overwrite);
    void (*ptr_g_unsetenv)(const gchar *variable);
    gchar ** (*ptr_g_listenv)(void);
    gchar ** (*ptr_g_get_environ)(void);
    const gchar * (*ptr_g_environ_getenv)(gchar **envp, const gchar *variable);
    gchar ** (*ptr_g_environ_setenv)(gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite);
    gchar ** (*ptr_g_environ_unsetenv)(gchar **envp, const gchar *variable);
    const gchar * (*ptr_g_getenv)(const gchar *variable);
    // Header /usr/include/glib-2.0/glib/gerror.h
    GQuark (*ptr_g_error_domain_register)(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
    GError* (*ptr_g_error_new_literal)(GQuark domain, gint code, const gchar *message);
    GError* (*ptr_g_error_new_valist)(GQuark domain, gint code, const gchar *format, va_list args);
    void (*ptr_g_error_free)(GError *error);
    GError* (*ptr_g_error_copy)(const GError *error);
    gboolean (*ptr_g_error_matches)(const GError *error, GQuark domain, gint code);
    void (*ptr_g_set_error_literal)(GError **err, GQuark domain, gint code, const gchar *message);
    void (*ptr_g_propagate_error)(GError **dest, GError *src);
    void (*ptr_g_clear_error)(GError **err);
    void (*ptr_g_prefix_error_literal)(GError **err, const gchar *prefix);
    GQuark (*ptr_g_error_domain_register_static)(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
    // Header /usr/include/glib-2.0/glib/gfileutils.h
    GQuark (*ptr_g_file_error_quark)(void);
    GFileError (*ptr_g_file_error_from_errno)(gint err_no);
    gboolean (*ptr_g_file_test)(const gchar *filename, GFileTest test);
    gboolean (*ptr_g_file_get_contents)(const gchar *filename, gchar **contents, gsize *length, GError **error);
    gboolean (*ptr_g_file_set_contents)(const gchar *filename, const gchar *contents, gssize length, GError **error);
    gchar* (*ptr_g_mkdtemp)(gchar *tmpl);
    gchar* (*ptr_g_mkdtemp_full)(gchar *tmpl, gint mode);
    gint (*ptr_g_mkstemp)(gchar *tmpl);
    gint (*ptr_g_mkstemp_full)(gchar *tmpl, gint flags, gint mode);
    gint (*ptr_g_file_open_tmp)(const gchar *tmpl, gchar **name_used, GError **error);
    gchar* (*ptr_g_dir_make_tmp)(const gchar *tmpl, GError **error);
    gchar* (*ptr_g_build_pathv)(const gchar *separator, gchar **args);
    gchar* (*ptr_g_build_filenamev)(gchar **args);
    gchar* (*ptr_g_build_filename_valist)(const gchar *first_element, va_list *args);
    gboolean (*ptr_g_path_is_absolute)(const gchar *file_name);
    const gchar* (*ptr_g_path_skip_root)(const gchar *file_name);
    const gchar* (*ptr_g_basename)(const gchar *file_name);
    gchar* (*ptr_g_get_current_dir)(void);
    gchar* (*ptr_g_path_get_basename)(const gchar *file_name);
    gchar* (*ptr_g_path_get_dirname)(const gchar *file_name);
    gchar* (*ptr_g_canonicalize_filename)(const gchar *filename, const gchar *relative_to);
    // Header /usr/include/glib-2.0/glib/ggettext.h
    const gchar* (*ptr_g_dgettext)(const gchar *domain, const gchar *msgid);
    const gchar* (*ptr_g_dcgettext)(const gchar *domain, const gchar *msgid, gint category);
    const gchar* (*ptr_g_dngettext)(const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n);
    const gchar* (*ptr_g_dpgettext)(const gchar *domain, const gchar *msgctxtid, gsize msgidoffset);
    const gchar* (*ptr_g_dpgettext2)(const gchar *domain, const gchar *context, const gchar *msgid);
    const gchar* (*ptr_g_strip_context)(const gchar *msgid, const gchar *msgval);
    // Header /usr/include/glib-2.0/glib/ghash.h
    GHashTable* (*ptr_g_hash_table_new_full)(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
    GHashTable* (*ptr_g_hash_table_new_similar)(GHashTable *other_hash_table);
    void (*ptr_g_hash_table_destroy)(GHashTable *hash_table);
    gboolean (*ptr_g_hash_table_insert)(GHashTable *hash_table, gpointer key, gpointer value);
    gboolean (*ptr_g_hash_table_replace)(GHashTable *hash_table, gpointer key, gpointer value);
    gboolean (*ptr_g_hash_table_add)(GHashTable *hash_table, gpointer key);
    gboolean (*ptr_g_hash_table_remove)(GHashTable *hash_table, gconstpointer key);
    void (*ptr_g_hash_table_remove_all)(GHashTable *hash_table);
    gboolean (*ptr_g_hash_table_steal)(GHashTable *hash_table, gconstpointer key);
    gboolean (*ptr_g_hash_table_steal_extended)(GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value);
    void (*ptr_g_hash_table_steal_all)(GHashTable *hash_table);
    GPtrArray * (*ptr_g_hash_table_steal_all_keys)(GHashTable *hash_table);
    GPtrArray * (*ptr_g_hash_table_steal_all_values)(GHashTable *hash_table);
    gpointer (*ptr_g_hash_table_lookup)(GHashTable *hash_table, gconstpointer key);
    gboolean (*ptr_g_hash_table_contains)(GHashTable *hash_table, gconstpointer key);
    gboolean (*ptr_g_hash_table_lookup_extended)(GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
    void (*ptr_g_hash_table_foreach)(GHashTable *hash_table, GHFunc func, gpointer user_data);
    gpointer (*ptr_g_hash_table_find)(GHashTable *hash_table, GHRFunc predicate, gpointer user_data);
    guint (*ptr_g_hash_table_foreach_remove)(GHashTable *hash_table, GHRFunc func, gpointer user_data);
    guint (*ptr_g_hash_table_foreach_steal)(GHashTable *hash_table, GHRFunc func, gpointer user_data);
    guint (*ptr_g_hash_table_size)(GHashTable *hash_table);
    GList * (*ptr_g_hash_table_get_keys)(GHashTable *hash_table);
    GList * (*ptr_g_hash_table_get_values)(GHashTable *hash_table);
    gpointer * (*ptr_g_hash_table_get_keys_as_array)(GHashTable *hash_table, guint *length);
    GPtrArray * (*ptr_g_hash_table_get_keys_as_ptr_array)(GHashTable *hash_table);
    GPtrArray * (*ptr_g_hash_table_get_values_as_ptr_array)(GHashTable *hash_table);
    void (*ptr_g_hash_table_iter_init)(GHashTableIter *iter, GHashTable *hash_table);
    gboolean (*ptr_g_hash_table_iter_next)(GHashTableIter *iter, gpointer *key, gpointer *value);
    GHashTable* (*ptr_g_hash_table_iter_get_hash_table)(GHashTableIter *iter);
    void (*ptr_g_hash_table_iter_remove)(GHashTableIter *iter);
    void (*ptr_g_hash_table_iter_replace)(GHashTableIter *iter, gpointer value);
    void (*ptr_g_hash_table_iter_steal)(GHashTableIter *iter);
    GHashTable* (*ptr_g_hash_table_ref)(GHashTable *hash_table);
    void (*ptr_g_hash_table_unref)(GHashTable *hash_table);
    gboolean (*ptr_g_str_equal)(gconstpointer v1, gconstpointer v2);
    guint (*ptr_g_str_hash)(gconstpointer v);
    gboolean (*ptr_g_int_equal)(gconstpointer v1, gconstpointer v2);
    guint (*ptr_g_int_hash)(gconstpointer v);
    gboolean (*ptr_g_int64_equal)(gconstpointer v1, gconstpointer v2);
    guint (*ptr_g_int64_hash)(gconstpointer v);
    gboolean (*ptr_g_double_equal)(gconstpointer v1, gconstpointer v2);
    guint (*ptr_g_double_hash)(gconstpointer v);
    guint (*ptr_g_direct_hash)(gconstpointer v);
    gboolean (*ptr_g_direct_equal)(gconstpointer v1, gconstpointer v2);
    GHashTable* (*ptr_g_hash_table_new)(GHashFunc hash_func, GEqualFunc key_equal_func);
    // Header /usr/include/glib-2.0/glib/ghmac.h
    GHmac * (*ptr_g_hmac_copy)(const GHmac *hmac);
    GHmac * (*ptr_g_hmac_ref)(GHmac *hmac);
    void (*ptr_g_hmac_unref)(GHmac *hmac);
    void (*ptr_g_hmac_update)(GHmac *hmac, const guchar *data, gssize length);
    const gchar * (*ptr_g_hmac_get_string)(GHmac *hmac);
    void (*ptr_g_hmac_get_digest)(GHmac *hmac, guint8 *buffer, gsize *digest_len);
    gchar* (*ptr_g_compute_hmac_for_data)(GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length);
    gchar* (*ptr_g_compute_hmac_for_string)(GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length);
    gchar* (*ptr_g_compute_hmac_for_bytes)(GChecksumType digest_type, GBytes *key, GBytes *data);
    GHmac * (*ptr_g_hmac_new)(GChecksumType digest_type, const guchar *key, gsize key_len);
    // Header /usr/include/glib-2.0/glib/ghook.h
    void (*ptr_g_hook_list_clear)(GHookList *hook_list);
    GHook* (*ptr_g_hook_alloc)(GHookList *hook_list);
    void (*ptr_g_hook_free)(GHookList *hook_list, GHook *hook);
    GHook * (*ptr_g_hook_ref)(GHookList *hook_list, GHook *hook);
    void (*ptr_g_hook_unref)(GHookList *hook_list, GHook *hook);
    gboolean (*ptr_g_hook_destroy)(GHookList *hook_list, gulong hook_id);
    void (*ptr_g_hook_destroy_link)(GHookList *hook_list, GHook *hook);
    void (*ptr_g_hook_prepend)(GHookList *hook_list, GHook *hook);
    void (*ptr_g_hook_insert_before)(GHookList *hook_list, GHook *sibling, GHook *hook);
    void (*ptr_g_hook_insert_sorted)(GHookList *hook_list, GHook *hook, GHookCompareFunc func);
    GHook* (*ptr_g_hook_get)(GHookList *hook_list, gulong hook_id);
    GHook* (*ptr_g_hook_find)(GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);
    GHook* (*ptr_g_hook_find_data)(GHookList *hook_list, gboolean need_valids, gpointer data);
    GHook* (*ptr_g_hook_find_func)(GHookList *hook_list, gboolean need_valids, gpointer func);
    GHook* (*ptr_g_hook_find_func_data)(GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data);
    GHook* (*ptr_g_hook_first_valid)(GHookList *hook_list, gboolean may_be_in_call);
    GHook* (*ptr_g_hook_next_valid)(GHookList *hook_list, GHook *hook, gboolean may_be_in_call);
    gint (*ptr_g_hook_compare_ids)(GHook *new_hook, GHook *sibling);
    void (*ptr_g_hook_list_invoke)(GHookList *hook_list, gboolean may_recurse);
    void (*ptr_g_hook_list_invoke_check)(GHookList *hook_list, gboolean may_recurse);
    void (*ptr_g_hook_list_marshal)(GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);
    void (*ptr_g_hook_list_marshal_check)(GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
    void (*ptr_g_hook_list_init)(GHookList *hook_list, guint hook_size);
    // Header /usr/include/glib-2.0/glib/ghostutils.h
    gboolean (*ptr_g_hostname_is_ascii_encoded)(const gchar *hostname);
    gboolean (*ptr_g_hostname_is_ip_address)(const gchar *hostname);
    gchar* (*ptr_g_hostname_to_ascii)(const gchar *hostname);
    gchar* (*ptr_g_hostname_to_unicode)(const gchar *hostname);
    gboolean (*ptr_g_hostname_is_non_ascii)(const gchar *hostname);
    // Header /usr/include/glib-2.0/glib/giochannel.h
    GIOChannel* (*ptr_g_io_channel_ref)(GIOChannel *channel);
    void (*ptr_g_io_channel_unref)(GIOChannel *channel);
    GIOError (*ptr_g_io_channel_read)(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read);
    GIOError (*ptr_g_io_channel_write)(GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written);
    GIOError (*ptr_g_io_channel_seek)(GIOChannel *channel, gint64 offset, GSeekType type);
    void (*ptr_g_io_channel_close)(GIOChannel *channel);
    GIOStatus (*ptr_g_io_channel_shutdown)(GIOChannel *channel, gboolean flush, GError **err);
    guint (*ptr_g_io_add_watch_full)(GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify);
    GSource * (*ptr_g_io_create_watch)(GIOChannel *channel, GIOCondition condition);
    guint (*ptr_g_io_add_watch)(GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data);
    void (*ptr_g_io_channel_set_buffer_size)(GIOChannel *channel, gsize size);
    gsize (*ptr_g_io_channel_get_buffer_size)(GIOChannel *channel);
    GIOCondition (*ptr_g_io_channel_get_buffer_condition)(GIOChannel *channel);
    GIOStatus (*ptr_g_io_channel_set_flags)(GIOChannel *channel, GIOFlags flags, GError **error);
    GIOFlags (*ptr_g_io_channel_get_flags)(GIOChannel *channel);
    void (*ptr_g_io_channel_set_line_term)(GIOChannel *channel, const gchar *line_term, gint length);
    const gchar * (*ptr_g_io_channel_get_line_term)(GIOChannel *channel, gint *length);
    void (*ptr_g_io_channel_set_buffered)(GIOChannel *channel, gboolean buffered);
    gboolean (*ptr_g_io_channel_get_buffered)(GIOChannel *channel);
    GIOStatus (*ptr_g_io_channel_set_encoding)(GIOChannel *channel, const gchar *encoding, GError **error);
    const gchar * (*ptr_g_io_channel_get_encoding)(GIOChannel *channel);
    void (*ptr_g_io_channel_set_close_on_unref)(GIOChannel *channel, gboolean do_close);
    gboolean (*ptr_g_io_channel_get_close_on_unref)(GIOChannel *channel);
    GIOStatus (*ptr_g_io_channel_flush)(GIOChannel *channel, GError **error);
    GIOStatus (*ptr_g_io_channel_read_line)(GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error);
    GIOStatus (*ptr_g_io_channel_read_line_string)(GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error);
    GIOStatus (*ptr_g_io_channel_read_to_end)(GIOChannel *channel, gchar **str_return, gsize *length, GError **error);
    GIOStatus (*ptr_g_io_channel_read_chars)(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error);
    GIOStatus (*ptr_g_io_channel_read_unichar)(GIOChannel *channel, gunichar *thechar, GError **error);
    GIOStatus (*ptr_g_io_channel_write_chars)(GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error);
    GIOStatus (*ptr_g_io_channel_write_unichar)(GIOChannel *channel, gunichar thechar, GError **error);
    GIOStatus (*ptr_g_io_channel_seek_position)(GIOChannel *channel, gint64 offset, GSeekType type, GError **error);
    GIOChannel* (*ptr_g_io_channel_new_file)(const gchar *filename, const gchar *mode, GError **error);
    GQuark (*ptr_g_io_channel_error_quark)(void);
    GIOChannelError (*ptr_g_io_channel_error_from_errno)(gint en);
    GIOChannel* (*ptr_g_io_channel_unix_new)(int fd);
    gint (*ptr_g_io_channel_unix_get_fd)(GIOChannel *channel);
    void (*ptr_g_io_channel_win32_make_pollfd)(GIOChannel *channel, GIOCondition condition, GPollFD *fd);
    gint (*ptr_g_io_channel_win32_poll)(GPollFD *fds, gint n_fds, gint timeout_);
    GIOChannel* (*ptr_g_io_channel_win32_new_messages)(gsize hwnd);
    GIOChannel* (*ptr_g_io_channel_win32_new_fd)(gint fd);
    gint (*ptr_g_io_channel_win32_get_fd)(GIOChannel *channel);
    GIOChannel* (*ptr_g_io_channel_win32_new_socket)(gint socket);
    GIOChannel* (*ptr_g_io_channel_win32_new_stream_socket)(gint socket);
    void (*ptr_g_io_channel_win32_set_debug)(GIOChannel *channel, gboolean flag);
    void (*ptr_g_io_channel_init)(GIOChannel *channel);
    // Header /usr/include/glib-2.0/glib/gkeyfile.h
    GKeyFile* (*ptr_g_key_file_new)(void);
    GKeyFile* (*ptr_g_key_file_ref)(GKeyFile *key_file);
    void (*ptr_g_key_file_unref)(GKeyFile *key_file);
    void (*ptr_g_key_file_free)(GKeyFile *key_file);
    void (*ptr_g_key_file_set_list_separator)(GKeyFile *key_file, gchar separator);
    gboolean (*ptr_g_key_file_load_from_file)(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);
    gboolean (*ptr_g_key_file_load_from_data)(GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error);
    gboolean (*ptr_g_key_file_load_from_bytes)(GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error);
    gboolean (*ptr_g_key_file_load_from_dirs)(GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error);
    gboolean (*ptr_g_key_file_load_from_data_dirs)(GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error);
    gchar* (*ptr_g_key_file_to_data)(GKeyFile *key_file, gsize *length, GError **error);
    gboolean (*ptr_g_key_file_save_to_file)(GKeyFile *key_file, const gchar *filename, GError **error);
    gchar* (*ptr_g_key_file_get_start_group)(GKeyFile *key_file);
    gchar** (*ptr_g_key_file_get_groups)(GKeyFile *key_file, gsize *length);
    gchar** (*ptr_g_key_file_get_keys)(GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error);
    gboolean (*ptr_g_key_file_has_group)(GKeyFile *key_file, const gchar *group_name);
    gboolean (*ptr_g_key_file_has_key)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    gchar* (*ptr_g_key_file_get_value)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    void (*ptr_g_key_file_set_value)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value);
    gchar* (*ptr_g_key_file_get_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    void (*ptr_g_key_file_set_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string);
    gchar* (*ptr_g_key_file_get_locale_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error);
    gchar* (*ptr_g_key_file_get_locale_for_key)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale);
    void (*ptr_g_key_file_set_locale_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string);
    gboolean (*ptr_g_key_file_get_boolean)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    void (*ptr_g_key_file_set_boolean)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value);
    gint (*ptr_g_key_file_get_integer)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    void (*ptr_g_key_file_set_integer)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value);
    gint64 (*ptr_g_key_file_get_int64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    void (*ptr_g_key_file_set_int64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value);
    guint64 (*ptr_g_key_file_get_uint64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    void (*ptr_g_key_file_set_uint64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value);
    gdouble (*ptr_g_key_file_get_double)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    void (*ptr_g_key_file_set_double)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value);
    gchar** (*ptr_g_key_file_get_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error);
    void (*ptr_g_key_file_set_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar * const list[], gsize length);
    gchar** (*ptr_g_key_file_get_locale_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error);
    void (*ptr_g_key_file_set_locale_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar * const list[], gsize length);
    gboolean* (*ptr_g_key_file_get_boolean_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error);
    void (*ptr_g_key_file_set_boolean_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length);
    gint* (*ptr_g_key_file_get_integer_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error);
    void (*ptr_g_key_file_set_double_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length);
    gdouble* (*ptr_g_key_file_get_double_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error);
    void (*ptr_g_key_file_set_integer_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length);
    gboolean (*ptr_g_key_file_set_comment)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error);
    gchar* (*ptr_g_key_file_get_comment)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    gboolean (*ptr_g_key_file_remove_comment)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    gboolean (*ptr_g_key_file_remove_key)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
    gboolean (*ptr_g_key_file_remove_group)(GKeyFile *key_file, const gchar *group_name, GError **error);
    GQuark (*ptr_g_key_file_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/glist.h
    void (*ptr_g_list_free)(GList *list);
    void (*ptr_g_list_free_1)(GList *list);
    void (*ptr_g_list_free_full)(GList *list, GDestroyNotify free_func);
    GList* (*ptr_g_list_append)(GList *list, gpointer data);
    GList* (*ptr_g_list_prepend)(GList *list, gpointer data);
    GList* (*ptr_g_list_insert)(GList *list, gpointer data, gint position);
    GList* (*ptr_g_list_insert_sorted)(GList *list, gpointer data, GCompareFunc func);
    GList* (*ptr_g_list_insert_sorted_with_data)(GList *list, gpointer data, GCompareDataFunc func, gpointer user_data);
    GList* (*ptr_g_list_insert_before)(GList *list, GList *sibling, gpointer data);
    GList* (*ptr_g_list_insert_before_link)(GList *list, GList *sibling, GList *link_);
    GList* (*ptr_g_list_concat)(GList *list1, GList *list2);
    GList* (*ptr_g_list_remove)(GList *list, gconstpointer data);
    GList* (*ptr_g_list_remove_all)(GList *list, gconstpointer data);
    GList* (*ptr_g_list_remove_link)(GList *list, GList *llink);
    GList* (*ptr_g_list_delete_link)(GList *list, GList *link_);
    GList* (*ptr_g_list_reverse)(GList *list);
    GList* (*ptr_g_list_copy)(GList *list);
    GList* (*ptr_g_list_copy_deep)(GList *list, GCopyFunc func, gpointer user_data);
    GList* (*ptr_g_list_nth)(GList *list, guint n);
    GList* (*ptr_g_list_nth_prev)(GList *list, guint n);
    GList* (*ptr_g_list_find)(GList *list, gconstpointer data);
    GList* (*ptr_g_list_find_custom)(GList *list, gconstpointer data, GCompareFunc func);
    gint (*ptr_g_list_position)(GList *list, GList *llink);
    gint (*ptr_g_list_index)(GList *list, gconstpointer data);
    GList* (*ptr_g_list_last)(GList *list);
    GList* (*ptr_g_list_first)(GList *list);
    guint (*ptr_g_list_length)(GList *list);
    void (*ptr_g_list_foreach)(GList *list, GFunc func, gpointer user_data);
    GList* (*ptr_g_list_sort)(GList *list, GCompareFunc compare_func);
    GList* (*ptr_g_list_sort_with_data)(GList *list, GCompareDataFunc compare_func, gpointer user_data);
    gpointer (*ptr_g_list_nth_data)(GList *list, guint n);
    void (*ptr_g_clear_list)(GList **list_ptr, GDestroyNotify destroy);
    GList* (*ptr_g_list_alloc)(void);
    // Header /usr/include/glib-2.0/glib/gmacros.h
    // Header /usr/include/glib-2.0/glib/gmain.h
    void (*ptr_g_main_context_unref)(GMainContext *context);
    GMainContext* (*ptr_g_main_context_default)(void);
    gboolean (*ptr_g_main_context_iteration)(GMainContext *context, gboolean may_block);
    gboolean (*ptr_g_main_context_pending)(GMainContext *context);
    GSource* (*ptr_g_main_context_find_source_by_id)(GMainContext *context, guint source_id);
    GSource* (*ptr_g_main_context_find_source_by_user_data)(GMainContext *context, gpointer user_data);
    GSource* (*ptr_g_main_context_find_source_by_funcs_user_data)(GMainContext *context, GSourceFuncs *funcs, gpointer user_data);
    void (*ptr_g_main_context_wakeup)(GMainContext *context);
    gboolean (*ptr_g_main_context_acquire)(GMainContext *context);
    void (*ptr_g_main_context_release)(GMainContext *context);
    gboolean (*ptr_g_main_context_is_owner)(GMainContext *context);
    gboolean (*ptr_g_main_context_wait)(GMainContext *context, GCond *cond, GMutex *mutex);
    gboolean (*ptr_g_main_context_prepare)(GMainContext *context, gint *priority);
    gint (*ptr_g_main_context_query)(GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds);
    gboolean (*ptr_g_main_context_check)(GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds);
    void (*ptr_g_main_context_dispatch)(GMainContext *context);
    void (*ptr_g_main_context_set_poll_func)(GMainContext *context, GPollFunc func);
    GPollFunc (*ptr_g_main_context_get_poll_func)(GMainContext *context);
    void (*ptr_g_main_context_add_poll)(GMainContext *context, GPollFD *fd, gint priority);
    void (*ptr_g_main_context_remove_poll)(GMainContext *context, GPollFD *fd);
    gint (*ptr_g_main_depth)(void);
    GSource* (*ptr_g_main_current_source)(void);
    void (*ptr_g_main_context_push_thread_default)(GMainContext *context);
    void (*ptr_g_main_context_pop_thread_default)(GMainContext *context);
    GMainContext* (*ptr_g_main_context_get_thread_default)(void);
    GMainContext* (*ptr_g_main_context_ref_thread_default)(void);
    void (*ptr_g_main_loop_run)(GMainLoop *loop);
    void (*ptr_g_main_loop_quit)(GMainLoop *loop);
    GMainLoop* (*ptr_g_main_loop_ref)(GMainLoop *loop);
    void (*ptr_g_main_loop_unref)(GMainLoop *loop);
    gboolean (*ptr_g_main_loop_is_running)(GMainLoop *loop);
    GMainContext* (*ptr_g_main_loop_get_context)(GMainLoop *loop);
    GSource* (*ptr_g_source_new)(GSourceFuncs *source_funcs, guint struct_size);
    void (*ptr_g_source_unref)(GSource *source);
    guint (*ptr_g_source_attach)(GSource *source, GMainContext *context);
    void (*ptr_g_source_destroy)(GSource *source);
    void (*ptr_g_source_set_priority)(GSource *source, gint priority);
    gint (*ptr_g_source_get_priority)(GSource *source);
    void (*ptr_g_source_set_can_recurse)(GSource *source, gboolean can_recurse);
    gboolean (*ptr_g_source_get_can_recurse)(GSource *source);
    guint (*ptr_g_source_get_id)(GSource *source);
    GMainContext* (*ptr_g_source_get_context)(GSource *source);
    void (*ptr_g_source_set_callback)(GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify);
    void (*ptr_g_source_set_funcs)(GSource *source, GSourceFuncs *funcs);
    gboolean (*ptr_g_source_is_destroyed)(GSource *source);
    void (*ptr_g_source_set_name)(GSource *source, const char *name);
    void (*ptr_g_source_set_static_name)(GSource *source, const char *name);
    const char * (*ptr_g_source_get_name)(GSource *source);
    void (*ptr_g_source_set_name_by_id)(guint tag, const char *name);
    void (*ptr_g_source_set_ready_time)(GSource *source, gint64 ready_time);
    gint64 (*ptr_g_source_get_ready_time)(GSource *source);
    gpointer (*ptr_g_source_add_unix_fd)(GSource *source, gint fd, GIOCondition events);
    void (*ptr_g_source_modify_unix_fd)(GSource *source, gpointer tag, GIOCondition new_events);
    void (*ptr_g_source_remove_unix_fd)(GSource *source, gpointer tag);
    GIOCondition (*ptr_g_source_query_unix_fd)(GSource *source, gpointer tag);
    void (*ptr_g_source_set_callback_indirect)(GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs);
    void (*ptr_g_source_add_poll)(GSource *source, GPollFD *fd);
    void (*ptr_g_source_remove_poll)(GSource *source, GPollFD *fd);
    void (*ptr_g_source_add_child_source)(GSource *source, GSource *child_source);
    void (*ptr_g_source_remove_child_source)(GSource *source, GSource *child_source);
    GSource* (*ptr_g_idle_source_new)(void);
    GSource* (*ptr_g_child_watch_source_new)(GPid pid);
    GSource* (*ptr_g_timeout_source_new)(guint interval);
    GSource* (*ptr_g_timeout_source_new_seconds)(guint interval);
    gint64 (*ptr_g_get_real_time)(void);
    gboolean (*ptr_g_source_remove)(guint tag);
    gboolean (*ptr_g_source_remove_by_user_data)(gpointer user_data);
    gboolean (*ptr_g_source_remove_by_funcs_user_data)(GSourceFuncs *funcs, gpointer user_data);
    void (*ptr_g_clear_handle_id)(guint *tag_ptr, GClearHandleFunc clear_func);
    guint (*ptr_g_timeout_add_full)(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
    guint (*ptr_g_timeout_add)(guint interval, GSourceFunc function, gpointer data);
    guint (*ptr_g_timeout_add_once)(guint interval, GSourceOnceFunc function, gpointer data);
    guint (*ptr_g_timeout_add_seconds_full)(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
    guint (*ptr_g_timeout_add_seconds)(guint interval, GSourceFunc function, gpointer data);
    guint (*ptr_g_timeout_add_seconds_once)(guint interval, GSourceOnceFunc function, gpointer data);
    guint (*ptr_g_child_watch_add_full)(gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify);
    guint (*ptr_g_child_watch_add)(GPid pid, GChildWatchFunc function, gpointer data);
    guint (*ptr_g_idle_add)(GSourceFunc function, gpointer data);
    guint (*ptr_g_idle_add_full)(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
    guint (*ptr_g_idle_add_once)(GSourceOnceFunc function, gpointer data);
    gboolean (*ptr_g_idle_remove_by_data)(gpointer data);
    void (*ptr_g_main_context_invoke_full)(GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
    void (*ptr_g_main_context_invoke)(GMainContext *context, GSourceFunc function, gpointer data);
    GMainContext* (*ptr_g_main_context_new)(void);
    // Header /usr/include/glib-2.0/glib/gmappedfile.h
    GMappedFile* (*ptr_g_mapped_file_new_from_fd)(gint fd, gboolean writable, GError **error);
    gsize (*ptr_g_mapped_file_get_length)(GMappedFile *file);
    gchar* (*ptr_g_mapped_file_get_contents)(GMappedFile *file);
    GBytes * (*ptr_g_mapped_file_get_bytes)(GMappedFile *file);
    GMappedFile* (*ptr_g_mapped_file_ref)(GMappedFile *file);
    void (*ptr_g_mapped_file_unref)(GMappedFile *file);
    void (*ptr_g_mapped_file_free)(GMappedFile *file);
    GMappedFile* (*ptr_g_mapped_file_new)(const gchar *filename, gboolean writable, GError **error);
    // Header /usr/include/glib-2.0/glib/gmarkup.h
    GMarkupParseContext* (*ptr_g_markup_parse_context_new)(const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify);
    GMarkupParseContext* (*ptr_g_markup_parse_context_ref)(GMarkupParseContext *context);
    void (*ptr_g_markup_parse_context_unref)(GMarkupParseContext *context);
    void (*ptr_g_markup_parse_context_free)(GMarkupParseContext *context);
    gboolean (*ptr_g_markup_parse_context_parse)(GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error);
    void (*ptr_g_markup_parse_context_push)(GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data);
    gpointer (*ptr_g_markup_parse_context_pop)(GMarkupParseContext *context);
    gboolean (*ptr_g_markup_parse_context_end_parse)(GMarkupParseContext *context, GError **error);
    const gchar * (*ptr_g_markup_parse_context_get_element)(GMarkupParseContext *context);
    const GSList * (*ptr_g_markup_parse_context_get_element_stack)(GMarkupParseContext *context);
    void (*ptr_g_markup_parse_context_get_position)(GMarkupParseContext *context, gint *line_number, gint *char_number);
    gpointer (*ptr_g_markup_parse_context_get_user_data)(GMarkupParseContext *context);
    gchar* (*ptr_g_markup_escape_text)(const gchar *text, gssize length);
    gchar* (*ptr_g_markup_vprintf_escaped)(const char *format, va_list args);
    GQuark (*ptr_g_markup_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gmem.h
    void (*ptr_g_free_sized)(gpointer mem, size_t size);
    void (*ptr_g_clear_pointer)(gpointer *pp, GDestroyNotify destroy);
    gpointer (*ptr_g_malloc)(gsize n_bytes);
    gpointer (*ptr_g_malloc0)(gsize n_bytes);
    gpointer (*ptr_g_realloc)(gpointer mem, gsize n_bytes);
    gpointer (*ptr_g_try_malloc)(gsize n_bytes);
    gpointer (*ptr_g_try_malloc0)(gsize n_bytes);
    gpointer (*ptr_g_try_realloc)(gpointer mem, gsize n_bytes);
    gpointer (*ptr_g_malloc_n)(gsize n_blocks, gsize n_block_bytes);
    gpointer (*ptr_g_malloc0_n)(gsize n_blocks, gsize n_block_bytes);
    gpointer (*ptr_g_realloc_n)(gpointer mem, gsize n_blocks, gsize n_block_bytes);
    gpointer (*ptr_g_try_malloc_n)(gsize n_blocks, gsize n_block_bytes);
    gpointer (*ptr_g_try_malloc0_n)(gsize n_blocks, gsize n_block_bytes);
    gpointer (*ptr_g_try_realloc_n)(gpointer mem, gsize n_blocks, gsize n_block_bytes);
    gpointer (*ptr_g_aligned_alloc)(gsize n_blocks, gsize n_block_bytes, gsize alignment);
    gpointer (*ptr_g_aligned_alloc0)(gsize n_blocks, gsize n_block_bytes, gsize alignment);
    void (*ptr_g_aligned_free)(gpointer mem);
    void (*ptr_g_aligned_free_sized)(gpointer mem, size_t alignment, size_t size);
    void (*ptr_g_mem_set_vtable)(GMemVTable *vtable);
    gboolean (*ptr_g_mem_is_system_malloc)(void);
    void (*ptr_g_mem_profile)(void);
    void (*ptr_g_free)(gpointer mem);
    // Header /usr/include/glib-2.0/glib/gmessages.h
    guint (*ptr_g_log_set_handler)(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data);
    guint (*ptr_g_log_set_handler_full)(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy);
    void (*ptr_g_log_default_handler)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data);
    GLogFunc (*ptr_g_log_set_default_handler)(GLogFunc log_func, gpointer user_data);
    void (*ptr_g_logv)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args);
    GLogLevelFlags (*ptr_g_log_set_fatal_mask)(const gchar *log_domain, GLogLevelFlags fatal_mask);
    GLogLevelFlags (*ptr_g_log_set_always_fatal)(GLogLevelFlags fatal_mask);
    void (*ptr_g_log_structured_array)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields);
    void (*ptr_g_log_variant)(const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields);
    void (*ptr_g_log_set_writer_func)(GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free);
    gboolean (*ptr_g_log_writer_supports_color)(gint output_fd);
    gboolean (*ptr_g_log_writer_is_journald)(gint output_fd);
    gchar* (*ptr_g_log_writer_format_fields)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color);
    GLogWriterOutput (*ptr_g_log_writer_syslog)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
    GLogWriterOutput (*ptr_g_log_writer_journald)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
    GLogWriterOutput (*ptr_g_log_writer_standard_streams)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
    GLogWriterOutput (*ptr_g_log_writer_default)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
    void (*ptr_g_log_writer_default_set_use_stderr)(gboolean use_stderr);
    gboolean (*ptr_g_log_writer_default_would_drop)(GLogLevelFlags log_level, const char *log_domain);
    void (*ptr_g_log_writer_default_set_debug_domains)(const gchar * const *domains);
    gboolean (*ptr_g_log_get_debug_enabled)(void);
    void (*ptr_g_log_set_debug_enabled)(gboolean enabled);
    void (*ptr__g_log_fallback_handler)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data);
    void (*ptr_g_return_if_fail_warning)(const char *log_domain, const char *pretty_function, const char *expression);
    void (*ptr_g_warn_message)(const char *domain, const char *file, int line, const char *func, const char *warnexpr);
    void (*ptr_g_assert_warning)(const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression);
    GPrintFunc (*ptr_g_set_print_handler)(GPrintFunc func);
    GPrintFunc (*ptr_g_set_printerr_handler)(GPrintFunc func);
    gsize (*ptr_g_printf_string_upper_bound)(const gchar* format, va_list args);
    // Header /usr/include/glib-2.0/glib/gnode.h
    void (*ptr_g_node_destroy)(GNode *root);
    void (*ptr_g_node_unlink)(GNode *node);
    GNode* (*ptr_g_node_copy_deep)(GNode *node, GCopyFunc copy_func, gpointer data);
    GNode* (*ptr_g_node_copy)(GNode *node);
    GNode* (*ptr_g_node_insert)(GNode *parent, gint position, GNode *node);
    GNode* (*ptr_g_node_insert_before)(GNode *parent, GNode *sibling, GNode *node);
    GNode* (*ptr_g_node_insert_after)(GNode *parent, GNode *sibling, GNode *node);
    GNode* (*ptr_g_node_prepend)(GNode *parent, GNode *node);
    guint (*ptr_g_node_n_nodes)(GNode *root, GTraverseFlags flags);
    GNode* (*ptr_g_node_get_root)(GNode *node);
    gboolean (*ptr_g_node_is_ancestor)(GNode *node, GNode *descendant);
    guint (*ptr_g_node_depth)(GNode *node);
    GNode* (*ptr_g_node_find)(GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data);
    void (*ptr_g_node_traverse)(GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
    guint (*ptr_g_node_max_height)(GNode *root);
    void (*ptr_g_node_children_foreach)(GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);
    void (*ptr_g_node_reverse_children)(GNode *node);
    guint (*ptr_g_node_n_children)(GNode *node);
    GNode* (*ptr_g_node_nth_child)(GNode *node, guint n);
    GNode* (*ptr_g_node_last_child)(GNode *node);
    GNode* (*ptr_g_node_find_child)(GNode *node, GTraverseFlags flags, gpointer data);
    gint (*ptr_g_node_child_position)(GNode *node, GNode *child);
    gint (*ptr_g_node_child_index)(GNode *node, gpointer data);
    GNode* (*ptr_g_node_first_sibling)(GNode *node);
    GNode* (*ptr_g_node_last_sibling)(GNode *node);
    GNode* (*ptr_g_node_new)(gpointer data);
    // Header /usr/include/glib-2.0/glib/goption.h
    GOptionContext* (*ptr_g_option_context_new)(const gchar *parameter_string);
    void (*ptr_g_option_context_set_summary)(GOptionContext *context, const gchar *summary);
    const gchar * (*ptr_g_option_context_get_summary)(GOptionContext *context);
    void (*ptr_g_option_context_set_description)(GOptionContext *context, const gchar *description);
    const gchar * (*ptr_g_option_context_get_description)(GOptionContext *context);
    void (*ptr_g_option_context_free)(GOptionContext *context);
    void (*ptr_g_option_context_set_help_enabled)(GOptionContext *context, gboolean help_enabled);
    gboolean (*ptr_g_option_context_get_help_enabled)(GOptionContext *context);
    void (*ptr_g_option_context_set_ignore_unknown_options)(GOptionContext *context, gboolean ignore_unknown);
    gboolean (*ptr_g_option_context_get_ignore_unknown_options)(GOptionContext *context);
    void (*ptr_g_option_context_set_strict_posix)(GOptionContext *context, gboolean strict_posix);
    gboolean (*ptr_g_option_context_get_strict_posix)(GOptionContext *context);
    void (*ptr_g_option_context_add_main_entries)(GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain);
    gboolean (*ptr_g_option_context_parse)(GOptionContext *context, gint *argc, gchar ***argv, GError **error);
    gboolean (*ptr_g_option_context_parse_strv)(GOptionContext *context, gchar ***arguments, GError **error);
    void (*ptr_g_option_context_set_translate_func)(GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
    void (*ptr_g_option_context_set_translation_domain)(GOptionContext *context, const gchar *domain);
    void (*ptr_g_option_context_add_group)(GOptionContext *context, GOptionGroup *group);
    void (*ptr_g_option_context_set_main_group)(GOptionContext *context, GOptionGroup *group);
    GOptionGroup* (*ptr_g_option_context_get_main_group)(GOptionContext *context);
    gchar* (*ptr_g_option_context_get_help)(GOptionContext *context, gboolean main_help, GOptionGroup *group);
    GOptionGroup* (*ptr_g_option_group_new)(const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy);
    void (*ptr_g_option_group_set_parse_hooks)(GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
    void (*ptr_g_option_group_set_error_hook)(GOptionGroup *group, GOptionErrorFunc error_func);
    void (*ptr_g_option_group_free)(GOptionGroup *group);
    GOptionGroup* (*ptr_g_option_group_ref)(GOptionGroup *group);
    void (*ptr_g_option_group_unref)(GOptionGroup *group);
    void (*ptr_g_option_group_add_entries)(GOptionGroup *group, const GOptionEntry *entries);
    void (*ptr_g_option_group_set_translate_func)(GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
    void (*ptr_g_option_group_set_translation_domain)(GOptionGroup *group, const gchar *domain);
    GQuark (*ptr_g_option_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gpathbuf.h
    GPathBuf * (*ptr_g_path_buf_new_from_path)(const char *path);
    GPathBuf * (*ptr_g_path_buf_init)(GPathBuf *buf);
    GPathBuf * (*ptr_g_path_buf_init_from_path)(GPathBuf *buf, const char *path);
    void (*ptr_g_path_buf_clear)(GPathBuf *buf);
    char * (*ptr_g_path_buf_clear_to_path)(GPathBuf *buf);
    void (*ptr_g_path_buf_free)(GPathBuf *buf);
    char * (*ptr_g_path_buf_free_to_path)(GPathBuf *buf);
    GPathBuf * (*ptr_g_path_buf_copy)(GPathBuf *buf);
    GPathBuf * (*ptr_g_path_buf_push)(GPathBuf *buf, const char *path);
    gboolean (*ptr_g_path_buf_pop)(GPathBuf *buf);
    gboolean (*ptr_g_path_buf_set_filename)(GPathBuf *buf, const char *file_name);
    gboolean (*ptr_g_path_buf_set_extension)(GPathBuf *buf, const char *extension);
    char * (*ptr_g_path_buf_to_path)(GPathBuf *buf);
    gboolean (*ptr_g_path_buf_equal)(gconstpointer v1, gconstpointer v2);
    GPathBuf * (*ptr_g_path_buf_new)(void);
    // Header /usr/include/glib-2.0/glib/gpattern.h
    void (*ptr_g_pattern_spec_free)(GPatternSpec *pspec);
    GPatternSpec* (*ptr_g_pattern_spec_copy)(GPatternSpec *pspec);
    gboolean (*ptr_g_pattern_spec_equal)(GPatternSpec *pspec1, GPatternSpec *pspec2);
    gboolean (*ptr_g_pattern_spec_match)(GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed);
    gboolean (*ptr_g_pattern_spec_match_string)(GPatternSpec *pspec, const gchar *string);
    gboolean (*ptr_g_pattern_match)(GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed);
    gboolean (*ptr_g_pattern_match_string)(GPatternSpec *pspec, const gchar *string);
    gboolean (*ptr_g_pattern_match_simple)(const gchar *pattern, const gchar *string);
    GPatternSpec* (*ptr_g_pattern_spec_new)(const gchar *pattern);
    // Header /usr/include/glib-2.0/glib/gpoll.h
    gint (*ptr_g_poll)(GPollFD *fds, guint nfds, gint timeout);
    // Header /usr/include/glib-2.0/glib/gprimes.h
    guint (*ptr_g_spaced_primes_closest)(guint num);
    // Header /usr/include/glib-2.0/glib/gprintf.h
    gint (*ptr_g_vprintf)(gchar const *format, va_list args);
    gint (*ptr_g_vfprintf)(FILE *file, gchar const *format, va_list args);
    gint (*ptr_g_vsprintf)(gchar *string, gchar const *format, va_list args);
    gint (*ptr_g_vasprintf)(gchar **string, gchar const *format, va_list args);
    // Header /usr/include/glib-2.0/glib/gqsort.h
    void (*ptr_g_qsort_with_data)(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data);
    // Header /usr/include/glib-2.0/glib/gquark.h
    GQuark (*ptr_g_quark_from_static_string)(const gchar *string);
    GQuark (*ptr_g_quark_from_string)(const gchar *string);
    const gchar * (*ptr_g_quark_to_string)(GQuark quark);
    const gchar * (*ptr_g_intern_string)(const gchar *string);
    const gchar * (*ptr_g_intern_static_string)(const gchar *string);
    GQuark (*ptr_g_quark_try_string)(const gchar *string);
    // Header /usr/include/glib-2.0/glib/gqueue.h
    void (*ptr_g_queue_free)(GQueue *queue);
    void (*ptr_g_queue_free_full)(GQueue *queue, GDestroyNotify free_func);
    void (*ptr_g_queue_init)(GQueue *queue);
    void (*ptr_g_queue_clear)(GQueue *queue);
    gboolean (*ptr_g_queue_is_empty)(GQueue *queue);
    void (*ptr_g_queue_clear_full)(GQueue *queue, GDestroyNotify free_func);
    guint (*ptr_g_queue_get_length)(GQueue *queue);
    void (*ptr_g_queue_reverse)(GQueue *queue);
    GQueue * (*ptr_g_queue_copy)(GQueue *queue);
    void (*ptr_g_queue_foreach)(GQueue *queue, GFunc func, gpointer user_data);
    GList * (*ptr_g_queue_find)(GQueue *queue, gconstpointer data);
    GList * (*ptr_g_queue_find_custom)(GQueue *queue, gconstpointer data, GCompareFunc func);
    void (*ptr_g_queue_sort)(GQueue *queue, GCompareDataFunc compare_func, gpointer user_data);
    void (*ptr_g_queue_push_head)(GQueue *queue, gpointer data);
    void (*ptr_g_queue_push_tail)(GQueue *queue, gpointer data);
    void (*ptr_g_queue_push_nth)(GQueue *queue, gpointer data, gint n);
    gpointer (*ptr_g_queue_pop_head)(GQueue *queue);
    gpointer (*ptr_g_queue_pop_tail)(GQueue *queue);
    gpointer (*ptr_g_queue_pop_nth)(GQueue *queue, guint n);
    gpointer (*ptr_g_queue_peek_head)(GQueue *queue);
    gpointer (*ptr_g_queue_peek_tail)(GQueue *queue);
    gpointer (*ptr_g_queue_peek_nth)(GQueue *queue, guint n);
    gint (*ptr_g_queue_index)(GQueue *queue, gconstpointer data);
    gboolean (*ptr_g_queue_remove)(GQueue *queue, gconstpointer data);
    guint (*ptr_g_queue_remove_all)(GQueue *queue, gconstpointer data);
    void (*ptr_g_queue_insert_before)(GQueue *queue, GList *sibling, gpointer data);
    void (*ptr_g_queue_insert_before_link)(GQueue *queue, GList *sibling, GList *link_);
    void (*ptr_g_queue_insert_after)(GQueue *queue, GList *sibling, gpointer data);
    void (*ptr_g_queue_insert_after_link)(GQueue *queue, GList *sibling, GList *link_);
    void (*ptr_g_queue_insert_sorted)(GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
    void (*ptr_g_queue_push_head_link)(GQueue *queue, GList *link_);
    void (*ptr_g_queue_push_tail_link)(GQueue *queue, GList *link_);
    void (*ptr_g_queue_push_nth_link)(GQueue *queue, gint n, GList *link_);
    GList* (*ptr_g_queue_pop_head_link)(GQueue *queue);
    GList* (*ptr_g_queue_pop_tail_link)(GQueue *queue);
    GList* (*ptr_g_queue_pop_nth_link)(GQueue *queue, guint n);
    GList* (*ptr_g_queue_peek_head_link)(GQueue *queue);
    GList* (*ptr_g_queue_peek_tail_link)(GQueue *queue);
    GList* (*ptr_g_queue_peek_nth_link)(GQueue *queue, guint n);
    gint (*ptr_g_queue_link_index)(GQueue *queue, GList *link_);
    void (*ptr_g_queue_unlink)(GQueue *queue, GList *link_);
    void (*ptr_g_queue_delete_link)(GQueue *queue, GList *link_);
    GQueue* (*ptr_g_queue_new)(void);
    // Header /usr/include/glib-2.0/glib/grand.h
    GRand* (*ptr_g_rand_new_with_seed_array)(const guint32 *seed, guint seed_length);
    GRand* (*ptr_g_rand_new)(void);
    void (*ptr_g_rand_free)(GRand *rand_);
    GRand* (*ptr_g_rand_copy)(GRand *rand_);
    void (*ptr_g_rand_set_seed)(GRand *rand_, guint32 seed);
    void (*ptr_g_rand_set_seed_array)(GRand *rand_, const guint32 *seed, guint seed_length);
    guint32 (*ptr_g_rand_int)(GRand *rand_);
    gint32 (*ptr_g_rand_int_range)(GRand *rand_, gint32 begin, gint32 end);
    gdouble (*ptr_g_rand_double)(GRand *rand_);
    gdouble (*ptr_g_rand_double_range)(GRand *rand_, gdouble begin, gdouble end);
    void (*ptr_g_random_set_seed)(guint32 seed);
    guint32 (*ptr_g_random_int)(void);
    gint32 (*ptr_g_random_int_range)(gint32 begin, gint32 end);
    gdouble (*ptr_g_random_double)(void);
    gdouble (*ptr_g_random_double_range)(gdouble begin, gdouble end);
    GRand* (*ptr_g_rand_new_with_seed)(guint32 seed);
    // Header /usr/include/glib-2.0/glib/grcbox.h
    gpointer (*ptr_g_rc_box_alloc0)(gsize block_size);
    gpointer (*ptr_g_rc_box_dup)(gsize block_size, gconstpointer mem_block);
    gpointer (*ptr_g_rc_box_acquire)(gpointer mem_block);
    void (*ptr_g_rc_box_release)(gpointer mem_block);
    void (*ptr_g_rc_box_release_full)(gpointer mem_block, GDestroyNotify clear_func);
    gsize (*ptr_g_rc_box_get_size)(gpointer mem_block);
    gpointer (*ptr_g_atomic_rc_box_alloc)(gsize block_size);
    gpointer (*ptr_g_atomic_rc_box_alloc0)(gsize block_size);
    gpointer (*ptr_g_atomic_rc_box_dup)(gsize block_size, gconstpointer mem_block);
    gpointer (*ptr_g_atomic_rc_box_acquire)(gpointer mem_block);
    void (*ptr_g_atomic_rc_box_release)(gpointer mem_block);
    void (*ptr_g_atomic_rc_box_release_full)(gpointer mem_block, GDestroyNotify clear_func);
    gsize (*ptr_g_atomic_rc_box_get_size)(gpointer mem_block);
    gpointer (*ptr_g_rc_box_alloc)(gsize block_size);
    // Header /usr/include/glib-2.0/glib/grefcount.h
    void (*ptr_g_ref_count_inc)(grefcount *rc);
    gboolean (*ptr_g_ref_count_dec)(grefcount *rc);
    gboolean (*ptr_g_ref_count_compare)(grefcount *rc, gint val);
    void (*ptr_g_atomic_ref_count_init)(gatomicrefcount *arc);
    void (*ptr_g_atomic_ref_count_inc)(gatomicrefcount *arc);
    gboolean (*ptr_g_atomic_ref_count_dec)(gatomicrefcount *arc);
    gboolean (*ptr_g_atomic_ref_count_compare)(gatomicrefcount *arc, gint val);
    void (*ptr_g_ref_count_init)(grefcount *rc);
    // Header /usr/include/glib-2.0/glib/grefstring.h
    char * (*ptr_g_ref_string_new_len)(const char *str, gssize len);
    char * (*ptr_g_ref_string_new_intern)(const char *str);
    char * (*ptr_g_ref_string_acquire)(char *str);
    void (*ptr_g_ref_string_release)(char *str);
    gsize (*ptr_g_ref_string_length)(char *str);
    char * (*ptr_g_ref_string_new)(const char *str);
    // Header /usr/include/glib-2.0/glib/gregex.h
    GRegex* (*ptr_g_regex_new)(const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error);
    GRegex* (*ptr_g_regex_ref)(GRegex *regex);
    void (*ptr_g_regex_unref)(GRegex *regex);
    const gchar* (*ptr_g_regex_get_pattern)(const GRegex *regex);
    gint (*ptr_g_regex_get_max_backref)(const GRegex *regex);
    gint (*ptr_g_regex_get_capture_count)(const GRegex *regex);
    gboolean (*ptr_g_regex_get_has_cr_or_lf)(const GRegex *regex);
    gint (*ptr_g_regex_get_max_lookbehind)(const GRegex *regex);
    gint (*ptr_g_regex_get_string_number)(const GRegex *regex, const gchar *name);
    gchar* (*ptr_g_regex_escape_string)(const gchar *string, gint length);
    gchar* (*ptr_g_regex_escape_nul)(const gchar *string, gint length);
    GRegexCompileFlags (*ptr_g_regex_get_compile_flags)(const GRegex *regex);
    GRegexMatchFlags (*ptr_g_regex_get_match_flags)(const GRegex *regex);
    gboolean (*ptr_g_regex_match_simple)(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
    gboolean (*ptr_g_regex_match)(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
    gboolean (*ptr_g_regex_match_full)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
    gboolean (*ptr_g_regex_match_all)(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
    gboolean (*ptr_g_regex_match_all_full)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
    gchar** (*ptr_g_regex_split_simple)(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
    gchar** (*ptr_g_regex_split)(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options);
    gchar** (*ptr_g_regex_split_full)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error);
    gchar* (*ptr_g_regex_replace)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
    gchar* (*ptr_g_regex_replace_literal)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
    gchar* (*ptr_g_regex_replace_eval)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error);
    gboolean (*ptr_g_regex_check_replacement)(const gchar *replacement, gboolean *has_references, GError **error);
    GRegex* (*ptr_g_match_info_get_regex)(const GMatchInfo *match_info);
    const gchar* (*ptr_g_match_info_get_string)(const GMatchInfo *match_info);
    GMatchInfo* (*ptr_g_match_info_ref)(GMatchInfo *match_info);
    void (*ptr_g_match_info_unref)(GMatchInfo *match_info);
    void (*ptr_g_match_info_free)(GMatchInfo *match_info);
    gboolean (*ptr_g_match_info_next)(GMatchInfo *match_info, GError **error);
    gboolean (*ptr_g_match_info_matches)(const GMatchInfo *match_info);
    gint (*ptr_g_match_info_get_match_count)(const GMatchInfo *match_info);
    gboolean (*ptr_g_match_info_is_partial_match)(const GMatchInfo *match_info);
    gchar* (*ptr_g_match_info_expand_references)(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error);
    gchar* (*ptr_g_match_info_fetch)(const GMatchInfo *match_info, gint match_num);
    gboolean (*ptr_g_match_info_fetch_pos)(const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos);
    gchar* (*ptr_g_match_info_fetch_named)(const GMatchInfo *match_info, const gchar *name);
    gboolean (*ptr_g_match_info_fetch_named_pos)(const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos);
    gchar** (*ptr_g_match_info_fetch_all)(const GMatchInfo *match_info);
    GQuark (*ptr_g_regex_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gscanner.h
    void (*ptr_g_scanner_destroy)(GScanner *scanner);
    void (*ptr_g_scanner_input_file)(GScanner *scanner, gint input_fd);
    void (*ptr_g_scanner_sync_file_offset)(GScanner *scanner);
    void (*ptr_g_scanner_input_text)(GScanner *scanner, const gchar *text, guint text_len);
    GTokenType (*ptr_g_scanner_get_next_token)(GScanner *scanner);
    GTokenType (*ptr_g_scanner_peek_next_token)(GScanner *scanner);
    GTokenType (*ptr_g_scanner_cur_token)(GScanner *scanner);
    GTokenValue (*ptr_g_scanner_cur_value)(GScanner *scanner);
    guint (*ptr_g_scanner_cur_line)(GScanner *scanner);
    guint (*ptr_g_scanner_cur_position)(GScanner *scanner);
    gboolean (*ptr_g_scanner_eof)(GScanner *scanner);
    guint (*ptr_g_scanner_set_scope)(GScanner *scanner, guint scope_id);
    void (*ptr_g_scanner_scope_add_symbol)(GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value);
    void (*ptr_g_scanner_scope_remove_symbol)(GScanner *scanner, guint scope_id, const gchar *symbol);
    gpointer (*ptr_g_scanner_scope_lookup_symbol)(GScanner *scanner, guint scope_id, const gchar *symbol);
    void (*ptr_g_scanner_scope_foreach_symbol)(GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data);
    gpointer (*ptr_g_scanner_lookup_symbol)(GScanner *scanner, const gchar *symbol);
    void (*ptr_g_scanner_unexp_token)(GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error);
    GScanner* (*ptr_g_scanner_new)(const GScannerConfig *config_templ);
    // Header /usr/include/glib-2.0/glib/gsequence.h
    void (*ptr_g_sequence_free)(GSequence *seq);
    gint (*ptr_g_sequence_get_length)(GSequence *seq);
    void (*ptr_g_sequence_foreach)(GSequence *seq, GFunc func, gpointer user_data);
    void (*ptr_g_sequence_foreach_range)(GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data);
    void (*ptr_g_sequence_sort)(GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data);
    void (*ptr_g_sequence_sort_iter)(GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data);
    gboolean (*ptr_g_sequence_is_empty)(GSequence *seq);
    GSequenceIter* (*ptr_g_sequence_get_begin_iter)(GSequence *seq);
    GSequenceIter* (*ptr_g_sequence_get_end_iter)(GSequence *seq);
    GSequenceIter* (*ptr_g_sequence_get_iter_at_pos)(GSequence *seq, gint pos);
    GSequenceIter* (*ptr_g_sequence_append)(GSequence *seq, gpointer data);
    GSequenceIter* (*ptr_g_sequence_prepend)(GSequence *seq, gpointer data);
    GSequenceIter* (*ptr_g_sequence_insert_before)(GSequenceIter *iter, gpointer data);
    void (*ptr_g_sequence_move)(GSequenceIter *src, GSequenceIter *dest);
    void (*ptr_g_sequence_swap)(GSequenceIter *a, GSequenceIter *b);
    GSequenceIter* (*ptr_g_sequence_insert_sorted)(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
    GSequenceIter* (*ptr_g_sequence_insert_sorted_iter)(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
    void (*ptr_g_sequence_sort_changed)(GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data);
    void (*ptr_g_sequence_sort_changed_iter)(GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
    void (*ptr_g_sequence_remove)(GSequenceIter *iter);
    void (*ptr_g_sequence_remove_range)(GSequenceIter *begin, GSequenceIter *end);
    void (*ptr_g_sequence_move_range)(GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end);
    GSequenceIter* (*ptr_g_sequence_search)(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
    GSequenceIter* (*ptr_g_sequence_search_iter)(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
    GSequenceIter* (*ptr_g_sequence_lookup)(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
    GSequenceIter* (*ptr_g_sequence_lookup_iter)(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
    gpointer (*ptr_g_sequence_get)(GSequenceIter *iter);
    void (*ptr_g_sequence_set)(GSequenceIter *iter, gpointer data);
    gboolean (*ptr_g_sequence_iter_is_begin)(GSequenceIter *iter);
    gboolean (*ptr_g_sequence_iter_is_end)(GSequenceIter *iter);
    GSequenceIter* (*ptr_g_sequence_iter_next)(GSequenceIter *iter);
    GSequenceIter* (*ptr_g_sequence_iter_prev)(GSequenceIter *iter);
    gint (*ptr_g_sequence_iter_get_position)(GSequenceIter *iter);
    GSequenceIter* (*ptr_g_sequence_iter_move)(GSequenceIter *iter, gint delta);
    GSequence * (*ptr_g_sequence_iter_get_sequence)(GSequenceIter *iter);
    gint (*ptr_g_sequence_iter_compare)(GSequenceIter *a, GSequenceIter *b);
    GSequenceIter* (*ptr_g_sequence_range_get_midpoint)(GSequenceIter *begin, GSequenceIter *end);
    GSequence * (*ptr_g_sequence_new)(GDestroyNotify data_destroy);
    // Header /usr/include/glib-2.0/glib/gshell.h
    gchar* (*ptr_g_shell_quote)(const gchar *unquoted_string);
    gchar* (*ptr_g_shell_unquote)(const gchar *quoted_string, GError **error);
    gboolean (*ptr_g_shell_parse_argv)(const gchar *command_line, gint *argcp, gchar ***argvp, GError **error);
    GQuark (*ptr_g_shell_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gslice.h
    gpointer (*ptr_g_slice_alloc0)(gsize block_size);
    gpointer (*ptr_g_slice_copy)(gsize block_size, gconstpointer mem_block);
    void (*ptr_g_slice_free1)(gsize block_size, gpointer mem_block);
    void (*ptr_g_slice_free_chain_with_offset)(gsize block_size, gpointer mem_chain, gsize next_offset);
    void (*ptr_g_slice_set_config)(GSliceConfig ckey, gint64 value);
    gint64 (*ptr_g_slice_get_config)(GSliceConfig ckey);
    void (*ptr_g_slice_debug_tree_statistics)(void);
    gpointer (*ptr_g_slice_alloc)(gsize block_size);
    // Header /usr/include/glib-2.0/glib/gslist.h
    void (*ptr_g_slist_free)(GSList *list);
    void (*ptr_g_slist_free_1)(GSList *list);
    void (*ptr_g_slist_free_full)(GSList *list, GDestroyNotify free_func);
    GSList* (*ptr_g_slist_append)(GSList *list, gpointer data);
    GSList* (*ptr_g_slist_prepend)(GSList *list, gpointer data);
    GSList* (*ptr_g_slist_insert)(GSList *list, gpointer data, gint position);
    GSList* (*ptr_g_slist_insert_sorted)(GSList *list, gpointer data, GCompareFunc func);
    GSList* (*ptr_g_slist_insert_sorted_with_data)(GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data);
    GSList* (*ptr_g_slist_insert_before)(GSList *slist, GSList *sibling, gpointer data);
    GSList* (*ptr_g_slist_concat)(GSList *list1, GSList *list2);
    GSList* (*ptr_g_slist_remove)(GSList *list, gconstpointer data);
    GSList* (*ptr_g_slist_remove_all)(GSList *list, gconstpointer data);
    GSList* (*ptr_g_slist_remove_link)(GSList *list, GSList *link_);
    GSList* (*ptr_g_slist_delete_link)(GSList *list, GSList *link_);
    GSList* (*ptr_g_slist_reverse)(GSList *list);
    GSList* (*ptr_g_slist_copy)(GSList *list);
    GSList* (*ptr_g_slist_copy_deep)(GSList *list, GCopyFunc func, gpointer user_data);
    GSList* (*ptr_g_slist_nth)(GSList *list, guint n);
    GSList* (*ptr_g_slist_find)(GSList *list, gconstpointer data);
    GSList* (*ptr_g_slist_find_custom)(GSList *list, gconstpointer data, GCompareFunc func);
    gint (*ptr_g_slist_position)(GSList *list, GSList *llink);
    gint (*ptr_g_slist_index)(GSList *list, gconstpointer data);
    GSList* (*ptr_g_slist_last)(GSList *list);
    guint (*ptr_g_slist_length)(GSList *list);
    void (*ptr_g_slist_foreach)(GSList *list, GFunc func, gpointer user_data);
    GSList* (*ptr_g_slist_sort)(GSList *list, GCompareFunc compare_func);
    GSList* (*ptr_g_slist_sort_with_data)(GSList *list, GCompareDataFunc compare_func, gpointer user_data);
    gpointer (*ptr_g_slist_nth_data)(GSList *list, guint n);
    void (*ptr_g_clear_slist)(GSList **slist_ptr, GDestroyNotify destroy);
    GSList* (*ptr_g_slist_alloc)(void);
    // Header /usr/include/glib-2.0/glib/gspawn.h
    GQuark (*ptr_g_spawn_exit_error_quark)(void);
    gboolean (*ptr_g_spawn_async)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error);
    gboolean (*ptr_g_spawn_async_with_pipes)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error);
    gboolean (*ptr_g_spawn_async_with_pipes_and_fds)(const gchar *working_directory, const gchar * const *argv, const gchar * const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error);
    gboolean (*ptr_g_spawn_async_with_fds)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error);
    gboolean (*ptr_g_spawn_sync)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error);
    gboolean (*ptr_g_spawn_command_line_sync)(const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error);
    gboolean (*ptr_g_spawn_command_line_async)(const gchar *command_line, GError **error);
    gboolean (*ptr_g_spawn_check_wait_status)(gint wait_status, GError **error);
    gboolean (*ptr_g_spawn_check_exit_status)(gint wait_status, GError **error);
    void (*ptr_g_spawn_close_pid)(GPid pid);
    GQuark (*ptr_g_spawn_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gstdio.h
    int (*ptr_g_chdir)(const gchar *path);
    int (*ptr_g_unlink)(const gchar *filename);
    int (*ptr_g_rmdir)(const gchar *filename);
    int (*ptr_g_access)(const gchar *filename, int mode);
    gboolean (*ptr_g_close)(gint fd, GError **error);
    // Header /usr/include/glib-2.0/glib/gstrfuncs.h
    gchar (*ptr_g_ascii_tolower)(gchar c);
    gchar (*ptr_g_ascii_toupper)(gchar c);
    gint (*ptr_g_ascii_digit_value)(gchar c);
    gint (*ptr_g_ascii_xdigit_value)(gchar c);
    gchar* (*ptr_g_strdelimit)(gchar *string, const gchar *delimiters, gchar new_delimiter);
    gchar* (*ptr_g_strcanon)(gchar *string, const gchar *valid_chars, gchar substitutor);
    const gchar * (*ptr_g_strerror)(gint errnum);
    const gchar * (*ptr_g_strsignal)(gint signum);
    gchar * (*ptr_g_strreverse)(gchar *string);
    gsize (*ptr_g_strlcpy)(gchar *dest, const gchar *src, gsize dest_size);
    gsize (*ptr_g_strlcat)(gchar *dest, const gchar *src, gsize dest_size);
    gchar * (*ptr_g_strstr_len)(const gchar *haystack, gssize haystack_len, const gchar *needle);
    gchar * (*ptr_g_strrstr)(const gchar *haystack, const gchar *needle);
    gchar * (*ptr_g_strrstr_len)(const gchar *haystack, gssize haystack_len, const gchar *needle);
    gboolean (*ptr_g_str_has_suffix)(const gchar *str, const gchar *suffix);
    gboolean (*ptr_g_str_has_prefix)(const gchar *str, const gchar *prefix);
    gdouble (*ptr_g_strtod)(const gchar *nptr, gchar **endptr);
    gdouble (*ptr_g_ascii_strtod)(const gchar *nptr, gchar **endptr);
    guint64 (*ptr_g_ascii_strtoull)(const gchar *nptr, gchar **endptr, guint base);
    gint64 (*ptr_g_ascii_strtoll)(const gchar *nptr, gchar **endptr, guint base);
    gchar * (*ptr_g_ascii_dtostr)(gchar *buffer, gint buf_len, gdouble d);
    gchar * (*ptr_g_ascii_formatd)(gchar *buffer, gint buf_len, const gchar *format, gdouble d);
    gchar* (*ptr_g_strchug)(gchar *string);
    gchar* (*ptr_g_strchomp)(gchar *string);
    gint (*ptr_g_ascii_strcasecmp)(const gchar *s1, const gchar *s2);
    gint (*ptr_g_ascii_strncasecmp)(const gchar *s1, const gchar *s2, gsize n);
    gchar* (*ptr_g_ascii_strdown)(const gchar *str, gssize len);
    gchar* (*ptr_g_ascii_strup)(const gchar *str, gssize len);
    gboolean (*ptr_g_str_is_ascii)(const gchar *str);
    gint (*ptr_g_strcasecmp)(const gchar *s1, const gchar *s2);
    gint (*ptr_g_strncasecmp)(const gchar *s1, const gchar *s2, guint n);
    gchar* (*ptr_g_strdown)(gchar *string);
    gchar* (*ptr_g_strup)(gchar *string);
    gchar* (*ptr_g_strdup)(const gchar *str);
    gchar* (*ptr_g_strdup_vprintf)(const gchar *format, va_list args);
    gchar* (*ptr_g_strndup)(const gchar *str, gsize n);
    gchar* (*ptr_g_strnfill)(gsize length, gchar fill_char);
    gchar* (*ptr_g_strcompress)(const gchar *source);
    gchar* (*ptr_g_strescape)(const gchar *source, const gchar *exceptions);
    gpointer (*ptr_g_memdup)(gconstpointer mem, guint byte_size);
    gpointer (*ptr_g_memdup2)(gconstpointer mem, gsize byte_size);
    gchar** (*ptr_g_strsplit)(const gchar *string, const gchar *delimiter, gint max_tokens);
    gchar ** (*ptr_g_strsplit_set)(const gchar *string, const gchar *delimiters, gint max_tokens);
    gchar* (*ptr_g_strjoinv)(const gchar *separator, gchar **str_array);
    void (*ptr_g_strfreev)(gchar **str_array);
    gchar** (*ptr_g_strdupv)(gchar **str_array);
    guint (*ptr_g_strv_length)(gchar **str_array);
    gchar* (*ptr_g_stpcpy)(gchar *dest, const char *src);
    gchar * (*ptr_g_str_to_ascii)(const gchar *str, const gchar *from_locale);
    gchar ** (*ptr_g_str_tokenize_and_fold)(const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates);
    gboolean (*ptr_g_str_match_string)(const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates);
    gboolean (*ptr_g_strv_contains)(const gchar * const *strv, const gchar *str);
    gboolean (*ptr_g_strv_equal)(const gchar * const *strv1, const gchar * const *strv2);
    GQuark (*ptr_g_number_parser_error_quark)(void);
    gboolean (*ptr_g_ascii_string_to_signed)(const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error);
    gboolean (*ptr_g_ascii_string_to_unsigned)(const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error);
    // Header /usr/include/glib-2.0/glib/gstring.h
    GString* (*ptr_g_string_new_take)(gchar *init);
    GString* (*ptr_g_string_new_len)(const gchar *init, gssize len);
    GString* (*ptr_g_string_sized_new)(gsize dfl_size);
    gchar* (*ptr_g_string_free)(GString *string, gboolean free_segment);
    gchar* (*ptr_g_string_free_and_steal)(GString *string);
    GBytes* (*ptr_g_string_free_to_bytes)(GString *string);
    gboolean (*ptr_g_string_equal)(const GString *v, const GString *v2);
    guint (*ptr_g_string_hash)(const GString *str);
    GString* (*ptr_g_string_assign)(GString *string, const gchar *rval);
    GString* (*ptr_g_string_truncate)(GString *string, gsize len);
    GString* (*ptr_g_string_set_size)(GString *string, gsize len);
    GString* (*ptr_g_string_insert_len)(GString *string, gssize pos, const gchar *val, gssize len);
    GString* (*ptr_g_string_append)(GString *string, const gchar *val);
    GString* (*ptr_g_string_append_len)(GString *string, const gchar *val, gssize len);
    GString* (*ptr_g_string_append_c)(GString *string, gchar c);
    GString* (*ptr_g_string_append_unichar)(GString *string, gunichar wc);
    GString* (*ptr_g_string_prepend)(GString *string, const gchar *val);
    GString* (*ptr_g_string_prepend_c)(GString *string, gchar c);
    GString* (*ptr_g_string_prepend_unichar)(GString *string, gunichar wc);
    GString* (*ptr_g_string_prepend_len)(GString *string, const gchar *val, gssize len);
    GString* (*ptr_g_string_insert)(GString *string, gssize pos, const gchar *val);
    GString* (*ptr_g_string_insert_c)(GString *string, gssize pos, gchar c);
    GString* (*ptr_g_string_insert_unichar)(GString *string, gssize pos, gunichar wc);
    GString* (*ptr_g_string_overwrite)(GString *string, gsize pos, const gchar *val);
    GString* (*ptr_g_string_overwrite_len)(GString *string, gsize pos, const gchar *val, gssize len);
    GString* (*ptr_g_string_erase)(GString *string, gssize pos, gssize len);
    guint (*ptr_g_string_replace)(GString *string, const gchar *find, const gchar *replace, guint limit);
    GString* (*ptr_g_string_ascii_down)(GString *string);
    GString* (*ptr_g_string_ascii_up)(GString *string);
    void (*ptr_g_string_vprintf)(GString *string, const gchar *format, va_list args);
    void (*ptr_g_string_append_vprintf)(GString *string, const gchar *format, va_list args);
    GString* (*ptr_g_string_append_uri_escaped)(GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8);
    GString* (*ptr_g_string_down)(GString *string);
    GString* (*ptr_g_string_up)(GString *string);
    GString* (*ptr_g_string_new)(const gchar *init);
    // Header /usr/include/glib-2.0/glib/gstringchunk.h
    void (*ptr_g_string_chunk_free)(GStringChunk *chunk);
    void (*ptr_g_string_chunk_clear)(GStringChunk *chunk);
    gchar* (*ptr_g_string_chunk_insert)(GStringChunk *chunk, const gchar *string);
    gchar* (*ptr_g_string_chunk_insert_len)(GStringChunk *chunk, const gchar *string, gssize len);
    gchar* (*ptr_g_string_chunk_insert_const)(GStringChunk *chunk, const gchar *string);
    GStringChunk* (*ptr_g_string_chunk_new)(gsize size);
    // Header /usr/include/glib-2.0/glib/gstrvbuilder.h
    void (*ptr_g_strv_builder_unref)(GStrvBuilder *builder);
    GStrvBuilder* (*ptr_g_strv_builder_ref)(GStrvBuilder *builder);
    void (*ptr_g_strv_builder_add)(GStrvBuilder *builder, const char *value);
    void (*ptr_g_strv_builder_addv)(GStrvBuilder *builder, const char **value);
    void (*ptr_g_strv_builder_take)(GStrvBuilder *builder, char *value);
    GStrv (*ptr_g_strv_builder_end)(GStrvBuilder *builder);
    GStrvBuilder* (*ptr_g_strv_builder_new)(void);
    // Header /usr/include/glib-2.0/glib/gtestutils.h
    gboolean (*ptr_g_test_subprocess)(void);
    int (*ptr_g_test_run)(void);
    void (*ptr_g_test_add_func)(const char *testpath, GTestFunc test_func);
    void (*ptr_g_test_add_data_func)(const char *testpath, gconstpointer test_data, GTestDataFunc test_func);
    void (*ptr_g_test_add_data_func_full)(const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func);
    const char * (*ptr_g_test_get_path)(void);
    void (*ptr_g_test_fail)(void);
    void (*ptr_g_test_incomplete)(const gchar *msg);
    void (*ptr_g_test_skip)(const gchar *msg);
    gboolean (*ptr_g_test_failed)(void);
    void (*ptr_g_test_set_nonfatal_assertions)(void);
    void (*ptr_g_test_disable_crash_reporting)(void);
    void (*ptr_g_test_bug_base)(const char *uri_pattern);
    void (*ptr_g_test_bug)(const char *bug_uri_snippet);
    void (*ptr_g_test_summary)(const char *summary);
    void (*ptr_g_test_timer_start)(void);
    double (*ptr_g_test_timer_elapsed)(void);
    double (*ptr_g_test_timer_last)(void);
    void (*ptr_g_test_queue_free)(gpointer gfree_pointer);
    void (*ptr_g_test_queue_destroy)(GDestroyNotify destroy_func, gpointer destroy_data);
    void (*ptr_g_test_trap_subprocess_with_envp)(const char *test_path, const char * const *envp, guint64 usec_timeout, GTestSubprocessFlags test_flags);
    gboolean (*ptr_g_test_trap_has_passed)(void);
    gboolean (*ptr_g_test_trap_reached_timeout)(void);
    gint32 (*ptr_g_test_rand_int)(void);
    gint32 (*ptr_g_test_rand_int_range)(gint32 begin, gint32 end);
    double (*ptr_g_test_rand_double)(void);
    double (*ptr_g_test_rand_double_range)(double range_start, double range_end);
    GTestCase* (*ptr_g_test_create_case)(const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
    GTestSuite* (*ptr_g_test_create_suite)(const char *suite_name);
    GTestSuite* (*ptr_g_test_get_root)(void);
    void (*ptr_g_test_suite_add)(GTestSuite *suite, GTestCase *test_case);
    void (*ptr_g_test_suite_add_suite)(GTestSuite *suite, GTestSuite *nestedsuite);
    int (*ptr_g_test_run_suite)(GTestSuite *suite);
    void (*ptr_g_test_case_free)(GTestCase *test_case);
    void (*ptr_g_test_suite_free)(GTestSuite *suite);
    void (*ptr_g_test_trap_assertions)(const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern);
    void (*ptr_g_assertion_message)(const char *domain, const char *file, int line, const char *func, const char *message);
    void (*ptr_g_assertion_message_expr)(const char *domain, const char *file, int line, const char *func, const char *expr);
    void (*ptr_g_assertion_message_cmpstr)(const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2);
    void (*ptr_g_assertion_message_cmpstrv)(const char *domain, const char *file, int line, const char *func, const char *expr, const char * const *arg1, const char * const *arg2, gsize first_wrong_idx);
    void (*ptr_g_assertion_message_cmpint)(const char *domain, const char *file, int line, const char *func, const char *expr, guint64 arg1, const char *cmp, guint64 arg2, char numtype);
    void (*ptr_g_assertion_message_cmpnum)(const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype);
    void (*ptr_g_assertion_message_error)(const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code);
    void (*ptr_g_test_add_vtable)(const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
    const char* (*ptr_g_test_log_type_name)(GTestLogType log_type);
    GTestLogBuffer* (*ptr_g_test_log_buffer_new)(void);
    void (*ptr_g_test_log_buffer_free)(GTestLogBuffer *tbuffer);
    void (*ptr_g_test_log_buffer_push)(GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes);
    GTestLogMsg* (*ptr_g_test_log_buffer_pop)(GTestLogBuffer *tbuffer);
    void (*ptr_g_test_log_msg_free)(GTestLogMsg *tmsg);
    void (*ptr_g_test_log_set_fatal_handler)(GTestLogFatalFunc log_func, gpointer user_data);
    void (*ptr_g_test_expect_message)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern);
    void (*ptr_g_test_assert_expected_messages_internal)(const char *domain, const char *file, int line, const char *func);
    const gchar* (*ptr_g_test_get_dir)(GTestFileType file_type);
    int (*ptr_g_strcmp0)(const char *str1, const char *str2);
    // Header /usr/include/glib-2.0/glib/gthread.h
    GThread * (*ptr_g_thread_ref)(GThread *thread);
    void (*ptr_g_thread_unref)(GThread *thread);
    GThread * (*ptr_g_thread_new)(const gchar *name, GThreadFunc func, gpointer data);
    GThread * (*ptr_g_thread_try_new)(const gchar *name, GThreadFunc func, gpointer data, GError **error);
    GThread * (*ptr_g_thread_self)(void);
    void (*ptr_g_thread_exit)(gpointer retval);
    gpointer (*ptr_g_thread_join)(GThread *thread);
    void (*ptr_g_thread_yield)(void);
    void (*ptr_g_mutex_init)(GMutex *mutex);
    void (*ptr_g_mutex_clear)(GMutex *mutex);
    void (*ptr_g_mutex_lock)(GMutex *mutex);
    gboolean (*ptr_g_mutex_trylock)(GMutex *mutex);
    void (*ptr_g_mutex_unlock)(GMutex *mutex);
    void (*ptr_g_rw_lock_init)(GRWLock *rw_lock);
    void (*ptr_g_rw_lock_clear)(GRWLock *rw_lock);
    void (*ptr_g_rw_lock_writer_lock)(GRWLock *rw_lock);
    gboolean (*ptr_g_rw_lock_writer_trylock)(GRWLock *rw_lock);
    void (*ptr_g_rw_lock_writer_unlock)(GRWLock *rw_lock);
    void (*ptr_g_rw_lock_reader_lock)(GRWLock *rw_lock);
    gboolean (*ptr_g_rw_lock_reader_trylock)(GRWLock *rw_lock);
    void (*ptr_g_rw_lock_reader_unlock)(GRWLock *rw_lock);
    void (*ptr_g_rec_mutex_init)(GRecMutex *rec_mutex);
    void (*ptr_g_rec_mutex_clear)(GRecMutex *rec_mutex);
    void (*ptr_g_rec_mutex_lock)(GRecMutex *rec_mutex);
    gboolean (*ptr_g_rec_mutex_trylock)(GRecMutex *rec_mutex);
    void (*ptr_g_rec_mutex_unlock)(GRecMutex *rec_mutex);
    void (*ptr_g_cond_init)(GCond *cond);
    void (*ptr_g_cond_clear)(GCond *cond);
    void (*ptr_g_cond_wait)(GCond *cond, GMutex *mutex);
    void (*ptr_g_cond_signal)(GCond *cond);
    void (*ptr_g_cond_broadcast)(GCond *cond);
    gboolean (*ptr_g_cond_wait_until)(GCond *cond, GMutex *mutex, gint64 end_time);
    gpointer (*ptr_g_private_get)(GPrivate *key);
    void (*ptr_g_private_set)(GPrivate *key, gpointer value);
    void (*ptr_g_private_replace)(GPrivate *key, gpointer value);
    gpointer (*ptr_g_once_impl)(GOnce *once, GThreadFunc func, gpointer arg);
    gboolean (*ptr_g_once_init_enter)(volatile void *location);
    void (*ptr_g_once_init_leave)(volatile void *location, gsize result);
    gboolean (*ptr_g_once_init_enter_pointer)(void *location);
    void (*ptr_g_once_init_leave_pointer)(void *location, gpointer result);
    guint (*ptr_g_get_num_processors)(void);
    GQuark (*ptr_g_thread_error_quark)(void);
    // Header /usr/include/glib-2.0/glib/gthreadpool.h
    GThreadPool * (*ptr_g_thread_pool_new_full)(GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error);
    void (*ptr_g_thread_pool_free)(GThreadPool *pool, gboolean immediate, gboolean wait_);
    gboolean (*ptr_g_thread_pool_push)(GThreadPool *pool, gpointer data, GError **error);
    guint (*ptr_g_thread_pool_unprocessed)(GThreadPool *pool);
    void (*ptr_g_thread_pool_set_sort_function)(GThreadPool *pool, GCompareDataFunc func, gpointer user_data);
    gboolean (*ptr_g_thread_pool_move_to_front)(GThreadPool *pool, gpointer data);
    gboolean (*ptr_g_thread_pool_set_max_threads)(GThreadPool *pool, gint max_threads, GError **error);
    gint (*ptr_g_thread_pool_get_max_threads)(GThreadPool *pool);
    guint (*ptr_g_thread_pool_get_num_threads)(GThreadPool *pool);
    void (*ptr_g_thread_pool_set_max_unused_threads)(gint max_threads);
    gint (*ptr_g_thread_pool_get_max_unused_threads)(void);
    guint (*ptr_g_thread_pool_get_num_unused_threads)(void);
    void (*ptr_g_thread_pool_stop_unused_threads)(void);
    void (*ptr_g_thread_pool_set_max_idle_time)(guint interval);
    guint (*ptr_g_thread_pool_get_max_idle_time)(void);
    GThreadPool * (*ptr_g_thread_pool_new)(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error);
    // Header /usr/include/glib-2.0/glib/gtimer.h
    void (*ptr_g_timer_destroy)(GTimer *timer);
    void (*ptr_g_timer_start)(GTimer *timer);
    void (*ptr_g_timer_stop)(GTimer *timer);
    void (*ptr_g_timer_reset)(GTimer *timer);
    void (*ptr_g_timer_continue)(GTimer *timer);
    gdouble (*ptr_g_timer_elapsed)(GTimer *timer, gulong *microseconds);
    gboolean (*ptr_g_timer_is_active)(GTimer *timer);
    void (*ptr_g_usleep)(gulong microseconds);
    gboolean (*ptr_g_time_val_from_iso8601)(const gchar *iso_date, GTimeVal *time_);
    gchar* (*ptr_g_time_val_to_iso8601)(GTimeVal *time_);
    GTimer* (*ptr_g_timer_new)(void);
    // Header /usr/include/glib-2.0/glib/gtimezone.h
    GTimeZone * (*ptr_g_time_zone_new_identifier)(const gchar *identifier);
    GTimeZone * (*ptr_g_time_zone_new_utc)(void);
    GTimeZone * (*ptr_g_time_zone_new_local)(void);
    GTimeZone * (*ptr_g_time_zone_new_offset)(gint32 seconds);
    GTimeZone * (*ptr_g_time_zone_ref)(GTimeZone *tz);
    void (*ptr_g_time_zone_unref)(GTimeZone *tz);
    gint (*ptr_g_time_zone_find_interval)(GTimeZone *tz, GTimeType type, gint64 time_);
    gint (*ptr_g_time_zone_adjust_time)(GTimeZone *tz, GTimeType type, gint64 *time_);
    const gchar * (*ptr_g_time_zone_get_abbreviation)(GTimeZone *tz, gint interval);
    gint32 (*ptr_g_time_zone_get_offset)(GTimeZone *tz, gint interval);
    gboolean (*ptr_g_time_zone_is_dst)(GTimeZone *tz, gint interval);
    const gchar * (*ptr_g_time_zone_get_identifier)(GTimeZone *tz);
    GTimeZone * (*ptr_g_time_zone_new)(const gchar *identifier);
    // Header /usr/include/glib-2.0/glib/gtrashstack.h
    gpointer (*ptr_g_trash_stack_pop)(GTrashStack **stack_p);
    gpointer (*ptr_g_trash_stack_peek)(GTrashStack **stack_p);
    guint (*ptr_g_trash_stack_height)(GTrashStack **stack_p);
    // Header /usr/include/glib-2.0/glib/gtree.h
    GTree* (*ptr_g_tree_new_with_data)(GCompareDataFunc key_compare_func, gpointer key_compare_data);
    GTree* (*ptr_g_tree_new_full)(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
    GTreeNode* (*ptr_g_tree_node_first)(GTree *tree);
    GTreeNode* (*ptr_g_tree_node_last)(GTree *tree);
    GTreeNode* (*ptr_g_tree_node_previous)(GTreeNode *node);
    GTreeNode* (*ptr_g_tree_node_next)(GTreeNode *node);
    GTree* (*ptr_g_tree_ref)(GTree *tree);
    void (*ptr_g_tree_unref)(GTree *tree);
    void (*ptr_g_tree_destroy)(GTree *tree);
    GTreeNode* (*ptr_g_tree_insert_node)(GTree *tree, gpointer key, gpointer value);
    void (*ptr_g_tree_insert)(GTree *tree, gpointer key, gpointer value);
    GTreeNode* (*ptr_g_tree_replace_node)(GTree *tree, gpointer key, gpointer value);
    void (*ptr_g_tree_replace)(GTree *tree, gpointer key, gpointer value);
    gboolean (*ptr_g_tree_remove)(GTree *tree, gconstpointer key);
    void (*ptr_g_tree_remove_all)(GTree *tree);
    gboolean (*ptr_g_tree_steal)(GTree *tree, gconstpointer key);
    gpointer (*ptr_g_tree_node_key)(GTreeNode *node);
    gpointer (*ptr_g_tree_node_value)(GTreeNode *node);
    GTreeNode* (*ptr_g_tree_lookup_node)(GTree *tree, gconstpointer key);
    gpointer (*ptr_g_tree_lookup)(GTree *tree, gconstpointer key);
    gboolean (*ptr_g_tree_lookup_extended)(GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
    void (*ptr_g_tree_foreach)(GTree *tree, GTraverseFunc func, gpointer user_data);
    void (*ptr_g_tree_foreach_node)(GTree *tree, GTraverseNodeFunc func, gpointer user_data);
    void (*ptr_g_tree_traverse)(GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data);
    GTreeNode* (*ptr_g_tree_search_node)(GTree *tree, GCompareFunc search_func, gconstpointer user_data);
    gpointer (*ptr_g_tree_search)(GTree *tree, GCompareFunc search_func, gconstpointer user_data);
    GTreeNode* (*ptr_g_tree_lower_bound)(GTree *tree, gconstpointer key);
    GTreeNode* (*ptr_g_tree_upper_bound)(GTree *tree, gconstpointer key);
    gint (*ptr_g_tree_height)(GTree *tree);
    gint (*ptr_g_tree_nnodes)(GTree *tree);
    void (*ptr_g_tree_dump)(GTree *tree);
    GTree* (*ptr_g_tree_new)(GCompareFunc key_compare_func);
    // Header /usr/include/glib-2.0/glib/gtypes.h
    // Header /usr/include/glib-2.0/glib/gunicode.h
    GUnicodeScript (*ptr_g_unicode_script_from_iso15924)(guint32 iso15924);
    gboolean (*ptr_g_unichar_isalnum)(gunichar c);
    gboolean (*ptr_g_unichar_isalpha)(gunichar c);
    gboolean (*ptr_g_unichar_iscntrl)(gunichar c);
    gboolean (*ptr_g_unichar_isdigit)(gunichar c);
    gboolean (*ptr_g_unichar_isgraph)(gunichar c);
    gboolean (*ptr_g_unichar_islower)(gunichar c);
    gboolean (*ptr_g_unichar_isprint)(gunichar c);
    gboolean (*ptr_g_unichar_ispunct)(gunichar c);
    gboolean (*ptr_g_unichar_isspace)(gunichar c);
    gboolean (*ptr_g_unichar_isupper)(gunichar c);
    gboolean (*ptr_g_unichar_isxdigit)(gunichar c);
    gboolean (*ptr_g_unichar_istitle)(gunichar c);
    gboolean (*ptr_g_unichar_isdefined)(gunichar c);
    gboolean (*ptr_g_unichar_iswide)(gunichar c);
    gboolean (*ptr_g_unichar_iswide_cjk)(gunichar c);
    gboolean (*ptr_g_unichar_iszerowidth)(gunichar c);
    gboolean (*ptr_g_unichar_ismark)(gunichar c);
    gunichar (*ptr_g_unichar_toupper)(gunichar c);
    gunichar (*ptr_g_unichar_tolower)(gunichar c);
    gunichar (*ptr_g_unichar_totitle)(gunichar c);
    gint (*ptr_g_unichar_digit_value)(gunichar c);
    gint (*ptr_g_unichar_xdigit_value)(gunichar c);
    GUnicodeType (*ptr_g_unichar_type)(gunichar c);
    GUnicodeBreakType (*ptr_g_unichar_break_type)(gunichar c);
    gint (*ptr_g_unichar_combining_class)(gunichar uc);
    gboolean (*ptr_g_unichar_get_mirror_char)(gunichar ch, gunichar *mirrored_ch);
    GUnicodeScript (*ptr_g_unichar_get_script)(gunichar ch);
    gboolean (*ptr_g_unichar_validate)(gunichar ch);
    gboolean (*ptr_g_unichar_compose)(gunichar a, gunichar b, gunichar *ch);
    gboolean (*ptr_g_unichar_decompose)(gunichar ch, gunichar *a, gunichar *b);
    gsize (*ptr_g_unichar_fully_decompose)(gunichar ch, gboolean compat, gunichar *result, gsize result_len);
    void (*ptr_g_unicode_canonical_ordering)(gunichar *string, gsize len);
    gunichar* (*ptr_g_unicode_canonical_decomposition)(gunichar ch, gsize *result_len);
    gunichar (*ptr_g_utf8_get_char)(const gchar *p);
    gunichar (*ptr_g_utf8_get_char_validated)(const gchar *p, gssize max_len);
    gchar* (*ptr_g_utf8_offset_to_pointer)(const gchar *str, glong offset);
    glong (*ptr_g_utf8_pointer_to_offset)(const gchar *str, const gchar *pos);
    gchar* (*ptr_g_utf8_prev_char)(const gchar *p);
    gchar* (*ptr_g_utf8_find_next_char)(const gchar *p, const gchar *end);
    gchar* (*ptr_g_utf8_find_prev_char)(const gchar *str, const gchar *p);
    glong (*ptr_g_utf8_strlen)(const gchar *p, gssize max);
    gchar* (*ptr_g_utf8_substring)(const gchar *str, glong start_pos, glong end_pos);
    gchar* (*ptr_g_utf8_strncpy)(gchar *dest, const gchar *src, gsize n);
    gchar* (*ptr_g_utf8_truncate_middle)(const gchar *string, gsize truncate_length);
    gchar* (*ptr_g_utf8_strchr)(const gchar *p, gssize len, gunichar c);
    gchar* (*ptr_g_utf8_strrchr)(const gchar *p, gssize len, gunichar c);
    gchar* (*ptr_g_utf8_strreverse)(const gchar *str, gssize len);
    gunichar2* (*ptr_g_utf8_to_utf16)(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error);
    gunichar * (*ptr_g_utf8_to_ucs4)(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error);
    gunichar * (*ptr_g_utf8_to_ucs4_fast)(const gchar *str, glong len, glong *items_written);
    gunichar * (*ptr_g_utf16_to_ucs4)(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error);
    gchar* (*ptr_g_utf16_to_utf8)(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error);
    gunichar2* (*ptr_g_ucs4_to_utf16)(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error);
    gchar* (*ptr_g_ucs4_to_utf8)(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error);
    gint (*ptr_g_unichar_to_utf8)(gunichar c, gchar *outbuf);
    gboolean (*ptr_g_utf8_validate)(const gchar *str, gssize max_len, const gchar **end);
    gboolean (*ptr_g_utf8_validate_len)(const gchar *str, gsize max_len, const gchar **end);
    gchar* (*ptr_g_utf8_strup)(const gchar *str, gssize len);
    gchar* (*ptr_g_utf8_strdown)(const gchar *str, gssize len);
    gchar* (*ptr_g_utf8_casefold)(const gchar *str, gssize len);
    gchar* (*ptr_g_utf8_normalize)(const gchar *str, gssize len, GNormalizeMode mode);
    gint (*ptr_g_utf8_collate)(const gchar *str1, const gchar *str2);
    gchar* (*ptr_g_utf8_collate_key)(const gchar *str, gssize len);
    gchar* (*ptr_g_utf8_collate_key_for_filename)(const gchar *str, gssize len);
    gchar* (*ptr_g_utf8_make_valid)(const gchar *str, gssize len);
    guint32 (*ptr_g_unicode_script_to_iso15924)(GUnicodeScript script);
    // Header /usr/include/glib-2.0/glib/guri.h
    void (*ptr_g_uri_unref)(GUri *uri);
    gboolean (*ptr_g_uri_split)(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **userinfo, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error);
    gboolean (*ptr_g_uri_split_with_user)(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error);
    gboolean (*ptr_g_uri_split_network)(const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error);
    gboolean (*ptr_g_uri_is_valid)(const gchar *uri_string, GUriFlags flags, GError **error);
    gchar * (*ptr_g_uri_join)(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
    gchar * (*ptr_g_uri_join_with_user)(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
    GUri * (*ptr_g_uri_parse)(const gchar *uri_string, GUriFlags flags, GError **error);
    GUri * (*ptr_g_uri_parse_relative)(GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error);
    gchar * (*ptr_g_uri_resolve_relative)(const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error);
    GUri * (*ptr_g_uri_build)(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
    GUri * (*ptr_g_uri_build_with_user)(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
    char * (*ptr_g_uri_to_string)(GUri *uri);
    char * (*ptr_g_uri_to_string_partial)(GUri *uri, GUriHideFlags flags);
    const gchar* (*ptr_g_uri_get_scheme)(GUri *uri);
    const gchar* (*ptr_g_uri_get_userinfo)(GUri *uri);
    const gchar* (*ptr_g_uri_get_user)(GUri *uri);
    const gchar* (*ptr_g_uri_get_password)(GUri *uri);
    const gchar* (*ptr_g_uri_get_auth_params)(GUri *uri);
    const gchar* (*ptr_g_uri_get_host)(GUri *uri);
    gint (*ptr_g_uri_get_port)(GUri *uri);
    const gchar* (*ptr_g_uri_get_path)(GUri *uri);
    const gchar* (*ptr_g_uri_get_query)(GUri *uri);
    const gchar* (*ptr_g_uri_get_fragment)(GUri *uri);
    GUriFlags (*ptr_g_uri_get_flags)(GUri *uri);
    GHashTable* (*ptr_g_uri_parse_params)(const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error);
    void (*ptr_g_uri_params_iter_init)(GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags);
    gboolean (*ptr_g_uri_params_iter_next)(GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error);
    GQuark (*ptr_g_uri_error_quark)(void);
    char * (*ptr_g_uri_unescape_string)(const char *escaped_string, const char *illegal_characters);
    char * (*ptr_g_uri_unescape_segment)(const char *escaped_string, const char *escaped_string_end, const char *illegal_characters);
    char * (*ptr_g_uri_parse_scheme)(const char *uri);
    const char* (*ptr_g_uri_peek_scheme)(const char *uri);
    char * (*ptr_g_uri_escape_string)(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);
    GBytes * (*ptr_g_uri_unescape_bytes)(const char *escaped_string, gssize length, const char *illegal_characters, GError **error);
    char * (*ptr_g_uri_escape_bytes)(const guint8 *unescaped, gsize length, const char *reserved_chars_allowed);
    // Header /usr/include/glib-2.0/glib/gutils.h
    const gchar * (*ptr_g_get_real_name)(void);
    const gchar * (*ptr_g_get_home_dir)(void);
    const gchar * (*ptr_g_get_tmp_dir)(void);
    const gchar * (*ptr_g_get_host_name)(void);
    const gchar * (*ptr_g_get_prgname)(void);
    void (*ptr_g_set_prgname)(const gchar *prgname);
    const gchar * (*ptr_g_get_application_name)(void);
    void (*ptr_g_set_application_name)(const gchar *application_name);
    gchar * (*ptr_g_get_os_info)(const gchar *key_name);
    void (*ptr_g_reload_user_special_dirs_cache)(void);
    const gchar * (*ptr_g_get_user_data_dir)(void);
    const gchar * (*ptr_g_get_user_config_dir)(void);
    const gchar * (*ptr_g_get_user_cache_dir)(void);
    const gchar * (*ptr_g_get_user_state_dir)(void);
    const gchar * const * (*ptr_g_get_system_data_dirs)(void);
    const gchar * const * (*ptr_g_get_system_config_dirs)(void);
    const gchar * (*ptr_g_get_user_runtime_dir)(void);
    const gchar * (*ptr_g_get_user_special_dir)(GUserDirectory directory);
    guint (*ptr_g_parse_debug_string)(const gchar *string, const GDebugKey *keys, guint nkeys);
    gint (*ptr_g_vsnprintf)(gchar *string, gulong n, gchar const *format, va_list args);
    void (*ptr_g_nullify_pointer)(gpointer *nullify_location);
    gchar* (*ptr_g_format_size_full)(guint64 size, GFormatSizeFlags flags);
    gchar* (*ptr_g_format_size)(guint64 size);
    gchar* (*ptr_g_format_size_for_display)(goffset size);
    gchar* (*ptr_g_find_program_in_path)(const gchar *program);
    gint (*ptr_g_bit_nth_lsf)(gulong mask, gint nth_bit);
    gint (*ptr_g_bit_nth_msf)(gulong mask, gint nth_bit);
    guint (*ptr_g_bit_storage)(gulong number);
    void (*ptr_g_abort)(void);
    const gchar * (*ptr_g_get_user_name)(void);
    // Header /usr/include/glib-2.0/glib/guuid.h
    gchar * (*ptr_g_uuid_string_random)(void);
    gboolean (*ptr_g_uuid_string_is_valid)(const gchar *str);
    // Header /usr/include/glib-2.0/glib/gvariant.h
    GVariant * (*ptr_g_variant_ref)(GVariant *value);
    GVariant * (*ptr_g_variant_ref_sink)(GVariant *value);
    gboolean (*ptr_g_variant_is_floating)(GVariant *value);
    GVariant * (*ptr_g_variant_take_ref)(GVariant *value);
    const GVariantType * (*ptr_g_variant_get_type)(GVariant *value);
    const gchar * (*ptr_g_variant_get_type_string)(GVariant *value);
    gboolean (*ptr_g_variant_is_of_type)(GVariant *value, const GVariantType *type);
    gboolean (*ptr_g_variant_is_container)(GVariant *value);
    GVariantClass (*ptr_g_variant_classify)(GVariant *value);
    GVariant * (*ptr_g_variant_new_boolean)(gboolean value);
    GVariant * (*ptr_g_variant_new_byte)(guint8 value);
    GVariant * (*ptr_g_variant_new_int16)(gint16 value);
    GVariant * (*ptr_g_variant_new_uint16)(guint16 value);
    GVariant * (*ptr_g_variant_new_int32)(gint32 value);
    GVariant * (*ptr_g_variant_new_uint32)(guint32 value);
    GVariant * (*ptr_g_variant_new_int64)(gint64 value);
    GVariant * (*ptr_g_variant_new_uint64)(guint64 value);
    GVariant * (*ptr_g_variant_new_handle)(gint32 value);
    GVariant * (*ptr_g_variant_new_double)(gdouble value);
    GVariant * (*ptr_g_variant_new_string)(const gchar *string);
    GVariant * (*ptr_g_variant_new_take_string)(gchar *string);
    GVariant * (*ptr_g_variant_new_object_path)(const gchar *object_path);
    gboolean (*ptr_g_variant_is_object_path)(const gchar *string);
    GVariant * (*ptr_g_variant_new_signature)(const gchar *signature);
    gboolean (*ptr_g_variant_is_signature)(const gchar *string);
    GVariant * (*ptr_g_variant_new_variant)(GVariant *value);
    GVariant * (*ptr_g_variant_new_strv)(const gchar * const *strv, gssize length);
    GVariant * (*ptr_g_variant_new_objv)(const gchar * const *strv, gssize length);
    GVariant * (*ptr_g_variant_new_bytestring)(const gchar *string);
    GVariant * (*ptr_g_variant_new_bytestring_array)(const gchar * const *strv, gssize length);
    GVariant * (*ptr_g_variant_new_fixed_array)(const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size);
    gboolean (*ptr_g_variant_get_boolean)(GVariant *value);
    guint8 (*ptr_g_variant_get_byte)(GVariant *value);
    gint16 (*ptr_g_variant_get_int16)(GVariant *value);
    guint16 (*ptr_g_variant_get_uint16)(GVariant *value);
    gint32 (*ptr_g_variant_get_int32)(GVariant *value);
    guint32 (*ptr_g_variant_get_uint32)(GVariant *value);
    gint64 (*ptr_g_variant_get_int64)(GVariant *value);
    guint64 (*ptr_g_variant_get_uint64)(GVariant *value);
    gint32 (*ptr_g_variant_get_handle)(GVariant *value);
    gdouble (*ptr_g_variant_get_double)(GVariant *value);
    GVariant * (*ptr_g_variant_get_variant)(GVariant *value);
    const gchar * (*ptr_g_variant_get_string)(GVariant *value, gsize *length);
    gchar * (*ptr_g_variant_dup_string)(GVariant *value, gsize *length);
    const gchar ** (*ptr_g_variant_get_strv)(GVariant *value, gsize *length);
    gchar ** (*ptr_g_variant_dup_strv)(GVariant *value, gsize *length);
    const gchar ** (*ptr_g_variant_get_objv)(GVariant *value, gsize *length);
    gchar ** (*ptr_g_variant_dup_objv)(GVariant *value, gsize *length);
    const gchar * (*ptr_g_variant_get_bytestring)(GVariant *value);
    gchar * (*ptr_g_variant_dup_bytestring)(GVariant *value, gsize *length);
    const gchar ** (*ptr_g_variant_get_bytestring_array)(GVariant *value, gsize *length);
    gchar ** (*ptr_g_variant_dup_bytestring_array)(GVariant *value, gsize *length);
    GVariant * (*ptr_g_variant_new_maybe)(const GVariantType *child_type, GVariant *child);
    GVariant * (*ptr_g_variant_new_array)(const GVariantType *child_type, GVariant * const *children, gsize n_children);
    GVariant * (*ptr_g_variant_new_tuple)(GVariant * const *children, gsize n_children);
    GVariant * (*ptr_g_variant_new_dict_entry)(GVariant *key, GVariant *value);
    GVariant * (*ptr_g_variant_get_maybe)(GVariant *value);
    gsize (*ptr_g_variant_n_children)(GVariant *value);
    GVariant * (*ptr_g_variant_get_child_value)(GVariant *value, gsize index_);
    GVariant * (*ptr_g_variant_lookup_value)(GVariant *dictionary, const gchar *key, const GVariantType *expected_type);
    gconstpointer (*ptr_g_variant_get_fixed_array)(GVariant *value, gsize *n_elements, gsize element_size);
    gsize (*ptr_g_variant_get_size)(GVariant *value);
    gconstpointer (*ptr_g_variant_get_data)(GVariant *value);
    GBytes * (*ptr_g_variant_get_data_as_bytes)(GVariant *value);
    void (*ptr_g_variant_store)(GVariant *value, gpointer data);
    gchar * (*ptr_g_variant_print)(GVariant *value, gboolean type_annotate);
    GString * (*ptr_g_variant_print_string)(GVariant *value, GString *string, gboolean type_annotate);
    guint (*ptr_g_variant_hash)(gconstpointer value);
    gboolean (*ptr_g_variant_equal)(gconstpointer one, gconstpointer two);
    GVariant * (*ptr_g_variant_get_normal_form)(GVariant *value);
    gboolean (*ptr_g_variant_is_normal_form)(GVariant *value);
    GVariant * (*ptr_g_variant_byteswap)(GVariant *value);
    GVariant * (*ptr_g_variant_new_from_bytes)(const GVariantType *type, GBytes *bytes, gboolean trusted);
    GVariant * (*ptr_g_variant_new_from_data)(const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data);
    GVariantIter * (*ptr_g_variant_iter_new)(GVariant *value);
    gsize (*ptr_g_variant_iter_init)(GVariantIter *iter, GVariant *value);
    GVariantIter * (*ptr_g_variant_iter_copy)(GVariantIter *iter);
    gsize (*ptr_g_variant_iter_n_children)(GVariantIter *iter);
    void (*ptr_g_variant_iter_free)(GVariantIter *iter);
    GVariant * (*ptr_g_variant_iter_next_value)(GVariantIter *iter);
    GQuark (*ptr_g_variant_parser_get_error_quark)(void);
    GQuark (*ptr_g_variant_parse_error_quark)(void);
    GVariantBuilder * (*ptr_g_variant_builder_new)(const GVariantType *type);
    void (*ptr_g_variant_builder_unref)(GVariantBuilder *builder);
    GVariantBuilder * (*ptr_g_variant_builder_ref)(GVariantBuilder *builder);
    void (*ptr_g_variant_builder_init)(GVariantBuilder *builder, const GVariantType *type);
    GVariant * (*ptr_g_variant_builder_end)(GVariantBuilder *builder);
    void (*ptr_g_variant_builder_clear)(GVariantBuilder *builder);
    void (*ptr_g_variant_builder_open)(GVariantBuilder *builder, const GVariantType *type);
    void (*ptr_g_variant_builder_close)(GVariantBuilder *builder);
    void (*ptr_g_variant_builder_add_value)(GVariantBuilder *builder, GVariant *value);
    GVariant * (*ptr_g_variant_new_va)(const gchar *format_string, const gchar **endptr, va_list *app);
    void (*ptr_g_variant_get_va)(GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app);
    gboolean (*ptr_g_variant_check_format_string)(GVariant *value, const gchar *format_string, gboolean copy_only);
    GVariant * (*ptr_g_variant_parse)(const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error);
    GVariant * (*ptr_g_variant_new_parsed_va)(const gchar *format, va_list *app);
    gchar * (*ptr_g_variant_parse_error_print_context)(GError *error, const gchar *source_str);
    gint (*ptr_g_variant_compare)(gconstpointer one, gconstpointer two);
    GVariantDict * (*ptr_g_variant_dict_new)(GVariant *from_asv);
    void (*ptr_g_variant_dict_init)(GVariantDict *dict, GVariant *from_asv);
    GVariant * (*ptr_g_variant_dict_lookup_value)(GVariantDict *dict, const gchar *key, const GVariantType *expected_type);
    gboolean (*ptr_g_variant_dict_contains)(GVariantDict *dict, const gchar *key);
    void (*ptr_g_variant_dict_insert_value)(GVariantDict *dict, const gchar *key, GVariant *value);
    gboolean (*ptr_g_variant_dict_remove)(GVariantDict *dict, const gchar *key);
    void (*ptr_g_variant_dict_clear)(GVariantDict *dict);
    GVariant * (*ptr_g_variant_dict_end)(GVariantDict *dict);
    GVariantDict * (*ptr_g_variant_dict_ref)(GVariantDict *dict);
    void (*ptr_g_variant_dict_unref)(GVariantDict *dict);
    void (*ptr_g_variant_unref)(GVariant *value);
    // Header /usr/include/glib-2.0/glib/gvarianttype.h
    gboolean (*ptr_g_variant_type_string_scan)(const gchar *string, const gchar *limit, const gchar **endptr);
    void (*ptr_g_variant_type_free)(GVariantType *type);
    GVariantType * (*ptr_g_variant_type_copy)(const GVariantType *type);
    GVariantType * (*ptr_g_variant_type_new)(const gchar *type_string);
    gsize (*ptr_g_variant_type_get_string_length)(const GVariantType *type);
    const gchar * (*ptr_g_variant_type_peek_string)(const GVariantType *type);
    gchar * (*ptr_g_variant_type_dup_string)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_definite)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_container)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_basic)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_maybe)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_array)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_tuple)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_dict_entry)(const GVariantType *type);
    gboolean (*ptr_g_variant_type_is_variant)(const GVariantType *type);
    guint (*ptr_g_variant_type_hash)(gconstpointer type);
    gboolean (*ptr_g_variant_type_equal)(gconstpointer type1, gconstpointer type2);
    gboolean (*ptr_g_variant_type_is_subtype_of)(const GVariantType *type, const GVariantType *supertype);
    const GVariantType * (*ptr_g_variant_type_element)(const GVariantType *type);
    const GVariantType * (*ptr_g_variant_type_first)(const GVariantType *type);
    const GVariantType * (*ptr_g_variant_type_next)(const GVariantType *type);
    gsize (*ptr_g_variant_type_n_items)(const GVariantType *type);
    const GVariantType * (*ptr_g_variant_type_key)(const GVariantType *type);
    const GVariantType * (*ptr_g_variant_type_value)(const GVariantType *type);
    GVariantType * (*ptr_g_variant_type_new_array)(const GVariantType *element);
    GVariantType * (*ptr_g_variant_type_new_maybe)(const GVariantType *element);
    GVariantType * (*ptr_g_variant_type_new_tuple)(const GVariantType * const *items, gint length);
    GVariantType * (*ptr_g_variant_type_new_dict_entry)(const GVariantType *key, const GVariantType *value);
    const GVariantType * (*ptr_g_variant_type_checked_)(const gchar *type_string);
    gsize (*ptr_g_variant_type_string_get_depth_)(const gchar *type_string);
    gboolean (*ptr_g_variant_type_string_is_valid)(const gchar *type_string);
    // Header /usr/include/glib-2.0/glib/gversion.h
    const gchar * (*ptr_glib_check_version)(guint required_major, guint required_minor, guint required_micro);
    // Header /usr/include/glib-2.0/glib-unix.h
    gboolean (*ptr_g_unix_open_pipe)(gint *fds, gint flags, GError **error);
    gboolean (*ptr_g_unix_set_fd_nonblocking)(gint fd, gboolean nonblock, GError **error);
    GSource* (*ptr_g_unix_signal_source_new)(gint signum);
    guint (*ptr_g_unix_signal_add_full)(gint priority, gint signum, GSourceFunc handler, gpointer user_data, GDestroyNotify notify);
    guint (*ptr_g_unix_signal_add)(gint signum, GSourceFunc handler, gpointer user_data);
    GSource* (*ptr_g_unix_fd_source_new)(gint fd, GIOCondition condition);
    guint (*ptr_g_unix_fd_add_full)(gint priority, gint fd, GIOCondition condition, GUnixFDSourceFunc function, gpointer user_data, GDestroyNotify notify);
    guint (*ptr_g_unix_fd_add)(gint fd, GIOCondition condition, GUnixFDSourceFunc function, gpointer user_data);
    struct passwd* (*ptr_g_unix_get_passwd_entry)(const gchar *user_name, GError **error);
    int (*ptr_g_fdwalk_set_cloexec)(int lowfd);
    GQuark (*ptr_g_unix_error_quark)(void);
    // Header /usr/include/glib-2.0/gobject/gbinding.h
    GType (*ptr_g_binding_flags_get_type)(void);
    GType (*ptr_g_binding_get_type)(void);
    GBindingFlags (*ptr_g_binding_get_flags)(GBinding *binding);
    GObject * (*ptr_g_binding_get_source)(GBinding *binding);
    GObject * (*ptr_g_binding_dup_source)(GBinding *binding);
    GObject * (*ptr_g_binding_get_target)(GBinding *binding);
    GObject * (*ptr_g_binding_dup_target)(GBinding *binding);
    const gchar * (*ptr_g_binding_get_source_property)(GBinding *binding);
    const gchar * (*ptr_g_binding_get_target_property)(GBinding *binding);
    void (*ptr_g_binding_unbind)(GBinding *binding);
    GBinding* (*ptr_g_object_bind_property)(gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
    GBinding* (*ptr_g_object_bind_property_full)(gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify notify);
    GBinding* (*ptr_g_object_bind_property_with_closures)(gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
    // Header /usr/include/glib-2.0/gobject/gbindinggroup.h
    GType (*ptr_g_binding_group_get_type)(void);
    GBindingGroup* (*ptr_g_binding_group_new)(void);
    gpointer (*ptr_g_binding_group_dup_source)(GBindingGroup *self);
    void (*ptr_g_binding_group_set_source)(GBindingGroup *self, gpointer source);
    void (*ptr_g_binding_group_bind)(GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
    void (*ptr_g_binding_group_bind_full)(GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify user_data_destroy);
    void (*ptr_g_binding_group_bind_with_closures)(GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
    // Header /usr/include/glib-2.0/gobject/gboxed.h
    gpointer (*ptr_g_boxed_copy)(GType boxed_type, gconstpointer src_boxed);
    void (*ptr_g_boxed_free)(GType boxed_type, gpointer boxed);
    void (*ptr_g_value_set_boxed)(GValue *value, gconstpointer v_boxed);
    void (*ptr_g_value_set_static_boxed)(GValue *value, gconstpointer v_boxed);
    void (*ptr_g_value_take_boxed)(GValue *value, gconstpointer v_boxed);
    void (*ptr_g_value_set_boxed_take_ownership)(GValue *value, gconstpointer v_boxed);
    gpointer (*ptr_g_value_get_boxed)(const GValue *value);
    gpointer (*ptr_g_value_dup_boxed)(const GValue *value);
    GType (*ptr_g_boxed_type_register_static)(const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free);
    GType (*ptr_g_closure_get_type)(void);
    GType (*ptr_g_value_get_type)(void);
    // Header /usr/include/glib-2.0/gobject/gclosure.h
    GClosure* (*ptr_g_cclosure_new_swap)(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
    GClosure* (*ptr_g_signal_type_cclosure_new)(GType itype, guint struct_offset);
    GClosure* (*ptr_g_closure_ref)(GClosure *closure);
    void (*ptr_g_closure_sink)(GClosure *closure);
    void (*ptr_g_closure_unref)(GClosure *closure);
    GClosure* (*ptr_g_closure_new_simple)(guint sizeof_closure, gpointer data);
    void (*ptr_g_closure_add_finalize_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
    void (*ptr_g_closure_remove_finalize_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
    void (*ptr_g_closure_add_invalidate_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
    void (*ptr_g_closure_remove_invalidate_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
    void (*ptr_g_closure_add_marshal_guards)(GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify);
    void (*ptr_g_closure_set_marshal)(GClosure *closure, GClosureMarshal marshal);
    void (*ptr_g_closure_set_meta_marshal)(GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal);
    void (*ptr_g_closure_invalidate)(GClosure *closure);
    void (*ptr_g_closure_invoke)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint);
    void (*ptr_g_cclosure_marshal_generic)(GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_generic_va)(GClosure *closure, GValue *return_value, gpointer instance, va_list args_list, gpointer marshal_data, int n_params, GType *param_types);
    GClosure* (*ptr_g_cclosure_new)(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
    // Header /usr/include/glib-2.0/gobject/genums.h
    GEnumValue* (*ptr_g_enum_get_value)(GEnumClass *enum_class, gint value);
    GEnumValue* (*ptr_g_enum_get_value_by_name)(GEnumClass *enum_class, const gchar *name);
    GEnumValue* (*ptr_g_enum_get_value_by_nick)(GEnumClass *enum_class, const gchar *nick);
    GFlagsValue* (*ptr_g_flags_get_first_value)(GFlagsClass *flags_class, guint value);
    GFlagsValue* (*ptr_g_flags_get_value_by_name)(GFlagsClass *flags_class, const gchar *name);
    GFlagsValue* (*ptr_g_flags_get_value_by_nick)(GFlagsClass *flags_class, const gchar *nick);
    gchar* (*ptr_g_enum_to_string)(GType g_enum_type, gint value);
    gchar* (*ptr_g_flags_to_string)(GType flags_type, guint value);
    void (*ptr_g_value_set_enum)(GValue *value, gint v_enum);
    gint (*ptr_g_value_get_enum)(const GValue *value);
    void (*ptr_g_value_set_flags)(GValue *value, guint v_flags);
    guint (*ptr_g_value_get_flags)(const GValue *value);
    GType (*ptr_g_enum_register_static)(const gchar *name, const GEnumValue *const_static_values);
    GType (*ptr_g_flags_register_static)(const gchar *name, const GFlagsValue *const_static_values);
    void (*ptr_g_enum_complete_type_info)(GType g_enum_type, GTypeInfo *info, const GEnumValue *const_values);
    void (*ptr_g_flags_complete_type_info)(GType g_flags_type, GTypeInfo *info, const GFlagsValue *const_values);
    // Header /usr/include/glib-2.0/gobject/glib-enumtypes.h
    GType (*ptr_g_unicode_type_get_type)(void);
    GType (*ptr_g_unicode_break_type_get_type)(void);
    GType (*ptr_g_unicode_script_get_type)(void);
    GType (*ptr_g_normalize_mode_get_type)(void);
    // Header /usr/include/glib-2.0/gobject/glib-types.h
    GType (*ptr_g_date_get_type)(void);
    GType (*ptr_g_strv_get_type)(void);
    GType (*ptr_g_gstring_get_type)(void);
    GType (*ptr_g_hash_table_get_type)(void);
    GType (*ptr_g_regex_get_type)(void);
    GType (*ptr_g_match_info_get_type)(void);
    GType (*ptr_g_array_get_type)(void);
    GType (*ptr_g_byte_array_get_type)(void);
    GType (*ptr_g_ptr_array_get_type)(void);
    GType (*ptr_g_bytes_get_type)(void);
    GType (*ptr_g_variant_type_get_gtype)(void);
    GType (*ptr_g_error_get_type)(void);
    GType (*ptr_g_date_time_get_type)(void);
    GType (*ptr_g_time_zone_get_type)(void);
    GType (*ptr_g_io_channel_get_type)(void);
    GType (*ptr_g_io_condition_get_type)(void);
    GType (*ptr_g_variant_builder_get_type)(void);
    GType (*ptr_g_variant_dict_get_type)(void);
    GType (*ptr_g_main_loop_get_type)(void);
    GType (*ptr_g_main_context_get_type)(void);
    GType (*ptr_g_source_get_type)(void);
    GType (*ptr_g_pollfd_get_type)(void);
    GType (*ptr_g_markup_parse_context_get_type)(void);
    GType (*ptr_g_key_file_get_type)(void);
    GType (*ptr_g_mapped_file_get_type)(void);
    GType (*ptr_g_thread_get_type)(void);
    GType (*ptr_g_option_group_get_type)(void);
    GType (*ptr_g_uri_get_type)(void);
    GType (*ptr_g_tree_get_type)(void);
    GType (*ptr_g_pattern_spec_get_type)(void);
    GType (*ptr_g_bookmark_file_get_type)(void);
    GType (*ptr_g_hmac_get_type)(void);
    GType (*ptr_g_dir_get_type)(void);
    GType (*ptr_g_rand_get_type)(void);
    GType (*ptr_g_strv_builder_get_type)(void);
    GType (*ptr_g_checksum_get_type)(void);
    GType (*ptr_g_variant_get_gtype)(void);
    // Header /usr/include/glib-2.0/gobject/gmarshal.h
    void (*ptr_g_cclosure_marshal_VOID__VOIDv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__BOOLEAN)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__BOOLEANv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__CHAR)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__CHARv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__UCHAR)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__UCHARv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__INT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__INTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__UINT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__UINTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__LONG)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__LONGv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__ULONG)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__ULONGv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__ENUM)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__ENUMv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__FLAGS)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__FLAGSv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__FLOAT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__FLOATv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__DOUBLE)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__DOUBLEv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__STRING)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__STRINGv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__PARAM)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__PARAMv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__BOXED)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__BOXEDv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__POINTER)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__POINTERv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__OBJECT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__OBJECTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__VARIANT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__VARIANTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__UINT_POINTER)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_VOID__UINT_POINTERv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_BOOLEAN__FLAGS)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_BOOLEAN__FLAGSv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_STRING__OBJECT_POINTER)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_STRING__OBJECT_POINTERv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_BOOLEAN__BOXED_BOXED)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    void (*ptr_g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
    void (*ptr_g_cclosure_marshal_VOID__VOID)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
    // Header /usr/include/glib-2.0/gobject/gobject.h
    GType (*ptr_g_initially_unowned_get_type)(void);
    void (*ptr_g_object_class_install_property)(GObjectClass *oclass, guint property_id, GParamSpec *pspec);
    GParamSpec* (*ptr_g_object_class_find_property)(GObjectClass *oclass, const gchar *property_name);
    GParamSpec** (*ptr_g_object_class_list_properties)(GObjectClass *oclass, guint *n_properties);
    void (*ptr_g_object_class_override_property)(GObjectClass *oclass, guint property_id, const gchar *name);
    void (*ptr_g_object_class_install_properties)(GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs);
    void (*ptr_g_object_interface_install_property)(gpointer g_iface, GParamSpec *pspec);
    GParamSpec* (*ptr_g_object_interface_find_property)(gpointer g_iface, const gchar *property_name);
    GParamSpec** (*ptr_g_object_interface_list_properties)(gpointer g_iface, guint *n_properties_p);
    GType (*ptr_g_object_get_type)(void);
    GObject* (*ptr_g_object_new_with_properties)(GType object_type, guint n_properties, const char *names[], const GValue values[]);
    void (*ptr_g_object_setv)(GObject *object, guint n_properties, const gchar *names[], const GValue values[]);
    void (*ptr_g_object_set_valist)(GObject *object, const gchar *first_property_name, va_list var_args);
    void (*ptr_g_object_getv)(GObject *object, guint n_properties, const gchar *names[], GValue values[]);
    void (*ptr_g_object_get_valist)(GObject *object, const gchar *first_property_name, va_list var_args);
    void (*ptr_g_object_set_property)(GObject *object, const gchar *property_name, const GValue *value);
    void (*ptr_g_object_get_property)(GObject *object, const gchar *property_name, GValue *value);
    void (*ptr_g_object_freeze_notify)(GObject *object);
    void (*ptr_g_object_notify)(GObject *object, const gchar *property_name);
    void (*ptr_g_object_notify_by_pspec)(GObject *object, GParamSpec *pspec);
    void (*ptr_g_object_thaw_notify)(GObject *object);
    gboolean (*ptr_g_object_is_floating)(gpointer object);
    gpointer (*ptr_g_object_ref_sink)(gpointer object);
    gpointer (*ptr_g_object_take_ref)(gpointer object);
    gpointer (*ptr_g_object_ref)(gpointer object);
    void (*ptr_g_object_unref)(gpointer object);
    void (*ptr_g_object_weak_ref)(GObject *object, GWeakNotify notify, gpointer data);
    void (*ptr_g_object_weak_unref)(GObject *object, GWeakNotify notify, gpointer data);
    void (*ptr_g_object_add_weak_pointer)(GObject *object, gpointer *weak_pointer_location);
    void (*ptr_g_object_remove_weak_pointer)(GObject *object, gpointer *weak_pointer_location);
    void (*ptr_g_object_add_toggle_ref)(GObject *object, GToggleNotify notify, gpointer data);
    void (*ptr_g_object_remove_toggle_ref)(GObject *object, GToggleNotify notify, gpointer data);
    gpointer (*ptr_g_object_get_qdata)(GObject *object, GQuark quark);
    void (*ptr_g_object_set_qdata)(GObject *object, GQuark quark, gpointer data);
    void (*ptr_g_object_set_qdata_full)(GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy);
    gpointer (*ptr_g_object_steal_qdata)(GObject *object, GQuark quark);
    gpointer (*ptr_g_object_dup_qdata)(GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data);
    gboolean (*ptr_g_object_replace_qdata)(GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
    gpointer (*ptr_g_object_get_data)(GObject *object, const gchar *key);
    void (*ptr_g_object_set_data)(GObject *object, const gchar *key, gpointer data);
    void (*ptr_g_object_set_data_full)(GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy);
    gpointer (*ptr_g_object_steal_data)(GObject *object, const gchar *key);
    gpointer (*ptr_g_object_dup_data)(GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data);
    gboolean (*ptr_g_object_replace_data)(GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
    void (*ptr_g_object_watch_closure)(GObject *object, GClosure *closure);
    GClosure* (*ptr_g_cclosure_new_object)(GCallback callback_func, GObject *object);
    GClosure* (*ptr_g_cclosure_new_object_swap)(GCallback callback_func, GObject *object);
    GClosure* (*ptr_g_closure_new_object)(guint sizeof_closure, GObject *object);
    void (*ptr_g_value_set_object)(GValue *value, gpointer v_object);
    gpointer (*ptr_g_value_get_object)(const GValue *value);
    gpointer (*ptr_g_value_dup_object)(const GValue *value);
    gulong (*ptr_g_signal_connect_object)(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags);
    void (*ptr_g_object_force_floating)(GObject *object);
    void (*ptr_g_object_run_dispose)(GObject *object);
    void (*ptr_g_value_take_object)(GValue *value, gpointer v_object);
    void (*ptr_g_value_set_object_take_ownership)(GValue *value, gpointer v_object);
    gsize (*ptr_g_object_compat_control)(gsize what, gpointer data);
    void (*ptr_g_clear_object)(GObject **object_ptr);
    void (*ptr_g_weak_ref_init)(GWeakRef *weak_ref, gpointer object);
    void (*ptr_g_weak_ref_clear)(GWeakRef *weak_ref);
    gpointer (*ptr_g_weak_ref_get)(GWeakRef *weak_ref);
    void (*ptr_g_weak_ref_set)(GWeakRef *weak_ref, gpointer object);
    // Header /usr/include/glib-2.0/gobject/gparam.h
    GParamSpec* (*ptr_g_param_spec_ref)(GParamSpec *pspec);
    void (*ptr_g_param_spec_unref)(GParamSpec *pspec);
    void (*ptr_g_param_spec_sink)(GParamSpec *pspec);
    GParamSpec* (*ptr_g_param_spec_ref_sink)(GParamSpec *pspec);
    gpointer (*ptr_g_param_spec_get_qdata)(GParamSpec *pspec, GQuark quark);
    void (*ptr_g_param_spec_set_qdata)(GParamSpec *pspec, GQuark quark, gpointer data);
    void (*ptr_g_param_spec_set_qdata_full)(GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy);
    gpointer (*ptr_g_param_spec_steal_qdata)(GParamSpec *pspec, GQuark quark);
    GParamSpec* (*ptr_g_param_spec_get_redirect_target)(GParamSpec *pspec);
    void (*ptr_g_param_value_set_default)(GParamSpec *pspec, GValue *value);
    gboolean (*ptr_g_param_value_defaults)(GParamSpec *pspec, const GValue *value);
    gboolean (*ptr_g_param_value_validate)(GParamSpec *pspec, GValue *value);
    gboolean (*ptr_g_param_value_is_valid)(GParamSpec *pspec, const GValue *value);
    gboolean (*ptr_g_param_value_convert)(GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation);
    gint (*ptr_g_param_values_cmp)(GParamSpec *pspec, const GValue *value1, const GValue *value2);
    const gchar * (*ptr_g_param_spec_get_name)(GParamSpec *pspec);
    const gchar * (*ptr_g_param_spec_get_nick)(GParamSpec *pspec);
    const gchar * (*ptr_g_param_spec_get_blurb)(GParamSpec *pspec);
    void (*ptr_g_value_set_param)(GValue *value, GParamSpec *param);
    GParamSpec* (*ptr_g_value_get_param)(const GValue *value);
    GParamSpec* (*ptr_g_value_dup_param)(const GValue *value);
    void (*ptr_g_value_take_param)(GValue *value, GParamSpec *param);
    void (*ptr_g_value_set_param_take_ownership)(GValue *value, GParamSpec *param);
    const GValue * (*ptr_g_param_spec_get_default_value)(GParamSpec *pspec);
    GQuark (*ptr_g_param_spec_get_name_quark)(GParamSpec *pspec);
    GType (*ptr_g_param_type_register_static)(const gchar *name, const GParamSpecTypeInfo *pspec_info);
    gboolean (*ptr_g_param_spec_is_valid_name)(const gchar *name);
    GType (*ptr__g_param_type_register_static_constant)(const gchar *name, const GParamSpecTypeInfo *pspec_info, GType opt_type);
    gpointer (*ptr_g_param_spec_internal)(GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
    GParamSpecPool* (*ptr_g_param_spec_pool_new)(gboolean type_prefixing);
    void (*ptr_g_param_spec_pool_insert)(GParamSpecPool *pool, GParamSpec *pspec, GType owner_type);
    void (*ptr_g_param_spec_pool_remove)(GParamSpecPool *pool, GParamSpec *pspec);
    GParamSpec* (*ptr_g_param_spec_pool_lookup)(GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors);
    GList* (*ptr_g_param_spec_pool_list_owned)(GParamSpecPool *pool, GType owner_type);
    GParamSpec** (*ptr_g_param_spec_pool_list)(GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p);
    void (*ptr_g_param_spec_pool_free)(GParamSpecPool *pool);
    // Header /usr/include/glib-2.0/gobject/gparamspecs.h
    GParamSpec* (*ptr_g_param_spec_char)(const gchar *name, const gchar *nick, const gchar *blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_uchar)(const gchar *name, const gchar *nick, const gchar *blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_boolean)(const gchar *name, const gchar *nick, const gchar *blurb, gboolean default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_int)(const gchar *name, const gchar *nick, const gchar *blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_uint)(const gchar *name, const gchar *nick, const gchar *blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_long)(const gchar *name, const gchar *nick, const gchar *blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_ulong)(const gchar *name, const gchar *nick, const gchar *blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_int64)(const gchar *name, const gchar *nick, const gchar *blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_uint64)(const gchar *name, const gchar *nick, const gchar *blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_unichar)(const gchar *name, const gchar *nick, const gchar *blurb, gunichar default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_enum)(const gchar *name, const gchar *nick, const gchar *blurb, GType enum_type, gint default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_flags)(const gchar *name, const gchar *nick, const gchar *blurb, GType flags_type, guint default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_float)(const gchar *name, const gchar *nick, const gchar *blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_double)(const gchar *name, const gchar *nick, const gchar *blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_string)(const gchar *name, const gchar *nick, const gchar *blurb, const gchar *default_value, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_param)(const gchar *name, const gchar *nick, const gchar *blurb, GType param_type, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_boxed)(const gchar *name, const gchar *nick, const gchar *blurb, GType boxed_type, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_pointer)(const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_value_array)(const gchar *name, const gchar *nick, const gchar *blurb, GParamSpec *element_spec, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_object)(const gchar *name, const gchar *nick, const gchar *blurb, GType object_type, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_override)(const gchar *name, GParamSpec *overridden);
    GParamSpec* (*ptr_g_param_spec_gtype)(const gchar *name, const gchar *nick, const gchar *blurb, GType is_a_type, GParamFlags flags);
    GParamSpec* (*ptr_g_param_spec_variant)(const gchar *name, const gchar *nick, const gchar *blurb, const GVariantType *type, GVariant *default_value, GParamFlags flags);
    // Header /usr/include/glib-2.0/gobject/gsignal.h
    guint (*ptr_g_signal_new_valist)(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args);
    void (*ptr_g_signal_set_va_marshaller)(guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller);
    void (*ptr_g_signal_emitv)(const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value);
    void (*ptr_g_signal_emit_valist)(gpointer instance, guint signal_id, GQuark detail, va_list var_args);
    guint (*ptr_g_signal_lookup)(const gchar *name, GType itype);
    const gchar * (*ptr_g_signal_name)(guint signal_id);
    void (*ptr_g_signal_query)(guint signal_id, GSignalQuery *query);
    guint* (*ptr_g_signal_list_ids)(GType itype, guint *n_ids);
    gboolean (*ptr_g_signal_is_valid_name)(const gchar *name);
    gboolean (*ptr_g_signal_parse_name)(const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark);
    GSignalInvocationHint* (*ptr_g_signal_get_invocation_hint)(gpointer instance);
    void (*ptr_g_signal_stop_emission)(gpointer instance, guint signal_id, GQuark detail);
    void (*ptr_g_signal_stop_emission_by_name)(gpointer instance, const gchar *detailed_signal);
    gulong (*ptr_g_signal_add_emission_hook)(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy);
    void (*ptr_g_signal_remove_emission_hook)(guint signal_id, gulong hook_id);
    gboolean (*ptr_g_signal_has_handler_pending)(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked);
    gulong (*ptr_g_signal_connect_closure_by_id)(gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after);
    gulong (*ptr_g_signal_connect_closure)(gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after);
    gulong (*ptr_g_signal_connect_data)(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags);
    void (*ptr_g_signal_handler_block)(gpointer instance, gulong handler_id);
    void (*ptr_g_signal_handler_unblock)(gpointer instance, gulong handler_id);
    void (*ptr_g_signal_handler_disconnect)(gpointer instance, gulong handler_id);
    gboolean (*ptr_g_signal_handler_is_connected)(gpointer instance, gulong handler_id);
    gulong (*ptr_g_signal_handler_find)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
    guint (*ptr_g_signal_handlers_block_matched)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
    guint (*ptr_g_signal_handlers_unblock_matched)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
    guint (*ptr_g_signal_handlers_disconnect_matched)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
    void (*ptr_g_clear_signal_handler)(gulong *handler_id_ptr, gpointer instance);
    void (*ptr_g_signal_override_class_closure)(guint signal_id, GType instance_type, GClosure *class_closure);
    void (*ptr_g_signal_override_class_handler)(const gchar *signal_name, GType instance_type, GCallback class_handler);
    void (*ptr_g_signal_chain_from_overridden)(const GValue *instance_and_params, GValue *return_value);
    gboolean (*ptr_g_signal_accumulator_true_handled)(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
    gboolean (*ptr_g_signal_accumulator_first_wins)(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
    void (*ptr_g_signal_handlers_destroy)(gpointer instance);
    void (*ptr__g_signals_destroy)(GType itype);
    guint (*ptr_g_signal_newv)(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types);
    // Header /usr/include/glib-2.0/gobject/gsignalgroup.h
    GType (*ptr_g_signal_group_get_type)(void);
    GSignalGroup* (*ptr_g_signal_group_new)(GType target_type);
    void (*ptr_g_signal_group_set_target)(GSignalGroup *self, gpointer target);
    gpointer (*ptr_g_signal_group_dup_target)(GSignalGroup *self);
    void (*ptr_g_signal_group_block)(GSignalGroup *self);
    void (*ptr_g_signal_group_unblock)(GSignalGroup *self);
    void (*ptr_g_signal_group_connect_closure)(GSignalGroup *self, const gchar *detailed_signal, GClosure *closure, gboolean after);
    void (*ptr_g_signal_group_connect_object)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer object, GConnectFlags flags);
    void (*ptr_g_signal_group_connect_data)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify notify, GConnectFlags flags);
    void (*ptr_g_signal_group_connect)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
    void (*ptr_g_signal_group_connect_after)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
    void (*ptr_g_signal_group_connect_swapped)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
    // Header /usr/include/glib-2.0/gobject/gsourceclosure.h
    void (*ptr_g_source_set_dummy_callback)(GSource *source);
    void (*ptr_g_source_set_closure)(GSource *source, GClosure *closure);
    // Header /usr/include/glib-2.0/gobject/gtype.h
    void (*ptr_g_type_init_with_debug_flags)(GTypeDebugFlags debug_flags);
    GQuark (*ptr_g_type_qname)(GType type);
    GType (*ptr_g_type_from_name)(const gchar *name);
    GType (*ptr_g_type_parent)(GType type);
    guint (*ptr_g_type_depth)(GType type);
    GType (*ptr_g_type_next_base)(GType leaf_type, GType root_type);
    gboolean (*ptr_g_type_is_a)(GType type, GType is_a_type);
    gpointer (*ptr_g_type_class_ref)(GType type);
    gpointer (*ptr_g_type_class_peek)(GType type);
    gpointer (*ptr_g_type_class_peek_static)(GType type);
    void (*ptr_g_type_class_unref)(gpointer g_class);
    gpointer (*ptr_g_type_class_peek_parent)(gpointer g_class);
    gpointer (*ptr_g_type_interface_peek)(gpointer instance_class, GType iface_type);
    gpointer (*ptr_g_type_interface_peek_parent)(gpointer g_iface);
    gpointer (*ptr_g_type_default_interface_ref)(GType g_type);
    gpointer (*ptr_g_type_default_interface_peek)(GType g_type);
    void (*ptr_g_type_default_interface_unref)(gpointer g_iface);
    GType* (*ptr_g_type_children)(GType type, guint *n_children);
    GType* (*ptr_g_type_interfaces)(GType type, guint *n_interfaces);
    void (*ptr_g_type_set_qdata)(GType type, GQuark quark, gpointer data);
    gpointer (*ptr_g_type_get_qdata)(GType type, GQuark quark);
    void (*ptr_g_type_query)(GType type, GTypeQuery *query);
    int (*ptr_g_type_get_instance_count)(GType type);
    GType (*ptr_g_type_register_static_simple)(GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags);
    GType (*ptr_g_type_register_dynamic)(GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags);
    GType (*ptr_g_type_register_fundamental)(GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags);
    void (*ptr_g_type_add_interface_static)(GType instance_type, GType interface_type, const GInterfaceInfo *info);
    void (*ptr_g_type_add_interface_dynamic)(GType instance_type, GType interface_type, GTypePlugin *plugin);
    void (*ptr_g_type_interface_add_prerequisite)(GType interface_type, GType prerequisite_type);
    GType* (*ptr_g_type_interface_prerequisites)(GType interface_type, guint *n_prerequisites);
    GType (*ptr_g_type_interface_instantiatable_prerequisite)(GType interface_type);
    void (*ptr_g_type_class_add_private)(gpointer g_class, gsize private_size);
    gint (*ptr_g_type_add_instance_private)(GType class_type, gsize private_size);
    gpointer (*ptr_g_type_instance_get_private)(GTypeInstance *instance, GType private_type);
    void (*ptr_g_type_class_adjust_private_offset)(gpointer g_class, gint *private_size_or_offset);
    void (*ptr_g_type_add_class_private)(GType class_type, gsize private_size);
    gpointer (*ptr_g_type_class_get_private)(GTypeClass *klass, GType private_type);
    gint (*ptr_g_type_class_get_instance_private_offset)(gpointer g_class);
    void (*ptr_g_type_ensure)(GType type);
    guint (*ptr_g_type_get_type_registration_serial)(void);
    GTypePlugin* (*ptr_g_type_get_plugin)(GType type);
    GTypePlugin* (*ptr_g_type_interface_get_plugin)(GType instance_type, GType interface_type);
    GType (*ptr_g_type_fundamental_next)(void);
    GType (*ptr_g_type_fundamental)(GType type_id);
    GTypeInstance* (*ptr_g_type_create_instance)(GType type);
    void (*ptr_g_type_free_instance)(GTypeInstance *instance);
    void (*ptr_g_type_add_class_cache_func)(gpointer cache_data, GTypeClassCacheFunc cache_func);
    void (*ptr_g_type_remove_class_cache_func)(gpointer cache_data, GTypeClassCacheFunc cache_func);
    void (*ptr_g_type_class_unref_uncached)(gpointer g_class);
    void (*ptr_g_type_add_interface_check)(gpointer check_data, GTypeInterfaceCheckFunc check_func);
    void (*ptr_g_type_remove_interface_check)(gpointer check_data, GTypeInterfaceCheckFunc check_func);
    GTypeValueTable* (*ptr_g_type_value_table_peek)(GType type);
    gboolean (*ptr_g_type_check_instance)(GTypeInstance *instance);
    GTypeInstance* (*ptr_g_type_check_instance_cast)(GTypeInstance *instance, GType iface_type);
    gboolean (*ptr_g_type_check_instance_is_a)(GTypeInstance *instance, GType iface_type);
    gboolean (*ptr_g_type_check_instance_is_fundamentally_a)(GTypeInstance *instance, GType fundamental_type);
    GTypeClass* (*ptr_g_type_check_class_cast)(GTypeClass *g_class, GType is_a_type);
    gboolean (*ptr_g_type_check_class_is_a)(GTypeClass *g_class, GType is_a_type);
    gboolean (*ptr_g_type_check_is_value_type)(GType type);
    gboolean (*ptr_g_type_check_value)(const GValue *value);
    gboolean (*ptr_g_type_check_value_holds)(const GValue *value, GType type);
    gboolean (*ptr_g_type_test_flags)(GType type, guint flags);
    const gchar * (*ptr_g_type_name_from_instance)(GTypeInstance *instance);
    const gchar * (*ptr_g_type_name_from_class)(GTypeClass *g_class);
    // Header /usr/include/glib-2.0/gobject/gtypemodule.h
    GType (*ptr_g_type_module_get_type)(void);
    gboolean (*ptr_g_type_module_use)(GTypeModule *module);
    void (*ptr_g_type_module_unuse)(GTypeModule *module);
    void (*ptr_g_type_module_set_name)(GTypeModule *module, const gchar *name);
    GType (*ptr_g_type_module_register_type)(GTypeModule *module, GType parent_type, const gchar *type_name, const GTypeInfo *type_info, GTypeFlags flags);
    void (*ptr_g_type_module_add_interface)(GTypeModule *module, GType instance_type, GType interface_type, const GInterfaceInfo *interface_info);
    GType (*ptr_g_type_module_register_enum)(GTypeModule *module, const gchar *name, const GEnumValue *const_static_values);
    GType (*ptr_g_type_module_register_flags)(GTypeModule *module, const gchar *name, const GFlagsValue *const_static_values);
    // Header /usr/include/glib-2.0/gobject/gtypeplugin.h
    GType (*ptr_g_type_plugin_get_type)(void);
    void (*ptr_g_type_plugin_use)(GTypePlugin *plugin);
    void (*ptr_g_type_plugin_unuse)(GTypePlugin *plugin);
    void (*ptr_g_type_plugin_complete_type_info)(GTypePlugin *plugin, GType g_type, GTypeInfo *info, GTypeValueTable *value_table);
    void (*ptr_g_type_plugin_complete_interface_info)(GTypePlugin *plugin, GType instance_type, GType interface_type, GInterfaceInfo *info);
    // Header /usr/include/glib-2.0/gobject/gvalue.h
    void (*ptr_g_value_copy)(const GValue *src_value, GValue *dest_value);
    GValue* (*ptr_g_value_reset)(GValue *value);
    void (*ptr_g_value_unset)(GValue *value);
    void (*ptr_g_value_set_instance)(GValue *value, gpointer instance);
    void (*ptr_g_value_init_from_instance)(GValue *value, gpointer instance);
    gboolean (*ptr_g_value_fits_pointer)(const GValue *value);
    gpointer (*ptr_g_value_peek_pointer)(const GValue *value);
    gboolean (*ptr_g_value_type_compatible)(GType src_type, GType dest_type);
    gboolean (*ptr_g_value_type_transformable)(GType src_type, GType dest_type);
    gboolean (*ptr_g_value_transform)(const GValue *src_value, GValue *dest_value);
    void (*ptr_g_value_register_transform_func)(GType src_type, GType dest_type, GValueTransform transform_func);
    GValue* (*ptr_g_value_init)(GValue *value, GType g_type);
    // Header /usr/include/glib-2.0/gobject/gvaluearray.h
    GType (*ptr_g_value_array_get_type)(void);
    GValue* (*ptr_g_value_array_get_nth)(GValueArray *value_array, guint index_);
    GValueArray* (*ptr_g_value_array_new)(guint n_prealloced);
    void (*ptr_g_value_array_free)(GValueArray *value_array);
    GValueArray* (*ptr_g_value_array_copy)(const GValueArray *value_array);
    GValueArray* (*ptr_g_value_array_prepend)(GValueArray *value_array, const GValue *value);
    GValueArray* (*ptr_g_value_array_append)(GValueArray *value_array, const GValue *value);
    GValueArray* (*ptr_g_value_array_insert)(GValueArray *value_array, guint index_, const GValue *value);
    GValueArray* (*ptr_g_value_array_remove)(GValueArray *value_array, guint index_);
    GValueArray* (*ptr_g_value_array_sort)(GValueArray *value_array, GCompareFunc compare_func);
    GValueArray* (*ptr_g_value_array_sort_with_data)(GValueArray *value_array, GCompareDataFunc compare_func, gpointer user_data);
    // Header /usr/include/glib-2.0/gobject/gvaluecollector.h
    // Header /usr/include/glib-2.0/gobject/gvaluetypes.h
    gchar (*ptr_g_value_get_char)(const GValue *value);
    void (*ptr_g_value_set_schar)(GValue *value, gint8 v_char);
    gint8 (*ptr_g_value_get_schar)(const GValue *value);
    void (*ptr_g_value_set_uchar)(GValue *value, guchar v_uchar);
    guchar (*ptr_g_value_get_uchar)(const GValue *value);
    void (*ptr_g_value_set_boolean)(GValue *value, gboolean v_boolean);
    gboolean (*ptr_g_value_get_boolean)(const GValue *value);
    void (*ptr_g_value_set_int)(GValue *value, gint v_int);
    gint (*ptr_g_value_get_int)(const GValue *value);
    void (*ptr_g_value_set_uint)(GValue *value, guint v_uint);
    guint (*ptr_g_value_get_uint)(const GValue *value);
    void (*ptr_g_value_set_long)(GValue *value, glong v_long);
    glong (*ptr_g_value_get_long)(const GValue *value);
    void (*ptr_g_value_set_ulong)(GValue *value, gulong v_ulong);
    gulong (*ptr_g_value_get_ulong)(const GValue *value);
    void (*ptr_g_value_set_int64)(GValue *value, gint64 v_int64);
    gint64 (*ptr_g_value_get_int64)(const GValue *value);
    void (*ptr_g_value_set_uint64)(GValue *value, guint64 v_uint64);
    guint64 (*ptr_g_value_get_uint64)(const GValue *value);
    void (*ptr_g_value_set_float)(GValue *value, gfloat v_float);
    gfloat (*ptr_g_value_get_float)(const GValue *value);
    void (*ptr_g_value_set_double)(GValue *value, gdouble v_double);
    gdouble (*ptr_g_value_get_double)(const GValue *value);
    void (*ptr_g_value_set_string)(GValue *value, const gchar *v_string);
    void (*ptr_g_value_set_static_string)(GValue *value, const gchar *v_string);
    void (*ptr_g_value_set_interned_string)(GValue *value, const gchar *v_string);
    const gchar * (*ptr_g_value_get_string)(const GValue *value);
    gchar* (*ptr_g_value_dup_string)(const GValue *value);
    gchar* (*ptr_g_value_steal_string)(GValue *value);
    void (*ptr_g_value_set_pointer)(GValue *value, gpointer v_pointer);
    gpointer (*ptr_g_value_get_pointer)(const GValue *value);
    GType (*ptr_g_gtype_get_type)(void);
    void (*ptr_g_value_set_gtype)(GValue *value, GType v_gtype);
    GType (*ptr_g_value_get_gtype)(const GValue *value);
    void (*ptr_g_value_set_variant)(GValue *value, GVariant *variant);
    void (*ptr_g_value_take_variant)(GValue *value, GVariant *variant);
    GVariant* (*ptr_g_value_get_variant)(const GValue *value);
    GVariant* (*ptr_g_value_dup_variant)(const GValue *value);
    GType (*ptr_g_pointer_type_register_static)(const gchar *name);
    gchar* (*ptr_g_strdup_value_contents)(const GValue *value);
    void (*ptr_g_value_take_string)(GValue *value, gchar *v_string);
    void (*ptr_g_value_set_string_take_ownership)(GValue *value, gchar *v_string);
    void (*ptr_g_value_set_char)(GValue *value, gchar v_char);
    // Header /usr/include/glib-2.0/gio/gaction.h
    GType (*ptr_g_action_get_type)(void);
    const gchar * (*ptr_g_action_get_name)(GAction *action);
    const GVariantType * (*ptr_g_action_get_parameter_type)(GAction *action);
    const GVariantType * (*ptr_g_action_get_state_type)(GAction *action);
    GVariant * (*ptr_g_action_get_state_hint)(GAction *action);
    gboolean (*ptr_g_action_get_enabled)(GAction *action);
    GVariant * (*ptr_g_action_get_state)(GAction *action);
    void (*ptr_g_action_change_state)(GAction *action, GVariant *value);
    void (*ptr_g_action_activate)(GAction *action, GVariant *parameter);
    gboolean (*ptr_g_action_name_is_valid)(const gchar *action_name);
    gboolean (*ptr_g_action_parse_detailed_name)(const gchar *detailed_name, gchar **action_name, GVariant **target_value, GError **error);
    gchar * (*ptr_g_action_print_detailed_name)(const gchar *action_name, GVariant *target_value);
    // Header /usr/include/glib-2.0/gio/gactiongroup.h
    GType (*ptr_g_action_group_get_type)(void);
    gboolean (*ptr_g_action_group_has_action)(GActionGroup *action_group, const gchar *action_name);
    gchar ** (*ptr_g_action_group_list_actions)(GActionGroup *action_group);
    const GVariantType * (*ptr_g_action_group_get_action_parameter_type)(GActionGroup *action_group, const gchar *action_name);
    const GVariantType * (*ptr_g_action_group_get_action_state_type)(GActionGroup *action_group, const gchar *action_name);
    GVariant * (*ptr_g_action_group_get_action_state_hint)(GActionGroup *action_group, const gchar *action_name);
    gboolean (*ptr_g_action_group_get_action_enabled)(GActionGroup *action_group, const gchar *action_name);
    GVariant * (*ptr_g_action_group_get_action_state)(GActionGroup *action_group, const gchar *action_name);
    void (*ptr_g_action_group_change_action_state)(GActionGroup *action_group, const gchar *action_name, GVariant *value);
    void (*ptr_g_action_group_activate_action)(GActionGroup *action_group, const gchar *action_name, GVariant *parameter);
    void (*ptr_g_action_group_action_added)(GActionGroup *action_group, const gchar *action_name);
    void (*ptr_g_action_group_action_removed)(GActionGroup *action_group, const gchar *action_name);
    void (*ptr_g_action_group_action_enabled_changed)(GActionGroup *action_group, const gchar *action_name, gboolean enabled);
    void (*ptr_g_action_group_action_state_changed)(GActionGroup *action_group, const gchar *action_name, GVariant *state);
    gboolean (*ptr_g_action_group_query_action)(GActionGroup *action_group, const gchar *action_name, gboolean *enabled, const GVariantType **parameter_type, const GVariantType **state_type, GVariant **state_hint, GVariant **state);
    // Header /usr/include/glib-2.0/gio/gactiongroupexporter.h
    void (*ptr_g_dbus_connection_unexport_action_group)(GDBusConnection *connection, guint export_id);
    guint (*ptr_g_dbus_connection_export_action_group)(GDBusConnection *connection, const gchar *object_path, GActionGroup *action_group, GError **error);
    // Header /usr/include/glib-2.0/gio/gactionmap.h
    GType (*ptr_g_action_map_get_type)(void);
    GAction * (*ptr_g_action_map_lookup_action)(GActionMap *action_map, const gchar *action_name);
    void (*ptr_g_action_map_add_action)(GActionMap *action_map, GAction *action);
    void (*ptr_g_action_map_remove_action)(GActionMap *action_map, const gchar *action_name);
    void (*ptr_g_action_map_add_action_entries)(GActionMap *action_map, const GActionEntry *entries, gint n_entries, gpointer user_data);
    void (*ptr_g_action_map_remove_action_entries)(GActionMap *action_map, const GActionEntry *entries, gint n_entries);
    // Header /usr/include/glib-2.0/gio/gappinfo.h
    GType (*ptr_g_app_info_get_type)(void);
    GType (*ptr_g_app_launch_context_get_type)(void);
    GAppInfo * (*ptr_g_app_info_create_from_commandline)(const char *commandline, const char *application_name, GAppInfoCreateFlags flags, GError **error);
    GAppInfo * (*ptr_g_app_info_dup)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_equal)(GAppInfo *appinfo1, GAppInfo *appinfo2);
    const char* (*ptr_g_app_info_get_id)(GAppInfo *appinfo);
    const char* (*ptr_g_app_info_get_name)(GAppInfo *appinfo);
    const char* (*ptr_g_app_info_get_display_name)(GAppInfo *appinfo);
    const char* (*ptr_g_app_info_get_description)(GAppInfo *appinfo);
    const char* (*ptr_g_app_info_get_executable)(GAppInfo *appinfo);
    const char* (*ptr_g_app_info_get_commandline)(GAppInfo *appinfo);
    GIcon * (*ptr_g_app_info_get_icon)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_launch)(GAppInfo *appinfo, GList *files, GAppLaunchContext *context, GError **error);
    gboolean (*ptr_g_app_info_supports_uris)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_supports_files)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_launch_uris)(GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GError **error);
    void (*ptr_g_app_info_launch_uris_async)(GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_app_info_launch_uris_finish)(GAppInfo *appinfo, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_app_info_should_show)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_set_as_default_for_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    gboolean (*ptr_g_app_info_set_as_default_for_extension)(GAppInfo *appinfo, const char *extension, GError **error);
    gboolean (*ptr_g_app_info_add_supports_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    gboolean (*ptr_g_app_info_can_remove_supports_type)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_remove_supports_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    const char** (*ptr_g_app_info_get_supported_types)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_can_delete)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_delete)(GAppInfo *appinfo);
    gboolean (*ptr_g_app_info_set_as_last_used_for_type)(GAppInfo *appinfo, const char *content_type, GError **error);
    GList * (*ptr_g_app_info_get_all)(void);
    GList * (*ptr_g_app_info_get_all_for_type)(const char *content_type);
    GList * (*ptr_g_app_info_get_recommended_for_type)(const gchar *content_type);
    GList * (*ptr_g_app_info_get_fallback_for_type)(const gchar *content_type);
    void (*ptr_g_app_info_reset_type_associations)(const char *content_type);
    GAppInfo* (*ptr_g_app_info_get_default_for_type)(const char *content_type, gboolean must_support_uris);
    void (*ptr_g_app_info_get_default_for_type_async)(const char *content_type, gboolean must_support_uris, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GAppInfo* (*ptr_g_app_info_get_default_for_type_finish)(GAsyncResult *result, GError **error);
    GAppInfo* (*ptr_g_app_info_get_default_for_uri_scheme)(const char *uri_scheme);
    void (*ptr_g_app_info_get_default_for_uri_scheme_async)(const char *uri_scheme, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GAppInfo* (*ptr_g_app_info_get_default_for_uri_scheme_finish)(GAsyncResult *result, GError **error);
    gboolean (*ptr_g_app_info_launch_default_for_uri)(const char *uri, GAppLaunchContext *context, GError **error);
    void (*ptr_g_app_info_launch_default_for_uri_async)(const char *uri, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_app_info_launch_default_for_uri_finish)(GAsyncResult *result, GError **error);
    GAppLaunchContext* (*ptr_g_app_launch_context_new)(void);
    void (*ptr_g_app_launch_context_setenv)(GAppLaunchContext *context, const char *variable, const char *value);
    void (*ptr_g_app_launch_context_unsetenv)(GAppLaunchContext *context, const char *variable);
    char ** (*ptr_g_app_launch_context_get_environment)(GAppLaunchContext *context);
    char * (*ptr_g_app_launch_context_get_display)(GAppLaunchContext *context, GAppInfo *info, GList *files);
    char * (*ptr_g_app_launch_context_get_startup_notify_id)(GAppLaunchContext *context, GAppInfo *info, GList *files);
    void (*ptr_g_app_launch_context_launch_failed)(GAppLaunchContext *context, const char * startup_notify_id);
    GType (*ptr_g_app_info_monitor_get_type)(void);
    GAppInfoMonitor * (*ptr_g_app_info_monitor_get)(void);
    // Header /usr/include/glib-2.0/gio/gapplication.h
    GType (*ptr_g_application_get_type)(void);
    gboolean (*ptr_g_application_id_is_valid)(const gchar *application_id);
    GApplication * (*ptr_g_application_new)(const gchar *application_id, GApplicationFlags flags);
    const gchar * (*ptr_g_application_get_application_id)(GApplication *application);
    void (*ptr_g_application_set_application_id)(GApplication *application, const gchar *application_id);
    const gchar * (*ptr_g_application_get_version)(GApplication *application);
    void (*ptr_g_application_set_version)(GApplication *application, const gchar *version);
    GDBusConnection * (*ptr_g_application_get_dbus_connection)(GApplication *application);
    const gchar * (*ptr_g_application_get_dbus_object_path)(GApplication *application);
    guint (*ptr_g_application_get_inactivity_timeout)(GApplication *application);
    void (*ptr_g_application_set_inactivity_timeout)(GApplication *application, guint inactivity_timeout);
    GApplicationFlags (*ptr_g_application_get_flags)(GApplication *application);
    void (*ptr_g_application_set_flags)(GApplication *application, GApplicationFlags flags);
    const gchar * (*ptr_g_application_get_resource_base_path)(GApplication *application);
    void (*ptr_g_application_set_resource_base_path)(GApplication *application, const gchar *resource_path);
    void (*ptr_g_application_set_action_group)(GApplication *application, GActionGroup *action_group);
    void (*ptr_g_application_add_main_option_entries)(GApplication *application, const GOptionEntry *entries);
    void (*ptr_g_application_add_main_option)(GApplication *application, const char *long_name, char short_name, GOptionFlags flags, GOptionArg arg, const char *description, const char *arg_description);
    void (*ptr_g_application_add_option_group)(GApplication *application, GOptionGroup *group);
    void (*ptr_g_application_set_option_context_parameter_string)(GApplication *application, const gchar *parameter_string);
    void (*ptr_g_application_set_option_context_summary)(GApplication *application, const gchar *summary);
    void (*ptr_g_application_set_option_context_description)(GApplication *application, const gchar *description);
    gboolean (*ptr_g_application_get_is_registered)(GApplication *application);
    gboolean (*ptr_g_application_get_is_remote)(GApplication *application);
    gboolean (*ptr_g_application_register)(GApplication *application, GCancellable *cancellable, GError **error);
    void (*ptr_g_application_hold)(GApplication *application);
    void (*ptr_g_application_release)(GApplication *application);
    void (*ptr_g_application_activate)(GApplication *application);
    void (*ptr_g_application_open)(GApplication *application, GFile **files, gint n_files, const gchar *hint);
    int (*ptr_g_application_run)(GApplication *application, int argc, char **argv);
    void (*ptr_g_application_quit)(GApplication *application);
    GApplication * (*ptr_g_application_get_default)(void);
    void (*ptr_g_application_set_default)(GApplication *application);
    void (*ptr_g_application_mark_busy)(GApplication *application);
    void (*ptr_g_application_unmark_busy)(GApplication *application);
    gboolean (*ptr_g_application_get_is_busy)(GApplication *application);
    void (*ptr_g_application_send_notification)(GApplication *application, const gchar *id, GNotification *notification);
    void (*ptr_g_application_withdraw_notification)(GApplication *application, const gchar *id);
    void (*ptr_g_application_bind_busy_property)(GApplication *application, gpointer object, const gchar *property);
    void (*ptr_g_application_unbind_busy_property)(GApplication *application, gpointer object, const gchar *property);
    // Header /usr/include/glib-2.0/gio/gapplicationcommandline.h
    GType (*ptr_g_application_command_line_get_type)(void);
    gchar ** (*ptr_g_application_command_line_get_arguments)(GApplicationCommandLine *cmdline, int *argc);
    GVariantDict * (*ptr_g_application_command_line_get_options_dict)(GApplicationCommandLine *cmdline);
    GInputStream * (*ptr_g_application_command_line_get_stdin)(GApplicationCommandLine *cmdline);
    const gchar * const * (*ptr_g_application_command_line_get_environ)(GApplicationCommandLine *cmdline);
    const gchar * (*ptr_g_application_command_line_getenv)(GApplicationCommandLine *cmdline, const gchar *name);
    const gchar * (*ptr_g_application_command_line_get_cwd)(GApplicationCommandLine *cmdline);
    gboolean (*ptr_g_application_command_line_get_is_remote)(GApplicationCommandLine *cmdline);
    void (*ptr_g_application_command_line_print_literal)(GApplicationCommandLine *cmdline, const gchar *message);
    void (*ptr_g_application_command_line_printerr_literal)(GApplicationCommandLine *cmdline, const gchar *message);
    int (*ptr_g_application_command_line_get_exit_status)(GApplicationCommandLine *cmdline);
    void (*ptr_g_application_command_line_set_exit_status)(GApplicationCommandLine *cmdline, int exit_status);
    GVariant * (*ptr_g_application_command_line_get_platform_data)(GApplicationCommandLine *cmdline);
    GFile * (*ptr_g_application_command_line_create_file_for_arg)(GApplicationCommandLine *cmdline, const gchar *arg);
    void (*ptr_g_application_command_line_done)(GApplicationCommandLine *cmdline);
    // Header /usr/include/glib-2.0/gio/gasyncinitable.h
    GType (*ptr_g_async_initable_get_type)(void);
    void (*ptr_g_async_initable_init_async)(GAsyncInitable *initable, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_async_initable_init_finish)(GAsyncInitable *initable, GAsyncResult *res, GError **error);
    GObject* (*ptr_g_async_initable_new_finish)(GAsyncInitable *initable, GAsyncResult *res, GError **error);
    // Header /usr/include/glib-2.0/gio/gasyncresult.h
    GType (*ptr_g_async_result_get_type)(void);
    gpointer (*ptr_g_async_result_get_user_data)(GAsyncResult *res);
    GObject* (*ptr_g_async_result_get_source_object)(GAsyncResult *res);
    gboolean (*ptr_g_async_result_legacy_propagate_error)(GAsyncResult *res, GError **error);
    gboolean (*ptr_g_async_result_is_tagged)(GAsyncResult *res, gpointer source_tag);
    // Header /usr/include/glib-2.0/gio/gbufferedinputstream.h
    GType (*ptr_g_buffered_input_stream_get_type)(void);
    GInputStream* (*ptr_g_buffered_input_stream_new)(GInputStream *base_stream);
    GInputStream* (*ptr_g_buffered_input_stream_new_sized)(GInputStream *base_stream, gsize size);
    gsize (*ptr_g_buffered_input_stream_get_buffer_size)(GBufferedInputStream *stream);
    void (*ptr_g_buffered_input_stream_set_buffer_size)(GBufferedInputStream *stream, gsize size);
    gsize (*ptr_g_buffered_input_stream_get_available)(GBufferedInputStream *stream);
    gsize (*ptr_g_buffered_input_stream_peek)(GBufferedInputStream *stream, void *buffer, gsize offset, gsize count);
    const void* (*ptr_g_buffered_input_stream_peek_buffer)(GBufferedInputStream *stream, gsize *count);
    gssize (*ptr_g_buffered_input_stream_fill)(GBufferedInputStream *stream, gssize count, GCancellable *cancellable, GError **error);
    void (*ptr_g_buffered_input_stream_fill_async)(GBufferedInputStream *stream, gssize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*ptr_g_buffered_input_stream_fill_finish)(GBufferedInputStream *stream, GAsyncResult *result, GError **error);
    int (*ptr_g_buffered_input_stream_read_byte)(GBufferedInputStream *stream, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gbufferedoutputstream.h
    GType (*ptr_g_buffered_output_stream_get_type)(void);
    GOutputStream* (*ptr_g_buffered_output_stream_new)(GOutputStream *base_stream);
    GOutputStream* (*ptr_g_buffered_output_stream_new_sized)(GOutputStream *base_stream, gsize size);
    gsize (*ptr_g_buffered_output_stream_get_buffer_size)(GBufferedOutputStream *stream);
    void (*ptr_g_buffered_output_stream_set_buffer_size)(GBufferedOutputStream *stream, gsize size);
    gboolean (*ptr_g_buffered_output_stream_get_auto_grow)(GBufferedOutputStream *stream);
    void (*ptr_g_buffered_output_stream_set_auto_grow)(GBufferedOutputStream *stream, gboolean auto_grow);
    // Header /usr/include/glib-2.0/gio/gbytesicon.h
    GType (*ptr_g_bytes_icon_get_type)(void);
    GIcon * (*ptr_g_bytes_icon_new)(GBytes *bytes);
    GBytes * (*ptr_g_bytes_icon_get_bytes)(GBytesIcon *icon);
    // Header /usr/include/glib-2.0/gio/gcancellable.h
    GType (*ptr_g_cancellable_get_type)(void);
    GCancellable* (*ptr_g_cancellable_new)(void);
    gboolean (*ptr_g_cancellable_is_cancelled)(GCancellable *cancellable);
    gboolean (*ptr_g_cancellable_set_error_if_cancelled)(GCancellable *cancellable, GError **error);
    int (*ptr_g_cancellable_get_fd)(GCancellable *cancellable);
    gboolean (*ptr_g_cancellable_make_pollfd)(GCancellable *cancellable, GPollFD *pollfd);
    void (*ptr_g_cancellable_release_fd)(GCancellable *cancellable);
    GSource * (*ptr_g_cancellable_source_new)(GCancellable *cancellable);
    GCancellable* (*ptr_g_cancellable_get_current)(void);
    void (*ptr_g_cancellable_push_current)(GCancellable *cancellable);
    void (*ptr_g_cancellable_pop_current)(GCancellable *cancellable);
    void (*ptr_g_cancellable_reset)(GCancellable *cancellable);
    gulong (*ptr_g_cancellable_connect)(GCancellable *cancellable, GCallback callback, gpointer data, GDestroyNotify data_destroy_func);
    void (*ptr_g_cancellable_disconnect)(GCancellable *cancellable, gulong handler_id);
    void (*ptr_g_cancellable_cancel)(GCancellable *cancellable);
    // Header /usr/include/glib-2.0/gio/gcharsetconverter.h
    GType (*ptr_g_charset_converter_get_type)(void);
    GCharsetConverter* (*ptr_g_charset_converter_new)(const gchar *to_charset, const gchar *from_charset, GError **error);
    void (*ptr_g_charset_converter_set_use_fallback)(GCharsetConverter *converter, gboolean use_fallback);
    gboolean (*ptr_g_charset_converter_get_use_fallback)(GCharsetConverter *converter);
    guint (*ptr_g_charset_converter_get_num_fallbacks)(GCharsetConverter *converter);
    // Header /usr/include/glib-2.0/gio/gcontenttype.h
    gboolean (*ptr_g_content_type_is_a)(const gchar *type, const gchar *supertype);
    gboolean (*ptr_g_content_type_is_mime_type)(const gchar *type, const gchar *mime_type);
    gboolean (*ptr_g_content_type_is_unknown)(const gchar *type);
    gchar * (*ptr_g_content_type_get_description)(const gchar *type);
    gchar * (*ptr_g_content_type_get_mime_type)(const gchar *type);
    GIcon * (*ptr_g_content_type_get_icon)(const gchar *type);
    GIcon * (*ptr_g_content_type_get_symbolic_icon)(const gchar *type);
    gchar * (*ptr_g_content_type_get_generic_icon_name)(const gchar *type);
    gboolean (*ptr_g_content_type_can_be_executable)(const gchar *type);
    gchar * (*ptr_g_content_type_from_mime_type)(const gchar *mime_type);
    gchar * (*ptr_g_content_type_guess)(const gchar *filename, const guchar *data, gsize data_size, gboolean *result_uncertain);
    gchar ** (*ptr_g_content_type_guess_for_tree)(GFile *root);
    GList * (*ptr_g_content_types_get_registered)(void);
    const gchar * const* (*ptr_g_content_type_get_mime_dirs)(void);
    void (*ptr_g_content_type_set_mime_dirs)(const gchar * const *dirs);
    gboolean (*ptr_g_content_type_equals)(const gchar *type1, const gchar *type2);
    // Header /usr/include/glib-2.0/gio/gconverter.h
    GType (*ptr_g_converter_get_type)(void);
    GConverterResult (*ptr_g_converter_convert)(GConverter *converter, const void *inbuf, gsize inbuf_size, void *outbuf, gsize outbuf_size, GConverterFlags flags, gsize *bytes_read, gsize *bytes_written, GError **error);
    void (*ptr_g_converter_reset)(GConverter *converter);
    // Header /usr/include/glib-2.0/gio/gconverterinputstream.h
    GType (*ptr_g_converter_input_stream_get_type)(void);
    GInputStream* (*ptr_g_converter_input_stream_new)(GInputStream *base_stream, GConverter *converter);
    GConverter* (*ptr_g_converter_input_stream_get_converter)(GConverterInputStream *converter_stream);
    // Header /usr/include/glib-2.0/gio/gconverteroutputstream.h
    GType (*ptr_g_converter_output_stream_get_type)(void);
    GOutputStream* (*ptr_g_converter_output_stream_new)(GOutputStream *base_stream, GConverter *converter);
    GConverter* (*ptr_g_converter_output_stream_get_converter)(GConverterOutputStream *converter_stream);
    // Header /usr/include/glib-2.0/gio/gcredentials.h
    GType (*ptr_g_credentials_get_type)(void);
    GCredentials* (*ptr_g_credentials_new)(void);
    gchar* (*ptr_g_credentials_to_string)(GCredentials *credentials);
    gpointer (*ptr_g_credentials_get_native)(GCredentials *credentials, GCredentialsType native_type);
    void (*ptr_g_credentials_set_native)(GCredentials *credentials, GCredentialsType native_type, gpointer native);
    gboolean (*ptr_g_credentials_is_same_user)(GCredentials *credentials, GCredentials *other_credentials, GError **error);
    pid_t (*ptr_g_credentials_get_unix_pid)(GCredentials *credentials, GError **error);
    uid_t (*ptr_g_credentials_get_unix_user)(GCredentials *credentials, GError **error);
    gboolean (*ptr_g_credentials_set_unix_user)(GCredentials *credentials, uid_t uid, GError **error);
    // Header /usr/include/glib-2.0/gio/gdatagrambased.h
    GType (*ptr_g_datagram_based_get_type)(void);
    gint (*ptr_g_datagram_based_receive_messages)(GDatagramBased *datagram_based, GInputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
    gint (*ptr_g_datagram_based_send_messages)(GDatagramBased *datagram_based, GOutputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
    GSource * (*ptr_g_datagram_based_create_source)(GDatagramBased *datagram_based, GIOCondition condition, GCancellable *cancellable);
    GIOCondition (*ptr_g_datagram_based_condition_check)(GDatagramBased *datagram_based, GIOCondition condition);
    gboolean (*ptr_g_datagram_based_condition_wait)(GDatagramBased *datagram_based, GIOCondition condition, gint64 timeout, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gdatainputstream.h
    GType (*ptr_g_data_input_stream_get_type)(void);
    GDataInputStream * (*ptr_g_data_input_stream_new)(GInputStream *base_stream);
    void (*ptr_g_data_input_stream_set_byte_order)(GDataInputStream *stream, GDataStreamByteOrder order);
    GDataStreamByteOrder (*ptr_g_data_input_stream_get_byte_order)(GDataInputStream *stream);
    void (*ptr_g_data_input_stream_set_newline_type)(GDataInputStream *stream, GDataStreamNewlineType type);
    GDataStreamNewlineType (*ptr_g_data_input_stream_get_newline_type)(GDataInputStream *stream);
    guchar (*ptr_g_data_input_stream_read_byte)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    gint16 (*ptr_g_data_input_stream_read_int16)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    guint16 (*ptr_g_data_input_stream_read_uint16)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    gint32 (*ptr_g_data_input_stream_read_int32)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    guint32 (*ptr_g_data_input_stream_read_uint32)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    gint64 (*ptr_g_data_input_stream_read_int64)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    guint64 (*ptr_g_data_input_stream_read_uint64)(GDataInputStream *stream, GCancellable *cancellable, GError **error);
    char * (*ptr_g_data_input_stream_read_line)(GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
    char * (*ptr_g_data_input_stream_read_line_utf8)(GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
    void (*ptr_g_data_input_stream_read_line_async)(GDataInputStream *stream, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    char * (*ptr_g_data_input_stream_read_line_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    char * (*ptr_g_data_input_stream_read_line_finish_utf8)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    char * (*ptr_g_data_input_stream_read_until)(GDataInputStream *stream, const gchar *stop_chars, gsize *length, GCancellable *cancellable, GError **error);
    void (*ptr_g_data_input_stream_read_until_async)(GDataInputStream *stream, const gchar *stop_chars, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    char * (*ptr_g_data_input_stream_read_until_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    char * (*ptr_g_data_input_stream_read_upto)(GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gsize *length, GCancellable *cancellable, GError **error);
    void (*ptr_g_data_input_stream_read_upto_async)(GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    char * (*ptr_g_data_input_stream_read_upto_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
    // Header /usr/include/glib-2.0/gio/gdataoutputstream.h
    GType (*ptr_g_data_output_stream_get_type)(void);
    GDataOutputStream * (*ptr_g_data_output_stream_new)(GOutputStream *base_stream);
    void (*ptr_g_data_output_stream_set_byte_order)(GDataOutputStream *stream, GDataStreamByteOrder order);
    GDataStreamByteOrder (*ptr_g_data_output_stream_get_byte_order)(GDataOutputStream *stream);
    gboolean (*ptr_g_data_output_stream_put_byte)(GDataOutputStream *stream, guchar data, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_data_output_stream_put_int16)(GDataOutputStream *stream, gint16 data, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_data_output_stream_put_uint16)(GDataOutputStream *stream, guint16 data, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_data_output_stream_put_int32)(GDataOutputStream *stream, gint32 data, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_data_output_stream_put_uint32)(GDataOutputStream *stream, guint32 data, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_data_output_stream_put_int64)(GDataOutputStream *stream, gint64 data, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_data_output_stream_put_uint64)(GDataOutputStream *stream, guint64 data, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_data_output_stream_put_string)(GDataOutputStream *stream, const char *str, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gdbusactiongroup.h
    GType (*ptr_g_dbus_action_group_get_type)(void);
    GDBusActionGroup * (*ptr_g_dbus_action_group_get)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
    // Header /usr/include/glib-2.0/gio/gdbusaddress.h
    gboolean (*ptr_g_dbus_is_address)(const gchar *string);
    gboolean (*ptr_g_dbus_is_supported_address)(const gchar *string, GError **error);
    void (*ptr_g_dbus_address_get_stream)(const gchar *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GIOStream* (*ptr_g_dbus_address_get_stream_finish)(GAsyncResult *res, gchar **out_guid, GError **error);
    GIOStream* (*ptr_g_dbus_address_get_stream_sync)(const gchar *address, gchar **out_guid, GCancellable *cancellable, GError **error);
    gchar* (*ptr_g_dbus_address_get_for_bus_sync)(GBusType bus_type, GCancellable *cancellable, GError **error);
    gchar* (*ptr_g_dbus_address_escape_value)(const gchar *string);
    // Header /usr/include/glib-2.0/gio/gdbusauthobserver.h
    GType (*ptr_g_dbus_auth_observer_get_type)(void);
    GDBusAuthObserver* (*ptr_g_dbus_auth_observer_new)(void);
    gboolean (*ptr_g_dbus_auth_observer_authorize_authenticated_peer)(GDBusAuthObserver *observer, GIOStream *stream, GCredentials *credentials);
    gboolean (*ptr_g_dbus_auth_observer_allow_mechanism)(GDBusAuthObserver *observer, const gchar *mechanism);
    // Header /usr/include/glib-2.0/gio/gdbusconnection.h
    GType (*ptr_g_dbus_connection_get_type)(void);
    void (*ptr_g_bus_get)(GBusType bus_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusConnection* (*ptr_g_bus_get_finish)(GAsyncResult *res, GError **error);
    GDBusConnection* (*ptr_g_bus_get_sync)(GBusType bus_type, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_connection_new)(GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusConnection* (*ptr_g_dbus_connection_new_finish)(GAsyncResult *res, GError **error);
    GDBusConnection* (*ptr_g_dbus_connection_new_sync)(GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_connection_new_for_address)(const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusConnection* (*ptr_g_dbus_connection_new_for_address_finish)(GAsyncResult *res, GError **error);
    GDBusConnection* (*ptr_g_dbus_connection_new_for_address_sync)(const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_connection_start_message_processing)(GDBusConnection *connection);
    gboolean (*ptr_g_dbus_connection_is_closed)(GDBusConnection *connection);
    GIOStream* (*ptr_g_dbus_connection_get_stream)(GDBusConnection *connection);
    const gchar* (*ptr_g_dbus_connection_get_guid)(GDBusConnection *connection);
    const gchar* (*ptr_g_dbus_connection_get_unique_name)(GDBusConnection *connection);
    GCredentials* (*ptr_g_dbus_connection_get_peer_credentials)(GDBusConnection *connection);
    guint32 (*ptr_g_dbus_connection_get_last_serial)(GDBusConnection *connection);
    gboolean (*ptr_g_dbus_connection_get_exit_on_close)(GDBusConnection *connection);
    void (*ptr_g_dbus_connection_set_exit_on_close)(GDBusConnection *connection, gboolean exit_on_close);
    GDBusCapabilityFlags (*ptr_g_dbus_connection_get_capabilities)(GDBusConnection *connection);
    GDBusConnectionFlags (*ptr_g_dbus_connection_get_flags)(GDBusConnection *connection);
    void (*ptr_g_dbus_connection_close)(GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_dbus_connection_close_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    gboolean (*ptr_g_dbus_connection_close_sync)(GDBusConnection *connection, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_connection_flush)(GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_dbus_connection_flush_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    gboolean (*ptr_g_dbus_connection_flush_sync)(GDBusConnection *connection, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_dbus_connection_send_message)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, volatile guint32 *out_serial, GError **error);
    void (*ptr_g_dbus_connection_send_message_with_reply)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusMessage* (*ptr_g_dbus_connection_send_message_with_reply_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    GDBusMessage* (*ptr_g_dbus_connection_send_message_with_reply_sync)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_dbus_connection_emit_signal)(GDBusConnection *connection, const gchar *destination_bus_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, GError **error);
    void (*ptr_g_dbus_connection_call)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*ptr_g_dbus_connection_call_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error);
    GVariant* (*ptr_g_dbus_connection_call_sync)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_connection_call_with_unix_fd_list)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*ptr_g_dbus_connection_call_with_unix_fd_list_finish)(GDBusConnection *connection, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
    GVariant* (*ptr_g_dbus_connection_call_with_unix_fd_list_sync)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
    guint (*ptr_g_dbus_connection_register_object)(GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, const GDBusInterfaceVTable *vtable, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
    guint (*ptr_g_dbus_connection_register_object_with_closures)(GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, GClosure *method_call_closure, GClosure *get_property_closure, GClosure *set_property_closure, GError **error);
    gboolean (*ptr_g_dbus_connection_unregister_object)(GDBusConnection *connection, guint registration_id);
    guint (*ptr_g_dbus_connection_register_subtree)(GDBusConnection *connection, const gchar *object_path, const GDBusSubtreeVTable *vtable, GDBusSubtreeFlags flags, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
    gboolean (*ptr_g_dbus_connection_unregister_subtree)(GDBusConnection *connection, guint registration_id);
    guint (*ptr_g_dbus_connection_signal_subscribe)(GDBusConnection *connection, const gchar *sender, const gchar *interface_name, const gchar *member, const gchar *object_path, const gchar *arg0, GDBusSignalFlags flags, GDBusSignalCallback callback, gpointer user_data, GDestroyNotify user_data_free_func);
    void (*ptr_g_dbus_connection_signal_unsubscribe)(GDBusConnection *connection, guint subscription_id);
    guint (*ptr_g_dbus_connection_add_filter)(GDBusConnection *connection, GDBusMessageFilterFunction filter_function, gpointer user_data, GDestroyNotify user_data_free_func);
    void (*ptr_g_dbus_connection_remove_filter)(GDBusConnection *connection, guint filter_id);
    // Header /usr/include/glib-2.0/gio/gdbuserror.h
    gboolean (*ptr_g_dbus_error_is_remote_error)(const GError *error);
    gchar* (*ptr_g_dbus_error_get_remote_error)(const GError *error);
    gboolean (*ptr_g_dbus_error_strip_remote_error)(GError *error);
    gboolean (*ptr_g_dbus_error_register_error)(GQuark error_domain, gint error_code, const gchar *dbus_error_name);
    gboolean (*ptr_g_dbus_error_unregister_error)(GQuark error_domain, gint error_code, const gchar *dbus_error_name);
    void (*ptr_g_dbus_error_register_error_domain)(const gchar *error_domain_quark_name, volatile gsize *quark_volatile, const GDBusErrorEntry *entries, guint num_entries);
    GError* (*ptr_g_dbus_error_new_for_dbus_error)(const gchar *dbus_error_name, const gchar *dbus_error_message);
    void (*ptr_g_dbus_error_set_dbus_error_valist)(GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, va_list var_args);
    gchar* (*ptr_g_dbus_error_encode_gerror)(const GError *error);
    GQuark (*ptr_g_dbus_error_quark)(void);
    // Header /usr/include/glib-2.0/gio/gdbusinterface.h
    GType (*ptr_g_dbus_interface_get_type)(void);
    GDBusInterfaceInfo* (*ptr_g_dbus_interface_get_info)(GDBusInterface *interface_);
    GDBusObject* (*ptr_g_dbus_interface_get_object)(GDBusInterface *interface_);
    void (*ptr_g_dbus_interface_set_object)(GDBusInterface *interface_, GDBusObject *object);
    GDBusObject* (*ptr_g_dbus_interface_dup_object)(GDBusInterface *interface_);
    // Header /usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h
    GType (*ptr_g_dbus_interface_skeleton_get_type)(void);
    GDBusInterfaceSkeletonFlags (*ptr_g_dbus_interface_skeleton_get_flags)(GDBusInterfaceSkeleton *interface_);
    void (*ptr_g_dbus_interface_skeleton_set_flags)(GDBusInterfaceSkeleton *interface_, GDBusInterfaceSkeletonFlags flags);
    GDBusInterfaceInfo* (*ptr_g_dbus_interface_skeleton_get_info)(GDBusInterfaceSkeleton *interface_);
    GDBusInterfaceVTable* (*ptr_g_dbus_interface_skeleton_get_vtable)(GDBusInterfaceSkeleton *interface_);
    GVariant* (*ptr_g_dbus_interface_skeleton_get_properties)(GDBusInterfaceSkeleton *interface_);
    void (*ptr_g_dbus_interface_skeleton_flush)(GDBusInterfaceSkeleton *interface_);
    gboolean (*ptr_g_dbus_interface_skeleton_export)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection, const gchar *object_path, GError **error);
    void (*ptr_g_dbus_interface_skeleton_unexport)(GDBusInterfaceSkeleton *interface_);
    void (*ptr_g_dbus_interface_skeleton_unexport_from_connection)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
    GDBusConnection* (*ptr_g_dbus_interface_skeleton_get_connection)(GDBusInterfaceSkeleton *interface_);
    GList* (*ptr_g_dbus_interface_skeleton_get_connections)(GDBusInterfaceSkeleton *interface_);
    gboolean (*ptr_g_dbus_interface_skeleton_has_connection)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
    const gchar* (*ptr_g_dbus_interface_skeleton_get_object_path)(GDBusInterfaceSkeleton *interface_);
    // Header /usr/include/glib-2.0/gio/gdbusintrospection.h
    GDBusMethodInfo* (*ptr_g_dbus_interface_info_lookup_method)(GDBusInterfaceInfo *info, const gchar *name);
    GDBusSignalInfo* (*ptr_g_dbus_interface_info_lookup_signal)(GDBusInterfaceInfo *info, const gchar *name);
    GDBusPropertyInfo* (*ptr_g_dbus_interface_info_lookup_property)(GDBusInterfaceInfo *info, const gchar *name);
    void (*ptr_g_dbus_interface_info_cache_build)(GDBusInterfaceInfo *info);
    void (*ptr_g_dbus_interface_info_cache_release)(GDBusInterfaceInfo *info);
    void (*ptr_g_dbus_interface_info_generate_xml)(GDBusInterfaceInfo *info, guint indent, GString *string_builder);
    GDBusNodeInfo* (*ptr_g_dbus_node_info_new_for_xml)(const gchar *xml_data, GError **error);
    GDBusInterfaceInfo* (*ptr_g_dbus_node_info_lookup_interface)(GDBusNodeInfo *info, const gchar *name);
    void (*ptr_g_dbus_node_info_generate_xml)(GDBusNodeInfo *info, guint indent, GString *string_builder);
    GDBusNodeInfo* (*ptr_g_dbus_node_info_ref)(GDBusNodeInfo *info);
    GDBusInterfaceInfo* (*ptr_g_dbus_interface_info_ref)(GDBusInterfaceInfo *info);
    GDBusMethodInfo* (*ptr_g_dbus_method_info_ref)(GDBusMethodInfo *info);
    GDBusSignalInfo* (*ptr_g_dbus_signal_info_ref)(GDBusSignalInfo *info);
    GDBusPropertyInfo* (*ptr_g_dbus_property_info_ref)(GDBusPropertyInfo *info);
    GDBusArgInfo* (*ptr_g_dbus_arg_info_ref)(GDBusArgInfo *info);
    GDBusAnnotationInfo* (*ptr_g_dbus_annotation_info_ref)(GDBusAnnotationInfo *info);
    void (*ptr_g_dbus_node_info_unref)(GDBusNodeInfo *info);
    void (*ptr_g_dbus_interface_info_unref)(GDBusInterfaceInfo *info);
    void (*ptr_g_dbus_method_info_unref)(GDBusMethodInfo *info);
    void (*ptr_g_dbus_signal_info_unref)(GDBusSignalInfo *info);
    void (*ptr_g_dbus_property_info_unref)(GDBusPropertyInfo *info);
    void (*ptr_g_dbus_arg_info_unref)(GDBusArgInfo *info);
    void (*ptr_g_dbus_annotation_info_unref)(GDBusAnnotationInfo *info);
    GType (*ptr_g_dbus_node_info_get_type)(void);
    GType (*ptr_g_dbus_interface_info_get_type)(void);
    GType (*ptr_g_dbus_method_info_get_type)(void);
    GType (*ptr_g_dbus_signal_info_get_type)(void);
    GType (*ptr_g_dbus_property_info_get_type)(void);
    GType (*ptr_g_dbus_arg_info_get_type)(void);
    GType (*ptr_g_dbus_annotation_info_get_type)(void);
    const gchar* (*ptr_g_dbus_annotation_info_lookup)(GDBusAnnotationInfo **annotations, const gchar *name);
    // Header /usr/include/glib-2.0/gio/gdbusmenumodel.h
    GType (*ptr_g_dbus_menu_model_get_type)(void);
    GDBusMenuModel * (*ptr_g_dbus_menu_model_get)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
    // Header /usr/include/glib-2.0/gio/gdbusmessage.h
    GType (*ptr_g_dbus_message_get_type)(void);
    GDBusMessage* (*ptr_g_dbus_message_new)(void);
    GDBusMessage* (*ptr_g_dbus_message_new_signal)(const gchar *path, const gchar *interface_, const gchar *signal);
    GDBusMessage* (*ptr_g_dbus_message_new_method_call)(const gchar *name, const gchar *path, const gchar *interface_, const gchar *method);
    GDBusMessage* (*ptr_g_dbus_message_new_method_reply)(GDBusMessage *method_call_message);
    GDBusMessage* (*ptr_g_dbus_message_new_method_error_valist)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, va_list var_args);
    GDBusMessage* (*ptr_g_dbus_message_new_method_error_literal)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message);
    gchar* (*ptr_g_dbus_message_print)(GDBusMessage *message, guint indent);
    gboolean (*ptr_g_dbus_message_get_locked)(GDBusMessage *message);
    void (*ptr_g_dbus_message_lock)(GDBusMessage *message);
    GDBusMessage* (*ptr_g_dbus_message_copy)(GDBusMessage *message, GError **error);
    GDBusMessageByteOrder (*ptr_g_dbus_message_get_byte_order)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_byte_order)(GDBusMessage *message, GDBusMessageByteOrder byte_order);
    GDBusMessageType (*ptr_g_dbus_message_get_message_type)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_message_type)(GDBusMessage *message, GDBusMessageType type);
    GDBusMessageFlags (*ptr_g_dbus_message_get_flags)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_flags)(GDBusMessage *message, GDBusMessageFlags flags);
    guint32 (*ptr_g_dbus_message_get_serial)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_serial)(GDBusMessage *message, guint32 serial);
    GVariant* (*ptr_g_dbus_message_get_header)(GDBusMessage *message, GDBusMessageHeaderField header_field);
    void (*ptr_g_dbus_message_set_header)(GDBusMessage *message, GDBusMessageHeaderField header_field, GVariant *value);
    guchar* (*ptr_g_dbus_message_get_header_fields)(GDBusMessage *message);
    GVariant* (*ptr_g_dbus_message_get_body)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_body)(GDBusMessage *message, GVariant *body);
    GUnixFDList* (*ptr_g_dbus_message_get_unix_fd_list)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_unix_fd_list)(GDBusMessage *message, GUnixFDList *fd_list);
    guint32 (*ptr_g_dbus_message_get_reply_serial)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_reply_serial)(GDBusMessage *message, guint32 value);
    const gchar* (*ptr_g_dbus_message_get_interface)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_interface)(GDBusMessage *message, const gchar *value);
    const gchar* (*ptr_g_dbus_message_get_member)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_member)(GDBusMessage *message, const gchar *value);
    const gchar* (*ptr_g_dbus_message_get_path)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_path)(GDBusMessage *message, const gchar *value);
    const gchar* (*ptr_g_dbus_message_get_sender)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_sender)(GDBusMessage *message, const gchar *value);
    const gchar* (*ptr_g_dbus_message_get_destination)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_destination)(GDBusMessage *message, const gchar *value);
    const gchar* (*ptr_g_dbus_message_get_error_name)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_error_name)(GDBusMessage *message, const gchar *value);
    const gchar* (*ptr_g_dbus_message_get_signature)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_signature)(GDBusMessage *message, const gchar *value);
    guint32 (*ptr_g_dbus_message_get_num_unix_fds)(GDBusMessage *message);
    void (*ptr_g_dbus_message_set_num_unix_fds)(GDBusMessage *message, guint32 value);
    const gchar* (*ptr_g_dbus_message_get_arg0)(GDBusMessage *message);
    const gchar* (*ptr_g_dbus_message_get_arg0_path)(GDBusMessage *message);
    GDBusMessage* (*ptr_g_dbus_message_new_from_blob)(guchar *blob, gsize blob_len, GDBusCapabilityFlags capabilities, GError **error);
    gssize (*ptr_g_dbus_message_bytes_needed)(guchar *blob, gsize blob_len, GError **error);
    guchar* (*ptr_g_dbus_message_to_blob)(GDBusMessage *message, gsize *out_size, GDBusCapabilityFlags capabilities, GError **error);
    gboolean (*ptr_g_dbus_message_to_gerror)(GDBusMessage *message, GError **error);
    // Header /usr/include/glib-2.0/gio/gdbusmethodinvocation.h
    GType (*ptr_g_dbus_method_invocation_get_type)(void);
    const gchar* (*ptr_g_dbus_method_invocation_get_sender)(GDBusMethodInvocation *invocation);
    const gchar* (*ptr_g_dbus_method_invocation_get_object_path)(GDBusMethodInvocation *invocation);
    const gchar* (*ptr_g_dbus_method_invocation_get_interface_name)(GDBusMethodInvocation *invocation);
    const gchar* (*ptr_g_dbus_method_invocation_get_method_name)(GDBusMethodInvocation *invocation);
    const GDBusMethodInfo* (*ptr_g_dbus_method_invocation_get_method_info)(GDBusMethodInvocation *invocation);
    const GDBusPropertyInfo* (*ptr_g_dbus_method_invocation_get_property_info)(GDBusMethodInvocation *invocation);
    GDBusConnection* (*ptr_g_dbus_method_invocation_get_connection)(GDBusMethodInvocation *invocation);
    GDBusMessage* (*ptr_g_dbus_method_invocation_get_message)(GDBusMethodInvocation *invocation);
    GVariant* (*ptr_g_dbus_method_invocation_get_parameters)(GDBusMethodInvocation *invocation);
    gpointer (*ptr_g_dbus_method_invocation_get_user_data)(GDBusMethodInvocation *invocation);
    void (*ptr_g_dbus_method_invocation_return_value)(GDBusMethodInvocation *invocation, GVariant *parameters);
    void (*ptr_g_dbus_method_invocation_return_value_with_unix_fd_list)(GDBusMethodInvocation *invocation, GVariant *parameters, GUnixFDList *fd_list);
    void (*ptr_g_dbus_method_invocation_return_error_valist)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, va_list var_args);
    void (*ptr_g_dbus_method_invocation_return_error_literal)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *message);
    void (*ptr_g_dbus_method_invocation_return_gerror)(GDBusMethodInvocation *invocation, const GError *error);
    void (*ptr_g_dbus_method_invocation_take_error)(GDBusMethodInvocation *invocation, GError *error);
    void (*ptr_g_dbus_method_invocation_return_dbus_error)(GDBusMethodInvocation *invocation, const gchar *error_name, const gchar *error_message);
    // Header /usr/include/glib-2.0/gio/gdbusnameowning.h
    guint (*ptr_g_bus_own_name_on_connection)(GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    guint (*ptr_g_bus_own_name_with_closures)(GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GClosure *bus_acquired_closure, GClosure *name_acquired_closure, GClosure *name_lost_closure);
    guint (*ptr_g_bus_own_name_on_connection_with_closures)( GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GClosure *name_acquired_closure, GClosure *name_lost_closure);
    void (*ptr_g_bus_unown_name)(guint owner_id);
    guint (*ptr_g_bus_own_name)(GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GBusAcquiredCallback bus_acquired_handler, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    // Header /usr/include/glib-2.0/gio/gdbusnamewatching.h
    guint (*ptr_g_bus_watch_name_on_connection)(GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    guint (*ptr_g_bus_watch_name_with_closures)(GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
    guint (*ptr_g_bus_watch_name_on_connection_with_closures)( GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
    void (*ptr_g_bus_unwatch_name)(guint watcher_id);
    guint (*ptr_g_bus_watch_name)(GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
    // Header /usr/include/glib-2.0/gio/gdbusobject.h
    GType (*ptr_g_dbus_object_get_type)(void);
    const gchar* (*ptr_g_dbus_object_get_object_path)(GDBusObject *object);
    GList* (*ptr_g_dbus_object_get_interfaces)(GDBusObject *object);
    GDBusInterface* (*ptr_g_dbus_object_get_interface)(GDBusObject *object, const gchar *interface_name);
    // Header /usr/include/glib-2.0/gio/gdbusobjectmanager.h
    GType (*ptr_g_dbus_object_manager_get_type)(void);
    const gchar* (*ptr_g_dbus_object_manager_get_object_path)(GDBusObjectManager *manager);
    GList* (*ptr_g_dbus_object_manager_get_objects)(GDBusObjectManager *manager);
    GDBusObject* (*ptr_g_dbus_object_manager_get_object)(GDBusObjectManager *manager, const gchar *object_path);
    GDBusInterface* (*ptr_g_dbus_object_manager_get_interface)(GDBusObjectManager *manager, const gchar *object_path, const gchar *interface_name);
    // Header /usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h
    GType (*ptr_g_dbus_object_manager_client_get_type)(void);
    void (*ptr_g_dbus_object_manager_client_new)(GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusObjectManager* (*ptr_g_dbus_object_manager_client_new_finish)(GAsyncResult *res, GError **error);
    GDBusObjectManager* (*ptr_g_dbus_object_manager_client_new_sync)(GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_object_manager_client_new_for_bus)(GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusObjectManager* (*ptr_g_dbus_object_manager_client_new_for_bus_finish)(GAsyncResult *res, GError **error);
    GDBusObjectManager* (*ptr_g_dbus_object_manager_client_new_for_bus_sync)(GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
    GDBusConnection* (*ptr_g_dbus_object_manager_client_get_connection)(GDBusObjectManagerClient *manager);
    GDBusObjectManagerClientFlags (*ptr_g_dbus_object_manager_client_get_flags)(GDBusObjectManagerClient *manager);
    const gchar* (*ptr_g_dbus_object_manager_client_get_name)(GDBusObjectManagerClient *manager);
    gchar* (*ptr_g_dbus_object_manager_client_get_name_owner)(GDBusObjectManagerClient *manager);
    // Header /usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h
    GType (*ptr_g_dbus_object_manager_server_get_type)(void);
    GDBusObjectManagerServer* (*ptr_g_dbus_object_manager_server_new)(const gchar *object_path);
    GDBusConnection* (*ptr_g_dbus_object_manager_server_get_connection)(GDBusObjectManagerServer *manager);
    void (*ptr_g_dbus_object_manager_server_set_connection)(GDBusObjectManagerServer *manager, GDBusConnection *connection);
    void (*ptr_g_dbus_object_manager_server_export)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
    void (*ptr_g_dbus_object_manager_server_export_uniquely)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
    gboolean (*ptr_g_dbus_object_manager_server_is_exported)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
    gboolean (*ptr_g_dbus_object_manager_server_unexport)(GDBusObjectManagerServer *manager, const gchar *object_path);
    // Header /usr/include/glib-2.0/gio/gdbusobjectproxy.h
    GType (*ptr_g_dbus_object_proxy_get_type)(void);
    GDBusObjectProxy* (*ptr_g_dbus_object_proxy_new)(GDBusConnection *connection, const gchar *object_path);
    GDBusConnection* (*ptr_g_dbus_object_proxy_get_connection)(GDBusObjectProxy *proxy);
    // Header /usr/include/glib-2.0/gio/gdbusobjectskeleton.h
    GType (*ptr_g_dbus_object_skeleton_get_type)(void);
    GDBusObjectSkeleton* (*ptr_g_dbus_object_skeleton_new)(const gchar *object_path);
    void (*ptr_g_dbus_object_skeleton_flush)(GDBusObjectSkeleton *object);
    void (*ptr_g_dbus_object_skeleton_add_interface)(GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
    void (*ptr_g_dbus_object_skeleton_remove_interface)(GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
    void (*ptr_g_dbus_object_skeleton_remove_interface_by_name)(GDBusObjectSkeleton *object, const gchar *interface_name);
    void (*ptr_g_dbus_object_skeleton_set_object_path)(GDBusObjectSkeleton *object, const gchar *object_path);
    // Header /usr/include/glib-2.0/gio/gdbusproxy.h
    GType (*ptr_g_dbus_proxy_get_type)(void);
    void (*ptr_g_dbus_proxy_new)(GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusProxy* (*ptr_g_dbus_proxy_new_finish)(GAsyncResult *res, GError **error);
    GDBusProxy* (*ptr_g_dbus_proxy_new_sync)(GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_proxy_new_for_bus)(GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GDBusProxy* (*ptr_g_dbus_proxy_new_for_bus_finish)(GAsyncResult *res, GError **error);
    GDBusProxy* (*ptr_g_dbus_proxy_new_for_bus_sync)(GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
    GDBusConnection* (*ptr_g_dbus_proxy_get_connection)(GDBusProxy *proxy);
    GDBusProxyFlags (*ptr_g_dbus_proxy_get_flags)(GDBusProxy *proxy);
    const gchar* (*ptr_g_dbus_proxy_get_name)(GDBusProxy *proxy);
    gchar* (*ptr_g_dbus_proxy_get_name_owner)(GDBusProxy *proxy);
    const gchar* (*ptr_g_dbus_proxy_get_object_path)(GDBusProxy *proxy);
    const gchar* (*ptr_g_dbus_proxy_get_interface_name)(GDBusProxy *proxy);
    gint (*ptr_g_dbus_proxy_get_default_timeout)(GDBusProxy *proxy);
    void (*ptr_g_dbus_proxy_set_default_timeout)(GDBusProxy *proxy, gint timeout_msec);
    GDBusInterfaceInfo* (*ptr_g_dbus_proxy_get_interface_info)(GDBusProxy *proxy);
    void (*ptr_g_dbus_proxy_set_interface_info)(GDBusProxy *proxy, GDBusInterfaceInfo *info);
    GVariant* (*ptr_g_dbus_proxy_get_cached_property)(GDBusProxy *proxy, const gchar *property_name);
    void (*ptr_g_dbus_proxy_set_cached_property)(GDBusProxy *proxy, const gchar *property_name, GVariant *value);
    gchar** (*ptr_g_dbus_proxy_get_cached_property_names)(GDBusProxy *proxy);
    void (*ptr_g_dbus_proxy_call)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*ptr_g_dbus_proxy_call_finish)(GDBusProxy *proxy, GAsyncResult *res, GError **error);
    GVariant* (*ptr_g_dbus_proxy_call_sync)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
    void (*ptr_g_dbus_proxy_call_with_unix_fd_list)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GVariant* (*ptr_g_dbus_proxy_call_with_unix_fd_list_finish)(GDBusProxy *proxy, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
    GVariant* (*ptr_g_dbus_proxy_call_with_unix_fd_list_sync)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gdbusserver.h
    GType (*ptr_g_dbus_server_get_type)(void);
    GDBusServer* (*ptr_g_dbus_server_new_sync)(const gchar *address, GDBusServerFlags flags, const gchar *guid, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
    const gchar* (*ptr_g_dbus_server_get_client_address)(GDBusServer *server);
    const gchar* (*ptr_g_dbus_server_get_guid)(GDBusServer *server);
    GDBusServerFlags (*ptr_g_dbus_server_get_flags)(GDBusServer *server);
    void (*ptr_g_dbus_server_start)(GDBusServer *server);
    void (*ptr_g_dbus_server_stop)(GDBusServer *server);
    gboolean (*ptr_g_dbus_server_is_active)(GDBusServer *server);
    // Header /usr/include/glib-2.0/gio/gdbusutils.h
    gchar* (*ptr_g_dbus_generate_guid)(void);
    gboolean (*ptr_g_dbus_is_name)(const gchar *string);
    gboolean (*ptr_g_dbus_is_unique_name)(const gchar *string);
    gboolean (*ptr_g_dbus_is_member_name)(const gchar *string);
    gboolean (*ptr_g_dbus_is_interface_name)(const gchar *string);
    gboolean (*ptr_g_dbus_is_error_name)(const gchar *string);
    void (*ptr_g_dbus_gvariant_to_gvalue)(GVariant *value, GValue *out_gvalue);
    GVariant* (*ptr_g_dbus_gvalue_to_gvariant)(const GValue *gvalue, const GVariantType *type);
    gchar* (*ptr_g_dbus_escape_object_path_bytestring)(const guint8 *bytes);
    gchar* (*ptr_g_dbus_escape_object_path)(const gchar *s);
    guint8* (*ptr_g_dbus_unescape_object_path)(const gchar *s);
    gboolean (*ptr_g_dbus_is_guid)(const gchar *string);
    // Header /usr/include/glib-2.0/gio/gdebugcontroller.h
    GType (*ptr_g_debug_controller_get_type)(void);
    void (*ptr_g_debug_controller_set_debug_enabled)(GDebugController *self, gboolean debug_enabled);
    // Header /usr/include/glib-2.0/gio/gdebugcontrollerdbus.h
    GType (*ptr_g_debug_controller_dbus_get_type)(void);
    GDebugControllerDBus* (*ptr_g_debug_controller_dbus_new)(GDBusConnection *connection, GCancellable *cancellable, GError **error);
    void (*ptr_g_debug_controller_dbus_stop)(GDebugControllerDBus *self);
    // Header /usr/include/glib-2.0/gio/gdrive.h
    GType (*ptr_g_drive_get_type)(void);
    char * (*ptr_g_drive_get_name)(GDrive *drive);
    GIcon * (*ptr_g_drive_get_icon)(GDrive *drive);
    GIcon * (*ptr_g_drive_get_symbolic_icon)(GDrive *drive);
    gboolean (*ptr_g_drive_has_volumes)(GDrive *drive);
    GList * (*ptr_g_drive_get_volumes)(GDrive *drive);
    gboolean (*ptr_g_drive_is_removable)(GDrive *drive);
    gboolean (*ptr_g_drive_is_media_removable)(GDrive *drive);
    gboolean (*ptr_g_drive_has_media)(GDrive *drive);
    gboolean (*ptr_g_drive_is_media_check_automatic)(GDrive *drive);
    gboolean (*ptr_g_drive_can_poll_for_media)(GDrive *drive);
    gboolean (*ptr_g_drive_can_eject)(GDrive *drive);
    void (*ptr_g_drive_eject)(GDrive *drive, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_drive_eject_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    void (*ptr_g_drive_poll_for_media)(GDrive *drive, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_drive_poll_for_media_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    char * (*ptr_g_drive_get_identifier)(GDrive *drive, const char *kind);
    char ** (*ptr_g_drive_enumerate_identifiers)(GDrive *drive);
    GDriveStartStopType (*ptr_g_drive_get_start_stop_type)(GDrive *drive);
    gboolean (*ptr_g_drive_can_start)(GDrive *drive);
    gboolean (*ptr_g_drive_can_start_degraded)(GDrive *drive);
    void (*ptr_g_drive_start)(GDrive *drive, GDriveStartFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_drive_start_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_drive_can_stop)(GDrive *drive);
    void (*ptr_g_drive_stop)(GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_drive_stop_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    void (*ptr_g_drive_eject_with_operation)(GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_drive_eject_with_operation_finish)(GDrive *drive, GAsyncResult *result, GError **error);
    const gchar* (*ptr_g_drive_get_sort_key)(GDrive *drive);
    // Header /usr/include/glib-2.0/gio/gdtlsclientconnection.h
    GType (*ptr_g_dtls_client_connection_get_type)(void);
    GDatagramBased* (*ptr_g_dtls_client_connection_new)(GDatagramBased *base_socket, GSocketConnectable *server_identity, GError **error);
    GTlsCertificateFlags (*ptr_g_dtls_client_connection_get_validation_flags)(GDtlsClientConnection *conn);
    void (*ptr_g_dtls_client_connection_set_validation_flags)(GDtlsClientConnection *conn, GTlsCertificateFlags flags);
    GSocketConnectable* (*ptr_g_dtls_client_connection_get_server_identity)(GDtlsClientConnection *conn);
    void (*ptr_g_dtls_client_connection_set_server_identity)(GDtlsClientConnection *conn, GSocketConnectable *identity);
    GList * (*ptr_g_dtls_client_connection_get_accepted_cas)(GDtlsClientConnection *conn);
    // Header /usr/include/glib-2.0/gio/gdtlsconnection.h
    GType (*ptr_g_dtls_connection_get_type)(void);
    void (*ptr_g_dtls_connection_set_database)(GDtlsConnection *conn, GTlsDatabase *database);
    GTlsDatabase* (*ptr_g_dtls_connection_get_database)(GDtlsConnection *conn);
    void (*ptr_g_dtls_connection_set_certificate)(GDtlsConnection *conn, GTlsCertificate *certificate);
    GTlsCertificate* (*ptr_g_dtls_connection_get_certificate)(GDtlsConnection *conn);
    void (*ptr_g_dtls_connection_set_interaction)(GDtlsConnection *conn, GTlsInteraction *interaction);
    GTlsInteraction* (*ptr_g_dtls_connection_get_interaction)(GDtlsConnection *conn);
    GTlsCertificate* (*ptr_g_dtls_connection_get_peer_certificate)(GDtlsConnection *conn);
    GTlsCertificateFlags (*ptr_g_dtls_connection_get_peer_certificate_errors)(GDtlsConnection *conn);
    void (*ptr_g_dtls_connection_set_require_close_notify)(GDtlsConnection *conn, gboolean require_close_notify);
    gboolean (*ptr_g_dtls_connection_get_require_close_notify)(GDtlsConnection *conn);
    GTlsRehandshakeMode (*ptr_g_dtls_connection_get_rehandshake_mode)(GDtlsConnection *conn);
    void (*ptr_g_dtls_connection_handshake_async)(GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_dtls_connection_handshake_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_dtls_connection_shutdown)(GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, GCancellable *cancellable, GError **error);
    void (*ptr_g_dtls_connection_shutdown_async)(GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_dtls_connection_shutdown_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_dtls_connection_close)(GDtlsConnection *conn, GCancellable *cancellable, GError **error);
    void (*ptr_g_dtls_connection_close_async)(GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_dtls_connection_close_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_dtls_connection_emit_accept_certificate)(GDtlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
    void (*ptr_g_dtls_connection_set_advertised_protocols)(GDtlsConnection *conn, const gchar * const *protocols);
    const gchar * (*ptr_g_dtls_connection_get_negotiated_protocol)(GDtlsConnection *conn);
    gchar * (*ptr_g_dtls_connection_get_ciphersuite_name)(GDtlsConnection *conn);
    // Header /usr/include/glib-2.0/gio/gdtlsserverconnection.h
    GType (*ptr_g_dtls_server_connection_get_type)(void);
    GDatagramBased* (*ptr_g_dtls_server_connection_new)(GDatagramBased *base_socket, GTlsCertificate *certificate, GError **error);
    // Header /usr/include/glib-2.0/gio/gemblem.h
    GType (*ptr_g_emblem_get_type)(void);
    GEmblem* (*ptr_g_emblem_new)(GIcon *icon);
    GEmblem* (*ptr_g_emblem_new_with_origin)(GIcon *icon, GEmblemOrigin origin);
    GIcon* (*ptr_g_emblem_get_icon)(GEmblem *emblem);
    GEmblemOrigin (*ptr_g_emblem_get_origin)(GEmblem *emblem);
    // Header /usr/include/glib-2.0/gio/gemblemedicon.h
    GType (*ptr_g_emblemed_icon_get_type)(void);
    GIcon* (*ptr_g_emblemed_icon_new)(GIcon *icon, GEmblem *emblem);
    GIcon* (*ptr_g_emblemed_icon_get_icon)(GEmblemedIcon *emblemed);
    GList* (*ptr_g_emblemed_icon_get_emblems)(GEmblemedIcon *emblemed);
    void (*ptr_g_emblemed_icon_add_emblem)(GEmblemedIcon *emblemed, GEmblem *emblem);
    void (*ptr_g_emblemed_icon_clear_emblems)(GEmblemedIcon *emblemed);
    // Header /usr/include/glib-2.0/gio/gfile.h
    GType (*ptr_g_file_get_type)(void);
    GFile * (*ptr_g_file_new_for_path)(const char *path);
    GFile * (*ptr_g_file_new_for_uri)(const char *uri);
    GFile * (*ptr_g_file_new_for_commandline_arg)(const char *arg);
    GFile * (*ptr_g_file_new_for_commandline_arg_and_cwd)(const gchar *arg, const gchar *cwd);
    GFile * (*ptr_g_file_new_tmp)(const char *tmpl, GFileIOStream **iostream, GError **error);
    void (*ptr_g_file_new_tmp_async)(const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*ptr_g_file_new_tmp_finish)(GAsyncResult *result, GFileIOStream **iostream, GError **error);
    void (*ptr_g_file_new_tmp_dir_async)(const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*ptr_g_file_new_tmp_dir_finish)(GAsyncResult *result, GError **error);
    GFile * (*ptr_g_file_parse_name)(const char *parse_name);
    GFile * (*ptr_g_file_new_build_filenamev)(const gchar * const *args);
    GFile * (*ptr_g_file_dup)(GFile *file);
    guint (*ptr_g_file_hash)(gconstpointer file);
    gboolean (*ptr_g_file_equal)(GFile *file1, GFile *file2);
    char * (*ptr_g_file_get_basename)(GFile *file);
    char * (*ptr_g_file_get_path)(GFile *file);
    const char * (*ptr_g_file_peek_path)(GFile *file);
    char * (*ptr_g_file_get_uri)(GFile *file);
    char * (*ptr_g_file_get_parse_name)(GFile *file);
    GFile * (*ptr_g_file_get_parent)(GFile *file);
    gboolean (*ptr_g_file_has_parent)(GFile *file, GFile *parent);
    GFile * (*ptr_g_file_get_child)(GFile *file, const char *name);
    GFile * (*ptr_g_file_get_child_for_display_name)(GFile *file, const char *display_name, GError **error);
    gboolean (*ptr_g_file_has_prefix)(GFile *file, GFile *prefix);
    char * (*ptr_g_file_get_relative_path)(GFile *parent, GFile *descendant);
    GFile * (*ptr_g_file_resolve_relative_path)(GFile *file, const char *relative_path);
    gboolean (*ptr_g_file_is_native)(GFile *file);
    gboolean (*ptr_g_file_has_uri_scheme)(GFile *file, const char *uri_scheme);
    char * (*ptr_g_file_get_uri_scheme)(GFile *file);
    GFileInputStream * (*ptr_g_file_read)(GFile *file, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_read_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInputStream * (*ptr_g_file_read_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileOutputStream * (*ptr_g_file_append_to)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    GFileOutputStream * (*ptr_g_file_create)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    GFileOutputStream * (*ptr_g_file_replace)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_append_to_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileOutputStream * (*ptr_g_file_append_to_finish)(GFile *file, GAsyncResult *res, GError **error);
    void (*ptr_g_file_create_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileOutputStream * (*ptr_g_file_create_finish)(GFile *file, GAsyncResult *res, GError **error);
    void (*ptr_g_file_replace_async)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileOutputStream * (*ptr_g_file_replace_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileIOStream * (*ptr_g_file_open_readwrite)(GFile *file, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_open_readwrite_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileIOStream * (*ptr_g_file_open_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileIOStream * (*ptr_g_file_create_readwrite)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_create_readwrite_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileIOStream * (*ptr_g_file_create_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileIOStream * (*ptr_g_file_replace_readwrite)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_replace_readwrite_async)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileIOStream * (*ptr_g_file_replace_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error);
    gboolean (*ptr_g_file_query_exists)(GFile *file, GCancellable *cancellable);
    GFileType (*ptr_g_file_query_file_type)(GFile *file, GFileQueryInfoFlags flags, GCancellable *cancellable);
    GFileInfo * (*ptr_g_file_query_info)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_query_info_async)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo * (*ptr_g_file_query_info_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileInfo * (*ptr_g_file_query_filesystem_info)(GFile *file, const char *attributes, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_query_filesystem_info_async)(GFile *file, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo * (*ptr_g_file_query_filesystem_info_finish)(GFile *file, GAsyncResult *res, GError **error);
    GMount * (*ptr_g_file_find_enclosing_mount)(GFile *file, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_find_enclosing_mount_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GMount * (*ptr_g_file_find_enclosing_mount_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFileEnumerator * (*ptr_g_file_enumerate_children)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_enumerate_children_async)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileEnumerator * (*ptr_g_file_enumerate_children_finish)(GFile *file, GAsyncResult *res, GError **error);
    GFile * (*ptr_g_file_set_display_name)(GFile *file, const char *display_name, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_set_display_name_async)(GFile *file, const char *display_name, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*ptr_g_file_set_display_name_finish)(GFile *file, GAsyncResult *res, GError **error);
    gboolean (*ptr_g_file_delete)(GFile *file, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_delete_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_delete_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_file_trash)(GFile *file, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_trash_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_trash_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_file_copy)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
    void (*ptr_g_file_copy_async)(GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_copy_finish)(GFile *file, GAsyncResult *res, GError **error);
    gboolean (*ptr_g_file_move)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
    void (*ptr_g_file_move_async)(GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_move_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_file_make_directory)(GFile *file, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_make_directory_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_make_directory_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_file_make_directory_with_parents)(GFile *file, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_make_symbolic_link)(GFile *file, const char *symlink_value, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_make_symbolic_link_async)(GFile *file, const char *symlink_value, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_make_symbolic_link_finish)(GFile *file, GAsyncResult *result, GError **error);
    GFileAttributeInfoList* (*ptr_g_file_query_settable_attributes)(GFile *file, GCancellable *cancellable, GError **error);
    GFileAttributeInfoList* (*ptr_g_file_query_writable_namespaces)(GFile *file, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_set_attribute)(GFile *file, const char *attribute, GFileAttributeType type, gpointer value_p, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_set_attributes_from_info)(GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_set_attributes_async)(GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_set_attributes_finish)(GFile *file, GAsyncResult *result, GFileInfo **info, GError **error);
    gboolean (*ptr_g_file_set_attribute_string)(GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_set_attribute_byte_string)(GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_set_attribute_uint32)(GFile *file, const char *attribute, guint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_set_attribute_int32)(GFile *file, const char *attribute, gint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_set_attribute_uint64)(GFile *file, const char *attribute, guint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_set_attribute_int64)(GFile *file, const char *attribute, gint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_mount_enclosing_volume)(GFile *location, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_mount_enclosing_volume_finish)(GFile *location, GAsyncResult *result, GError **error);
    void (*ptr_g_file_mount_mountable)(GFile *file, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFile * (*ptr_g_file_mount_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*ptr_g_file_unmount_mountable)(GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_unmount_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*ptr_g_file_unmount_mountable_with_operation)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_unmount_mountable_with_operation_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*ptr_g_file_eject_mountable)(GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_eject_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*ptr_g_file_eject_mountable_with_operation)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_eject_mountable_with_operation_finish)(GFile *file, GAsyncResult *result, GError **error);
    char * (*ptr_g_file_build_attribute_list_for_copy)(GFile *file, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_copy_attributes)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
    GFileMonitor* (*ptr_g_file_monitor_directory)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
    GFileMonitor* (*ptr_g_file_monitor_file)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
    GFileMonitor* (*ptr_g_file_monitor)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_measure_disk_usage)(GFile *file, GFileMeasureFlags flags, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
    void (*ptr_g_file_measure_disk_usage_async)(GFile *file, GFileMeasureFlags flags, gint io_priority, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_measure_disk_usage_finish)(GFile *file, GAsyncResult *result, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
    void (*ptr_g_file_start_mountable)(GFile *file, GDriveStartFlags flags, GMountOperation *start_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_start_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*ptr_g_file_stop_mountable)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_stop_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    void (*ptr_g_file_poll_mountable)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_poll_mountable_finish)(GFile *file, GAsyncResult *result, GError **error);
    GAppInfo* (*ptr_g_file_query_default_handler)(GFile *file, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_query_default_handler_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GAppInfo* (*ptr_g_file_query_default_handler_finish)(GFile *file, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_file_load_contents)(GFile *file, GCancellable *cancellable, char **contents, gsize *length, char **etag_out, GError **error);
    void (*ptr_g_file_load_contents_async)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_load_contents_finish)(GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
    void (*ptr_g_file_load_partial_contents_async)(GFile *file, GCancellable *cancellable, GFileReadMoreCallback read_more_callback, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_load_partial_contents_finish)(GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
    gboolean (*ptr_g_file_replace_contents)(GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, char **new_etag, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_replace_contents_async)(GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    void (*ptr_g_file_replace_contents_bytes_async)(GFile *file, GBytes *contents, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_replace_contents_finish)(GFile *file, GAsyncResult *res, char **new_etag, GError **error);
    gboolean (*ptr_g_file_supports_thread_contexts)(GFile *file);
    GBytes* (*ptr_g_file_load_bytes)(GFile *file, GCancellable *cancellable, gchar **etag_out, GError **error);
    void (*ptr_g_file_load_bytes_async)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GBytes* (*ptr_g_file_load_bytes_finish)(GFile *file, GAsyncResult *result, gchar **etag_out, GError **error);
    // Header /usr/include/glib-2.0/gio/gfileattribute.h
    GType (*ptr_g_file_attribute_info_list_get_type)(void);
    GFileAttributeInfoList * (*ptr_g_file_attribute_info_list_new)(void);
    GFileAttributeInfoList * (*ptr_g_file_attribute_info_list_ref)(GFileAttributeInfoList *list);
    void (*ptr_g_file_attribute_info_list_unref)(GFileAttributeInfoList *list);
    GFileAttributeInfoList * (*ptr_g_file_attribute_info_list_dup)(GFileAttributeInfoList *list);
    const GFileAttributeInfo* (*ptr_g_file_attribute_info_list_lookup)(GFileAttributeInfoList *list, const char *name);
    void (*ptr_g_file_attribute_info_list_add)(GFileAttributeInfoList *list, const char *name, GFileAttributeType type, GFileAttributeInfoFlags flags);
    // Header /usr/include/glib-2.0/gio/gfileenumerator.h
    GType (*ptr_g_file_enumerator_get_type)(void);
    GFileInfo* (*ptr_g_file_enumerator_next_file)(GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_file_enumerator_close)(GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_enumerator_next_files_async)(GFileEnumerator *enumerator, int num_files, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList * (*ptr_g_file_enumerator_next_files_finish)(GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
    void (*ptr_g_file_enumerator_close_async)(GFileEnumerator *enumerator, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_file_enumerator_close_finish)(GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_file_enumerator_is_closed)(GFileEnumerator *enumerator);
    gboolean (*ptr_g_file_enumerator_has_pending)(GFileEnumerator *enumerator);
    void (*ptr_g_file_enumerator_set_pending)(GFileEnumerator *enumerator, gboolean pending);
    GFile * (*ptr_g_file_enumerator_get_container)(GFileEnumerator *enumerator);
    GFile * (*ptr_g_file_enumerator_get_child)(GFileEnumerator *enumerator, GFileInfo *info);
    gboolean (*ptr_g_file_enumerator_iterate)(GFileEnumerator *direnum, GFileInfo **out_info, GFile **out_child, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gfileicon.h
    GType (*ptr_g_file_icon_get_type)(void);
    GIcon * (*ptr_g_file_icon_new)(GFile *file);
    GFile * (*ptr_g_file_icon_get_file)(GFileIcon *icon);
    // Header /usr/include/glib-2.0/gio/gfileinfo.h
    GType (*ptr_g_file_info_get_type)(void);
    GFileInfo * (*ptr_g_file_info_new)(void);
    GFileInfo * (*ptr_g_file_info_dup)(GFileInfo *other);
    void (*ptr_g_file_info_copy_into)(GFileInfo *src_info, GFileInfo *dest_info);
    gboolean (*ptr_g_file_info_has_attribute)(GFileInfo *info, const char *attribute);
    gboolean (*ptr_g_file_info_has_namespace)(GFileInfo *info, const char *name_space);
    char ** (*ptr_g_file_info_list_attributes)(GFileInfo *info, const char *name_space);
    gboolean (*ptr_g_file_info_get_attribute_data)(GFileInfo *info, const char *attribute, GFileAttributeType *type, gpointer *value_pp, GFileAttributeStatus *status);
    GFileAttributeType (*ptr_g_file_info_get_attribute_type)(GFileInfo *info, const char *attribute);
    void (*ptr_g_file_info_remove_attribute)(GFileInfo *info, const char *attribute);
    GFileAttributeStatus (*ptr_g_file_info_get_attribute_status)(GFileInfo *info, const char *attribute);
    gboolean (*ptr_g_file_info_set_attribute_status)(GFileInfo *info, const char *attribute, GFileAttributeStatus status);
    char * (*ptr_g_file_info_get_attribute_as_string)(GFileInfo *info, const char *attribute);
    const char * (*ptr_g_file_info_get_attribute_string)(GFileInfo *info, const char *attribute);
    const char * (*ptr_g_file_info_get_attribute_byte_string)(GFileInfo *info, const char *attribute);
    gboolean (*ptr_g_file_info_get_attribute_boolean)(GFileInfo *info, const char *attribute);
    guint32 (*ptr_g_file_info_get_attribute_uint32)(GFileInfo *info, const char *attribute);
    gint32 (*ptr_g_file_info_get_attribute_int32)(GFileInfo *info, const char *attribute);
    guint64 (*ptr_g_file_info_get_attribute_uint64)(GFileInfo *info, const char *attribute);
    gint64 (*ptr_g_file_info_get_attribute_int64)(GFileInfo *info, const char *attribute);
    GObject * (*ptr_g_file_info_get_attribute_object)(GFileInfo *info, const char *attribute);
    char ** (*ptr_g_file_info_get_attribute_stringv)(GFileInfo *info, const char *attribute);
    const char * (*ptr_g_file_info_get_attribute_file_path)(GFileInfo *info, const char *attribute);
    void (*ptr_g_file_info_set_attribute)(GFileInfo *info, const char *attribute, GFileAttributeType type, gpointer value_p);
    void (*ptr_g_file_info_set_attribute_string)(GFileInfo *info, const char *attribute, const char *attr_value);
    void (*ptr_g_file_info_set_attribute_byte_string)(GFileInfo *info, const char *attribute, const char *attr_value);
    void (*ptr_g_file_info_set_attribute_boolean)(GFileInfo *info, const char *attribute, gboolean attr_value);
    void (*ptr_g_file_info_set_attribute_uint32)(GFileInfo *info, const char *attribute, guint32 attr_value);
    void (*ptr_g_file_info_set_attribute_int32)(GFileInfo *info, const char *attribute, gint32 attr_value);
    void (*ptr_g_file_info_set_attribute_uint64)(GFileInfo *info, const char *attribute, guint64 attr_value);
    void (*ptr_g_file_info_set_attribute_int64)(GFileInfo *info, const char *attribute, gint64 attr_value);
    void (*ptr_g_file_info_set_attribute_object)(GFileInfo *info, const char *attribute, GObject *attr_value);
    void (*ptr_g_file_info_set_attribute_stringv)(GFileInfo *info, const char *attribute, char **attr_value);
    void (*ptr_g_file_info_set_attribute_file_path)(GFileInfo *info, const char *attribute, const char *attr_value);
    void (*ptr_g_file_info_clear_status)(GFileInfo *info);
    GDateTime * (*ptr_g_file_info_get_deletion_date)(GFileInfo *info);
    GFileType (*ptr_g_file_info_get_file_type)(GFileInfo *info);
    gboolean (*ptr_g_file_info_get_is_hidden)(GFileInfo *info);
    gboolean (*ptr_g_file_info_get_is_backup)(GFileInfo *info);
    gboolean (*ptr_g_file_info_get_is_symlink)(GFileInfo *info);
    const char * (*ptr_g_file_info_get_name)(GFileInfo *info);
    const char * (*ptr_g_file_info_get_display_name)(GFileInfo *info);
    const char * (*ptr_g_file_info_get_edit_name)(GFileInfo *info);
    GIcon * (*ptr_g_file_info_get_icon)(GFileInfo *info);
    GIcon * (*ptr_g_file_info_get_symbolic_icon)(GFileInfo *info);
    const char * (*ptr_g_file_info_get_content_type)(GFileInfo *info);
    goffset (*ptr_g_file_info_get_size)(GFileInfo *info);
    GDateTime * (*ptr_g_file_info_get_access_date_time)(GFileInfo *info);
    GDateTime * (*ptr_g_file_info_get_creation_date_time)(GFileInfo *info);
    const char * (*ptr_g_file_info_get_symlink_target)(GFileInfo *info);
    const char * (*ptr_g_file_info_get_etag)(GFileInfo *info);
    gint32 (*ptr_g_file_info_get_sort_order)(GFileInfo *info);
    void (*ptr_g_file_info_set_attribute_mask)(GFileInfo *info, GFileAttributeMatcher *mask);
    void (*ptr_g_file_info_unset_attribute_mask)(GFileInfo *info);
    void (*ptr_g_file_info_set_file_type)(GFileInfo *info, GFileType type);
    void (*ptr_g_file_info_set_is_hidden)(GFileInfo *info, gboolean is_hidden);
    void (*ptr_g_file_info_set_is_symlink)(GFileInfo *info, gboolean is_symlink);
    void (*ptr_g_file_info_set_name)(GFileInfo *info, const char *name);
    void (*ptr_g_file_info_set_display_name)(GFileInfo *info, const char *display_name);
    void (*ptr_g_file_info_set_edit_name)(GFileInfo *info, const char *edit_name);
    void (*ptr_g_file_info_set_icon)(GFileInfo *info, GIcon *icon);
    void (*ptr_g_file_info_set_symbolic_icon)(GFileInfo *info, GIcon *icon);
    void (*ptr_g_file_info_set_content_type)(GFileInfo *info, const char *content_type);
    void (*ptr_g_file_info_set_size)(GFileInfo *info, goffset size);
    void (*ptr_g_file_info_set_access_date_time)(GFileInfo *info, GDateTime *atime);
    void (*ptr_g_file_info_set_creation_date_time)(GFileInfo *info, GDateTime *creation_time);
    void (*ptr_g_file_info_set_symlink_target)(GFileInfo *info, const char *symlink_target);
    void (*ptr_g_file_info_set_sort_order)(GFileInfo *info, gint32 sort_order);
    GType (*ptr_g_file_attribute_matcher_get_type)(void);
    GFileAttributeMatcher* (*ptr_g_file_attribute_matcher_new)(const char *attributes);
    GFileAttributeMatcher* (*ptr_g_file_attribute_matcher_ref)(GFileAttributeMatcher *matcher);
    void (*ptr_g_file_attribute_matcher_unref)(GFileAttributeMatcher *matcher);
    GFileAttributeMatcher* (*ptr_g_file_attribute_matcher_subtract)(GFileAttributeMatcher *matcher, GFileAttributeMatcher *subtract);
    gboolean (*ptr_g_file_attribute_matcher_matches)(GFileAttributeMatcher *matcher, const char *attribute);
    gboolean (*ptr_g_file_attribute_matcher_matches_only)(GFileAttributeMatcher *matcher, const char *attribute);
    gboolean (*ptr_g_file_attribute_matcher_enumerate_namespace)(GFileAttributeMatcher *matcher, const char *ns);
    const char * (*ptr_g_file_attribute_matcher_enumerate_next)(GFileAttributeMatcher *matcher);
    char * (*ptr_g_file_attribute_matcher_to_string)(GFileAttributeMatcher *matcher);
    // Header /usr/include/glib-2.0/gio/gfileinputstream.h
    GType (*ptr_g_file_input_stream_get_type)(void);
    GFileInfo* (*ptr_g_file_input_stream_query_info)(GFileInputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_input_stream_query_info_async)(GFileInputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo* (*ptr_g_file_input_stream_query_info_finish)(GFileInputStream *stream, GAsyncResult *result, GError **error);
    // Header /usr/include/glib-2.0/gio/gfileiostream.h
    GType (*ptr_g_file_io_stream_get_type)(void);
    GFileInfo* (*ptr_g_file_io_stream_query_info)(GFileIOStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_io_stream_query_info_async)(GFileIOStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo* (*ptr_g_file_io_stream_query_info_finish)(GFileIOStream *stream, GAsyncResult *result, GError **error);
    char * (*ptr_g_file_io_stream_get_etag)(GFileIOStream *stream);
    // Header /usr/include/glib-2.0/gio/gfilemonitor.h
    GType (*ptr_g_file_monitor_get_type)(void);
    gboolean (*ptr_g_file_monitor_cancel)(GFileMonitor *monitor);
    gboolean (*ptr_g_file_monitor_is_cancelled)(GFileMonitor *monitor);
    void (*ptr_g_file_monitor_set_rate_limit)(GFileMonitor *monitor, gint limit_msecs);
    void (*ptr_g_file_monitor_emit_event)(GFileMonitor *monitor, GFile *child, GFile *other_file, GFileMonitorEvent event_type);
    // Header /usr/include/glib-2.0/gio/gfilenamecompleter.h
    GType (*ptr_g_filename_completer_get_type)(void);
    GFilenameCompleter* (*ptr_g_filename_completer_new)(void);
    char * (*ptr_g_filename_completer_get_completion_suffix)(GFilenameCompleter *completer, const char *initial_text);
    char ** (*ptr_g_filename_completer_get_completions)(GFilenameCompleter *completer, const char *initial_text);
    void (*ptr_g_filename_completer_set_dirs_only)(GFilenameCompleter *completer, gboolean dirs_only);
    // Header /usr/include/glib-2.0/gio/gfileoutputstream.h
    GType (*ptr_g_file_output_stream_get_type)(void);
    GFileInfo* (*ptr_g_file_output_stream_query_info)(GFileOutputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
    void (*ptr_g_file_output_stream_query_info_async)(GFileOutputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GFileInfo* (*ptr_g_file_output_stream_query_info_finish)(GFileOutputStream *stream, GAsyncResult *result, GError **error);
    char * (*ptr_g_file_output_stream_get_etag)(GFileOutputStream *stream);
    // Header /usr/include/glib-2.0/gio/gfilterinputstream.h
    GType (*ptr_g_filter_input_stream_get_type)(void);
    GInputStream * (*ptr_g_filter_input_stream_get_base_stream)(GFilterInputStream *stream);
    gboolean (*ptr_g_filter_input_stream_get_close_base_stream)(GFilterInputStream *stream);
    void (*ptr_g_filter_input_stream_set_close_base_stream)(GFilterInputStream *stream, gboolean close_base);
    // Header /usr/include/glib-2.0/gio/gfilteroutputstream.h
    GType (*ptr_g_filter_output_stream_get_type)(void);
    GOutputStream * (*ptr_g_filter_output_stream_get_base_stream)(GFilterOutputStream *stream);
    gboolean (*ptr_g_filter_output_stream_get_close_base_stream)(GFilterOutputStream *stream);
    void (*ptr_g_filter_output_stream_set_close_base_stream)(GFilterOutputStream *stream, gboolean close_base);
    // Header /usr/include/glib-2.0/gio/gicon.h
    GType (*ptr_g_icon_get_type)(void);
    guint (*ptr_g_icon_hash)(gconstpointer icon);
    gboolean (*ptr_g_icon_equal)(GIcon *icon1, GIcon *icon2);
    gchar* (*ptr_g_icon_to_string)(GIcon *icon);
    GIcon* (*ptr_g_icon_new_for_string)(const gchar *str, GError **error);
    GVariant * (*ptr_g_icon_serialize)(GIcon *icon);
    GIcon * (*ptr_g_icon_deserialize)(GVariant *value);
    // Header /usr/include/glib-2.0/gio/ginetaddress.h
    GType (*ptr_g_inet_address_get_type)(void);
    GInetAddress * (*ptr_g_inet_address_new_from_string)(const gchar *string);
    GInetAddress * (*ptr_g_inet_address_new_from_bytes)(const guint8 *bytes, GSocketFamily family);
    GInetAddress * (*ptr_g_inet_address_new_loopback)(GSocketFamily family);
    GInetAddress * (*ptr_g_inet_address_new_any)(GSocketFamily family);
    gboolean (*ptr_g_inet_address_equal)(GInetAddress *address, GInetAddress *other_address);
    gchar * (*ptr_g_inet_address_to_string)(GInetAddress *address);
    const guint8 * (*ptr_g_inet_address_to_bytes)(GInetAddress *address);
    gsize (*ptr_g_inet_address_get_native_size)(GInetAddress *address);
    GSocketFamily (*ptr_g_inet_address_get_family)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_any)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_loopback)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_link_local)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_site_local)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_multicast)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_mc_global)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_mc_link_local)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_mc_node_local)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_mc_org_local)(GInetAddress *address);
    gboolean (*ptr_g_inet_address_get_is_mc_site_local)(GInetAddress *address);
    // Header /usr/include/glib-2.0/gio/ginetaddressmask.h
    GType (*ptr_g_inet_address_mask_get_type)(void);
    GInetAddressMask* (*ptr_g_inet_address_mask_new)(GInetAddress *addr, guint length, GError **error);
    GInetAddressMask* (*ptr_g_inet_address_mask_new_from_string)(const gchar *mask_string, GError **error);
    gchar* (*ptr_g_inet_address_mask_to_string)(GInetAddressMask *mask);
    GSocketFamily (*ptr_g_inet_address_mask_get_family)(GInetAddressMask *mask);
    GInetAddress* (*ptr_g_inet_address_mask_get_address)(GInetAddressMask *mask);
    guint (*ptr_g_inet_address_mask_get_length)(GInetAddressMask *mask);
    gboolean (*ptr_g_inet_address_mask_matches)(GInetAddressMask *mask, GInetAddress *address);
    gboolean (*ptr_g_inet_address_mask_equal)(GInetAddressMask *mask, GInetAddressMask *mask2);
    // Header /usr/include/glib-2.0/gio/ginetsocketaddress.h
    GType (*ptr_g_inet_socket_address_get_type)(void);
    GSocketAddress* (*ptr_g_inet_socket_address_new)(GInetAddress *address, guint16 port);
    GSocketAddress* (*ptr_g_inet_socket_address_new_from_string)(const char *address, guint port);
    GInetAddress * (*ptr_g_inet_socket_address_get_address)(GInetSocketAddress *address);
    guint16 (*ptr_g_inet_socket_address_get_port)(GInetSocketAddress *address);
    guint32 (*ptr_g_inet_socket_address_get_flowinfo)(GInetSocketAddress *address);
    guint32 (*ptr_g_inet_socket_address_get_scope_id)(GInetSocketAddress *address);
    // Header /usr/include/glib-2.0/gio/ginitable.h
    GType (*ptr_g_initable_get_type)(void);
    gboolean (*ptr_g_initable_init)(GInitable *initable, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/ginputstream.h
    GType (*ptr_g_input_stream_get_type)(void);
    gssize (*ptr_g_input_stream_read)(GInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_input_stream_read_all)(GInputStream *stream, void *buffer, gsize count, gsize *bytes_read, GCancellable *cancellable, GError **error);
    GBytes* (*ptr_g_input_stream_read_bytes)(GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_input_stream_skip)(GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_input_stream_close)(GInputStream *stream, GCancellable *cancellable, GError **error);
    void (*ptr_g_input_stream_read_async)(GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*ptr_g_input_stream_read_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    void (*ptr_g_input_stream_read_all_async)(GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_input_stream_read_all_finish)(GInputStream *stream, GAsyncResult *result, gsize *bytes_read, GError **error);
    void (*ptr_g_input_stream_read_bytes_async)(GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GBytes* (*ptr_g_input_stream_read_bytes_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    void (*ptr_g_input_stream_skip_async)(GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*ptr_g_input_stream_skip_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    void (*ptr_g_input_stream_close_async)(GInputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_input_stream_close_finish)(GInputStream *stream, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_input_stream_is_closed)(GInputStream *stream);
    gboolean (*ptr_g_input_stream_has_pending)(GInputStream *stream);
    gboolean (*ptr_g_input_stream_set_pending)(GInputStream *stream, GError **error);
    void (*ptr_g_input_stream_clear_pending)(GInputStream *stream);
    // Header /usr/include/glib-2.0/gio/gioenums.h
    // Header /usr/include/glib-2.0/gio/gioenumtypes.h
    GType (*ptr_g_app_info_create_flags_get_type)(void);
    GType (*ptr_g_converter_flags_get_type)(void);
    GType (*ptr_g_converter_result_get_type)(void);
    GType (*ptr_g_data_stream_byte_order_get_type)(void);
    GType (*ptr_g_data_stream_newline_type_get_type)(void);
    GType (*ptr_g_file_attribute_type_get_type)(void);
    GType (*ptr_g_file_attribute_info_flags_get_type)(void);
    GType (*ptr_g_file_attribute_status_get_type)(void);
    GType (*ptr_g_file_query_info_flags_get_type)(void);
    GType (*ptr_g_file_create_flags_get_type)(void);
    GType (*ptr_g_file_measure_flags_get_type)(void);
    GType (*ptr_g_mount_mount_flags_get_type)(void);
    GType (*ptr_g_mount_unmount_flags_get_type)(void);
    GType (*ptr_g_drive_start_flags_get_type)(void);
    GType (*ptr_g_drive_start_stop_type_get_type)(void);
    GType (*ptr_g_file_copy_flags_get_type)(void);
    GType (*ptr_g_file_monitor_flags_get_type)(void);
    GType (*ptr_g_file_type_get_type)(void);
    GType (*ptr_g_filesystem_preview_type_get_type)(void);
    GType (*ptr_g_file_monitor_event_get_type)(void);
    GType (*ptr_g_io_error_enum_get_type)(void);
    GType (*ptr_g_ask_password_flags_get_type)(void);
    GType (*ptr_g_password_save_get_type)(void);
    GType (*ptr_g_mount_operation_result_get_type)(void);
    GType (*ptr_g_output_stream_splice_flags_get_type)(void);
    GType (*ptr_g_io_stream_splice_flags_get_type)(void);
    GType (*ptr_g_emblem_origin_get_type)(void);
    GType (*ptr_g_resolver_error_get_type)(void);
    GType (*ptr_g_resolver_record_type_get_type)(void);
    GType (*ptr_g_resource_error_get_type)(void);
    GType (*ptr_g_resource_flags_get_type)(void);
    GType (*ptr_g_resource_lookup_flags_get_type)(void);
    GType (*ptr_g_socket_family_get_type)(void);
    GType (*ptr_g_socket_type_get_type)(void);
    GType (*ptr_g_socket_msg_flags_get_type)(void);
    GType (*ptr_g_socket_protocol_get_type)(void);
    GType (*ptr_g_zlib_compressor_format_get_type)(void);
    GType (*ptr_g_unix_socket_address_type_get_type)(void);
    GType (*ptr_g_bus_type_get_type)(void);
    GType (*ptr_g_bus_name_owner_flags_get_type)(void);
    GType (*ptr_g_bus_name_watcher_flags_get_type)(void);
    GType (*ptr_g_dbus_proxy_flags_get_type)(void);
    GType (*ptr_g_dbus_error_get_type)(void);
    GType (*ptr_g_dbus_connection_flags_get_type)(void);
    GType (*ptr_g_dbus_capability_flags_get_type)(void);
    GType (*ptr_g_dbus_call_flags_get_type)(void);
    GType (*ptr_g_dbus_message_type_get_type)(void);
    GType (*ptr_g_dbus_message_flags_get_type)(void);
    GType (*ptr_g_dbus_message_header_field_get_type)(void);
    GType (*ptr_g_dbus_property_info_flags_get_type)(void);
    GType (*ptr_g_dbus_subtree_flags_get_type)(void);
    GType (*ptr_g_dbus_server_flags_get_type)(void);
    GType (*ptr_g_dbus_signal_flags_get_type)(void);
    GType (*ptr_g_dbus_send_message_flags_get_type)(void);
    GType (*ptr_g_credentials_type_get_type)(void);
    GType (*ptr_g_dbus_message_byte_order_get_type)(void);
    GType (*ptr_g_application_flags_get_type)(void);
    GType (*ptr_g_tls_error_get_type)(void);
    GType (*ptr_g_tls_certificate_flags_get_type)(void);
    GType (*ptr_g_tls_authentication_mode_get_type)(void);
    GType (*ptr_g_tls_channel_binding_type_get_type)(void);
    GType (*ptr_g_tls_channel_binding_error_get_type)(void);
    GType (*ptr_g_tls_rehandshake_mode_get_type)(void);
    GType (*ptr_g_tls_password_flags_get_type)(void);
    GType (*ptr_g_tls_interaction_result_get_type)(void);
    GType (*ptr_g_dbus_interface_skeleton_flags_get_type)(void);
    GType (*ptr_g_dbus_object_manager_client_flags_get_type)(void);
    GType (*ptr_g_tls_database_verify_flags_get_type)(void);
    GType (*ptr_g_tls_database_lookup_flags_get_type)(void);
    GType (*ptr_g_tls_certificate_request_flags_get_type)(void);
    GType (*ptr_g_tls_protocol_version_get_type)(void);
    GType (*ptr_g_io_module_scope_flags_get_type)(void);
    GType (*ptr_g_socket_client_event_get_type)(void);
    GType (*ptr_g_socket_listener_event_get_type)(void);
    GType (*ptr_g_test_dbus_flags_get_type)(void);
    GType (*ptr_g_subprocess_flags_get_type)(void);
    GType (*ptr_g_notification_priority_get_type)(void);
    GType (*ptr_g_network_connectivity_get_type)(void);
    GType (*ptr_g_pollable_return_get_type)(void);
    GType (*ptr_g_memory_monitor_warning_level_get_type)(void);
    GType (*ptr_g_resolver_name_lookup_flags_get_type)(void);
    GType (*ptr_g_settings_bind_flags_get_type)(void);
    // Header /usr/include/glib-2.0/gio/gioerror.h
    GIOErrorEnum (*ptr_g_io_error_from_errno)(gint err_no);
    GIOErrorEnum (*ptr_g_io_error_from_file_error)(GFileError file_error);
    GIOErrorEnum (*ptr_g_io_error_from_win32_error)(gint error_code);
    GQuark (*ptr_g_io_error_quark)(void);
    // Header /usr/include/glib-2.0/gio/giomodule.h
    void (*ptr_g_io_module_scope_free)(GIOModuleScope *scope);
    void (*ptr_g_io_module_scope_block)(GIOModuleScope *scope, const gchar *basename);
    GType (*ptr_g_io_module_get_type)(void);
    GIOModule* (*ptr_g_io_module_new)(const gchar *filename);
    void (*ptr_g_io_modules_scan_all_in_directory)(const char *dirname);
    GList* (*ptr_g_io_modules_load_all_in_directory)(const gchar *dirname);
    void (*ptr_g_io_modules_scan_all_in_directory_with_scope)(const gchar *dirname, GIOModuleScope *scope);
    GList* (*ptr_g_io_modules_load_all_in_directory_with_scope)(const gchar *dirname, GIOModuleScope *scope);
    GIOExtensionPoint* (*ptr_g_io_extension_point_register)(const char *name);
    GIOExtensionPoint* (*ptr_g_io_extension_point_lookup)(const char *name);
    void (*ptr_g_io_extension_point_set_required_type)(GIOExtensionPoint *extension_point, GType type);
    GType (*ptr_g_io_extension_point_get_required_type)(GIOExtensionPoint *extension_point);
    GList* (*ptr_g_io_extension_point_get_extensions)(GIOExtensionPoint *extension_point);
    GIOExtension * (*ptr_g_io_extension_point_get_extension_by_name)(GIOExtensionPoint *extension_point, const char *name);
    GIOExtension * (*ptr_g_io_extension_point_implement)(const char *extension_point_name, GType type, const char *extension_name, gint priority);
    GType (*ptr_g_io_extension_get_type)(GIOExtension *extension);
    const char * (*ptr_g_io_extension_get_name)(GIOExtension *extension);
    gint (*ptr_g_io_extension_get_priority)(GIOExtension *extension);
    GTypeClass* (*ptr_g_io_extension_ref_class)(GIOExtension *extension);
    void (*ptr_g_io_module_load)(GIOModule *module);
    void (*ptr_g_io_module_unload)(GIOModule *module);
    char** (*ptr_g_io_module_query)(void);
    GIOModuleScope * (*ptr_g_io_module_scope_new)(GIOModuleScopeFlags flags);
    // Header /usr/include/glib-2.0/gio/gioscheduler.h
    void (*ptr_g_io_scheduler_cancel_all_jobs)(void);
    gboolean (*ptr_g_io_scheduler_job_send_to_mainloop)(GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
    void (*ptr_g_io_scheduler_job_send_to_mainloop_async)(GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
    void (*ptr_g_io_scheduler_push_job)(GIOSchedulerJobFunc job_func, gpointer user_data, GDestroyNotify notify, gint io_priority, GCancellable *cancellable);
    // Header /usr/include/glib-2.0/gio/giostream.h
    GType (*ptr_g_io_stream_get_type)(void);
    GInputStream * (*ptr_g_io_stream_get_input_stream)(GIOStream *stream);
    GOutputStream* (*ptr_g_io_stream_get_output_stream)(GIOStream *stream);
    void (*ptr_g_io_stream_splice_async)(GIOStream *stream1, GIOStream *stream2, GIOStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_io_stream_splice_finish)(GAsyncResult *result, GError **error);
    gboolean (*ptr_g_io_stream_close)(GIOStream *stream, GCancellable *cancellable, GError **error);
    void (*ptr_g_io_stream_close_async)(GIOStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_io_stream_close_finish)(GIOStream *stream, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_io_stream_is_closed)(GIOStream *stream);
    gboolean (*ptr_g_io_stream_has_pending)(GIOStream *stream);
    gboolean (*ptr_g_io_stream_set_pending)(GIOStream *stream, GError **error);
    void (*ptr_g_io_stream_clear_pending)(GIOStream *stream);
    // Header /usr/include/glib-2.0/gio/giotypes.h
    // Header /usr/include/glib-2.0/gio/glistmodel.h
    GType (*ptr_g_list_model_get_type)(void);
    guint (*ptr_g_list_model_get_n_items)(GListModel *list);
    gpointer (*ptr_g_list_model_get_item)(GListModel *list, guint position);
    GObject * (*ptr_g_list_model_get_object)(GListModel *list, guint position);
    void (*ptr_g_list_model_items_changed)(GListModel *list, guint position, guint removed, guint added);
    // Header /usr/include/glib-2.0/gio/gliststore.h
    GType (*ptr_g_list_store_get_type)(void);
    GListStore * (*ptr_g_list_store_new)(GType item_type);
    void (*ptr_g_list_store_insert)(GListStore *store, guint position, gpointer item);
    guint (*ptr_g_list_store_insert_sorted)(GListStore *store, gpointer item, GCompareDataFunc compare_func, gpointer user_data);
    void (*ptr_g_list_store_sort)(GListStore *store, GCompareDataFunc compare_func, gpointer user_data);
    void (*ptr_g_list_store_append)(GListStore *store, gpointer item);
    void (*ptr_g_list_store_remove)(GListStore *store, guint position);
    void (*ptr_g_list_store_remove_all)(GListStore *store);
    void (*ptr_g_list_store_splice)(GListStore *store, guint position, guint n_removals, gpointer *additions, guint n_additions);
    gboolean (*ptr_g_list_store_find)(GListStore *store, gpointer item, guint *position);
    gboolean (*ptr_g_list_store_find_with_equal_func)(GListStore *store, gpointer item, GEqualFunc equal_func, guint *position);
    gboolean (*ptr_g_list_store_find_with_equal_func_full)(GListStore *store, gpointer item, GEqualFuncFull equal_func, gpointer user_data, guint *position);
    // Header /usr/include/glib-2.0/gio/gloadableicon.h
    GType (*ptr_g_loadable_icon_get_type)(void);
    GInputStream* (*ptr_g_loadable_icon_load)(GLoadableIcon *icon, int size, char **type, GCancellable *cancellable, GError **error);
    void (*ptr_g_loadable_icon_load_async)(GLoadableIcon *icon, int size, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GInputStream* (*ptr_g_loadable_icon_load_finish)(GLoadableIcon *icon, GAsyncResult *res, char **type, GError **error);
    // Header /usr/include/glib-2.0/gio/gmemoryinputstream.h
    GType (*ptr_g_memory_input_stream_get_type)(void);
    GInputStream * (*ptr_g_memory_input_stream_new)(void);
    GInputStream * (*ptr_g_memory_input_stream_new_from_data)(const void *data, gssize len, GDestroyNotify destroy);
    GInputStream * (*ptr_g_memory_input_stream_new_from_bytes)(GBytes *bytes);
    void (*ptr_g_memory_input_stream_add_data)(GMemoryInputStream *stream, const void *data, gssize len, GDestroyNotify destroy);
    void (*ptr_g_memory_input_stream_add_bytes)(GMemoryInputStream *stream, GBytes *bytes);
    // Header /usr/include/glib-2.0/gio/gmemorymonitor.h
    GType (*ptr_g_memory_monitor_get_type)(void);
    // Header /usr/include/glib-2.0/gio/gmemoryoutputstream.h
    GType (*ptr_g_memory_output_stream_get_type)(void);
    GOutputStream* (*ptr_g_memory_output_stream_new)(gpointer data, gsize size, GReallocFunc realloc_function, GDestroyNotify destroy_function);
    GOutputStream* (*ptr_g_memory_output_stream_new_resizable)(void);
    gpointer (*ptr_g_memory_output_stream_get_data)(GMemoryOutputStream *ostream);
    gsize (*ptr_g_memory_output_stream_get_size)(GMemoryOutputStream *ostream);
    gsize (*ptr_g_memory_output_stream_get_data_size)(GMemoryOutputStream *ostream);
    gpointer (*ptr_g_memory_output_stream_steal_data)(GMemoryOutputStream *ostream);
    GBytes * (*ptr_g_memory_output_stream_steal_as_bytes)(GMemoryOutputStream *ostream);
    // Header /usr/include/glib-2.0/gio/gmenu.h
    GType (*ptr_g_menu_get_type)(void);
    GType (*ptr_g_menu_item_get_type)(void);
    GMenu * (*ptr_g_menu_new)(void);
    void (*ptr_g_menu_freeze)(GMenu *menu);
    void (*ptr_g_menu_insert_item)(GMenu *menu, gint position, GMenuItem *item);
    void (*ptr_g_menu_prepend_item)(GMenu *menu, GMenuItem *item);
    void (*ptr_g_menu_append_item)(GMenu *menu, GMenuItem *item);
    void (*ptr_g_menu_remove)(GMenu *menu, gint position);
    void (*ptr_g_menu_remove_all)(GMenu *menu);
    void (*ptr_g_menu_insert)(GMenu *menu, gint position, const gchar *label, const gchar *detailed_action);
    void (*ptr_g_menu_prepend)(GMenu *menu, const gchar *label, const gchar *detailed_action);
    void (*ptr_g_menu_append)(GMenu *menu, const gchar *label, const gchar *detailed_action);
    void (*ptr_g_menu_insert_section)(GMenu *menu, gint position, const gchar *label, GMenuModel *section);
    void (*ptr_g_menu_prepend_section)(GMenu *menu, const gchar *label, GMenuModel *section);
    void (*ptr_g_menu_append_section)(GMenu *menu, const gchar *label, GMenuModel *section);
    void (*ptr_g_menu_insert_submenu)(GMenu *menu, gint position, const gchar *label, GMenuModel *submenu);
    void (*ptr_g_menu_prepend_submenu)(GMenu *menu, const gchar *label, GMenuModel *submenu);
    void (*ptr_g_menu_append_submenu)(GMenu *menu, const gchar *label, GMenuModel *submenu);
    GMenuItem * (*ptr_g_menu_item_new)(const gchar *label, const gchar *detailed_action);
    GMenuItem * (*ptr_g_menu_item_new_from_model)(GMenuModel *model, gint item_index);
    GMenuItem * (*ptr_g_menu_item_new_submenu)(const gchar *label, GMenuModel *submenu);
    GMenuItem * (*ptr_g_menu_item_new_section)(const gchar *label, GMenuModel *section);
    GVariant * (*ptr_g_menu_item_get_attribute_value)(GMenuItem *menu_item, const gchar *attribute, const GVariantType *expected_type);
    GMenuModel* (*ptr_g_menu_item_get_link)(GMenuItem *menu_item, const gchar *link);
    void (*ptr_g_menu_item_set_attribute_value)(GMenuItem *menu_item, const gchar *attribute, GVariant *value);
    void (*ptr_g_menu_item_set_link)(GMenuItem *menu_item, const gchar *link, GMenuModel *model);
    void (*ptr_g_menu_item_set_label)(GMenuItem *menu_item, const gchar *label);
    void (*ptr_g_menu_item_set_submenu)(GMenuItem *menu_item, GMenuModel *submenu);
    void (*ptr_g_menu_item_set_section)(GMenuItem *menu_item, GMenuModel *section);
    void (*ptr_g_menu_item_set_action_and_target_value)(GMenuItem *menu_item, const gchar *action, GVariant *target_value);
    void (*ptr_g_menu_item_set_detailed_action)(GMenuItem *menu_item, const gchar *detailed_action);
    void (*ptr_g_menu_item_set_icon)(GMenuItem *menu_item, GIcon *icon);
    // Header /usr/include/glib-2.0/gio/gmenuexporter.h
    void (*ptr_g_dbus_connection_unexport_menu_model)(GDBusConnection *connection, guint export_id);
    guint (*ptr_g_dbus_connection_export_menu_model)(GDBusConnection *connection, const gchar *object_path, GMenuModel *menu, GError **error);
    // Header /usr/include/glib-2.0/gio/gmenumodel.h
    GType (*ptr_g_menu_model_get_type)(void);
    gboolean (*ptr_g_menu_model_is_mutable)(GMenuModel *model);
    gint (*ptr_g_menu_model_get_n_items)(GMenuModel *model);
    GMenuAttributeIter * (*ptr_g_menu_model_iterate_item_attributes)(GMenuModel *model, gint item_index);
    GVariant * (*ptr_g_menu_model_get_item_attribute_value)(GMenuModel *model, gint item_index, const gchar *attribute, const GVariantType *expected_type);
    GMenuLinkIter * (*ptr_g_menu_model_iterate_item_links)(GMenuModel *model, gint item_index);
    GMenuModel * (*ptr_g_menu_model_get_item_link)(GMenuModel *model, gint item_index, const gchar *link);
    void (*ptr_g_menu_model_items_changed)(GMenuModel *model, gint position, gint removed, gint added);
    GType (*ptr_g_menu_attribute_iter_get_type)(void);
    gboolean (*ptr_g_menu_attribute_iter_get_next)(GMenuAttributeIter *iter, const gchar **out_name, GVariant **value);
    gboolean (*ptr_g_menu_attribute_iter_next)(GMenuAttributeIter *iter);
    const gchar * (*ptr_g_menu_attribute_iter_get_name)(GMenuAttributeIter *iter);
    GVariant * (*ptr_g_menu_attribute_iter_get_value)(GMenuAttributeIter *iter);
    GType (*ptr_g_menu_link_iter_get_type)(void);
    gboolean (*ptr_g_menu_link_iter_get_next)(GMenuLinkIter *iter, const gchar **out_link, GMenuModel **value);
    gboolean (*ptr_g_menu_link_iter_next)(GMenuLinkIter *iter);
    const gchar * (*ptr_g_menu_link_iter_get_name)(GMenuLinkIter *iter);
    GMenuModel * (*ptr_g_menu_link_iter_get_value)(GMenuLinkIter *iter);
    // Header /usr/include/glib-2.0/gio/gmount.h
    GType (*ptr_g_mount_get_type)(void);
    GFile * (*ptr_g_mount_get_root)(GMount *mount);
    GFile * (*ptr_g_mount_get_default_location)(GMount *mount);
    char * (*ptr_g_mount_get_name)(GMount *mount);
    GIcon * (*ptr_g_mount_get_icon)(GMount *mount);
    GIcon * (*ptr_g_mount_get_symbolic_icon)(GMount *mount);
    char * (*ptr_g_mount_get_uuid)(GMount *mount);
    GVolume * (*ptr_g_mount_get_volume)(GMount *mount);
    GDrive * (*ptr_g_mount_get_drive)(GMount *mount);
    gboolean (*ptr_g_mount_can_unmount)(GMount *mount);
    gboolean (*ptr_g_mount_can_eject)(GMount *mount);
    void (*ptr_g_mount_unmount)(GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_mount_unmount_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*ptr_g_mount_eject)(GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_mount_eject_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*ptr_g_mount_remount)(GMount *mount, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_mount_remount_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*ptr_g_mount_guess_content_type)(GMount *mount, gboolean force_rescan, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gchar ** (*ptr_g_mount_guess_content_type_finish)(GMount *mount, GAsyncResult *result, GError **error);
    gchar ** (*ptr_g_mount_guess_content_type_sync)(GMount *mount, gboolean force_rescan, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_mount_is_shadowed)(GMount *mount);
    void (*ptr_g_mount_shadow)(GMount *mount);
    void (*ptr_g_mount_unshadow)(GMount *mount);
    void (*ptr_g_mount_unmount_with_operation)(GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_mount_unmount_with_operation_finish)(GMount *mount, GAsyncResult *result, GError **error);
    void (*ptr_g_mount_eject_with_operation)(GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_mount_eject_with_operation_finish)(GMount *mount, GAsyncResult *result, GError **error);
    const gchar* (*ptr_g_mount_get_sort_key)(GMount *mount);
    // Header /usr/include/glib-2.0/gio/gmountoperation.h
    GType (*ptr_g_mount_operation_get_type)(void);
    GMountOperation * (*ptr_g_mount_operation_new)(void);
    const char * (*ptr_g_mount_operation_get_username)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_username)(GMountOperation *op, const char *username);
    const char * (*ptr_g_mount_operation_get_password)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_password)(GMountOperation *op, const char *password);
    gboolean (*ptr_g_mount_operation_get_anonymous)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_anonymous)(GMountOperation *op, gboolean anonymous);
    const char * (*ptr_g_mount_operation_get_domain)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_domain)(GMountOperation *op, const char *domain);
    GPasswordSave (*ptr_g_mount_operation_get_password_save)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_password_save)(GMountOperation *op, GPasswordSave save);
    int (*ptr_g_mount_operation_get_choice)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_choice)(GMountOperation *op, int choice);
    void (*ptr_g_mount_operation_reply)(GMountOperation *op, GMountOperationResult result);
    gboolean (*ptr_g_mount_operation_get_is_tcrypt_hidden_volume)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_is_tcrypt_hidden_volume)(GMountOperation *op, gboolean hidden_volume);
    gboolean (*ptr_g_mount_operation_get_is_tcrypt_system_volume)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_is_tcrypt_system_volume)(GMountOperation *op, gboolean system_volume);
    guint (*ptr_g_mount_operation_get_pim)(GMountOperation *op);
    void (*ptr_g_mount_operation_set_pim)(GMountOperation *op, guint pim);
    // Header /usr/include/glib-2.0/gio/gnativesocketaddress.h
    GType (*ptr_g_native_socket_address_get_type)(void);
    GSocketAddress* (*ptr_g_native_socket_address_new)(gpointer native, gsize len);
    // Header /usr/include/glib-2.0/gio/gnativevolumemonitor.h
    GType (*ptr_g_native_volume_monitor_get_type)(void);
    // Header /usr/include/glib-2.0/gio/gnetworkaddress.h
    GType (*ptr_g_network_address_get_type)(void);
    GSocketConnectable* (*ptr_g_network_address_new)(const gchar *hostname, guint16 port);
    GSocketConnectable* (*ptr_g_network_address_new_loopback)(guint16 port);
    GSocketConnectable* (*ptr_g_network_address_parse)(const gchar *host_and_port, guint16 default_port, GError **error);
    GSocketConnectable* (*ptr_g_network_address_parse_uri)(const gchar *uri, guint16 default_port, GError **error);
    const gchar* (*ptr_g_network_address_get_hostname)(GNetworkAddress *addr);
    guint16 (*ptr_g_network_address_get_port)(GNetworkAddress *addr);
    const gchar* (*ptr_g_network_address_get_scheme)(GNetworkAddress *addr);
    // Header /usr/include/glib-2.0/gio/gnetworking.h
    void (*ptr_g_networking_init)(void);
    // Header /usr/include/glib-2.0/gio/gnetworkmonitor.h
    GType (*ptr_g_network_monitor_get_type)(void);
    GNetworkMonitor* (*ptr_g_network_monitor_get_default)(void);
    gboolean (*ptr_g_network_monitor_get_network_available)(GNetworkMonitor *monitor);
    gboolean (*ptr_g_network_monitor_get_network_metered)(GNetworkMonitor *monitor);
    GNetworkConnectivity (*ptr_g_network_monitor_get_connectivity)(GNetworkMonitor *monitor);
    gboolean (*ptr_g_network_monitor_can_reach)(GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
    void (*ptr_g_network_monitor_can_reach_async)(GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_network_monitor_can_reach_finish)(GNetworkMonitor *monitor, GAsyncResult *result, GError **error);
    // Header /usr/include/glib-2.0/gio/gnetworkservice.h
    GType (*ptr_g_network_service_get_type)(void);
    GSocketConnectable* (*ptr_g_network_service_new)(const gchar *service, const gchar *protocol, const gchar *domain);
    const gchar* (*ptr_g_network_service_get_service)(GNetworkService *srv);
    const gchar* (*ptr_g_network_service_get_protocol)(GNetworkService *srv);
    const gchar* (*ptr_g_network_service_get_domain)(GNetworkService *srv);
    const gchar* (*ptr_g_network_service_get_scheme)(GNetworkService *srv);
    void (*ptr_g_network_service_set_scheme)(GNetworkService *srv, const gchar *scheme);
    // Header /usr/include/glib-2.0/gio/gnotification.h
    GType (*ptr_g_notification_get_type)(void);
    GNotification * (*ptr_g_notification_new)(const gchar *title);
    void (*ptr_g_notification_set_title)(GNotification *notification, const gchar *title);
    void (*ptr_g_notification_set_body)(GNotification *notification, const gchar *body);
    void (*ptr_g_notification_set_icon)(GNotification *notification, GIcon *icon);
    void (*ptr_g_notification_set_urgent)(GNotification *notification, gboolean urgent);
    void (*ptr_g_notification_set_priority)(GNotification *notification, GNotificationPriority priority);
    void (*ptr_g_notification_set_category)(GNotification *notification, const gchar *category);
    void (*ptr_g_notification_add_button)(GNotification *notification, const gchar *label, const gchar *detailed_action);
    void (*ptr_g_notification_add_button_with_target_value)(GNotification *notification, const gchar *label, const gchar *action, GVariant *target);
    void (*ptr_g_notification_set_default_action)(GNotification *notification, const gchar *detailed_action);
    void (*ptr_g_notification_set_default_action_and_target_value)(GNotification *notification, const gchar *action, GVariant *target);
    // Header /usr/include/glib-2.0/gio/goutputstream.h
    GType (*ptr_g_output_stream_get_type)(void);
    gssize (*ptr_g_output_stream_write)(GOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_output_stream_write_all)(GOutputStream *stream, const void *buffer, gsize count, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_output_stream_writev)(GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_output_stream_writev_all)(GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_output_stream_vprintf)(GOutputStream *stream, gsize *bytes_written, GCancellable *cancellable, GError **error, const gchar *format, va_list args);
    gssize (*ptr_g_output_stream_write_bytes)(GOutputStream *stream, GBytes *bytes, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_output_stream_splice)(GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_output_stream_flush)(GOutputStream *stream, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_output_stream_close)(GOutputStream *stream, GCancellable *cancellable, GError **error);
    void (*ptr_g_output_stream_write_async)(GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*ptr_g_output_stream_write_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*ptr_g_output_stream_write_all_async)(GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_output_stream_write_all_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
    void (*ptr_g_output_stream_writev_async)(GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_output_stream_writev_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
    void (*ptr_g_output_stream_writev_all_async)(GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_output_stream_writev_all_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
    void (*ptr_g_output_stream_write_bytes_async)(GOutputStream *stream, GBytes *bytes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*ptr_g_output_stream_write_bytes_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*ptr_g_output_stream_splice_async)(GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gssize (*ptr_g_output_stream_splice_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*ptr_g_output_stream_flush_async)(GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_output_stream_flush_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    void (*ptr_g_output_stream_close_async)(GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_output_stream_close_finish)(GOutputStream *stream, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_output_stream_is_closed)(GOutputStream *stream);
    gboolean (*ptr_g_output_stream_is_closing)(GOutputStream *stream);
    gboolean (*ptr_g_output_stream_has_pending)(GOutputStream *stream);
    gboolean (*ptr_g_output_stream_set_pending)(GOutputStream *stream, GError **error);
    void (*ptr_g_output_stream_clear_pending)(GOutputStream *stream);
    // Header /usr/include/glib-2.0/gio/gpermission.h
    GType (*ptr_g_permission_get_type)(void);
    gboolean (*ptr_g_permission_acquire)(GPermission *permission, GCancellable *cancellable, GError **error);
    void (*ptr_g_permission_acquire_async)(GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_permission_acquire_finish)(GPermission *permission, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_permission_release)(GPermission *permission, GCancellable *cancellable, GError **error);
    void (*ptr_g_permission_release_async)(GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_permission_release_finish)(GPermission *permission, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_permission_get_allowed)(GPermission *permission);
    gboolean (*ptr_g_permission_get_can_acquire)(GPermission *permission);
    gboolean (*ptr_g_permission_get_can_release)(GPermission *permission);
    void (*ptr_g_permission_impl_update)(GPermission *permission, gboolean allowed, gboolean can_acquire, gboolean can_release);
    // Header /usr/include/glib-2.0/gio/gpollableinputstream.h
    GType (*ptr_g_pollable_input_stream_get_type)(void);
    gboolean (*ptr_g_pollable_input_stream_can_poll)(GPollableInputStream *stream);
    gboolean (*ptr_g_pollable_input_stream_is_readable)(GPollableInputStream *stream);
    GSource* (*ptr_g_pollable_input_stream_create_source)(GPollableInputStream *stream, GCancellable *cancellable);
    gssize (*ptr_g_pollable_input_stream_read_nonblocking)(GPollableInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gpollableoutputstream.h
    GType (*ptr_g_pollable_output_stream_get_type)(void);
    gboolean (*ptr_g_pollable_output_stream_can_poll)(GPollableOutputStream *stream);
    gboolean (*ptr_g_pollable_output_stream_is_writable)(GPollableOutputStream *stream);
    GSource* (*ptr_g_pollable_output_stream_create_source)(GPollableOutputStream *stream, GCancellable *cancellable);
    gssize (*ptr_g_pollable_output_stream_write_nonblocking)(GPollableOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
    GPollableReturn (*ptr_g_pollable_output_stream_writev_nonblocking)(GPollableOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gpollableutils.h
    GSource* (*ptr_g_pollable_source_new_full)(gpointer pollable_stream, GSource *child_source, GCancellable *cancellable);
    gssize (*ptr_g_pollable_stream_read)(GInputStream *stream, void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_pollable_stream_write)(GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_pollable_stream_write_all)(GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, gsize *bytes_written, GCancellable *cancellable, GError **error);
    GSource* (*ptr_g_pollable_source_new)(GObject *pollable_stream);
    // Header /usr/include/glib-2.0/gio/gpowerprofilemonitor.h
    GType (*ptr_g_power_profile_monitor_get_type)(void);
    gboolean (*ptr_g_power_profile_monitor_get_power_saver_enabled)(GPowerProfileMonitor *monitor);
    // Header /usr/include/glib-2.0/gio/gpropertyaction.h
    GType (*ptr_g_property_action_get_type)(void);
    GPropertyAction * (*ptr_g_property_action_new)(const gchar *name, gpointer object, const gchar *property_name);
    // Header /usr/include/glib-2.0/gio/gproxy.h
    GType (*ptr_g_proxy_get_type)(void);
    GProxy* (*ptr_g_proxy_get_default_for_protocol)(const gchar *protocol);
    GIOStream* (*ptr_g_proxy_connect)(GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GError **error);
    void (*ptr_g_proxy_connect_async)(GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GIOStream* (*ptr_g_proxy_connect_finish)(GProxy *proxy, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_proxy_supports_hostname)(GProxy *proxy);
    // Header /usr/include/glib-2.0/gio/gproxyaddress.h
    GType (*ptr_g_proxy_address_get_type)(void);
    GSocketAddress* (*ptr_g_proxy_address_new)(GInetAddress *inetaddr, guint16 port, const gchar *protocol, const gchar *dest_hostname, guint16 dest_port, const gchar *username, const gchar *password);
    const gchar* (*ptr_g_proxy_address_get_protocol)(GProxyAddress *proxy);
    const gchar* (*ptr_g_proxy_address_get_destination_protocol)(GProxyAddress *proxy);
    const gchar* (*ptr_g_proxy_address_get_destination_hostname)(GProxyAddress *proxy);
    guint16 (*ptr_g_proxy_address_get_destination_port)(GProxyAddress *proxy);
    const gchar* (*ptr_g_proxy_address_get_username)(GProxyAddress *proxy);
    const gchar* (*ptr_g_proxy_address_get_password)(GProxyAddress *proxy);
    const gchar* (*ptr_g_proxy_address_get_uri)(GProxyAddress *proxy);
    // Header /usr/include/glib-2.0/gio/gproxyaddressenumerator.h
    GType (*ptr_g_proxy_address_enumerator_get_type)(void);
    // Header /usr/include/glib-2.0/gio/gproxyresolver.h
    GType (*ptr_g_proxy_resolver_get_type)(void);
    GProxyResolver* (*ptr_g_proxy_resolver_get_default)(void);
    gboolean (*ptr_g_proxy_resolver_is_supported)(GProxyResolver *resolver);
    gchar** (*ptr_g_proxy_resolver_lookup)(GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GError **error);
    void (*ptr_g_proxy_resolver_lookup_async)(GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gchar** (*ptr_g_proxy_resolver_lookup_finish)(GProxyResolver *resolver, GAsyncResult *result, GError **error);
    // Header /usr/include/glib-2.0/gio/gremoteactiongroup.h
    GType (*ptr_g_remote_action_group_get_type)(void);
    void (*ptr_g_remote_action_group_activate_action_full)(GRemoteActionGroup *remote, const gchar *action_name, GVariant *parameter, GVariant *platform_data);
    void (*ptr_g_remote_action_group_change_action_state_full)(GRemoteActionGroup *remote, const gchar *action_name, GVariant *value, GVariant *platform_data);
    // Header /usr/include/glib-2.0/gio/gresolver.h
    GType (*ptr_g_resolver_get_type)(void);
    GResolver* (*ptr_g_resolver_get_default)(void);
    void (*ptr_g_resolver_set_default)(GResolver *resolver);
    GList* (*ptr_g_resolver_lookup_by_name)(GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GError **error);
    void (*ptr_g_resolver_lookup_by_name_async)(GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*ptr_g_resolver_lookup_by_name_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    void (*ptr_g_resolver_lookup_by_name_with_flags_async)(GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*ptr_g_resolver_lookup_by_name_with_flags_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    GList* (*ptr_g_resolver_lookup_by_name_with_flags)(GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_resolver_free_addresses)(GList *addresses);
    gchar* (*ptr_g_resolver_lookup_by_address)(GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GError **error);
    void (*ptr_g_resolver_lookup_by_address_async)(GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gchar* (*ptr_g_resolver_lookup_by_address_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    GList* (*ptr_g_resolver_lookup_service)(GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GError **error);
    void (*ptr_g_resolver_lookup_service_async)(GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*ptr_g_resolver_lookup_service_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    GList* (*ptr_g_resolver_lookup_records)(GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GError **error);
    void (*ptr_g_resolver_lookup_records_async)(GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*ptr_g_resolver_lookup_records_finish)(GResolver *resolver, GAsyncResult *result, GError **error);
    void (*ptr_g_resolver_free_targets)(GList *targets);
    unsigned (*ptr_g_resolver_get_timeout)(GResolver *resolver);
    void (*ptr_g_resolver_set_timeout)(GResolver *resolver, unsigned timeout_ms);
    GQuark (*ptr_g_resolver_error_quark)(void);
    // Header /usr/include/glib-2.0/gio/gresource.h
    GType (*ptr_g_resource_get_type)(void);
    GQuark (*ptr_g_resource_error_quark)(void);
    GResource * (*ptr_g_resource_new_from_data)(GBytes *data, GError **error);
    GResource * (*ptr_g_resource_ref)(GResource *resource);
    void (*ptr_g_resource_unref)(GResource *resource);
    GResource * (*ptr_g_resource_load)(const gchar *filename, GError **error);
    GInputStream* (*ptr_g_resource_open_stream)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
    GBytes * (*ptr_g_resource_lookup_data)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
    char ** (*ptr_g_resource_enumerate_children)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
    gboolean (*ptr_g_resource_get_info)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
    void (*ptr_g_resources_register)(GResource *resource);
    void (*ptr_g_resources_unregister)(GResource *resource);
    GInputStream* (*ptr_g_resources_open_stream)(const char *path, GResourceLookupFlags lookup_flags, GError **error);
    GBytes * (*ptr_g_resources_lookup_data)(const char *path, GResourceLookupFlags lookup_flags, GError **error);
    char ** (*ptr_g_resources_enumerate_children)(const char *path, GResourceLookupFlags lookup_flags, GError **error);
    gboolean (*ptr_g_resources_get_info)(const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
    // Header /usr/include/glib-2.0/gio/gseekable.h
    GType (*ptr_g_seekable_get_type)(void);
    goffset (*ptr_g_seekable_tell)(GSeekable *seekable);
    gboolean (*ptr_g_seekable_can_seek)(GSeekable *seekable);
    gboolean (*ptr_g_seekable_seek)(GSeekable *seekable, goffset offset, GSeekType type, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_seekable_can_truncate)(GSeekable *seekable);
    gboolean (*ptr_g_seekable_truncate)(GSeekable *seekable, goffset offset, GCancellable *cancellable, GError **error);
    // Header /usr/include/glib-2.0/gio/gsettings.h
    GType (*ptr_g_settings_get_type)(void);
    const gchar * const * (*ptr_g_settings_list_schemas)(void);
    const gchar * const * (*ptr_g_settings_list_relocatable_schemas)(void);
    GSettings * (*ptr_g_settings_new)(const gchar *schema_id);
    GSettings * (*ptr_g_settings_new_with_path)(const gchar *schema_id, const gchar *path);
    GSettings * (*ptr_g_settings_new_with_backend)(const gchar *schema_id, GSettingsBackend *backend);
    GSettings * (*ptr_g_settings_new_with_backend_and_path)(const gchar *schema_id, GSettingsBackend *backend, const gchar *path);
    GSettings * (*ptr_g_settings_new_full)(GSettingsSchema *schema, GSettingsBackend *backend, const gchar *path);
    gchar ** (*ptr_g_settings_list_children)(GSettings *settings);
    gchar ** (*ptr_g_settings_list_keys)(GSettings *settings);
    GVariant * (*ptr_g_settings_get_range)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_range_check)(GSettings *settings, const gchar *key, GVariant *value);
    gboolean (*ptr_g_settings_set_value)(GSettings *settings, const gchar *key, GVariant *value);
    GVariant * (*ptr_g_settings_get_value)(GSettings *settings, const gchar *key);
    GVariant * (*ptr_g_settings_get_user_value)(GSettings *settings, const gchar *key);
    GVariant * (*ptr_g_settings_get_default_value)(GSettings *settings, const gchar *key);
    void (*ptr_g_settings_reset)(GSettings *settings, const gchar *key);
    gint (*ptr_g_settings_get_int)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_int)(GSettings *settings, const gchar *key, gint value);
    gint64 (*ptr_g_settings_get_int64)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_int64)(GSettings *settings, const gchar *key, gint64 value);
    guint (*ptr_g_settings_get_uint)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_uint)(GSettings *settings, const gchar *key, guint value);
    guint64 (*ptr_g_settings_get_uint64)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_uint64)(GSettings *settings, const gchar *key, guint64 value);
    gchar * (*ptr_g_settings_get_string)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_string)(GSettings *settings, const gchar *key, const gchar *value);
    gboolean (*ptr_g_settings_get_boolean)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_boolean)(GSettings *settings, const gchar *key, gboolean value);
    gdouble (*ptr_g_settings_get_double)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_double)(GSettings *settings, const gchar *key, gdouble value);
    gchar ** (*ptr_g_settings_get_strv)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_strv)(GSettings *settings, const gchar *key, const gchar *const *value);
    gint (*ptr_g_settings_get_enum)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_enum)(GSettings *settings, const gchar *key, gint value);
    guint (*ptr_g_settings_get_flags)(GSettings *settings, const gchar *key);
    gboolean (*ptr_g_settings_set_flags)(GSettings *settings, const gchar *key, guint value);
    GSettings * (*ptr_g_settings_get_child)(GSettings *settings, const gchar *name);
    gboolean (*ptr_g_settings_is_writable)(GSettings *settings, const gchar *name);
    void (*ptr_g_settings_delay)(GSettings *settings);
    void (*ptr_g_settings_apply)(GSettings *settings);
    void (*ptr_g_settings_revert)(GSettings *settings);
    gboolean (*ptr_g_settings_get_has_unapplied)(GSettings *settings);
    void (*ptr_g_settings_sync)(void);
    void (*ptr_g_settings_bind)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags);
    void (*ptr_g_settings_bind_with_mapping)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags, GSettingsBindGetMapping get_mapping, GSettingsBindSetMapping set_mapping, gpointer user_data, GDestroyNotify destroy);
    void (*ptr_g_settings_bind_writable)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, gboolean inverted);
    void (*ptr_g_settings_unbind)(gpointer object, const gchar *property);
    GAction * (*ptr_g_settings_create_action)(GSettings *settings, const gchar *key);
    gpointer (*ptr_g_settings_get_mapped)(GSettings *settings, const gchar *key, GSettingsGetMapping mapping, gpointer user_data);
    // Header /usr/include/glib-2.0/gio/gsettingsbackend.h
    GType (*ptr_g_settings_backend_get_type)(void);
    void (*ptr_g_settings_backend_changed)(GSettingsBackend *backend, const gchar *key, gpointer origin_tag);
    void (*ptr_g_settings_backend_path_changed)(GSettingsBackend *backend, const gchar *path, gpointer origin_tag);
    void (*ptr_g_settings_backend_flatten_tree)(GTree *tree, gchar **path, const gchar ***keys, GVariant ***values);
    void (*ptr_g_settings_backend_keys_changed)(GSettingsBackend *backend, const gchar *path, gchar const * const *items, gpointer origin_tag);
    void (*ptr_g_settings_backend_path_writable_changed)(GSettingsBackend *backend, const gchar *path);
    void (*ptr_g_settings_backend_writable_changed)(GSettingsBackend *backend, const gchar *key);
    void (*ptr_g_settings_backend_changed_tree)(GSettingsBackend *backend, GTree *tree, gpointer origin_tag);
    GSettingsBackend * (*ptr_g_settings_backend_get_default)(void);
    GSettingsBackend * (*ptr_g_keyfile_settings_backend_new)(const gchar *filename, const gchar *root_path, const gchar *root_group);
    GSettingsBackend * (*ptr_g_null_settings_backend_new)(void);
    GSettingsBackend * (*ptr_g_memory_settings_backend_new)(void);
    // Header /usr/include/glib-2.0/gio/gsettingsschema.h
    GSettingsSchemaSource * (*ptr_g_settings_schema_source_get_default)(void);
    GSettingsSchemaSource * (*ptr_g_settings_schema_source_ref)(GSettingsSchemaSource *source);
    void (*ptr_g_settings_schema_source_unref)(GSettingsSchemaSource *source);
    GSettingsSchemaSource * (*ptr_g_settings_schema_source_new_from_directory)(const gchar *directory, GSettingsSchemaSource *parent, gboolean trusted, GError **error);
    GSettingsSchema * (*ptr_g_settings_schema_source_lookup)(GSettingsSchemaSource *source, const gchar *schema_id, gboolean recursive);
    void (*ptr_g_settings_schema_source_list_schemas)(GSettingsSchemaSource *source, gboolean recursive, gchar ***non_relocatable, gchar ***relocatable);
    GType (*ptr_g_settings_schema_get_type)(void);
    GSettingsSchema * (*ptr_g_settings_schema_ref)(GSettingsSchema *schema);
    void (*ptr_g_settings_schema_unref)(GSettingsSchema *schema);
    const gchar * (*ptr_g_settings_schema_get_id)(GSettingsSchema *schema);
    const gchar * (*ptr_g_settings_schema_get_path)(GSettingsSchema *schema);
    GSettingsSchemaKey * (*ptr_g_settings_schema_get_key)(GSettingsSchema *schema, const gchar *name);
    gboolean (*ptr_g_settings_schema_has_key)(GSettingsSchema *schema, const gchar *name);
    gchar** (*ptr_g_settings_schema_list_keys)(GSettingsSchema *schema);
    gchar ** (*ptr_g_settings_schema_list_children)(GSettingsSchema *schema);
    GType (*ptr_g_settings_schema_key_get_type)(void);
    GSettingsSchemaKey * (*ptr_g_settings_schema_key_ref)(GSettingsSchemaKey *key);
    void (*ptr_g_settings_schema_key_unref)(GSettingsSchemaKey *key);
    const GVariantType * (*ptr_g_settings_schema_key_get_value_type)(GSettingsSchemaKey *key);
    GVariant * (*ptr_g_settings_schema_key_get_default_value)(GSettingsSchemaKey *key);
    GVariant * (*ptr_g_settings_schema_key_get_range)(GSettingsSchemaKey *key);
    gboolean (*ptr_g_settings_schema_key_range_check)(GSettingsSchemaKey *key, GVariant *value);
    const gchar * (*ptr_g_settings_schema_key_get_name)(GSettingsSchemaKey *key);
    const gchar * (*ptr_g_settings_schema_key_get_summary)(GSettingsSchemaKey *key);
    const gchar * (*ptr_g_settings_schema_key_get_description)(GSettingsSchemaKey *key);
    GType (*ptr_g_settings_schema_source_get_type)(void);
    // Header /usr/include/glib-2.0/gio/gsimpleaction.h
    GType (*ptr_g_simple_action_get_type)(void);
    GSimpleAction * (*ptr_g_simple_action_new)(const gchar *name, const GVariantType *parameter_type);
    GSimpleAction * (*ptr_g_simple_action_new_stateful)(const gchar *name, const GVariantType *parameter_type, GVariant *state);
    void (*ptr_g_simple_action_set_enabled)(GSimpleAction *simple, gboolean enabled);
    void (*ptr_g_simple_action_set_state)(GSimpleAction *simple, GVariant *value);
    void (*ptr_g_simple_action_set_state_hint)(GSimpleAction *simple, GVariant *state_hint);
    // Header /usr/include/glib-2.0/gio/gsimpleactiongroup.h
    GType (*ptr_g_simple_action_group_get_type)(void);
    GSimpleActionGroup * (*ptr_g_simple_action_group_new)(void);
    GAction * (*ptr_g_simple_action_group_lookup)(GSimpleActionGroup *simple, const gchar *action_name);
    void (*ptr_g_simple_action_group_insert)(GSimpleActionGroup *simple, GAction *action);
    void (*ptr_g_simple_action_group_remove)(GSimpleActionGroup *simple, const gchar *action_name);
    void (*ptr_g_simple_action_group_add_entries)(GSimpleActionGroup *simple, const GActionEntry *entries, gint n_entries, gpointer user_data);
    // Header /usr/include/glib-2.0/gio/gsimpleasyncresult.h
    GType (*ptr_g_simple_async_result_get_type)(void);
    GSimpleAsyncResult* (*ptr_g_simple_async_result_new)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, gpointer source_tag);
    GSimpleAsyncResult* (*ptr_g_simple_async_result_new_from_error)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
    GSimpleAsyncResult* (*ptr_g_simple_async_result_new_take_error)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
    void (*ptr_g_simple_async_result_set_op_res_gpointer)(GSimpleAsyncResult *simple, gpointer op_res, GDestroyNotify destroy_op_res);
    gpointer (*ptr_g_simple_async_result_get_op_res_gpointer)(GSimpleAsyncResult *simple);
    void (*ptr_g_simple_async_result_set_op_res_gssize)(GSimpleAsyncResult *simple, gssize op_res);
    gssize (*ptr_g_simple_async_result_get_op_res_gssize)(GSimpleAsyncResult *simple);
    void (*ptr_g_simple_async_result_set_op_res_gboolean)(GSimpleAsyncResult *simple, gboolean op_res);
    gboolean (*ptr_g_simple_async_result_get_op_res_gboolean)(GSimpleAsyncResult *simple);
    void (*ptr_g_simple_async_result_set_check_cancellable)(GSimpleAsyncResult *simple, GCancellable *check_cancellable);
    gpointer (*ptr_g_simple_async_result_get_source_tag)(GSimpleAsyncResult *simple);
    void (*ptr_g_simple_async_result_set_handle_cancellation)(GSimpleAsyncResult *simple, gboolean handle_cancellation);
    void (*ptr_g_simple_async_result_complete)(GSimpleAsyncResult *simple);
    void (*ptr_g_simple_async_result_complete_in_idle)(GSimpleAsyncResult *simple);
    void (*ptr_g_simple_async_result_run_in_thread)(GSimpleAsyncResult *simple, GSimpleAsyncThreadFunc func, int io_priority, GCancellable *cancellable);
    void (*ptr_g_simple_async_result_set_from_error)(GSimpleAsyncResult *simple, const GError *error);
    void (*ptr_g_simple_async_result_take_error)(GSimpleAsyncResult *simple, GError *error);
    gboolean (*ptr_g_simple_async_result_propagate_error)(GSimpleAsyncResult *simple, GError **dest);
    void (*ptr_g_simple_async_result_set_error_va)(GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, va_list args);
    gboolean (*ptr_g_simple_async_result_is_valid)(GAsyncResult *result, GObject *source, gpointer source_tag);
    void (*ptr_g_simple_async_report_gerror_in_idle)(GObject *object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
    void (*ptr_g_simple_async_report_take_gerror_in_idle)(GObject *object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
    // Header /usr/include/glib-2.0/gio/gsimpleiostream.h
    GType (*ptr_g_simple_io_stream_get_type)(void);
    GIOStream* (*ptr_g_simple_io_stream_new)(GInputStream *input_stream, GOutputStream *output_stream);
    // Header /usr/include/glib-2.0/gio/gsimplepermission.h
    GType (*ptr_g_simple_permission_get_type)(void);
    GPermission * (*ptr_g_simple_permission_new)(gboolean allowed);
    // Header /usr/include/glib-2.0/gio/gsimpleproxyresolver.h
    GType (*ptr_g_simple_proxy_resolver_get_type)(void);
    GProxyResolver* (*ptr_g_simple_proxy_resolver_new)(const gchar *default_proxy, gchar **ignore_hosts);
    void (*ptr_g_simple_proxy_resolver_set_default_proxy)(GSimpleProxyResolver *resolver, const gchar *default_proxy);
    void (*ptr_g_simple_proxy_resolver_set_ignore_hosts)(GSimpleProxyResolver *resolver, gchar **ignore_hosts);
    void (*ptr_g_simple_proxy_resolver_set_uri_proxy)(GSimpleProxyResolver *resolver, const gchar *uri_scheme, const gchar *proxy);
    // Header /usr/include/glib-2.0/gio/gsocket.h
    GType (*ptr_g_socket_get_type)(void);
    GSocket * (*ptr_g_socket_new)(GSocketFamily family, GSocketType type, GSocketProtocol protocol, GError **error);
    GSocket * (*ptr_g_socket_new_from_fd)(gint fd, GError **error);
    int (*ptr_g_socket_get_fd)(GSocket *socket);
    GSocketFamily (*ptr_g_socket_get_family)(GSocket *socket);
    GSocketType (*ptr_g_socket_get_socket_type)(GSocket *socket);
    GSocketProtocol (*ptr_g_socket_get_protocol)(GSocket *socket);
    GSocketAddress * (*ptr_g_socket_get_local_address)(GSocket *socket, GError **error);
    GSocketAddress * (*ptr_g_socket_get_remote_address)(GSocket *socket, GError **error);
    void (*ptr_g_socket_set_blocking)(GSocket *socket, gboolean blocking);
    gboolean (*ptr_g_socket_get_blocking)(GSocket *socket);
    void (*ptr_g_socket_set_keepalive)(GSocket *socket, gboolean keepalive);
    gboolean (*ptr_g_socket_get_keepalive)(GSocket *socket);
    gint (*ptr_g_socket_get_listen_backlog)(GSocket *socket);
    void (*ptr_g_socket_set_listen_backlog)(GSocket *socket, gint backlog);
    guint (*ptr_g_socket_get_timeout)(GSocket *socket);
    void (*ptr_g_socket_set_timeout)(GSocket *socket, guint timeout);
    guint (*ptr_g_socket_get_ttl)(GSocket *socket);
    void (*ptr_g_socket_set_ttl)(GSocket *socket, guint ttl);
    gboolean (*ptr_g_socket_get_broadcast)(GSocket *socket);
    void (*ptr_g_socket_set_broadcast)(GSocket *socket, gboolean broadcast);
    gboolean (*ptr_g_socket_get_multicast_loopback)(GSocket *socket);
    void (*ptr_g_socket_set_multicast_loopback)(GSocket *socket, gboolean loopback);
    guint (*ptr_g_socket_get_multicast_ttl)(GSocket *socket);
    void (*ptr_g_socket_set_multicast_ttl)(GSocket *socket, guint ttl);
    gboolean (*ptr_g_socket_is_connected)(GSocket *socket);
    gboolean (*ptr_g_socket_bind)(GSocket *socket, GSocketAddress *address, gboolean allow_reuse, GError **error);
    gboolean (*ptr_g_socket_join_multicast_group)(GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
    gboolean (*ptr_g_socket_leave_multicast_group)(GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
    gboolean (*ptr_g_socket_join_multicast_group_ssm)(GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
    gboolean (*ptr_g_socket_leave_multicast_group_ssm)(GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
    gboolean (*ptr_g_socket_connect)(GSocket *socket, GSocketAddress *address, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_socket_check_connect_result)(GSocket *socket, GError **error);
    gssize (*ptr_g_socket_get_available_bytes)(GSocket *socket);
    GIOCondition (*ptr_g_socket_condition_check)(GSocket *socket, GIOCondition condition);
    gboolean (*ptr_g_socket_condition_wait)(GSocket *socket, GIOCondition condition, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_socket_condition_timed_wait)(GSocket *socket, GIOCondition condition, gint64 timeout_us, GCancellable *cancellable, GError **error);
    GSocket * (*ptr_g_socket_accept)(GSocket *socket, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_socket_listen)(GSocket *socket, GError **error);
    gssize (*ptr_g_socket_receive)(GSocket *socket, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    GBytes * (*ptr_g_socket_receive_bytes)(GSocket *socket, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_socket_receive_from)(GSocket *socket, GSocketAddress **address, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    GBytes * (*ptr_g_socket_receive_bytes_from)(GSocket *socket, GSocketAddress **address, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_socket_send)(GSocket *socket, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_socket_send_to)(GSocket *socket, GSocketAddress *address, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_socket_receive_message)(GSocket *socket, GSocketAddress **address, GInputVector *vectors, gint num_vectors, GSocketControlMessage ***messages, gint *num_messages, gint *flags, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_socket_send_message)(GSocket *socket, GSocketAddress *address, GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, GCancellable *cancellable, GError **error);
    gint (*ptr_g_socket_receive_messages)(GSocket *socket, GInputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
    gint (*ptr_g_socket_send_messages)(GSocket *socket, GOutputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_socket_close)(GSocket *socket, GError **error);
    gboolean (*ptr_g_socket_shutdown)(GSocket *socket, gboolean shutdown_read, gboolean shutdown_write, GError **error);
    gboolean (*ptr_g_socket_is_closed)(GSocket *socket);
    GSource * (*ptr_g_socket_create_source)(GSocket *socket, GIOCondition condition, GCancellable *cancellable);
    gboolean (*ptr_g_socket_speaks_ipv4)(GSocket *socket);
    GCredentials* (*ptr_g_socket_get_credentials)(GSocket *socket, GError **error);
    gssize (*ptr_g_socket_receive_with_blocking)(GSocket *socket, gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
    gssize (*ptr_g_socket_send_with_blocking)(GSocket *socket, const gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
    GPollableReturn (*ptr_g_socket_send_message_with_timeout)(GSocket *socket, GSocketAddress *address, const GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, gint64 timeout_us, gsize *bytes_written, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_socket_get_option)(GSocket *socket, gint level, gint optname, gint *value, GError **error);
    gboolean (*ptr_g_socket_set_option)(GSocket *socket, gint level, gint optname, gint value, GError **error);
    // Header /usr/include/glib-2.0/gio/gsocketaddress.h
    GType (*ptr_g_socket_address_get_type)(void);
    GSocketFamily (*ptr_g_socket_address_get_family)(GSocketAddress *address);
    GSocketAddress * (*ptr_g_socket_address_new_from_native)(gpointer native, gsize len);
    gboolean (*ptr_g_socket_address_to_native)(GSocketAddress *address, gpointer dest, gsize destlen, GError **error);
    gssize (*ptr_g_socket_address_get_native_size)(GSocketAddress *address);
    // Header /usr/include/glib-2.0/gio/gsocketaddressenumerator.h
    GType (*ptr_g_socket_address_enumerator_get_type)(void);
    GSocketAddress* (*ptr_g_socket_address_enumerator_next)(GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GError **error);
    void (*ptr_g_socket_address_enumerator_next_async)(GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketAddress* (*ptr_g_socket_address_enumerator_next_finish)(GSocketAddressEnumerator *enumerator, GAsyncResult *result, GError **error);
    // Header /usr/include/glib-2.0/gio/gsocketclient.h
    GType (*ptr_g_socket_client_get_type)(void);
    GSocketClient* (*ptr_g_socket_client_new)(void);
    GSocketFamily (*ptr_g_socket_client_get_family)(GSocketClient *client);
    void (*ptr_g_socket_client_set_family)(GSocketClient *client, GSocketFamily family);
    GSocketType (*ptr_g_socket_client_get_socket_type)(GSocketClient *client);
    void (*ptr_g_socket_client_set_socket_type)(GSocketClient *client, GSocketType type);
    GSocketProtocol (*ptr_g_socket_client_get_protocol)(GSocketClient *client);
    void (*ptr_g_socket_client_set_protocol)(GSocketClient *client, GSocketProtocol protocol);
    GSocketAddress* (*ptr_g_socket_client_get_local_address)(GSocketClient *client);
    void (*ptr_g_socket_client_set_local_address)(GSocketClient *client, GSocketAddress *address);
    guint (*ptr_g_socket_client_get_timeout)(GSocketClient *client);
    void (*ptr_g_socket_client_set_timeout)(GSocketClient *client, guint timeout);
    gboolean (*ptr_g_socket_client_get_enable_proxy)(GSocketClient *client);
    void (*ptr_g_socket_client_set_enable_proxy)(GSocketClient *client, gboolean enable);
    gboolean (*ptr_g_socket_client_get_tls)(GSocketClient *client);
    void (*ptr_g_socket_client_set_tls)(GSocketClient *client, gboolean tls);
    GTlsCertificateFlags (*ptr_g_socket_client_get_tls_validation_flags)(GSocketClient *client);
    void (*ptr_g_socket_client_set_tls_validation_flags)(GSocketClient *client, GTlsCertificateFlags flags);
    GProxyResolver* (*ptr_g_socket_client_get_proxy_resolver)(GSocketClient *client);
    void (*ptr_g_socket_client_set_proxy_resolver)(GSocketClient *client, GProxyResolver *proxy_resolver);
    GSocketConnection * (*ptr_g_socket_client_connect)(GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
    GSocketConnection * (*ptr_g_socket_client_connect_to_host)(GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GError **error);
    GSocketConnection * (*ptr_g_socket_client_connect_to_service)(GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GError **error);
    GSocketConnection * (*ptr_g_socket_client_connect_to_uri)(GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GError **error);
    void (*ptr_g_socket_client_connect_async)(GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*ptr_g_socket_client_connect_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*ptr_g_socket_client_connect_to_host_async)(GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*ptr_g_socket_client_connect_to_host_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*ptr_g_socket_client_connect_to_service_async)(GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*ptr_g_socket_client_connect_to_service_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*ptr_g_socket_client_connect_to_uri_async)(GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*ptr_g_socket_client_connect_to_uri_finish)(GSocketClient *client, GAsyncResult *result, GError **error);
    void (*ptr_g_socket_client_add_application_proxy)(GSocketClient *client, const gchar *protocol);
    // Header /usr/include/glib-2.0/gio/gsocketconnectable.h
    GType (*ptr_g_socket_connectable_get_type)(void);
    GSocketAddressEnumerator* (*ptr_g_socket_connectable_enumerate)(GSocketConnectable *connectable);
    GSocketAddressEnumerator* (*ptr_g_socket_connectable_proxy_enumerate)(GSocketConnectable *connectable);
    gchar* (*ptr_g_socket_connectable_to_string)(GSocketConnectable *connectable);
    // Header /usr/include/glib-2.0/gio/gsocketconnection.h
    GType (*ptr_g_socket_connection_get_type)(void);
    gboolean (*ptr_g_socket_connection_is_connected)(GSocketConnection *connection);
    gboolean (*ptr_g_socket_connection_connect)(GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GError **error);
    void (*ptr_g_socket_connection_connect_async)(GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_socket_connection_connect_finish)(GSocketConnection *connection, GAsyncResult *result, GError **error);
    GSocket* (*ptr_g_socket_connection_get_socket)(GSocketConnection *connection);
    GSocketAddress* (*ptr_g_socket_connection_get_local_address)(GSocketConnection *connection, GError **error);
    GSocketAddress* (*ptr_g_socket_connection_get_remote_address)(GSocketConnection *connection, GError **error);
    void (*ptr_g_socket_connection_factory_register_type)(GType g_type, GSocketFamily family, GSocketType type, gint protocol);
    GType (*ptr_g_socket_connection_factory_lookup_type)(GSocketFamily family, GSocketType type, gint protocol_id);
    GSocketConnection* (*ptr_g_socket_connection_factory_create_connection)(GSocket *socket);
    // Header /usr/include/glib-2.0/gio/gsocketcontrolmessage.h
    GType (*ptr_g_socket_control_message_get_type)(void);
    gsize (*ptr_g_socket_control_message_get_size)(GSocketControlMessage *message);
    int (*ptr_g_socket_control_message_get_level)(GSocketControlMessage *message);
    int (*ptr_g_socket_control_message_get_msg_type)(GSocketControlMessage *message);
    void (*ptr_g_socket_control_message_serialize)(GSocketControlMessage *message, gpointer data);
    GSocketControlMessage* (*ptr_g_socket_control_message_deserialize)(int level, int type, gsize size, gpointer data);
    // Header /usr/include/glib-2.0/gio/gsocketlistener.h
    GType (*ptr_g_socket_listener_get_type)(void);
    GSocketListener * (*ptr_g_socket_listener_new)(void);
    void (*ptr_g_socket_listener_set_backlog)(GSocketListener *listener, int listen_backlog);
    gboolean (*ptr_g_socket_listener_add_socket)(GSocketListener *listener, GSocket *socket, GObject *source_object, GError **error);
    gboolean (*ptr_g_socket_listener_add_address)(GSocketListener *listener, GSocketAddress *address, GSocketType type, GSocketProtocol protocol, GObject *source_object, GSocketAddress **effective_address, GError **error);
    gboolean (*ptr_g_socket_listener_add_inet_port)(GSocketListener *listener, guint16 port, GObject *source_object, GError **error);
    guint16 (*ptr_g_socket_listener_add_any_inet_port)(GSocketListener *listener, GObject *source_object, GError **error);
    GSocket * (*ptr_g_socket_listener_accept_socket)(GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
    void (*ptr_g_socket_listener_accept_socket_async)(GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocket * (*ptr_g_socket_listener_accept_socket_finish)(GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
    GSocketConnection * (*ptr_g_socket_listener_accept)(GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
    void (*ptr_g_socket_listener_accept_async)(GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GSocketConnection * (*ptr_g_socket_listener_accept_finish)(GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
    void (*ptr_g_socket_listener_close)(GSocketListener *listener);
    // Header /usr/include/glib-2.0/gio/gsocketservice.h
    GType (*ptr_g_socket_service_get_type)(void);
    GSocketService* (*ptr_g_socket_service_new)(void);
    void (*ptr_g_socket_service_start)(GSocketService *service);
    void (*ptr_g_socket_service_stop)(GSocketService *service);
    gboolean (*ptr_g_socket_service_is_active)(GSocketService *service);
    // Header /usr/include/glib-2.0/gio/gsrvtarget.h
    GType (*ptr_g_srv_target_get_type)(void);
    GSrvTarget* (*ptr_g_srv_target_new)(const gchar *hostname, guint16 port, guint16 priority, guint16 weight);
    GSrvTarget* (*ptr_g_srv_target_copy)(GSrvTarget *target);
    void (*ptr_g_srv_target_free)(GSrvTarget *target);
    const gchar* (*ptr_g_srv_target_get_hostname)(GSrvTarget *target);
    guint16 (*ptr_g_srv_target_get_port)(GSrvTarget *target);
    guint16 (*ptr_g_srv_target_get_priority)(GSrvTarget *target);
    guint16 (*ptr_g_srv_target_get_weight)(GSrvTarget *target);
    GList* (*ptr_g_srv_target_list_sort)(GList *targets);
    // Header /usr/include/glib-2.0/gio/gsubprocess.h
    GType (*ptr_g_subprocess_get_type)(void);
    GSubprocess * (*ptr_g_subprocess_newv)(const gchar * const *argv, GSubprocessFlags flags, GError **error);
    GOutputStream * (*ptr_g_subprocess_get_stdin_pipe)(GSubprocess *subprocess);
    GInputStream * (*ptr_g_subprocess_get_stdout_pipe)(GSubprocess *subprocess);
    GInputStream * (*ptr_g_subprocess_get_stderr_pipe)(GSubprocess *subprocess);
    const gchar * (*ptr_g_subprocess_get_identifier)(GSubprocess *subprocess);
    void (*ptr_g_subprocess_send_signal)(GSubprocess *subprocess, gint signal_num);
    void (*ptr_g_subprocess_force_exit)(GSubprocess *subprocess);
    gboolean (*ptr_g_subprocess_wait)(GSubprocess *subprocess, GCancellable *cancellable, GError **error);
    void (*ptr_g_subprocess_wait_async)(GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_subprocess_wait_finish)(GSubprocess *subprocess, GAsyncResult *result, GError **error);
    gboolean (*ptr_g_subprocess_wait_check)(GSubprocess *subprocess, GCancellable *cancellable, GError **error);
    void (*ptr_g_subprocess_wait_check_async)(GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_subprocess_wait_check_finish)(GSubprocess *subprocess, GAsyncResult *result, GError **error);
    gint (*ptr_g_subprocess_get_status)(GSubprocess *subprocess);
    gboolean (*ptr_g_subprocess_get_successful)(GSubprocess *subprocess);
    gboolean (*ptr_g_subprocess_get_if_exited)(GSubprocess *subprocess);
    gint (*ptr_g_subprocess_get_exit_status)(GSubprocess *subprocess);
    gboolean (*ptr_g_subprocess_get_if_signaled)(GSubprocess *subprocess);
    gint (*ptr_g_subprocess_get_term_sig)(GSubprocess *subprocess);
    gboolean (*ptr_g_subprocess_communicate)(GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
    void (*ptr_g_subprocess_communicate_async)(GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_subprocess_communicate_finish)(GSubprocess *subprocess, GAsyncResult *result, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
    gboolean (*ptr_g_subprocess_communicate_utf8)(GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, char **stdout_buf, char **stderr_buf, GError **error);
    void (*ptr_g_subprocess_communicate_utf8_async)(GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_subprocess_communicate_utf8_finish)(GSubprocess *subprocess, GAsyncResult *result, char **stdout_buf, char **stderr_buf, GError **error);
    // Header /usr/include/glib-2.0/gio/gsubprocesslauncher.h
    GType (*ptr_g_subprocess_launcher_get_type)(void);
    GSubprocessLauncher * (*ptr_g_subprocess_launcher_new)(GSubprocessFlags flags);
    GSubprocess * (*ptr_g_subprocess_launcher_spawnv)(GSubprocessLauncher *self, const gchar * const *argv, GError **error);
    void (*ptr_g_subprocess_launcher_set_environ)(GSubprocessLauncher *self, gchar **env);
    void (*ptr_g_subprocess_launcher_setenv)(GSubprocessLauncher *self, const gchar *variable, const gchar *value, gboolean overwrite);
    void (*ptr_g_subprocess_launcher_unsetenv)(GSubprocessLauncher *self, const gchar *variable);
    const gchar * (*ptr_g_subprocess_launcher_getenv)(GSubprocessLauncher *self, const gchar *variable);
    void (*ptr_g_subprocess_launcher_set_cwd)(GSubprocessLauncher *self, const gchar *cwd);
    void (*ptr_g_subprocess_launcher_set_flags)(GSubprocessLauncher *self, GSubprocessFlags flags);
    void (*ptr_g_subprocess_launcher_set_stdin_file_path)(GSubprocessLauncher *self, const gchar *path);
    void (*ptr_g_subprocess_launcher_take_stdin_fd)(GSubprocessLauncher *self, gint fd);
    void (*ptr_g_subprocess_launcher_set_stdout_file_path)(GSubprocessLauncher *self, const gchar *path);
    void (*ptr_g_subprocess_launcher_take_stdout_fd)(GSubprocessLauncher *self, gint fd);
    void (*ptr_g_subprocess_launcher_set_stderr_file_path)(GSubprocessLauncher *self, const gchar *path);
    void (*ptr_g_subprocess_launcher_take_stderr_fd)(GSubprocessLauncher *self, gint fd);
    void (*ptr_g_subprocess_launcher_take_fd)(GSubprocessLauncher *self, gint source_fd, gint target_fd);
    void (*ptr_g_subprocess_launcher_close)(GSubprocessLauncher *self);
    void (*ptr_g_subprocess_launcher_set_child_setup)(GSubprocessLauncher *self, GSpawnChildSetupFunc child_setup, gpointer user_data, GDestroyNotify destroy_notify);
    // Header /usr/include/glib-2.0/gio/gtask.h
    GType (*ptr_g_task_get_type)(void);
    GTask* (*ptr_g_task_new)(gpointer source_object, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer callback_data);
    void (*ptr_g_task_report_error)(gpointer source_object, GAsyncReadyCallback callback, gpointer callback_data, gpointer source_tag, GError *error);
    void (*ptr_g_task_set_task_data)(GTask *task, gpointer task_data, GDestroyNotify task_data_destroy);
    void (*ptr_g_task_set_priority)(GTask *task, gint priority);
    void (*ptr_g_task_set_check_cancellable)(GTask *task, gboolean check_cancellable);
    void (*ptr_g_task_set_source_tag)(GTask *task, gpointer source_tag);
    void (*ptr_g_task_set_name)(GTask *task, const gchar *name);
    void (*ptr_g_task_set_static_name)(GTask *task, const gchar *name);
    gpointer (*ptr_g_task_get_source_object)(GTask *task);
    gpointer (*ptr_g_task_get_task_data)(GTask *task);
    gint (*ptr_g_task_get_priority)(GTask *task);
    GMainContext* (*ptr_g_task_get_context)(GTask *task);
    GCancellable* (*ptr_g_task_get_cancellable)(GTask *task);
    gboolean (*ptr_g_task_get_check_cancellable)(GTask *task);
    gpointer (*ptr_g_task_get_source_tag)(GTask *task);
    const gchar* (*ptr_g_task_get_name)(GTask *task);
    gboolean (*ptr_g_task_is_valid)(gpointer result, gpointer source_object);
    void (*ptr_g_task_run_in_thread)(GTask *task, GTaskThreadFunc task_func);
    void (*ptr_g_task_run_in_thread_sync)(GTask *task, GTaskThreadFunc task_func);
    gboolean (*ptr_g_task_set_return_on_cancel)(GTask *task, gboolean return_on_cancel);
    gboolean (*ptr_g_task_get_return_on_cancel)(GTask *task);
    void (*ptr_g_task_attach_source)(GTask *task, GSource *source, GSourceFunc callback);
    void (*ptr_g_task_return_pointer)(GTask *task, gpointer result, GDestroyNotify result_destroy);
    void (*ptr_g_task_return_boolean)(GTask *task, gboolean result);
    void (*ptr_g_task_return_int)(GTask *task, gssize result);
    void (*ptr_g_task_return_error)(GTask *task, GError *error);
    void (*ptr_g_task_return_new_error_literal)(GTask *task, GQuark domain, gint code, const char *message);
    void (*ptr_g_task_return_value)(GTask *task, GValue *result);
    gboolean (*ptr_g_task_return_error_if_cancelled)(GTask *task);
    gpointer (*ptr_g_task_propagate_pointer)(GTask *task, GError **error);
    gboolean (*ptr_g_task_propagate_boolean)(GTask *task, GError **error);
    gssize (*ptr_g_task_propagate_int)(GTask *task, GError **error);
    gboolean (*ptr_g_task_propagate_value)(GTask *task, GValue *value, GError **error);
    gboolean (*ptr_g_task_had_error)(GTask *task);
    gboolean (*ptr_g_task_get_completed)(GTask *task);
    void (*ptr_g_task_print_alive_tasks)(void);
    // Header /usr/include/glib-2.0/gio/gtcpconnection.h
    GType (*ptr_g_tcp_connection_get_type)(void);
    void (*ptr_g_tcp_connection_set_graceful_disconnect)(GTcpConnection *connection, gboolean graceful_disconnect);
    gboolean (*ptr_g_tcp_connection_get_graceful_disconnect)(GTcpConnection *connection);
    // Header /usr/include/glib-2.0/gio/gtcpwrapperconnection.h
    GType (*ptr_g_tcp_wrapper_connection_get_type)(void);
    GSocketConnection* (*ptr_g_tcp_wrapper_connection_new)(GIOStream *base_io_stream, GSocket *socket);
    GIOStream* (*ptr_g_tcp_wrapper_connection_get_base_io_stream)(GTcpWrapperConnection *conn);
    // Header /usr/include/glib-2.0/gio/gtestdbus.h
    GType (*ptr_g_test_dbus_get_type)(void);
    GTestDBus * (*ptr_g_test_dbus_new)(GTestDBusFlags flags);
    GTestDBusFlags (*ptr_g_test_dbus_get_flags)(GTestDBus *self);
    const gchar * (*ptr_g_test_dbus_get_bus_address)(GTestDBus *self);
    void (*ptr_g_test_dbus_add_service_dir)(GTestDBus *self, const gchar *path);
    void (*ptr_g_test_dbus_up)(GTestDBus *self);
    void (*ptr_g_test_dbus_stop)(GTestDBus *self);
    void (*ptr_g_test_dbus_down)(GTestDBus *self);
    void (*ptr_g_test_dbus_unset)(void);
    // Header /usr/include/glib-2.0/gio/gthemedicon.h
    GType (*ptr_g_themed_icon_get_type)(void);
    GIcon* (*ptr_g_themed_icon_new)(const char *iconname);
    GIcon* (*ptr_g_themed_icon_new_with_default_fallbacks)(const char *iconname);
    GIcon* (*ptr_g_themed_icon_new_from_names)(char **iconnames, int len);
    void (*ptr_g_themed_icon_prepend_name)(GThemedIcon *icon, const char *iconname);
    void (*ptr_g_themed_icon_append_name)(GThemedIcon *icon, const char *iconname);
    const gchar* const * (*ptr_g_themed_icon_get_names)(GThemedIcon *icon);
    // Header /usr/include/glib-2.0/gio/gthreadedsocketservice.h
    GType (*ptr_g_threaded_socket_service_get_type)(void);
    GSocketService * (*ptr_g_threaded_socket_service_new)(int max_threads);
    // Header /usr/include/glib-2.0/gio/gtlsbackend.h
    GType (*ptr_g_tls_backend_get_type)(void);
    GTlsBackend * (*ptr_g_tls_backend_get_default)(void);
    GTlsDatabase * (*ptr_g_tls_backend_get_default_database)(GTlsBackend *backend);
    void (*ptr_g_tls_backend_set_default_database)(GTlsBackend *backend, GTlsDatabase *database);
    gboolean (*ptr_g_tls_backend_supports_tls)(GTlsBackend *backend);
    gboolean (*ptr_g_tls_backend_supports_dtls)(GTlsBackend *backend);
    GType (*ptr_g_tls_backend_get_certificate_type)(GTlsBackend *backend);
    GType (*ptr_g_tls_backend_get_client_connection_type)(GTlsBackend *backend);
    GType (*ptr_g_tls_backend_get_server_connection_type)(GTlsBackend *backend);
    GType (*ptr_g_tls_backend_get_file_database_type)(GTlsBackend *backend);
    GType (*ptr_g_tls_backend_get_dtls_client_connection_type)(GTlsBackend *backend);
    GType (*ptr_g_tls_backend_get_dtls_server_connection_type)(GTlsBackend *backend);
    // Header /usr/include/glib-2.0/gio/gtlscertificate.h
    GType (*ptr_g_tls_certificate_get_type)(void);
    GTlsCertificate* (*ptr_g_tls_certificate_new_from_pem)(const gchar *data, gssize length, GError **error);
    GTlsCertificate* (*ptr_g_tls_certificate_new_from_pkcs12)(const guint8 *data, gsize length, const gchar *password, GError **error);
    GTlsCertificate* (*ptr_g_tls_certificate_new_from_file_with_password)(const gchar *file, const gchar *password, GError **error);
    GTlsCertificate* (*ptr_g_tls_certificate_new_from_file)(const gchar *file, GError **error);
    GTlsCertificate* (*ptr_g_tls_certificate_new_from_files)(const gchar *cert_file, const gchar *key_file, GError **error);
    GTlsCertificate* (*ptr_g_tls_certificate_new_from_pkcs11_uris)(const gchar *pkcs11_uri, const gchar *private_key_pkcs11_uri, GError **error);
    GList* (*ptr_g_tls_certificate_list_new_from_file)(const gchar *file, GError **error);
    GTlsCertificate* (*ptr_g_tls_certificate_get_issuer)(GTlsCertificate *cert);
    GTlsCertificateFlags (*ptr_g_tls_certificate_verify)(GTlsCertificate *cert, GSocketConnectable *identity, GTlsCertificate *trusted_ca);
    gboolean (*ptr_g_tls_certificate_is_same)(GTlsCertificate *cert_one, GTlsCertificate *cert_two);
    GDateTime* (*ptr_g_tls_certificate_get_not_valid_before)(GTlsCertificate *cert);
    GDateTime* (*ptr_g_tls_certificate_get_not_valid_after)(GTlsCertificate *cert);
    gchar* (*ptr_g_tls_certificate_get_subject_name)(GTlsCertificate *cert);
    gchar* (*ptr_g_tls_certificate_get_issuer_name)(GTlsCertificate *cert);
    GPtrArray* (*ptr_g_tls_certificate_get_dns_names)(GTlsCertificate *cert);
    GPtrArray* (*ptr_g_tls_certificate_get_ip_addresses)(GTlsCertificate *cert);
    // Header /usr/include/glib-2.0/gio/gtlsclientconnection.h
    GType (*ptr_g_tls_client_connection_get_type)(void);
    GIOStream * (*ptr_g_tls_client_connection_new)(GIOStream *base_io_stream, GSocketConnectable *server_identity, GError **error);
    GTlsCertificateFlags (*ptr_g_tls_client_connection_get_validation_flags)(GTlsClientConnection *conn);
    void (*ptr_g_tls_client_connection_set_validation_flags)(GTlsClientConnection *conn, GTlsCertificateFlags flags);
    GSocketConnectable* (*ptr_g_tls_client_connection_get_server_identity)(GTlsClientConnection *conn);
    void (*ptr_g_tls_client_connection_set_server_identity)(GTlsClientConnection *conn, GSocketConnectable *identity);
    gboolean (*ptr_g_tls_client_connection_get_use_ssl3)(GTlsClientConnection *conn);
    void (*ptr_g_tls_client_connection_set_use_ssl3)(GTlsClientConnection *conn, gboolean use_ssl3);
    GList * (*ptr_g_tls_client_connection_get_accepted_cas)(GTlsClientConnection *conn);
    void (*ptr_g_tls_client_connection_copy_session_state)(GTlsClientConnection *conn, GTlsClientConnection *source);
    // Header /usr/include/glib-2.0/gio/gtlsconnection.h
    GType (*ptr_g_tls_connection_get_type)(void);
    void (*ptr_g_tls_connection_set_use_system_certdb)(GTlsConnection *conn, gboolean use_system_certdb);
    gboolean (*ptr_g_tls_connection_get_use_system_certdb)(GTlsConnection *conn);
    void (*ptr_g_tls_connection_set_database)(GTlsConnection *conn, GTlsDatabase *database);
    GTlsDatabase * (*ptr_g_tls_connection_get_database)(GTlsConnection *conn);
    void (*ptr_g_tls_connection_set_certificate)(GTlsConnection *conn, GTlsCertificate *certificate);
    GTlsCertificate* (*ptr_g_tls_connection_get_certificate)(GTlsConnection *conn);
    void (*ptr_g_tls_connection_set_interaction)(GTlsConnection *conn, GTlsInteraction *interaction);
    GTlsInteraction * (*ptr_g_tls_connection_get_interaction)(GTlsConnection *conn);
    GTlsCertificate* (*ptr_g_tls_connection_get_peer_certificate)(GTlsConnection *conn);
    GTlsCertificateFlags (*ptr_g_tls_connection_get_peer_certificate_errors)(GTlsConnection *conn);
    void (*ptr_g_tls_connection_set_require_close_notify)(GTlsConnection *conn, gboolean require_close_notify);
    gboolean (*ptr_g_tls_connection_get_require_close_notify)(GTlsConnection *conn);
    GTlsRehandshakeMode (*ptr_g_tls_connection_get_rehandshake_mode)(GTlsConnection *conn);
    const gchar * (*ptr_g_tls_connection_get_negotiated_protocol)(GTlsConnection *conn);
    void (*ptr_g_tls_connection_handshake_async)(GTlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_tls_connection_handshake_finish)(GTlsConnection *conn, GAsyncResult *result, GError **error);
    GTlsProtocolVersion (*ptr_g_tls_connection_get_protocol_version)(GTlsConnection *conn);
    gchar * (*ptr_g_tls_connection_get_ciphersuite_name)(GTlsConnection *conn);
    GQuark (*ptr_g_tls_error_quark)(void);
    GQuark (*ptr_g_tls_channel_binding_error_quark)(void);
    gboolean (*ptr_g_tls_connection_emit_accept_certificate)(GTlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
    // Header /usr/include/glib-2.0/gio/gtlsdatabase.h
    GType (*ptr_g_tls_database_get_type)(void);
    GTlsCertificateFlags (*ptr_g_tls_database_verify_chain)(GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_tls_database_verify_chain_async)(GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsCertificateFlags (*ptr_g_tls_database_verify_chain_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    gchar* (*ptr_g_tls_database_create_certificate_handle)(GTlsDatabase *self, GTlsCertificate *certificate);
    GTlsCertificate* (*ptr_g_tls_database_lookup_certificate_for_handle)(GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_tls_database_lookup_certificate_for_handle_async)(GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsCertificate* (*ptr_g_tls_database_lookup_certificate_for_handle_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    GTlsCertificate* (*ptr_g_tls_database_lookup_certificate_issuer)(GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_tls_database_lookup_certificate_issuer_async)(GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsCertificate* (*ptr_g_tls_database_lookup_certificate_issuer_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    GList* (*ptr_g_tls_database_lookup_certificates_issued_by)(GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_tls_database_lookup_certificates_issued_by_async)(GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GList* (*ptr_g_tls_database_lookup_certificates_issued_by_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error);
    // Header /usr/include/glib-2.0/gio/gtlsfiledatabase.h
    GType (*ptr_g_tls_file_database_get_type)(void);
    GTlsDatabase* (*ptr_g_tls_file_database_new)(const gchar *anchors, GError **error);
    // Header /usr/include/glib-2.0/gio/gtlsinteraction.h
    GType (*ptr_g_tls_interaction_get_type)(void);
    GTlsInteractionResult (*ptr_g_tls_interaction_invoke_ask_password)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
    GTlsInteractionResult (*ptr_g_tls_interaction_ask_password)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
    void (*ptr_g_tls_interaction_ask_password_async)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsInteractionResult (*ptr_g_tls_interaction_ask_password_finish)(GTlsInteraction *interaction, GAsyncResult *result, GError **error);
    GTlsInteractionResult (*ptr_g_tls_interaction_invoke_request_certificate)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
    GTlsInteractionResult (*ptr_g_tls_interaction_request_certificate)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
    void (*ptr_g_tls_interaction_request_certificate_async)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GTlsInteractionResult (*ptr_g_tls_interaction_request_certificate_finish)(GTlsInteraction *interaction, GAsyncResult *result, GError **error);
    // Header /usr/include/glib-2.0/gio/gtlspassword.h
    GType (*ptr_g_tls_password_get_type)(void);
    GTlsPassword * (*ptr_g_tls_password_new)(GTlsPasswordFlags flags, const gchar *description);
    const guchar * (*ptr_g_tls_password_get_value)(GTlsPassword *password, gsize *length);
    void (*ptr_g_tls_password_set_value)(GTlsPassword *password, const guchar *value, gssize length);
    void (*ptr_g_tls_password_set_value_full)(GTlsPassword *password, guchar *value, gssize length, GDestroyNotify destroy);
    GTlsPasswordFlags (*ptr_g_tls_password_get_flags)(GTlsPassword *password);
    void (*ptr_g_tls_password_set_flags)(GTlsPassword *password, GTlsPasswordFlags flags);
    const gchar* (*ptr_g_tls_password_get_description)(GTlsPassword *password);
    void (*ptr_g_tls_password_set_description)(GTlsPassword *password, const gchar *description);
    const gchar * (*ptr_g_tls_password_get_warning)(GTlsPassword *password);
    void (*ptr_g_tls_password_set_warning)(GTlsPassword *password, const gchar *warning);
    // Header /usr/include/glib-2.0/gio/gtlsserverconnection.h
    GType (*ptr_g_tls_server_connection_get_type)(void);
    GIOStream * (*ptr_g_tls_server_connection_new)(GIOStream *base_io_stream, GTlsCertificate *certificate, GError **error);
    // Header /usr/include/glib-2.0/gio/gunixconnection.h
    GType (*ptr_g_unix_connection_get_type)(void);
    gboolean (*ptr_g_unix_connection_send_fd)(GUnixConnection *connection, gint fd, GCancellable *cancellable, GError **error);
    gint (*ptr_g_unix_connection_receive_fd)(GUnixConnection *connection, GCancellable *cancellable, GError **error);
    gboolean (*ptr_g_unix_connection_send_credentials)(GUnixConnection *connection, GCancellable *cancellable, GError **error);
    void (*ptr_g_unix_connection_send_credentials_async)(GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_unix_connection_send_credentials_finish)(GUnixConnection *connection, GAsyncResult *result, GError **error);
    GCredentials* (*ptr_g_unix_connection_receive_credentials)(GUnixConnection *connection, GCancellable *cancellable, GError **error);
    void (*ptr_g_unix_connection_receive_credentials_async)(GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    GCredentials* (*ptr_g_unix_connection_receive_credentials_finish)(GUnixConnection *connection, GAsyncResult *result, GError **error);
    // Header /usr/include/glib-2.0/gio/gunixcredentialsmessage.h
    GType (*ptr_g_unix_credentials_message_get_type)(void);
    GSocketControlMessage* (*ptr_g_unix_credentials_message_new)(void);
    GSocketControlMessage* (*ptr_g_unix_credentials_message_new_with_credentials)(GCredentials *credentials);
    GCredentials* (*ptr_g_unix_credentials_message_get_credentials)(GUnixCredentialsMessage *message);
    gboolean (*ptr_g_unix_credentials_message_is_supported)(void);
    // Header /usr/include/glib-2.0/gio/gunixfdlist.h
    GType (*ptr_g_unix_fd_list_get_type)(void);
    GUnixFDList * (*ptr_g_unix_fd_list_new)(void);
    GUnixFDList * (*ptr_g_unix_fd_list_new_from_array)(const gint *fds, gint n_fds);
    gint (*ptr_g_unix_fd_list_append)(GUnixFDList *list, gint fd, GError **error);
    gint (*ptr_g_unix_fd_list_get_length)(GUnixFDList *list);
    gint (*ptr_g_unix_fd_list_get)(GUnixFDList *list, gint index_, GError **error);
    const gint * (*ptr_g_unix_fd_list_peek_fds)(GUnixFDList *list, gint *length);
    gint * (*ptr_g_unix_fd_list_steal_fds)(GUnixFDList *list, gint *length);
    // Header /usr/include/glib-2.0/gio/gunixsocketaddress.h
    GType (*ptr_g_unix_socket_address_get_type)(void);
    GSocketAddress* (*ptr_g_unix_socket_address_new)(const gchar *path);
    GSocketAddress* (*ptr_g_unix_socket_address_new_abstract)(const gchar *path, gint path_len);
    GSocketAddress* (*ptr_g_unix_socket_address_new_with_type)(const gchar *path, gint path_len, GUnixSocketAddressType type);
    const char * (*ptr_g_unix_socket_address_get_path)(GUnixSocketAddress *address);
    gsize (*ptr_g_unix_socket_address_get_path_len)(GUnixSocketAddress *address);
    GUnixSocketAddressType (*ptr_g_unix_socket_address_get_address_type)(GUnixSocketAddress *address);
    gboolean (*ptr_g_unix_socket_address_get_is_abstract)(GUnixSocketAddress *address);
    gboolean (*ptr_g_unix_socket_address_abstract_names_supported)(void);
    // Header /usr/include/glib-2.0/gio/gvfs.h
    GType (*ptr_g_vfs_get_type)(void);
    gboolean (*ptr_g_vfs_is_active)(GVfs *vfs);
    GFile * (*ptr_g_vfs_get_file_for_path)(GVfs *vfs, const char *path);
    GFile * (*ptr_g_vfs_get_file_for_uri)(GVfs *vfs, const char *uri);
    const gchar* const * (*ptr_g_vfs_get_supported_uri_schemes)(GVfs *vfs);
    GFile * (*ptr_g_vfs_parse_name)(GVfs *vfs, const char *parse_name);
    GVfs * (*ptr_g_vfs_get_default)(void);
    GVfs * (*ptr_g_vfs_get_local)(void);
    gboolean (*ptr_g_vfs_register_uri_scheme)(GVfs *vfs, const char *scheme, GVfsFileLookupFunc uri_func, gpointer uri_data, GDestroyNotify uri_destroy, GVfsFileLookupFunc parse_name_func, gpointer parse_name_data, GDestroyNotify parse_name_destroy);
    gboolean (*ptr_g_vfs_unregister_uri_scheme)(GVfs *vfs, const char *scheme);
    // Header /usr/include/glib-2.0/gio/gvolume.h
    GType (*ptr_g_volume_get_type)(void);
    char * (*ptr_g_volume_get_name)(GVolume *volume);
    GIcon * (*ptr_g_volume_get_icon)(GVolume *volume);
    GIcon * (*ptr_g_volume_get_symbolic_icon)(GVolume *volume);
    char * (*ptr_g_volume_get_uuid)(GVolume *volume);
    GDrive * (*ptr_g_volume_get_drive)(GVolume *volume);
    GMount * (*ptr_g_volume_get_mount)(GVolume *volume);
    gboolean (*ptr_g_volume_can_mount)(GVolume *volume);
    gboolean (*ptr_g_volume_can_eject)(GVolume *volume);
    gboolean (*ptr_g_volume_should_automount)(GVolume *volume);
    void (*ptr_g_volume_mount)(GVolume *volume, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_volume_mount_finish)(GVolume *volume, GAsyncResult *result, GError **error);
    void (*ptr_g_volume_eject)(GVolume *volume, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_volume_eject_finish)(GVolume *volume, GAsyncResult *result, GError **error);
    char * (*ptr_g_volume_get_identifier)(GVolume *volume, const char *kind);
    char ** (*ptr_g_volume_enumerate_identifiers)(GVolume *volume);
    GFile * (*ptr_g_volume_get_activation_root)(GVolume *volume);
    void (*ptr_g_volume_eject_with_operation)(GVolume *volume, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
    gboolean (*ptr_g_volume_eject_with_operation_finish)(GVolume *volume, GAsyncResult *result, GError **error);
    const gchar* (*ptr_g_volume_get_sort_key)(GVolume *volume);
    // Header /usr/include/glib-2.0/gio/gvolumemonitor.h
    GType (*ptr_g_volume_monitor_get_type)(void);
    GVolumeMonitor* (*ptr_g_volume_monitor_get)(void);
    GList * (*ptr_g_volume_monitor_get_connected_drives)(GVolumeMonitor *volume_monitor);
    GList * (*ptr_g_volume_monitor_get_volumes)(GVolumeMonitor *volume_monitor);
    GList * (*ptr_g_volume_monitor_get_mounts)(GVolumeMonitor *volume_monitor);
    GVolume * (*ptr_g_volume_monitor_get_volume_for_uuid)(GVolumeMonitor *volume_monitor, const char *uuid);
    GMount * (*ptr_g_volume_monitor_get_mount_for_uuid)(GVolumeMonitor *volume_monitor, const char *uuid);
    GVolume * (*ptr_g_volume_monitor_adopt_orphan_mount)(GMount *mount);
    // Header /usr/include/glib-2.0/gio/gzlibcompressor.h
    GType (*ptr_g_zlib_compressor_get_type)(void);
    GZlibCompressor* (*ptr_g_zlib_compressor_new)(GZlibCompressorFormat format, int level);
    GFileInfo* (*ptr_g_zlib_compressor_get_file_info)(GZlibCompressor *compressor);
    void (*ptr_g_zlib_compressor_set_file_info)(GZlibCompressor *compressor, GFileInfo *file_info);
    // Header /usr/include/glib-2.0/gio/gzlibdecompressor.h
    GType (*ptr_g_zlib_decompressor_get_type)(void);
    GZlibDecompressor* (*ptr_g_zlib_decompressor_new)(GZlibCompressorFormat format);
    GFileInfo* (*ptr_g_zlib_decompressor_get_file_info)(GZlibDecompressor *decompressor);
    // Header /usr/include/glib-2.0/gmodule.h
    gboolean (*ptr_g_module_supported)(void);
    GModule* (*ptr_g_module_open)(const gchar *file_name, GModuleFlags flags);
    GModule* (*ptr_g_module_open_full)(const gchar *file_name, GModuleFlags flags, GError **error);
    gboolean (*ptr_g_module_close)(GModule *module);
    void (*ptr_g_module_make_resident)(GModule *module);
    const gchar * (*ptr_g_module_error)(void);
    gboolean (*ptr_g_module_symbol)(GModule *module, const gchar *symbol_name, gpointer *symbol);
    const gchar * (*ptr_g_module_name)(GModule *module);
    gchar* (*ptr_g_module_build_path)(const gchar *directory, const gchar *module_name);
    GQuark (*ptr_g_module_error_quark)(void);
    // Header /usr/include/glib-2.0/girepository/girepository.h
    GType (*ptr_gi_repository_get_type)(void);
    GIRepository* (*ptr_gi_repository_new)(void);
    void (*ptr_gi_repository_prepend_search_path)(GIRepository *repository, const char *directory);
    void (*ptr_gi_repository_prepend_library_path)(GIRepository *repository, const char *directory);
    const char * const * (*ptr_gi_repository_get_search_path)(GIRepository *repository, size_t *n_paths_out);
    const char * const* (*ptr_gi_repository_get_library_path)(GIRepository *repository, size_t *n_paths_out);
    const char * (*ptr_gi_repository_load_typelib)(GIRepository *repository, GITypelib *typelib, GIRepositoryLoadFlags flags, GError **error);
    gboolean (*ptr_gi_repository_is_registered)(GIRepository *repository, const char *namespace_, const char *version);
    GIBaseInfo * (*ptr_gi_repository_find_by_name)(GIRepository *repository, const char *namespace_, const char *name);
    char ** (*ptr_gi_repository_enumerate_versions)(GIRepository *repository, const char *namespace_, size_t *n_versions_out);
    GITypelib * (*ptr_gi_repository_require)(GIRepository *repository, const char *namespace_, const char *version, GIRepositoryLoadFlags flags, GError **error);
    GITypelib * (*ptr_gi_repository_require_private)(GIRepository *repository, const char *typelib_dir, const char *namespace_, const char *version, GIRepositoryLoadFlags flags, GError **error);
    char ** (*ptr_gi_repository_get_immediate_dependencies)(GIRepository *repository, const char *namespace_, size_t *n_dependencies_out);
    char ** (*ptr_gi_repository_get_dependencies)(GIRepository *repository, const char *namespace_, size_t *n_dependencies_out);
    char ** (*ptr_gi_repository_get_loaded_namespaces)(GIRepository *repository, size_t *n_namespaces_out);
    GIBaseInfo * (*ptr_gi_repository_find_by_gtype)(GIRepository *repository, GType gtype);
    void (*ptr_gi_repository_get_object_gtype_interfaces)(GIRepository *repository, GType gtype, size_t *n_interfaces_out, GIInterfaceInfo ***interfaces_out);
    unsigned int (*ptr_gi_repository_get_n_infos)(GIRepository *repository, const char *namespace_);
    GIBaseInfo * (*ptr_gi_repository_get_info)(GIRepository *repository, const char *namespace_, unsigned int idx);
    GIEnumInfo * (*ptr_gi_repository_find_by_error_domain)(GIRepository *repository, GQuark domain);
    const char * (*ptr_gi_repository_get_typelib_path)(GIRepository *repository, const char *namespace_);
    const char * const* (*ptr_gi_repository_get_shared_libraries)(GIRepository *repository, const char *namespace_, size_t *out_n_elements);
    const char * (*ptr_gi_repository_get_c_prefix)(GIRepository *repository, const char *namespace_);
    const char * (*ptr_gi_repository_get_version)(GIRepository *repository, const char *namespace_);
    GOptionGroup * (*ptr_gi_repository_get_option_group)(void);
    gboolean (*ptr_gi_repository_dump)(const char *input_filename, const char *output_filename, GError **error);
    GQuark (*ptr_gi_repository_error_quark)(void);
    void (*ptr_gi_cclosure_marshal_generic)(GClosure *closure, GValue *return_gvalue, unsigned int n_param_values, const GValue *param_values, void *invocation_hint, void *marshal_data);
    // Header /usr/include/glib-2.0/girepository/girffi.h
    ffi_type * (*ptr_gi_type_info_get_ffi_type)(GITypeInfo *info);
    void (*ptr_gi_type_info_extract_ffi_return_value)(GITypeInfo *return_info, GIFFIReturnValue *ffi_value, GIArgument *arg);
    void (*ptr_gi_type_tag_extract_ffi_return_value)(GITypeTag return_tag, GType interface_type, GIFFIReturnValue *ffi_value, GIArgument *arg);
    gboolean (*ptr_gi_function_info_prep_invoker)(GIFunctionInfo *info, GIFunctionInvoker *invoker, GError **error);
    gboolean (*ptr_gi_function_invoker_new_for_address)(void *addr, GICallableInfo *info, GIFunctionInvoker *invoker, GError **error);
    void (*ptr_gi_function_invoker_clear)(GIFunctionInvoker *invoker);
    ffi_closure * (*ptr_gi_callable_info_create_closure)(GICallableInfo *callable_info, ffi_cif *cif, GIFFIClosureCallback callback, void *user_data);
    void ** (*ptr_gi_callable_info_get_closure_native_address)(GICallableInfo *callable_info, ffi_closure *closure);
    void (*ptr_gi_callable_info_destroy_closure)(GICallableInfo *callable_info, ffi_closure *closure);
    ffi_type * (*ptr_gi_type_tag_get_ffi_type)(GITypeTag type_tag, gboolean is_pointer);
} stub_funcs;

void *glib;
void *gobject;
void *gio;
void *gmodule;
void *girepository;

void initialize_glib(void) {
    char *candidates_glib[] = { "libglib-2.0.so" };
    glib = try_find_lib(candidates_glib, LEN(candidates_glib));

    if (!glib) {
        fprintf(stderr, "Unable to locate glib, exiting!");
        exit(1);
    }

    char *candidates_gobject[] = { "libgobject-2.0.so" };
    gobject = try_find_lib(candidates_gobject, LEN(candidates_gobject));

    if (!gobject) {
        fprintf(stderr, "Unable to locate gobject, exiting!");
        exit(1);
    }

    char *candidates_gio[] = { "libgio-2.0.so" };
    gio = try_find_lib(candidates_gio, LEN(candidates_gio));

    if (!gio) {
        fprintf(stderr, "Unable to locate gio, exiting!");
        exit(1);
    }

    char *candidates_gmodule[] = { "libgmodule-2.0.so" };
    gmodule = try_find_lib(candidates_gmodule, LEN(candidates_gmodule));

    if (!gmodule) {
        fprintf(stderr, "Unable to locate gmodule, exiting!");
        exit(1);
    }

    char *candidates_girepository[] = { "libgirepository-2.0.so" };
    girepository = try_find_lib(candidates_girepository, LEN(candidates_girepository));

    if (!girepository) {
        fprintf(stderr, "Unable to locate girepository, exiting!");
        exit(1);
    }

    // Header /usr/include/glib-2.0/glib/deprecated/gallocator.h
    stub_funcs.ptr_g_mem_chunk_destroy = try_find_sym(glib, "g_mem_chunk_destroy");
    stub_funcs.ptr_g_mem_chunk_alloc = try_find_sym(glib, "g_mem_chunk_alloc");
    stub_funcs.ptr_g_mem_chunk_alloc0 = try_find_sym(glib, "g_mem_chunk_alloc0");
    stub_funcs.ptr_g_mem_chunk_free = try_find_sym(glib, "g_mem_chunk_free");
    stub_funcs.ptr_g_mem_chunk_clean = try_find_sym(glib, "g_mem_chunk_clean");
    stub_funcs.ptr_g_mem_chunk_reset = try_find_sym(glib, "g_mem_chunk_reset");
    stub_funcs.ptr_g_mem_chunk_print = try_find_sym(glib, "g_mem_chunk_print");
    stub_funcs.ptr_g_mem_chunk_info = try_find_sym(glib, "g_mem_chunk_info");
    stub_funcs.ptr_g_blow_chunks = try_find_sym(glib, "g_blow_chunks");
    stub_funcs.ptr_g_mem_chunk_new = try_find_sym(glib, "g_mem_chunk_new");
    // Header /usr/include/glib-2.0/glib/deprecated/gcache.h
    stub_funcs.ptr_g_cache_destroy = try_find_sym(glib, "g_cache_destroy");
    stub_funcs.ptr_g_cache_insert = try_find_sym(glib, "g_cache_insert");
    stub_funcs.ptr_g_cache_remove = try_find_sym(glib, "g_cache_remove");
    stub_funcs.ptr_g_cache_key_foreach = try_find_sym(glib, "g_cache_key_foreach");
    stub_funcs.ptr_g_cache_value_foreach = try_find_sym(glib, "g_cache_value_foreach");
    // Header /usr/include/glib-2.0/glib/deprecated/gcompletion.h
    stub_funcs.ptr_g_completion_add_items = try_find_sym(glib, "g_completion_add_items");
    stub_funcs.ptr_g_completion_remove_items = try_find_sym(glib, "g_completion_remove_items");
    stub_funcs.ptr_g_completion_clear_items = try_find_sym(glib, "g_completion_clear_items");
    stub_funcs.ptr_g_completion_complete = try_find_sym(glib, "g_completion_complete");
    stub_funcs.ptr_g_completion_complete_utf8 = try_find_sym(glib, "g_completion_complete_utf8");
    stub_funcs.ptr_g_completion_set_compare = try_find_sym(glib, "g_completion_set_compare");
    stub_funcs.ptr_g_completion_free = try_find_sym(glib, "g_completion_free");
    stub_funcs.ptr_g_completion_new = try_find_sym(glib, "g_completion_new");
    // Header /usr/include/glib-2.0/glib/deprecated/gmain.h
    // Header /usr/include/glib-2.0/glib/deprecated/grel.h
    stub_funcs.ptr_g_relation_destroy = try_find_sym(glib, "g_relation_destroy");
    stub_funcs.ptr_g_relation_index = try_find_sym(glib, "g_relation_index");
    stub_funcs.ptr_g_relation_delete = try_find_sym(glib, "g_relation_delete");
    stub_funcs.ptr_g_relation_select = try_find_sym(glib, "g_relation_select");
    stub_funcs.ptr_g_relation_count = try_find_sym(glib, "g_relation_count");
    stub_funcs.ptr_g_relation_print = try_find_sym(glib, "g_relation_print");
    stub_funcs.ptr_g_tuples_destroy = try_find_sym(glib, "g_tuples_destroy");
    stub_funcs.ptr_g_tuples_index = try_find_sym(glib, "g_tuples_index");
    stub_funcs.ptr_g_relation_new = try_find_sym(glib, "g_relation_new");
    // Header /usr/include/glib-2.0/glib/deprecated/gthread.h
    stub_funcs.ptr_g_thread_create = try_find_sym(glib, "g_thread_create");
    stub_funcs.ptr_g_thread_create_full = try_find_sym(glib, "g_thread_create_full");
    stub_funcs.ptr_g_thread_set_priority = try_find_sym(glib, "g_thread_set_priority");
    stub_funcs.ptr_g_thread_foreach = try_find_sym(glib, "g_thread_foreach");
    stub_funcs.ptr_g_private_new = try_find_sym(glib, "g_private_new");
    stub_funcs.ptr_g_once_init_enter_impl = try_find_sym(glib, "g_once_init_enter_impl");
    stub_funcs.ptr_g_thread_init = try_find_sym(glib, "g_thread_init");
    stub_funcs.ptr_g_thread_init_with_errorcheck_mutexes = try_find_sym(glib, "g_thread_init_with_errorcheck_mutexes");
    stub_funcs.ptr_g_thread_get_initialized = try_find_sym(glib, "g_thread_get_initialized");
    stub_funcs.ptr_g_mutex_new = try_find_sym(glib, "g_mutex_new");
    stub_funcs.ptr_g_mutex_free = try_find_sym(glib, "g_mutex_free");
    stub_funcs.ptr_g_cond_new = try_find_sym(glib, "g_cond_new");
    stub_funcs.ptr_g_cond_free = try_find_sym(glib, "g_cond_free");
    stub_funcs.ptr_g_cond_timed_wait = try_find_sym(glib, "g_cond_timed_wait");
    // Header /usr/include/glib-2.0/glib/galloca.h
    // Header /usr/include/glib-2.0/glib/garray.h
    stub_funcs.ptr_g_array_new_take = try_find_sym(glib, "g_array_new_take");
    stub_funcs.ptr_g_array_new_take_zero_terminated = try_find_sym(glib, "g_array_new_take_zero_terminated");
    stub_funcs.ptr_g_array_steal = try_find_sym(glib, "g_array_steal");
    stub_funcs.ptr_g_array_sized_new = try_find_sym(glib, "g_array_sized_new");
    stub_funcs.ptr_g_array_copy = try_find_sym(glib, "g_array_copy");
    stub_funcs.ptr_g_array_free = try_find_sym(glib, "g_array_free");
    stub_funcs.ptr_g_array_ref = try_find_sym(glib, "g_array_ref");
    stub_funcs.ptr_g_array_unref = try_find_sym(glib, "g_array_unref");
    stub_funcs.ptr_g_array_get_element_size = try_find_sym(glib, "g_array_get_element_size");
    stub_funcs.ptr_g_array_append_vals = try_find_sym(glib, "g_array_append_vals");
    stub_funcs.ptr_g_array_prepend_vals = try_find_sym(glib, "g_array_prepend_vals");
    stub_funcs.ptr_g_array_insert_vals = try_find_sym(glib, "g_array_insert_vals");
    stub_funcs.ptr_g_array_set_size = try_find_sym(glib, "g_array_set_size");
    stub_funcs.ptr_g_array_remove_index = try_find_sym(glib, "g_array_remove_index");
    stub_funcs.ptr_g_array_remove_index_fast = try_find_sym(glib, "g_array_remove_index_fast");
    stub_funcs.ptr_g_array_remove_range = try_find_sym(glib, "g_array_remove_range");
    stub_funcs.ptr_g_array_sort = try_find_sym(glib, "g_array_sort");
    stub_funcs.ptr_g_array_sort_with_data = try_find_sym(glib, "g_array_sort_with_data");
    stub_funcs.ptr_g_array_binary_search = try_find_sym(glib, "g_array_binary_search");
    stub_funcs.ptr_g_array_set_clear_func = try_find_sym(glib, "g_array_set_clear_func");
    stub_funcs.ptr_g_ptr_array_new = try_find_sym(glib, "g_ptr_array_new");
    stub_funcs.ptr_g_ptr_array_new_with_free_func = try_find_sym(glib, "g_ptr_array_new_with_free_func");
    stub_funcs.ptr_g_ptr_array_new_take = try_find_sym(glib, "g_ptr_array_new_take");
    stub_funcs.ptr_g_ptr_array_new_from_array = try_find_sym(glib, "g_ptr_array_new_from_array");
    stub_funcs.ptr_g_ptr_array_steal = try_find_sym(glib, "g_ptr_array_steal");
    stub_funcs.ptr_g_ptr_array_copy = try_find_sym(glib, "g_ptr_array_copy");
    stub_funcs.ptr_g_ptr_array_sized_new = try_find_sym(glib, "g_ptr_array_sized_new");
    stub_funcs.ptr_g_ptr_array_new_full = try_find_sym(glib, "g_ptr_array_new_full");
    stub_funcs.ptr_g_ptr_array_new_null_terminated = try_find_sym(glib, "g_ptr_array_new_null_terminated");
    stub_funcs.ptr_g_ptr_array_new_take_null_terminated = try_find_sym(glib, "g_ptr_array_new_take_null_terminated");
    stub_funcs.ptr_g_ptr_array_new_from_null_terminated_array = try_find_sym(glib, "g_ptr_array_new_from_null_terminated_array");
    stub_funcs.ptr_g_ptr_array_free = try_find_sym(glib, "g_ptr_array_free");
    stub_funcs.ptr_g_ptr_array_ref = try_find_sym(glib, "g_ptr_array_ref");
    stub_funcs.ptr_g_ptr_array_unref = try_find_sym(glib, "g_ptr_array_unref");
    stub_funcs.ptr_g_ptr_array_set_free_func = try_find_sym(glib, "g_ptr_array_set_free_func");
    stub_funcs.ptr_g_ptr_array_set_size = try_find_sym(glib, "g_ptr_array_set_size");
    stub_funcs.ptr_g_ptr_array_remove_index = try_find_sym(glib, "g_ptr_array_remove_index");
    stub_funcs.ptr_g_ptr_array_remove_index_fast = try_find_sym(glib, "g_ptr_array_remove_index_fast");
    stub_funcs.ptr_g_ptr_array_steal_index = try_find_sym(glib, "g_ptr_array_steal_index");
    stub_funcs.ptr_g_ptr_array_steal_index_fast = try_find_sym(glib, "g_ptr_array_steal_index_fast");
    stub_funcs.ptr_g_ptr_array_remove = try_find_sym(glib, "g_ptr_array_remove");
    stub_funcs.ptr_g_ptr_array_remove_fast = try_find_sym(glib, "g_ptr_array_remove_fast");
    stub_funcs.ptr_g_ptr_array_remove_range = try_find_sym(glib, "g_ptr_array_remove_range");
    stub_funcs.ptr_g_ptr_array_add = try_find_sym(glib, "g_ptr_array_add");
    stub_funcs.ptr_g_ptr_array_extend = try_find_sym(glib, "g_ptr_array_extend");
    stub_funcs.ptr_g_ptr_array_extend_and_steal = try_find_sym(glib, "g_ptr_array_extend_and_steal");
    stub_funcs.ptr_g_ptr_array_insert = try_find_sym(glib, "g_ptr_array_insert");
    stub_funcs.ptr_g_ptr_array_sort = try_find_sym(glib, "g_ptr_array_sort");
    stub_funcs.ptr_g_ptr_array_sort_with_data = try_find_sym(glib, "g_ptr_array_sort_with_data");
    stub_funcs.ptr_g_ptr_array_sort_values = try_find_sym(glib, "g_ptr_array_sort_values");
    stub_funcs.ptr_g_ptr_array_sort_values_with_data = try_find_sym(glib, "g_ptr_array_sort_values_with_data");
    stub_funcs.ptr_g_ptr_array_foreach = try_find_sym(glib, "g_ptr_array_foreach");
    stub_funcs.ptr_g_ptr_array_find = try_find_sym(glib, "g_ptr_array_find");
    stub_funcs.ptr_g_ptr_array_find_with_equal_func = try_find_sym(glib, "g_ptr_array_find_with_equal_func");
    stub_funcs.ptr_g_ptr_array_is_null_terminated = try_find_sym(glib, "g_ptr_array_is_null_terminated");
    stub_funcs.ptr_g_byte_array_new = try_find_sym(glib, "g_byte_array_new");
    stub_funcs.ptr_g_byte_array_new_take = try_find_sym(glib, "g_byte_array_new_take");
    stub_funcs.ptr_g_byte_array_steal = try_find_sym(glib, "g_byte_array_steal");
    stub_funcs.ptr_g_byte_array_sized_new = try_find_sym(glib, "g_byte_array_sized_new");
    stub_funcs.ptr_g_byte_array_free = try_find_sym(glib, "g_byte_array_free");
    stub_funcs.ptr_g_byte_array_free_to_bytes = try_find_sym(glib, "g_byte_array_free_to_bytes");
    stub_funcs.ptr_g_byte_array_ref = try_find_sym(glib, "g_byte_array_ref");
    stub_funcs.ptr_g_byte_array_unref = try_find_sym(glib, "g_byte_array_unref");
    stub_funcs.ptr_g_byte_array_append = try_find_sym(glib, "g_byte_array_append");
    stub_funcs.ptr_g_byte_array_prepend = try_find_sym(glib, "g_byte_array_prepend");
    stub_funcs.ptr_g_byte_array_set_size = try_find_sym(glib, "g_byte_array_set_size");
    stub_funcs.ptr_g_byte_array_remove_index = try_find_sym(glib, "g_byte_array_remove_index");
    stub_funcs.ptr_g_byte_array_remove_index_fast = try_find_sym(glib, "g_byte_array_remove_index_fast");
    stub_funcs.ptr_g_byte_array_remove_range = try_find_sym(glib, "g_byte_array_remove_range");
    stub_funcs.ptr_g_byte_array_sort = try_find_sym(glib, "g_byte_array_sort");
    stub_funcs.ptr_g_byte_array_sort_with_data = try_find_sym(glib, "g_byte_array_sort_with_data");
    stub_funcs.ptr_g_array_new = try_find_sym(glib, "g_array_new");
    // Header /usr/include/glib-2.0/glib/gasyncqueue.h
    stub_funcs.ptr_g_async_queue_new_full = try_find_sym(glib, "g_async_queue_new_full");
    stub_funcs.ptr_g_async_queue_lock = try_find_sym(glib, "g_async_queue_lock");
    stub_funcs.ptr_g_async_queue_unlock = try_find_sym(glib, "g_async_queue_unlock");
    stub_funcs.ptr_g_async_queue_ref = try_find_sym(glib, "g_async_queue_ref");
    stub_funcs.ptr_g_async_queue_unref = try_find_sym(glib, "g_async_queue_unref");
    stub_funcs.ptr_g_async_queue_ref_unlocked = try_find_sym(glib, "g_async_queue_ref_unlocked");
    stub_funcs.ptr_g_async_queue_unref_and_unlock = try_find_sym(glib, "g_async_queue_unref_and_unlock");
    stub_funcs.ptr_g_async_queue_push = try_find_sym(glib, "g_async_queue_push");
    stub_funcs.ptr_g_async_queue_push_unlocked = try_find_sym(glib, "g_async_queue_push_unlocked");
    stub_funcs.ptr_g_async_queue_push_sorted = try_find_sym(glib, "g_async_queue_push_sorted");
    stub_funcs.ptr_g_async_queue_push_sorted_unlocked = try_find_sym(glib, "g_async_queue_push_sorted_unlocked");
    stub_funcs.ptr_g_async_queue_pop = try_find_sym(glib, "g_async_queue_pop");
    stub_funcs.ptr_g_async_queue_pop_unlocked = try_find_sym(glib, "g_async_queue_pop_unlocked");
    stub_funcs.ptr_g_async_queue_try_pop = try_find_sym(glib, "g_async_queue_try_pop");
    stub_funcs.ptr_g_async_queue_try_pop_unlocked = try_find_sym(glib, "g_async_queue_try_pop_unlocked");
    stub_funcs.ptr_g_async_queue_timeout_pop = try_find_sym(glib, "g_async_queue_timeout_pop");
    stub_funcs.ptr_g_async_queue_timeout_pop_unlocked = try_find_sym(glib, "g_async_queue_timeout_pop_unlocked");
    stub_funcs.ptr_g_async_queue_length = try_find_sym(glib, "g_async_queue_length");
    stub_funcs.ptr_g_async_queue_length_unlocked = try_find_sym(glib, "g_async_queue_length_unlocked");
    stub_funcs.ptr_g_async_queue_sort = try_find_sym(glib, "g_async_queue_sort");
    stub_funcs.ptr_g_async_queue_sort_unlocked = try_find_sym(glib, "g_async_queue_sort_unlocked");
    stub_funcs.ptr_g_async_queue_remove = try_find_sym(glib, "g_async_queue_remove");
    stub_funcs.ptr_g_async_queue_remove_unlocked = try_find_sym(glib, "g_async_queue_remove_unlocked");
    stub_funcs.ptr_g_async_queue_push_front = try_find_sym(glib, "g_async_queue_push_front");
    stub_funcs.ptr_g_async_queue_push_front_unlocked = try_find_sym(glib, "g_async_queue_push_front_unlocked");
    stub_funcs.ptr_g_async_queue_timed_pop_unlocked = try_find_sym(glib, "g_async_queue_timed_pop_unlocked");
    stub_funcs.ptr_g_async_queue_new = try_find_sym(glib, "g_async_queue_new");
    // Header /usr/include/glib-2.0/glib/gatomic.h
    stub_funcs.ptr_g_atomic_int_set = try_find_sym(glib, "g_atomic_int_set");
    stub_funcs.ptr_g_atomic_int_inc = try_find_sym(glib, "g_atomic_int_inc");
    stub_funcs.ptr_g_atomic_int_dec_and_test = try_find_sym(glib, "g_atomic_int_dec_and_test");
    stub_funcs.ptr_g_atomic_int_compare_and_exchange = try_find_sym(glib, "g_atomic_int_compare_and_exchange");
    stub_funcs.ptr_g_atomic_int_compare_and_exchange_full = try_find_sym(glib, "g_atomic_int_compare_and_exchange_full");
    stub_funcs.ptr_g_atomic_int_exchange = try_find_sym(glib, "g_atomic_int_exchange");
    stub_funcs.ptr_g_atomic_int_add = try_find_sym(glib, "g_atomic_int_add");
    stub_funcs.ptr_g_atomic_int_and = try_find_sym(glib, "g_atomic_int_and");
    stub_funcs.ptr_g_atomic_int_or = try_find_sym(glib, "g_atomic_int_or");
    stub_funcs.ptr_g_atomic_int_xor = try_find_sym(glib, "g_atomic_int_xor");
    stub_funcs.ptr_g_atomic_pointer_get = try_find_sym(glib, "g_atomic_pointer_get");
    stub_funcs.ptr_g_atomic_pointer_set = try_find_sym(glib, "g_atomic_pointer_set");
    stub_funcs.ptr_g_atomic_pointer_compare_and_exchange = try_find_sym(glib, "g_atomic_pointer_compare_and_exchange");
    stub_funcs.ptr_g_atomic_pointer_compare_and_exchange_full = try_find_sym(glib, "g_atomic_pointer_compare_and_exchange_full");
    stub_funcs.ptr_g_atomic_pointer_exchange = try_find_sym(glib, "g_atomic_pointer_exchange");
    stub_funcs.ptr_g_atomic_pointer_add = try_find_sym(glib, "g_atomic_pointer_add");
    stub_funcs.ptr_g_atomic_pointer_and = try_find_sym(glib, "g_atomic_pointer_and");
    stub_funcs.ptr_g_atomic_pointer_or = try_find_sym(glib, "g_atomic_pointer_or");
    stub_funcs.ptr_g_atomic_pointer_xor = try_find_sym(glib, "g_atomic_pointer_xor");
    stub_funcs.ptr_g_atomic_int_exchange_and_add = try_find_sym(glib, "g_atomic_int_exchange_and_add");
    stub_funcs.ptr_g_atomic_int_get = try_find_sym(glib, "g_atomic_int_get");
    // Header /usr/include/glib-2.0/glib/gbacktrace.h
    stub_funcs.ptr_g_on_error_stack_trace = try_find_sym(glib, "g_on_error_stack_trace");
    stub_funcs.ptr_g_on_error_query = try_find_sym(glib, "g_on_error_query");
    // Header /usr/include/glib-2.0/glib/gbase64.h
    stub_funcs.ptr_g_base64_encode_close = try_find_sym(glib, "g_base64_encode_close");
    stub_funcs.ptr_g_base64_encode = try_find_sym(glib, "g_base64_encode");
    stub_funcs.ptr_g_base64_decode_step = try_find_sym(glib, "g_base64_decode_step");
    stub_funcs.ptr_g_base64_decode = try_find_sym(glib, "g_base64_decode");
    stub_funcs.ptr_g_base64_decode_inplace = try_find_sym(glib, "g_base64_decode_inplace");
    stub_funcs.ptr_g_base64_encode_step = try_find_sym(glib, "g_base64_encode_step");
    // Header /usr/include/glib-2.0/glib/gbitlock.h
    stub_funcs.ptr_g_bit_trylock = try_find_sym(glib, "g_bit_trylock");
    stub_funcs.ptr_g_bit_unlock = try_find_sym(glib, "g_bit_unlock");
    stub_funcs.ptr_g_pointer_bit_lock = try_find_sym(glib, "g_pointer_bit_lock");
    stub_funcs.ptr_g_pointer_bit_lock_and_get = try_find_sym(glib, "g_pointer_bit_lock_and_get");
    stub_funcs.ptr_g_pointer_bit_trylock = try_find_sym(glib, "g_pointer_bit_trylock");
    stub_funcs.ptr_g_pointer_bit_unlock = try_find_sym(glib, "g_pointer_bit_unlock");
    stub_funcs.ptr_g_pointer_bit_lock_mask_ptr = try_find_sym(glib, "g_pointer_bit_lock_mask_ptr");
    stub_funcs.ptr_g_pointer_bit_unlock_and_set = try_find_sym(glib, "g_pointer_bit_unlock_and_set");
    stub_funcs.ptr_g_bit_lock = try_find_sym(glib, "g_bit_lock");
    // Header /usr/include/glib-2.0/glib/gbookmarkfile.h
    stub_funcs.ptr_g_bookmark_file_new = try_find_sym(glib, "g_bookmark_file_new");
    stub_funcs.ptr_g_bookmark_file_free = try_find_sym(glib, "g_bookmark_file_free");
    stub_funcs.ptr_g_bookmark_file_copy = try_find_sym(glib, "g_bookmark_file_copy");
    stub_funcs.ptr_g_bookmark_file_load_from_file = try_find_sym(glib, "g_bookmark_file_load_from_file");
    stub_funcs.ptr_g_bookmark_file_load_from_data = try_find_sym(glib, "g_bookmark_file_load_from_data");
    stub_funcs.ptr_g_bookmark_file_load_from_data_dirs = try_find_sym(glib, "g_bookmark_file_load_from_data_dirs");
    stub_funcs.ptr_g_bookmark_file_to_data = try_find_sym(glib, "g_bookmark_file_to_data");
    stub_funcs.ptr_g_bookmark_file_to_file = try_find_sym(glib, "g_bookmark_file_to_file");
    stub_funcs.ptr_g_bookmark_file_set_title = try_find_sym(glib, "g_bookmark_file_set_title");
    stub_funcs.ptr_g_bookmark_file_get_title = try_find_sym(glib, "g_bookmark_file_get_title");
    stub_funcs.ptr_g_bookmark_file_set_description = try_find_sym(glib, "g_bookmark_file_set_description");
    stub_funcs.ptr_g_bookmark_file_get_description = try_find_sym(glib, "g_bookmark_file_get_description");
    stub_funcs.ptr_g_bookmark_file_set_mime_type = try_find_sym(glib, "g_bookmark_file_set_mime_type");
    stub_funcs.ptr_g_bookmark_file_get_mime_type = try_find_sym(glib, "g_bookmark_file_get_mime_type");
    stub_funcs.ptr_g_bookmark_file_set_groups = try_find_sym(glib, "g_bookmark_file_set_groups");
    stub_funcs.ptr_g_bookmark_file_add_group = try_find_sym(glib, "g_bookmark_file_add_group");
    stub_funcs.ptr_g_bookmark_file_has_group = try_find_sym(glib, "g_bookmark_file_has_group");
    stub_funcs.ptr_g_bookmark_file_get_groups = try_find_sym(glib, "g_bookmark_file_get_groups");
    stub_funcs.ptr_g_bookmark_file_add_application = try_find_sym(glib, "g_bookmark_file_add_application");
    stub_funcs.ptr_g_bookmark_file_has_application = try_find_sym(glib, "g_bookmark_file_has_application");
    stub_funcs.ptr_g_bookmark_file_get_applications = try_find_sym(glib, "g_bookmark_file_get_applications");
    stub_funcs.ptr_g_bookmark_file_set_app_info = try_find_sym(glib, "g_bookmark_file_set_app_info");
    stub_funcs.ptr_g_bookmark_file_set_application_info = try_find_sym(glib, "g_bookmark_file_set_application_info");
    stub_funcs.ptr_g_bookmark_file_get_app_info = try_find_sym(glib, "g_bookmark_file_get_app_info");
    stub_funcs.ptr_g_bookmark_file_get_application_info = try_find_sym(glib, "g_bookmark_file_get_application_info");
    stub_funcs.ptr_g_bookmark_file_set_is_private = try_find_sym(glib, "g_bookmark_file_set_is_private");
    stub_funcs.ptr_g_bookmark_file_get_is_private = try_find_sym(glib, "g_bookmark_file_get_is_private");
    stub_funcs.ptr_g_bookmark_file_set_icon = try_find_sym(glib, "g_bookmark_file_set_icon");
    stub_funcs.ptr_g_bookmark_file_get_icon = try_find_sym(glib, "g_bookmark_file_get_icon");
    stub_funcs.ptr_g_bookmark_file_set_added = try_find_sym(glib, "g_bookmark_file_set_added");
    stub_funcs.ptr_g_bookmark_file_set_added_date_time = try_find_sym(glib, "g_bookmark_file_set_added_date_time");
    stub_funcs.ptr_g_bookmark_file_get_added = try_find_sym(glib, "g_bookmark_file_get_added");
    stub_funcs.ptr_g_bookmark_file_get_added_date_time = try_find_sym(glib, "g_bookmark_file_get_added_date_time");
    stub_funcs.ptr_g_bookmark_file_set_modified = try_find_sym(glib, "g_bookmark_file_set_modified");
    stub_funcs.ptr_g_bookmark_file_set_modified_date_time = try_find_sym(glib, "g_bookmark_file_set_modified_date_time");
    stub_funcs.ptr_g_bookmark_file_get_modified = try_find_sym(glib, "g_bookmark_file_get_modified");
    stub_funcs.ptr_g_bookmark_file_get_modified_date_time = try_find_sym(glib, "g_bookmark_file_get_modified_date_time");
    stub_funcs.ptr_g_bookmark_file_set_visited = try_find_sym(glib, "g_bookmark_file_set_visited");
    stub_funcs.ptr_g_bookmark_file_set_visited_date_time = try_find_sym(glib, "g_bookmark_file_set_visited_date_time");
    stub_funcs.ptr_g_bookmark_file_get_visited = try_find_sym(glib, "g_bookmark_file_get_visited");
    stub_funcs.ptr_g_bookmark_file_get_visited_date_time = try_find_sym(glib, "g_bookmark_file_get_visited_date_time");
    stub_funcs.ptr_g_bookmark_file_has_item = try_find_sym(glib, "g_bookmark_file_has_item");
    stub_funcs.ptr_g_bookmark_file_get_size = try_find_sym(glib, "g_bookmark_file_get_size");
    stub_funcs.ptr_g_bookmark_file_get_uris = try_find_sym(glib, "g_bookmark_file_get_uris");
    stub_funcs.ptr_g_bookmark_file_remove_group = try_find_sym(glib, "g_bookmark_file_remove_group");
    stub_funcs.ptr_g_bookmark_file_remove_application = try_find_sym(glib, "g_bookmark_file_remove_application");
    stub_funcs.ptr_g_bookmark_file_remove_item = try_find_sym(glib, "g_bookmark_file_remove_item");
    stub_funcs.ptr_g_bookmark_file_move_item = try_find_sym(glib, "g_bookmark_file_move_item");
    stub_funcs.ptr_g_bookmark_file_error_quark = try_find_sym(glib, "g_bookmark_file_error_quark");
    // Header /usr/include/glib-2.0/glib/gbytes.h
    stub_funcs.ptr_g_bytes_new_take = try_find_sym(glib, "g_bytes_new_take");
    stub_funcs.ptr_g_bytes_new_static = try_find_sym(glib, "g_bytes_new_static");
    stub_funcs.ptr_g_bytes_new_with_free_func = try_find_sym(glib, "g_bytes_new_with_free_func");
    stub_funcs.ptr_g_bytes_new_from_bytes = try_find_sym(glib, "g_bytes_new_from_bytes");
    stub_funcs.ptr_g_bytes_get_data = try_find_sym(glib, "g_bytes_get_data");
    stub_funcs.ptr_g_bytes_get_size = try_find_sym(glib, "g_bytes_get_size");
    stub_funcs.ptr_g_bytes_ref = try_find_sym(glib, "g_bytes_ref");
    stub_funcs.ptr_g_bytes_unref = try_find_sym(glib, "g_bytes_unref");
    stub_funcs.ptr_g_bytes_unref_to_data = try_find_sym(glib, "g_bytes_unref_to_data");
    stub_funcs.ptr_g_bytes_unref_to_array = try_find_sym(glib, "g_bytes_unref_to_array");
    stub_funcs.ptr_g_bytes_hash = try_find_sym(glib, "g_bytes_hash");
    stub_funcs.ptr_g_bytes_equal = try_find_sym(glib, "g_bytes_equal");
    stub_funcs.ptr_g_bytes_compare = try_find_sym(glib, "g_bytes_compare");
    stub_funcs.ptr_g_bytes_get_region = try_find_sym(glib, "g_bytes_get_region");
    stub_funcs.ptr_g_bytes_new = try_find_sym(glib, "g_bytes_new");
    // Header /usr/include/glib-2.0/glib/gcharset.h
    stub_funcs.ptr_g_get_codeset = try_find_sym(glib, "g_get_codeset");
    stub_funcs.ptr_g_get_console_charset = try_find_sym(glib, "g_get_console_charset");
    stub_funcs.ptr_g_get_language_names = try_find_sym(glib, "g_get_language_names");
    stub_funcs.ptr_g_get_language_names_with_category = try_find_sym(glib, "g_get_language_names_with_category");
    stub_funcs.ptr_g_get_locale_variants = try_find_sym(glib, "g_get_locale_variants");
    stub_funcs.ptr_g_get_charset = try_find_sym(glib, "g_get_charset");
    // Header /usr/include/glib-2.0/glib/gchecksum.h
    stub_funcs.ptr_g_checksum_new = try_find_sym(glib, "g_checksum_new");
    stub_funcs.ptr_g_checksum_reset = try_find_sym(glib, "g_checksum_reset");
    stub_funcs.ptr_g_checksum_copy = try_find_sym(glib, "g_checksum_copy");
    stub_funcs.ptr_g_checksum_free = try_find_sym(glib, "g_checksum_free");
    stub_funcs.ptr_g_checksum_update = try_find_sym(glib, "g_checksum_update");
    stub_funcs.ptr_g_checksum_get_string = try_find_sym(glib, "g_checksum_get_string");
    stub_funcs.ptr_g_checksum_get_digest = try_find_sym(glib, "g_checksum_get_digest");
    stub_funcs.ptr_g_compute_checksum_for_data = try_find_sym(glib, "g_compute_checksum_for_data");
    stub_funcs.ptr_g_compute_checksum_for_string = try_find_sym(glib, "g_compute_checksum_for_string");
    stub_funcs.ptr_g_compute_checksum_for_bytes = try_find_sym(glib, "g_compute_checksum_for_bytes");
    stub_funcs.ptr_g_checksum_type_get_length = try_find_sym(glib, "g_checksum_type_get_length");
    // Header /usr/include/glib-2.0/glib/gconvert.h
    stub_funcs.ptr_g_iconv_open = try_find_sym(glib, "g_iconv_open");
    stub_funcs.ptr_g_iconv = try_find_sym(glib, "g_iconv");
    stub_funcs.ptr_g_iconv_close = try_find_sym(glib, "g_iconv_close");
    stub_funcs.ptr_g_convert = try_find_sym(glib, "g_convert");
    stub_funcs.ptr_g_convert_with_iconv = try_find_sym(glib, "g_convert_with_iconv");
    stub_funcs.ptr_g_convert_with_fallback = try_find_sym(glib, "g_convert_with_fallback");
    stub_funcs.ptr_g_locale_to_utf8 = try_find_sym(glib, "g_locale_to_utf8");
    stub_funcs.ptr_g_locale_from_utf8 = try_find_sym(glib, "g_locale_from_utf8");
    stub_funcs.ptr_g_filename_to_utf8 = try_find_sym(glib, "g_filename_to_utf8");
    stub_funcs.ptr_g_filename_from_utf8 = try_find_sym(glib, "g_filename_from_utf8");
    stub_funcs.ptr_g_filename_from_uri = try_find_sym(glib, "g_filename_from_uri");
    stub_funcs.ptr_g_filename_to_uri = try_find_sym(glib, "g_filename_to_uri");
    stub_funcs.ptr_g_filename_display_name = try_find_sym(glib, "g_filename_display_name");
    stub_funcs.ptr_g_get_filename_charsets = try_find_sym(glib, "g_get_filename_charsets");
    stub_funcs.ptr_g_filename_display_basename = try_find_sym(glib, "g_filename_display_basename");
    stub_funcs.ptr_g_uri_list_extract_uris = try_find_sym(glib, "g_uri_list_extract_uris");
    stub_funcs.ptr_g_convert_error_quark = try_find_sym(glib, "g_convert_error_quark");
    // Header /usr/include/glib-2.0/glib/gdataset.h
    stub_funcs.ptr_g_datalist_clear = try_find_sym(glib, "g_datalist_clear");
    stub_funcs.ptr_g_datalist_id_get_data = try_find_sym(glib, "g_datalist_id_get_data");
    stub_funcs.ptr_g_datalist_id_set_data_full = try_find_sym(glib, "g_datalist_id_set_data_full");
    stub_funcs.ptr_g_datalist_id_remove_multiple = try_find_sym(glib, "g_datalist_id_remove_multiple");
    stub_funcs.ptr_g_datalist_id_dup_data = try_find_sym(glib, "g_datalist_id_dup_data");
    stub_funcs.ptr_g_datalist_id_replace_data = try_find_sym(glib, "g_datalist_id_replace_data");
    stub_funcs.ptr_g_datalist_id_remove_no_notify = try_find_sym(glib, "g_datalist_id_remove_no_notify");
    stub_funcs.ptr_g_datalist_foreach = try_find_sym(glib, "g_datalist_foreach");
    stub_funcs.ptr_g_datalist_set_flags = try_find_sym(glib, "g_datalist_set_flags");
    stub_funcs.ptr_g_datalist_unset_flags = try_find_sym(glib, "g_datalist_unset_flags");
    stub_funcs.ptr_g_datalist_get_flags = try_find_sym(glib, "g_datalist_get_flags");
    stub_funcs.ptr_g_dataset_destroy = try_find_sym(glib, "g_dataset_destroy");
    stub_funcs.ptr_g_dataset_id_get_data = try_find_sym(glib, "g_dataset_id_get_data");
    stub_funcs.ptr_g_datalist_get_data = try_find_sym(glib, "g_datalist_get_data");
    stub_funcs.ptr_g_dataset_id_set_data_full = try_find_sym(glib, "g_dataset_id_set_data_full");
    stub_funcs.ptr_g_dataset_id_remove_no_notify = try_find_sym(glib, "g_dataset_id_remove_no_notify");
    stub_funcs.ptr_g_dataset_foreach = try_find_sym(glib, "g_dataset_foreach");
    stub_funcs.ptr_g_datalist_init = try_find_sym(glib, "g_datalist_init");
    // Header /usr/include/glib-2.0/glib/gdate.h
    stub_funcs.ptr_g_date_new_dmy = try_find_sym(glib, "g_date_new_dmy");
    stub_funcs.ptr_g_date_new_julian = try_find_sym(glib, "g_date_new_julian");
    stub_funcs.ptr_g_date_free = try_find_sym(glib, "g_date_free");
    stub_funcs.ptr_g_date_copy = try_find_sym(glib, "g_date_copy");
    stub_funcs.ptr_g_date_valid = try_find_sym(glib, "g_date_valid");
    stub_funcs.ptr_g_date_valid_day = try_find_sym(glib, "g_date_valid_day");
    stub_funcs.ptr_g_date_valid_month = try_find_sym(glib, "g_date_valid_month");
    stub_funcs.ptr_g_date_valid_year = try_find_sym(glib, "g_date_valid_year");
    stub_funcs.ptr_g_date_valid_weekday = try_find_sym(glib, "g_date_valid_weekday");
    stub_funcs.ptr_g_date_valid_julian = try_find_sym(glib, "g_date_valid_julian");
    stub_funcs.ptr_g_date_valid_dmy = try_find_sym(glib, "g_date_valid_dmy");
    stub_funcs.ptr_g_date_get_weekday = try_find_sym(glib, "g_date_get_weekday");
    stub_funcs.ptr_g_date_get_month = try_find_sym(glib, "g_date_get_month");
    stub_funcs.ptr_g_date_get_year = try_find_sym(glib, "g_date_get_year");
    stub_funcs.ptr_g_date_get_day = try_find_sym(glib, "g_date_get_day");
    stub_funcs.ptr_g_date_get_julian = try_find_sym(glib, "g_date_get_julian");
    stub_funcs.ptr_g_date_get_day_of_year = try_find_sym(glib, "g_date_get_day_of_year");
    stub_funcs.ptr_g_date_get_monday_week_of_year = try_find_sym(glib, "g_date_get_monday_week_of_year");
    stub_funcs.ptr_g_date_get_sunday_week_of_year = try_find_sym(glib, "g_date_get_sunday_week_of_year");
    stub_funcs.ptr_g_date_get_iso8601_week_of_year = try_find_sym(glib, "g_date_get_iso8601_week_of_year");
    stub_funcs.ptr_g_date_clear = try_find_sym(glib, "g_date_clear");
    stub_funcs.ptr_g_date_set_parse = try_find_sym(glib, "g_date_set_parse");
    stub_funcs.ptr_g_date_set_time_t = try_find_sym(glib, "g_date_set_time_t");
    stub_funcs.ptr_g_date_set_time = try_find_sym(glib, "g_date_set_time");
    stub_funcs.ptr_g_date_set_day = try_find_sym(glib, "g_date_set_day");
    stub_funcs.ptr_g_date_set_year = try_find_sym(glib, "g_date_set_year");
    stub_funcs.ptr_g_date_set_dmy = try_find_sym(glib, "g_date_set_dmy");
    stub_funcs.ptr_g_date_set_julian = try_find_sym(glib, "g_date_set_julian");
    stub_funcs.ptr_g_date_is_first_of_month = try_find_sym(glib, "g_date_is_first_of_month");
    stub_funcs.ptr_g_date_is_last_of_month = try_find_sym(glib, "g_date_is_last_of_month");
    stub_funcs.ptr_g_date_add_days = try_find_sym(glib, "g_date_add_days");
    stub_funcs.ptr_g_date_subtract_days = try_find_sym(glib, "g_date_subtract_days");
    stub_funcs.ptr_g_date_add_months = try_find_sym(glib, "g_date_add_months");
    stub_funcs.ptr_g_date_subtract_months = try_find_sym(glib, "g_date_subtract_months");
    stub_funcs.ptr_g_date_add_years = try_find_sym(glib, "g_date_add_years");
    stub_funcs.ptr_g_date_subtract_years = try_find_sym(glib, "g_date_subtract_years");
    stub_funcs.ptr_g_date_is_leap_year = try_find_sym(glib, "g_date_is_leap_year");
    stub_funcs.ptr_g_date_get_days_in_month = try_find_sym(glib, "g_date_get_days_in_month");
    stub_funcs.ptr_g_date_get_monday_weeks_in_year = try_find_sym(glib, "g_date_get_monday_weeks_in_year");
    stub_funcs.ptr_g_date_get_sunday_weeks_in_year = try_find_sym(glib, "g_date_get_sunday_weeks_in_year");
    stub_funcs.ptr_g_date_days_between = try_find_sym(glib, "g_date_days_between");
    stub_funcs.ptr_g_date_compare = try_find_sym(glib, "g_date_compare");
    stub_funcs.ptr_g_date_to_struct_tm = try_find_sym(glib, "g_date_to_struct_tm");
    stub_funcs.ptr_g_date_clamp = try_find_sym(glib, "g_date_clamp");
    stub_funcs.ptr_g_date_order = try_find_sym(glib, "g_date_order");
    stub_funcs.ptr_g_date_strftime = try_find_sym(glib, "g_date_strftime");
    stub_funcs.ptr_g_date_new = try_find_sym(glib, "g_date_new");
    // Header /usr/include/glib-2.0/glib/gdatetime.h
    stub_funcs.ptr_g_date_time_ref = try_find_sym(glib, "g_date_time_ref");
    stub_funcs.ptr_g_date_time_new_now = try_find_sym(glib, "g_date_time_new_now");
    stub_funcs.ptr_g_date_time_new_now_local = try_find_sym(glib, "g_date_time_new_now_local");
    stub_funcs.ptr_g_date_time_new_now_utc = try_find_sym(glib, "g_date_time_new_now_utc");
    stub_funcs.ptr_g_date_time_new_from_unix_local = try_find_sym(glib, "g_date_time_new_from_unix_local");
    stub_funcs.ptr_g_date_time_new_from_unix_utc = try_find_sym(glib, "g_date_time_new_from_unix_utc");
    stub_funcs.ptr_g_date_time_new_from_unix_local_usec = try_find_sym(glib, "g_date_time_new_from_unix_local_usec");
    stub_funcs.ptr_g_date_time_new_from_unix_utc_usec = try_find_sym(glib, "g_date_time_new_from_unix_utc_usec");
    stub_funcs.ptr_g_date_time_new_from_timeval_utc = try_find_sym(glib, "g_date_time_new_from_timeval_utc");
    stub_funcs.ptr_g_date_time_new = try_find_sym(glib, "g_date_time_new");
    stub_funcs.ptr_g_date_time_new_local = try_find_sym(glib, "g_date_time_new_local");
    stub_funcs.ptr_g_date_time_new_utc = try_find_sym(glib, "g_date_time_new_utc");
    stub_funcs.ptr_g_date_time_add = try_find_sym(glib, "g_date_time_add");
    stub_funcs.ptr_g_date_time_add_years = try_find_sym(glib, "g_date_time_add_years");
    stub_funcs.ptr_g_date_time_add_months = try_find_sym(glib, "g_date_time_add_months");
    stub_funcs.ptr_g_date_time_add_weeks = try_find_sym(glib, "g_date_time_add_weeks");
    stub_funcs.ptr_g_date_time_add_days = try_find_sym(glib, "g_date_time_add_days");
    stub_funcs.ptr_g_date_time_add_hours = try_find_sym(glib, "g_date_time_add_hours");
    stub_funcs.ptr_g_date_time_add_minutes = try_find_sym(glib, "g_date_time_add_minutes");
    stub_funcs.ptr_g_date_time_add_seconds = try_find_sym(glib, "g_date_time_add_seconds");
    stub_funcs.ptr_g_date_time_add_full = try_find_sym(glib, "g_date_time_add_full");
    stub_funcs.ptr_g_date_time_compare = try_find_sym(glib, "g_date_time_compare");
    stub_funcs.ptr_g_date_time_difference = try_find_sym(glib, "g_date_time_difference");
    stub_funcs.ptr_g_date_time_hash = try_find_sym(glib, "g_date_time_hash");
    stub_funcs.ptr_g_date_time_equal = try_find_sym(glib, "g_date_time_equal");
    stub_funcs.ptr_g_date_time_get_ymd = try_find_sym(glib, "g_date_time_get_ymd");
    stub_funcs.ptr_g_date_time_get_year = try_find_sym(glib, "g_date_time_get_year");
    stub_funcs.ptr_g_date_time_get_month = try_find_sym(glib, "g_date_time_get_month");
    stub_funcs.ptr_g_date_time_get_day_of_month = try_find_sym(glib, "g_date_time_get_day_of_month");
    stub_funcs.ptr_g_date_time_get_week_numbering_year = try_find_sym(glib, "g_date_time_get_week_numbering_year");
    stub_funcs.ptr_g_date_time_get_week_of_year = try_find_sym(glib, "g_date_time_get_week_of_year");
    stub_funcs.ptr_g_date_time_get_day_of_week = try_find_sym(glib, "g_date_time_get_day_of_week");
    stub_funcs.ptr_g_date_time_get_day_of_year = try_find_sym(glib, "g_date_time_get_day_of_year");
    stub_funcs.ptr_g_date_time_get_hour = try_find_sym(glib, "g_date_time_get_hour");
    stub_funcs.ptr_g_date_time_get_minute = try_find_sym(glib, "g_date_time_get_minute");
    stub_funcs.ptr_g_date_time_get_second = try_find_sym(glib, "g_date_time_get_second");
    stub_funcs.ptr_g_date_time_get_microsecond = try_find_sym(glib, "g_date_time_get_microsecond");
    stub_funcs.ptr_g_date_time_get_seconds = try_find_sym(glib, "g_date_time_get_seconds");
    stub_funcs.ptr_g_date_time_to_unix = try_find_sym(glib, "g_date_time_to_unix");
    stub_funcs.ptr_g_date_time_to_unix_usec = try_find_sym(glib, "g_date_time_to_unix_usec");
    stub_funcs.ptr_g_date_time_get_timezone = try_find_sym(glib, "g_date_time_get_timezone");
    stub_funcs.ptr_g_date_time_get_timezone_abbreviation = try_find_sym(glib, "g_date_time_get_timezone_abbreviation");
    stub_funcs.ptr_g_date_time_is_daylight_savings = try_find_sym(glib, "g_date_time_is_daylight_savings");
    stub_funcs.ptr_g_date_time_to_timezone = try_find_sym(glib, "g_date_time_to_timezone");
    stub_funcs.ptr_g_date_time_to_local = try_find_sym(glib, "g_date_time_to_local");
    stub_funcs.ptr_g_date_time_to_utc = try_find_sym(glib, "g_date_time_to_utc");
    stub_funcs.ptr_g_date_time_format = try_find_sym(glib, "g_date_time_format");
    stub_funcs.ptr_g_date_time_format_iso8601 = try_find_sym(glib, "g_date_time_format_iso8601");
    stub_funcs.ptr_g_date_time_unref = try_find_sym(glib, "g_date_time_unref");
    // Header /usr/include/glib-2.0/glib/gdir.h
    stub_funcs.ptr_g_dir_read_name = try_find_sym(glib, "g_dir_read_name");
    stub_funcs.ptr_g_dir_rewind = try_find_sym(glib, "g_dir_rewind");
    stub_funcs.ptr_g_dir_close = try_find_sym(glib, "g_dir_close");
    stub_funcs.ptr_g_dir_ref = try_find_sym(glib, "g_dir_ref");
    stub_funcs.ptr_g_dir_unref = try_find_sym(glib, "g_dir_unref");
    stub_funcs.ptr_g_dir_open = try_find_sym(glib, "g_dir_open");
    // Header /usr/include/glib-2.0/glib/genviron.h
    stub_funcs.ptr_g_setenv = try_find_sym(glib, "g_setenv");
    stub_funcs.ptr_g_unsetenv = try_find_sym(glib, "g_unsetenv");
    stub_funcs.ptr_g_listenv = try_find_sym(glib, "g_listenv");
    stub_funcs.ptr_g_get_environ = try_find_sym(glib, "g_get_environ");
    stub_funcs.ptr_g_environ_getenv = try_find_sym(glib, "g_environ_getenv");
    stub_funcs.ptr_g_environ_setenv = try_find_sym(glib, "g_environ_setenv");
    stub_funcs.ptr_g_environ_unsetenv = try_find_sym(glib, "g_environ_unsetenv");
    stub_funcs.ptr_g_getenv = try_find_sym(glib, "g_getenv");
    // Header /usr/include/glib-2.0/glib/gerror.h
    stub_funcs.ptr_g_error_domain_register = try_find_sym(glib, "g_error_domain_register");
    stub_funcs.ptr_g_error_new_literal = try_find_sym(glib, "g_error_new_literal");
    stub_funcs.ptr_g_error_new_valist = try_find_sym(glib, "g_error_new_valist");
    stub_funcs.ptr_g_error_free = try_find_sym(glib, "g_error_free");
    stub_funcs.ptr_g_error_copy = try_find_sym(glib, "g_error_copy");
    stub_funcs.ptr_g_error_matches = try_find_sym(glib, "g_error_matches");
    stub_funcs.ptr_g_set_error_literal = try_find_sym(glib, "g_set_error_literal");
    stub_funcs.ptr_g_propagate_error = try_find_sym(glib, "g_propagate_error");
    stub_funcs.ptr_g_clear_error = try_find_sym(glib, "g_clear_error");
    stub_funcs.ptr_g_prefix_error_literal = try_find_sym(glib, "g_prefix_error_literal");
    stub_funcs.ptr_g_error_domain_register_static = try_find_sym(glib, "g_error_domain_register_static");
    // Header /usr/include/glib-2.0/glib/gfileutils.h
    stub_funcs.ptr_g_file_error_quark = try_find_sym(glib, "g_file_error_quark");
    stub_funcs.ptr_g_file_error_from_errno = try_find_sym(glib, "g_file_error_from_errno");
    stub_funcs.ptr_g_file_test = try_find_sym(glib, "g_file_test");
    stub_funcs.ptr_g_file_get_contents = try_find_sym(glib, "g_file_get_contents");
    stub_funcs.ptr_g_file_set_contents = try_find_sym(glib, "g_file_set_contents");
    stub_funcs.ptr_g_mkdtemp = try_find_sym(glib, "g_mkdtemp");
    stub_funcs.ptr_g_mkdtemp_full = try_find_sym(glib, "g_mkdtemp_full");
    stub_funcs.ptr_g_mkstemp = try_find_sym(glib, "g_mkstemp");
    stub_funcs.ptr_g_mkstemp_full = try_find_sym(glib, "g_mkstemp_full");
    stub_funcs.ptr_g_file_open_tmp = try_find_sym(glib, "g_file_open_tmp");
    stub_funcs.ptr_g_dir_make_tmp = try_find_sym(glib, "g_dir_make_tmp");
    stub_funcs.ptr_g_build_pathv = try_find_sym(glib, "g_build_pathv");
    stub_funcs.ptr_g_build_filenamev = try_find_sym(glib, "g_build_filenamev");
    stub_funcs.ptr_g_build_filename_valist = try_find_sym(glib, "g_build_filename_valist");
    stub_funcs.ptr_g_path_is_absolute = try_find_sym(glib, "g_path_is_absolute");
    stub_funcs.ptr_g_path_skip_root = try_find_sym(glib, "g_path_skip_root");
    stub_funcs.ptr_g_basename = try_find_sym(glib, "g_basename");
    stub_funcs.ptr_g_get_current_dir = try_find_sym(glib, "g_get_current_dir");
    stub_funcs.ptr_g_path_get_basename = try_find_sym(glib, "g_path_get_basename");
    stub_funcs.ptr_g_path_get_dirname = try_find_sym(glib, "g_path_get_dirname");
    stub_funcs.ptr_g_canonicalize_filename = try_find_sym(glib, "g_canonicalize_filename");
    // Header /usr/include/glib-2.0/glib/ggettext.h
    stub_funcs.ptr_g_dgettext = try_find_sym(glib, "g_dgettext");
    stub_funcs.ptr_g_dcgettext = try_find_sym(glib, "g_dcgettext");
    stub_funcs.ptr_g_dngettext = try_find_sym(glib, "g_dngettext");
    stub_funcs.ptr_g_dpgettext = try_find_sym(glib, "g_dpgettext");
    stub_funcs.ptr_g_dpgettext2 = try_find_sym(glib, "g_dpgettext2");
    stub_funcs.ptr_g_strip_context = try_find_sym(glib, "g_strip_context");
    // Header /usr/include/glib-2.0/glib/ghash.h
    stub_funcs.ptr_g_hash_table_new_full = try_find_sym(glib, "g_hash_table_new_full");
    stub_funcs.ptr_g_hash_table_new_similar = try_find_sym(glib, "g_hash_table_new_similar");
    stub_funcs.ptr_g_hash_table_destroy = try_find_sym(glib, "g_hash_table_destroy");
    stub_funcs.ptr_g_hash_table_insert = try_find_sym(glib, "g_hash_table_insert");
    stub_funcs.ptr_g_hash_table_replace = try_find_sym(glib, "g_hash_table_replace");
    stub_funcs.ptr_g_hash_table_add = try_find_sym(glib, "g_hash_table_add");
    stub_funcs.ptr_g_hash_table_remove = try_find_sym(glib, "g_hash_table_remove");
    stub_funcs.ptr_g_hash_table_remove_all = try_find_sym(glib, "g_hash_table_remove_all");
    stub_funcs.ptr_g_hash_table_steal = try_find_sym(glib, "g_hash_table_steal");
    stub_funcs.ptr_g_hash_table_steal_extended = try_find_sym(glib, "g_hash_table_steal_extended");
    stub_funcs.ptr_g_hash_table_steal_all = try_find_sym(glib, "g_hash_table_steal_all");
    stub_funcs.ptr_g_hash_table_steal_all_keys = try_find_sym(glib, "g_hash_table_steal_all_keys");
    stub_funcs.ptr_g_hash_table_steal_all_values = try_find_sym(glib, "g_hash_table_steal_all_values");
    stub_funcs.ptr_g_hash_table_lookup = try_find_sym(glib, "g_hash_table_lookup");
    stub_funcs.ptr_g_hash_table_contains = try_find_sym(glib, "g_hash_table_contains");
    stub_funcs.ptr_g_hash_table_lookup_extended = try_find_sym(glib, "g_hash_table_lookup_extended");
    stub_funcs.ptr_g_hash_table_foreach = try_find_sym(glib, "g_hash_table_foreach");
    stub_funcs.ptr_g_hash_table_find = try_find_sym(glib, "g_hash_table_find");
    stub_funcs.ptr_g_hash_table_foreach_remove = try_find_sym(glib, "g_hash_table_foreach_remove");
    stub_funcs.ptr_g_hash_table_foreach_steal = try_find_sym(glib, "g_hash_table_foreach_steal");
    stub_funcs.ptr_g_hash_table_size = try_find_sym(glib, "g_hash_table_size");
    stub_funcs.ptr_g_hash_table_get_keys = try_find_sym(glib, "g_hash_table_get_keys");
    stub_funcs.ptr_g_hash_table_get_values = try_find_sym(glib, "g_hash_table_get_values");
    stub_funcs.ptr_g_hash_table_get_keys_as_array = try_find_sym(glib, "g_hash_table_get_keys_as_array");
    stub_funcs.ptr_g_hash_table_get_keys_as_ptr_array = try_find_sym(glib, "g_hash_table_get_keys_as_ptr_array");
    stub_funcs.ptr_g_hash_table_get_values_as_ptr_array = try_find_sym(glib, "g_hash_table_get_values_as_ptr_array");
    stub_funcs.ptr_g_hash_table_iter_init = try_find_sym(glib, "g_hash_table_iter_init");
    stub_funcs.ptr_g_hash_table_iter_next = try_find_sym(glib, "g_hash_table_iter_next");
    stub_funcs.ptr_g_hash_table_iter_get_hash_table = try_find_sym(glib, "g_hash_table_iter_get_hash_table");
    stub_funcs.ptr_g_hash_table_iter_remove = try_find_sym(glib, "g_hash_table_iter_remove");
    stub_funcs.ptr_g_hash_table_iter_replace = try_find_sym(glib, "g_hash_table_iter_replace");
    stub_funcs.ptr_g_hash_table_iter_steal = try_find_sym(glib, "g_hash_table_iter_steal");
    stub_funcs.ptr_g_hash_table_ref = try_find_sym(glib, "g_hash_table_ref");
    stub_funcs.ptr_g_hash_table_unref = try_find_sym(glib, "g_hash_table_unref");
    stub_funcs.ptr_g_str_equal = try_find_sym(glib, "g_str_equal");
    stub_funcs.ptr_g_str_hash = try_find_sym(glib, "g_str_hash");
    stub_funcs.ptr_g_int_equal = try_find_sym(glib, "g_int_equal");
    stub_funcs.ptr_g_int_hash = try_find_sym(glib, "g_int_hash");
    stub_funcs.ptr_g_int64_equal = try_find_sym(glib, "g_int64_equal");
    stub_funcs.ptr_g_int64_hash = try_find_sym(glib, "g_int64_hash");
    stub_funcs.ptr_g_double_equal = try_find_sym(glib, "g_double_equal");
    stub_funcs.ptr_g_double_hash = try_find_sym(glib, "g_double_hash");
    stub_funcs.ptr_g_direct_hash = try_find_sym(glib, "g_direct_hash");
    stub_funcs.ptr_g_direct_equal = try_find_sym(glib, "g_direct_equal");
    stub_funcs.ptr_g_hash_table_new = try_find_sym(glib, "g_hash_table_new");
    // Header /usr/include/glib-2.0/glib/ghmac.h
    stub_funcs.ptr_g_hmac_copy = try_find_sym(glib, "g_hmac_copy");
    stub_funcs.ptr_g_hmac_ref = try_find_sym(glib, "g_hmac_ref");
    stub_funcs.ptr_g_hmac_unref = try_find_sym(glib, "g_hmac_unref");
    stub_funcs.ptr_g_hmac_update = try_find_sym(glib, "g_hmac_update");
    stub_funcs.ptr_g_hmac_get_string = try_find_sym(glib, "g_hmac_get_string");
    stub_funcs.ptr_g_hmac_get_digest = try_find_sym(glib, "g_hmac_get_digest");
    stub_funcs.ptr_g_compute_hmac_for_data = try_find_sym(glib, "g_compute_hmac_for_data");
    stub_funcs.ptr_g_compute_hmac_for_string = try_find_sym(glib, "g_compute_hmac_for_string");
    stub_funcs.ptr_g_compute_hmac_for_bytes = try_find_sym(glib, "g_compute_hmac_for_bytes");
    stub_funcs.ptr_g_hmac_new = try_find_sym(glib, "g_hmac_new");
    // Header /usr/include/glib-2.0/glib/ghook.h
    stub_funcs.ptr_g_hook_list_clear = try_find_sym(glib, "g_hook_list_clear");
    stub_funcs.ptr_g_hook_alloc = try_find_sym(glib, "g_hook_alloc");
    stub_funcs.ptr_g_hook_free = try_find_sym(glib, "g_hook_free");
    stub_funcs.ptr_g_hook_ref = try_find_sym(glib, "g_hook_ref");
    stub_funcs.ptr_g_hook_unref = try_find_sym(glib, "g_hook_unref");
    stub_funcs.ptr_g_hook_destroy = try_find_sym(glib, "g_hook_destroy");
    stub_funcs.ptr_g_hook_destroy_link = try_find_sym(glib, "g_hook_destroy_link");
    stub_funcs.ptr_g_hook_prepend = try_find_sym(glib, "g_hook_prepend");
    stub_funcs.ptr_g_hook_insert_before = try_find_sym(glib, "g_hook_insert_before");
    stub_funcs.ptr_g_hook_insert_sorted = try_find_sym(glib, "g_hook_insert_sorted");
    stub_funcs.ptr_g_hook_get = try_find_sym(glib, "g_hook_get");
    stub_funcs.ptr_g_hook_find = try_find_sym(glib, "g_hook_find");
    stub_funcs.ptr_g_hook_find_data = try_find_sym(glib, "g_hook_find_data");
    stub_funcs.ptr_g_hook_find_func = try_find_sym(glib, "g_hook_find_func");
    stub_funcs.ptr_g_hook_find_func_data = try_find_sym(glib, "g_hook_find_func_data");
    stub_funcs.ptr_g_hook_first_valid = try_find_sym(glib, "g_hook_first_valid");
    stub_funcs.ptr_g_hook_next_valid = try_find_sym(glib, "g_hook_next_valid");
    stub_funcs.ptr_g_hook_compare_ids = try_find_sym(glib, "g_hook_compare_ids");
    stub_funcs.ptr_g_hook_list_invoke = try_find_sym(glib, "g_hook_list_invoke");
    stub_funcs.ptr_g_hook_list_invoke_check = try_find_sym(glib, "g_hook_list_invoke_check");
    stub_funcs.ptr_g_hook_list_marshal = try_find_sym(glib, "g_hook_list_marshal");
    stub_funcs.ptr_g_hook_list_marshal_check = try_find_sym(glib, "g_hook_list_marshal_check");
    stub_funcs.ptr_g_hook_list_init = try_find_sym(glib, "g_hook_list_init");
    // Header /usr/include/glib-2.0/glib/ghostutils.h
    stub_funcs.ptr_g_hostname_is_ascii_encoded = try_find_sym(glib, "g_hostname_is_ascii_encoded");
    stub_funcs.ptr_g_hostname_is_ip_address = try_find_sym(glib, "g_hostname_is_ip_address");
    stub_funcs.ptr_g_hostname_to_ascii = try_find_sym(glib, "g_hostname_to_ascii");
    stub_funcs.ptr_g_hostname_to_unicode = try_find_sym(glib, "g_hostname_to_unicode");
    stub_funcs.ptr_g_hostname_is_non_ascii = try_find_sym(glib, "g_hostname_is_non_ascii");
    // Header /usr/include/glib-2.0/glib/giochannel.h
    stub_funcs.ptr_g_io_channel_ref = try_find_sym(glib, "g_io_channel_ref");
    stub_funcs.ptr_g_io_channel_unref = try_find_sym(glib, "g_io_channel_unref");
    stub_funcs.ptr_g_io_channel_read = try_find_sym(glib, "g_io_channel_read");
    stub_funcs.ptr_g_io_channel_write = try_find_sym(glib, "g_io_channel_write");
    stub_funcs.ptr_g_io_channel_seek = try_find_sym(glib, "g_io_channel_seek");
    stub_funcs.ptr_g_io_channel_close = try_find_sym(glib, "g_io_channel_close");
    stub_funcs.ptr_g_io_channel_shutdown = try_find_sym(glib, "g_io_channel_shutdown");
    stub_funcs.ptr_g_io_add_watch_full = try_find_sym(glib, "g_io_add_watch_full");
    stub_funcs.ptr_g_io_create_watch = try_find_sym(glib, "g_io_create_watch");
    stub_funcs.ptr_g_io_add_watch = try_find_sym(glib, "g_io_add_watch");
    stub_funcs.ptr_g_io_channel_set_buffer_size = try_find_sym(glib, "g_io_channel_set_buffer_size");
    stub_funcs.ptr_g_io_channel_get_buffer_size = try_find_sym(glib, "g_io_channel_get_buffer_size");
    stub_funcs.ptr_g_io_channel_get_buffer_condition = try_find_sym(glib, "g_io_channel_get_buffer_condition");
    stub_funcs.ptr_g_io_channel_set_flags = try_find_sym(glib, "g_io_channel_set_flags");
    stub_funcs.ptr_g_io_channel_get_flags = try_find_sym(glib, "g_io_channel_get_flags");
    stub_funcs.ptr_g_io_channel_set_line_term = try_find_sym(glib, "g_io_channel_set_line_term");
    stub_funcs.ptr_g_io_channel_get_line_term = try_find_sym(glib, "g_io_channel_get_line_term");
    stub_funcs.ptr_g_io_channel_set_buffered = try_find_sym(glib, "g_io_channel_set_buffered");
    stub_funcs.ptr_g_io_channel_get_buffered = try_find_sym(glib, "g_io_channel_get_buffered");
    stub_funcs.ptr_g_io_channel_set_encoding = try_find_sym(glib, "g_io_channel_set_encoding");
    stub_funcs.ptr_g_io_channel_get_encoding = try_find_sym(glib, "g_io_channel_get_encoding");
    stub_funcs.ptr_g_io_channel_set_close_on_unref = try_find_sym(glib, "g_io_channel_set_close_on_unref");
    stub_funcs.ptr_g_io_channel_get_close_on_unref = try_find_sym(glib, "g_io_channel_get_close_on_unref");
    stub_funcs.ptr_g_io_channel_flush = try_find_sym(glib, "g_io_channel_flush");
    stub_funcs.ptr_g_io_channel_read_line = try_find_sym(glib, "g_io_channel_read_line");
    stub_funcs.ptr_g_io_channel_read_line_string = try_find_sym(glib, "g_io_channel_read_line_string");
    stub_funcs.ptr_g_io_channel_read_to_end = try_find_sym(glib, "g_io_channel_read_to_end");
    stub_funcs.ptr_g_io_channel_read_chars = try_find_sym(glib, "g_io_channel_read_chars");
    stub_funcs.ptr_g_io_channel_read_unichar = try_find_sym(glib, "g_io_channel_read_unichar");
    stub_funcs.ptr_g_io_channel_write_chars = try_find_sym(glib, "g_io_channel_write_chars");
    stub_funcs.ptr_g_io_channel_write_unichar = try_find_sym(glib, "g_io_channel_write_unichar");
    stub_funcs.ptr_g_io_channel_seek_position = try_find_sym(glib, "g_io_channel_seek_position");
    stub_funcs.ptr_g_io_channel_new_file = try_find_sym(glib, "g_io_channel_new_file");
    stub_funcs.ptr_g_io_channel_error_quark = try_find_sym(glib, "g_io_channel_error_quark");
    stub_funcs.ptr_g_io_channel_error_from_errno = try_find_sym(glib, "g_io_channel_error_from_errno");
    stub_funcs.ptr_g_io_channel_unix_new = try_find_sym(glib, "g_io_channel_unix_new");
    stub_funcs.ptr_g_io_channel_unix_get_fd = try_find_sym(glib, "g_io_channel_unix_get_fd");
    stub_funcs.ptr_g_io_channel_win32_make_pollfd = try_find_sym(glib, "g_io_channel_win32_make_pollfd");
    stub_funcs.ptr_g_io_channel_win32_poll = try_find_sym(glib, "g_io_channel_win32_poll");
    stub_funcs.ptr_g_io_channel_win32_new_messages = try_find_sym(glib, "g_io_channel_win32_new_messages");
    stub_funcs.ptr_g_io_channel_win32_new_fd = try_find_sym(glib, "g_io_channel_win32_new_fd");
    stub_funcs.ptr_g_io_channel_win32_get_fd = try_find_sym(glib, "g_io_channel_win32_get_fd");
    stub_funcs.ptr_g_io_channel_win32_new_socket = try_find_sym(glib, "g_io_channel_win32_new_socket");
    stub_funcs.ptr_g_io_channel_win32_new_stream_socket = try_find_sym(glib, "g_io_channel_win32_new_stream_socket");
    stub_funcs.ptr_g_io_channel_win32_set_debug = try_find_sym(glib, "g_io_channel_win32_set_debug");
    stub_funcs.ptr_g_io_channel_init = try_find_sym(glib, "g_io_channel_init");
    // Header /usr/include/glib-2.0/glib/gkeyfile.h
    stub_funcs.ptr_g_key_file_new = try_find_sym(glib, "g_key_file_new");
    stub_funcs.ptr_g_key_file_ref = try_find_sym(glib, "g_key_file_ref");
    stub_funcs.ptr_g_key_file_unref = try_find_sym(glib, "g_key_file_unref");
    stub_funcs.ptr_g_key_file_free = try_find_sym(glib, "g_key_file_free");
    stub_funcs.ptr_g_key_file_set_list_separator = try_find_sym(glib, "g_key_file_set_list_separator");
    stub_funcs.ptr_g_key_file_load_from_file = try_find_sym(glib, "g_key_file_load_from_file");
    stub_funcs.ptr_g_key_file_load_from_data = try_find_sym(glib, "g_key_file_load_from_data");
    stub_funcs.ptr_g_key_file_load_from_bytes = try_find_sym(glib, "g_key_file_load_from_bytes");
    stub_funcs.ptr_g_key_file_load_from_dirs = try_find_sym(glib, "g_key_file_load_from_dirs");
    stub_funcs.ptr_g_key_file_load_from_data_dirs = try_find_sym(glib, "g_key_file_load_from_data_dirs");
    stub_funcs.ptr_g_key_file_to_data = try_find_sym(glib, "g_key_file_to_data");
    stub_funcs.ptr_g_key_file_save_to_file = try_find_sym(glib, "g_key_file_save_to_file");
    stub_funcs.ptr_g_key_file_get_start_group = try_find_sym(glib, "g_key_file_get_start_group");
    stub_funcs.ptr_g_key_file_get_groups = try_find_sym(glib, "g_key_file_get_groups");
    stub_funcs.ptr_g_key_file_get_keys = try_find_sym(glib, "g_key_file_get_keys");
    stub_funcs.ptr_g_key_file_has_group = try_find_sym(glib, "g_key_file_has_group");
    stub_funcs.ptr_g_key_file_has_key = try_find_sym(glib, "g_key_file_has_key");
    stub_funcs.ptr_g_key_file_get_value = try_find_sym(glib, "g_key_file_get_value");
    stub_funcs.ptr_g_key_file_set_value = try_find_sym(glib, "g_key_file_set_value");
    stub_funcs.ptr_g_key_file_get_string = try_find_sym(glib, "g_key_file_get_string");
    stub_funcs.ptr_g_key_file_set_string = try_find_sym(glib, "g_key_file_set_string");
    stub_funcs.ptr_g_key_file_get_locale_string = try_find_sym(glib, "g_key_file_get_locale_string");
    stub_funcs.ptr_g_key_file_get_locale_for_key = try_find_sym(glib, "g_key_file_get_locale_for_key");
    stub_funcs.ptr_g_key_file_set_locale_string = try_find_sym(glib, "g_key_file_set_locale_string");
    stub_funcs.ptr_g_key_file_get_boolean = try_find_sym(glib, "g_key_file_get_boolean");
    stub_funcs.ptr_g_key_file_set_boolean = try_find_sym(glib, "g_key_file_set_boolean");
    stub_funcs.ptr_g_key_file_get_integer = try_find_sym(glib, "g_key_file_get_integer");
    stub_funcs.ptr_g_key_file_set_integer = try_find_sym(glib, "g_key_file_set_integer");
    stub_funcs.ptr_g_key_file_get_int64 = try_find_sym(glib, "g_key_file_get_int64");
    stub_funcs.ptr_g_key_file_set_int64 = try_find_sym(glib, "g_key_file_set_int64");
    stub_funcs.ptr_g_key_file_get_uint64 = try_find_sym(glib, "g_key_file_get_uint64");
    stub_funcs.ptr_g_key_file_set_uint64 = try_find_sym(glib, "g_key_file_set_uint64");
    stub_funcs.ptr_g_key_file_get_double = try_find_sym(glib, "g_key_file_get_double");
    stub_funcs.ptr_g_key_file_set_double = try_find_sym(glib, "g_key_file_set_double");
    stub_funcs.ptr_g_key_file_get_string_list = try_find_sym(glib, "g_key_file_get_string_list");
    stub_funcs.ptr_g_key_file_set_string_list = try_find_sym(glib, "g_key_file_set_string_list");
    stub_funcs.ptr_g_key_file_get_locale_string_list = try_find_sym(glib, "g_key_file_get_locale_string_list");
    stub_funcs.ptr_g_key_file_set_locale_string_list = try_find_sym(glib, "g_key_file_set_locale_string_list");
    stub_funcs.ptr_g_key_file_get_boolean_list = try_find_sym(glib, "g_key_file_get_boolean_list");
    stub_funcs.ptr_g_key_file_set_boolean_list = try_find_sym(glib, "g_key_file_set_boolean_list");
    stub_funcs.ptr_g_key_file_get_integer_list = try_find_sym(glib, "g_key_file_get_integer_list");
    stub_funcs.ptr_g_key_file_set_double_list = try_find_sym(glib, "g_key_file_set_double_list");
    stub_funcs.ptr_g_key_file_get_double_list = try_find_sym(glib, "g_key_file_get_double_list");
    stub_funcs.ptr_g_key_file_set_integer_list = try_find_sym(glib, "g_key_file_set_integer_list");
    stub_funcs.ptr_g_key_file_set_comment = try_find_sym(glib, "g_key_file_set_comment");
    stub_funcs.ptr_g_key_file_get_comment = try_find_sym(glib, "g_key_file_get_comment");
    stub_funcs.ptr_g_key_file_remove_comment = try_find_sym(glib, "g_key_file_remove_comment");
    stub_funcs.ptr_g_key_file_remove_key = try_find_sym(glib, "g_key_file_remove_key");
    stub_funcs.ptr_g_key_file_remove_group = try_find_sym(glib, "g_key_file_remove_group");
    stub_funcs.ptr_g_key_file_error_quark = try_find_sym(glib, "g_key_file_error_quark");
    // Header /usr/include/glib-2.0/glib/glist.h
    stub_funcs.ptr_g_list_free = try_find_sym(glib, "g_list_free");
    stub_funcs.ptr_g_list_free_1 = try_find_sym(glib, "g_list_free_1");
    stub_funcs.ptr_g_list_free_full = try_find_sym(glib, "g_list_free_full");
    stub_funcs.ptr_g_list_append = try_find_sym(glib, "g_list_append");
    stub_funcs.ptr_g_list_prepend = try_find_sym(glib, "g_list_prepend");
    stub_funcs.ptr_g_list_insert = try_find_sym(glib, "g_list_insert");
    stub_funcs.ptr_g_list_insert_sorted = try_find_sym(glib, "g_list_insert_sorted");
    stub_funcs.ptr_g_list_insert_sorted_with_data = try_find_sym(glib, "g_list_insert_sorted_with_data");
    stub_funcs.ptr_g_list_insert_before = try_find_sym(glib, "g_list_insert_before");
    stub_funcs.ptr_g_list_insert_before_link = try_find_sym(glib, "g_list_insert_before_link");
    stub_funcs.ptr_g_list_concat = try_find_sym(glib, "g_list_concat");
    stub_funcs.ptr_g_list_remove = try_find_sym(glib, "g_list_remove");
    stub_funcs.ptr_g_list_remove_all = try_find_sym(glib, "g_list_remove_all");
    stub_funcs.ptr_g_list_remove_link = try_find_sym(glib, "g_list_remove_link");
    stub_funcs.ptr_g_list_delete_link = try_find_sym(glib, "g_list_delete_link");
    stub_funcs.ptr_g_list_reverse = try_find_sym(glib, "g_list_reverse");
    stub_funcs.ptr_g_list_copy = try_find_sym(glib, "g_list_copy");
    stub_funcs.ptr_g_list_copy_deep = try_find_sym(glib, "g_list_copy_deep");
    stub_funcs.ptr_g_list_nth = try_find_sym(glib, "g_list_nth");
    stub_funcs.ptr_g_list_nth_prev = try_find_sym(glib, "g_list_nth_prev");
    stub_funcs.ptr_g_list_find = try_find_sym(glib, "g_list_find");
    stub_funcs.ptr_g_list_find_custom = try_find_sym(glib, "g_list_find_custom");
    stub_funcs.ptr_g_list_position = try_find_sym(glib, "g_list_position");
    stub_funcs.ptr_g_list_index = try_find_sym(glib, "g_list_index");
    stub_funcs.ptr_g_list_last = try_find_sym(glib, "g_list_last");
    stub_funcs.ptr_g_list_first = try_find_sym(glib, "g_list_first");
    stub_funcs.ptr_g_list_length = try_find_sym(glib, "g_list_length");
    stub_funcs.ptr_g_list_foreach = try_find_sym(glib, "g_list_foreach");
    stub_funcs.ptr_g_list_sort = try_find_sym(glib, "g_list_sort");
    stub_funcs.ptr_g_list_sort_with_data = try_find_sym(glib, "g_list_sort_with_data");
    stub_funcs.ptr_g_list_nth_data = try_find_sym(glib, "g_list_nth_data");
    stub_funcs.ptr_g_clear_list = try_find_sym(glib, "g_clear_list");
    stub_funcs.ptr_g_list_alloc = try_find_sym(glib, "g_list_alloc");
    // Header /usr/include/glib-2.0/glib/gmacros.h
    // Header /usr/include/glib-2.0/glib/gmain.h
    stub_funcs.ptr_g_main_context_unref = try_find_sym(glib, "g_main_context_unref");
    stub_funcs.ptr_g_main_context_default = try_find_sym(glib, "g_main_context_default");
    stub_funcs.ptr_g_main_context_iteration = try_find_sym(glib, "g_main_context_iteration");
    stub_funcs.ptr_g_main_context_pending = try_find_sym(glib, "g_main_context_pending");
    stub_funcs.ptr_g_main_context_find_source_by_id = try_find_sym(glib, "g_main_context_find_source_by_id");
    stub_funcs.ptr_g_main_context_find_source_by_user_data = try_find_sym(glib, "g_main_context_find_source_by_user_data");
    stub_funcs.ptr_g_main_context_find_source_by_funcs_user_data = try_find_sym(glib, "g_main_context_find_source_by_funcs_user_data");
    stub_funcs.ptr_g_main_context_wakeup = try_find_sym(glib, "g_main_context_wakeup");
    stub_funcs.ptr_g_main_context_acquire = try_find_sym(glib, "g_main_context_acquire");
    stub_funcs.ptr_g_main_context_release = try_find_sym(glib, "g_main_context_release");
    stub_funcs.ptr_g_main_context_is_owner = try_find_sym(glib, "g_main_context_is_owner");
    stub_funcs.ptr_g_main_context_wait = try_find_sym(glib, "g_main_context_wait");
    stub_funcs.ptr_g_main_context_prepare = try_find_sym(glib, "g_main_context_prepare");
    stub_funcs.ptr_g_main_context_query = try_find_sym(glib, "g_main_context_query");
    stub_funcs.ptr_g_main_context_check = try_find_sym(glib, "g_main_context_check");
    stub_funcs.ptr_g_main_context_dispatch = try_find_sym(glib, "g_main_context_dispatch");
    stub_funcs.ptr_g_main_context_set_poll_func = try_find_sym(glib, "g_main_context_set_poll_func");
    stub_funcs.ptr_g_main_context_get_poll_func = try_find_sym(glib, "g_main_context_get_poll_func");
    stub_funcs.ptr_g_main_context_add_poll = try_find_sym(glib, "g_main_context_add_poll");
    stub_funcs.ptr_g_main_context_remove_poll = try_find_sym(glib, "g_main_context_remove_poll");
    stub_funcs.ptr_g_main_depth = try_find_sym(glib, "g_main_depth");
    stub_funcs.ptr_g_main_current_source = try_find_sym(glib, "g_main_current_source");
    stub_funcs.ptr_g_main_context_push_thread_default = try_find_sym(glib, "g_main_context_push_thread_default");
    stub_funcs.ptr_g_main_context_pop_thread_default = try_find_sym(glib, "g_main_context_pop_thread_default");
    stub_funcs.ptr_g_main_context_get_thread_default = try_find_sym(glib, "g_main_context_get_thread_default");
    stub_funcs.ptr_g_main_context_ref_thread_default = try_find_sym(glib, "g_main_context_ref_thread_default");
    stub_funcs.ptr_g_main_loop_run = try_find_sym(glib, "g_main_loop_run");
    stub_funcs.ptr_g_main_loop_quit = try_find_sym(glib, "g_main_loop_quit");
    stub_funcs.ptr_g_main_loop_ref = try_find_sym(glib, "g_main_loop_ref");
    stub_funcs.ptr_g_main_loop_unref = try_find_sym(glib, "g_main_loop_unref");
    stub_funcs.ptr_g_main_loop_is_running = try_find_sym(glib, "g_main_loop_is_running");
    stub_funcs.ptr_g_main_loop_get_context = try_find_sym(glib, "g_main_loop_get_context");
    stub_funcs.ptr_g_source_new = try_find_sym(glib, "g_source_new");
    stub_funcs.ptr_g_source_unref = try_find_sym(glib, "g_source_unref");
    stub_funcs.ptr_g_source_attach = try_find_sym(glib, "g_source_attach");
    stub_funcs.ptr_g_source_destroy = try_find_sym(glib, "g_source_destroy");
    stub_funcs.ptr_g_source_set_priority = try_find_sym(glib, "g_source_set_priority");
    stub_funcs.ptr_g_source_get_priority = try_find_sym(glib, "g_source_get_priority");
    stub_funcs.ptr_g_source_set_can_recurse = try_find_sym(glib, "g_source_set_can_recurse");
    stub_funcs.ptr_g_source_get_can_recurse = try_find_sym(glib, "g_source_get_can_recurse");
    stub_funcs.ptr_g_source_get_id = try_find_sym(glib, "g_source_get_id");
    stub_funcs.ptr_g_source_get_context = try_find_sym(glib, "g_source_get_context");
    stub_funcs.ptr_g_source_set_callback = try_find_sym(glib, "g_source_set_callback");
    stub_funcs.ptr_g_source_set_funcs = try_find_sym(glib, "g_source_set_funcs");
    stub_funcs.ptr_g_source_is_destroyed = try_find_sym(glib, "g_source_is_destroyed");
    stub_funcs.ptr_g_source_set_name = try_find_sym(glib, "g_source_set_name");
    stub_funcs.ptr_g_source_set_static_name = try_find_sym(glib, "g_source_set_static_name");
    stub_funcs.ptr_g_source_get_name = try_find_sym(glib, "g_source_get_name");
    stub_funcs.ptr_g_source_set_name_by_id = try_find_sym(glib, "g_source_set_name_by_id");
    stub_funcs.ptr_g_source_set_ready_time = try_find_sym(glib, "g_source_set_ready_time");
    stub_funcs.ptr_g_source_get_ready_time = try_find_sym(glib, "g_source_get_ready_time");
    stub_funcs.ptr_g_source_add_unix_fd = try_find_sym(glib, "g_source_add_unix_fd");
    stub_funcs.ptr_g_source_modify_unix_fd = try_find_sym(glib, "g_source_modify_unix_fd");
    stub_funcs.ptr_g_source_remove_unix_fd = try_find_sym(glib, "g_source_remove_unix_fd");
    stub_funcs.ptr_g_source_query_unix_fd = try_find_sym(glib, "g_source_query_unix_fd");
    stub_funcs.ptr_g_source_set_callback_indirect = try_find_sym(glib, "g_source_set_callback_indirect");
    stub_funcs.ptr_g_source_add_poll = try_find_sym(glib, "g_source_add_poll");
    stub_funcs.ptr_g_source_remove_poll = try_find_sym(glib, "g_source_remove_poll");
    stub_funcs.ptr_g_source_add_child_source = try_find_sym(glib, "g_source_add_child_source");
    stub_funcs.ptr_g_source_remove_child_source = try_find_sym(glib, "g_source_remove_child_source");
    stub_funcs.ptr_g_idle_source_new = try_find_sym(glib, "g_idle_source_new");
    stub_funcs.ptr_g_child_watch_source_new = try_find_sym(glib, "g_child_watch_source_new");
    stub_funcs.ptr_g_timeout_source_new = try_find_sym(glib, "g_timeout_source_new");
    stub_funcs.ptr_g_timeout_source_new_seconds = try_find_sym(glib, "g_timeout_source_new_seconds");
    stub_funcs.ptr_g_get_real_time = try_find_sym(glib, "g_get_real_time");
    stub_funcs.ptr_g_source_remove = try_find_sym(glib, "g_source_remove");
    stub_funcs.ptr_g_source_remove_by_user_data = try_find_sym(glib, "g_source_remove_by_user_data");
    stub_funcs.ptr_g_source_remove_by_funcs_user_data = try_find_sym(glib, "g_source_remove_by_funcs_user_data");
    stub_funcs.ptr_g_clear_handle_id = try_find_sym(glib, "g_clear_handle_id");
    stub_funcs.ptr_g_timeout_add_full = try_find_sym(glib, "g_timeout_add_full");
    stub_funcs.ptr_g_timeout_add = try_find_sym(glib, "g_timeout_add");
    stub_funcs.ptr_g_timeout_add_once = try_find_sym(glib, "g_timeout_add_once");
    stub_funcs.ptr_g_timeout_add_seconds_full = try_find_sym(glib, "g_timeout_add_seconds_full");
    stub_funcs.ptr_g_timeout_add_seconds = try_find_sym(glib, "g_timeout_add_seconds");
    stub_funcs.ptr_g_timeout_add_seconds_once = try_find_sym(glib, "g_timeout_add_seconds_once");
    stub_funcs.ptr_g_child_watch_add_full = try_find_sym(glib, "g_child_watch_add_full");
    stub_funcs.ptr_g_child_watch_add = try_find_sym(glib, "g_child_watch_add");
    stub_funcs.ptr_g_idle_add = try_find_sym(glib, "g_idle_add");
    stub_funcs.ptr_g_idle_add_full = try_find_sym(glib, "g_idle_add_full");
    stub_funcs.ptr_g_idle_add_once = try_find_sym(glib, "g_idle_add_once");
    stub_funcs.ptr_g_idle_remove_by_data = try_find_sym(glib, "g_idle_remove_by_data");
    stub_funcs.ptr_g_main_context_invoke_full = try_find_sym(glib, "g_main_context_invoke_full");
    stub_funcs.ptr_g_main_context_invoke = try_find_sym(glib, "g_main_context_invoke");
    stub_funcs.ptr_g_main_context_new = try_find_sym(glib, "g_main_context_new");
    // Header /usr/include/glib-2.0/glib/gmappedfile.h
    stub_funcs.ptr_g_mapped_file_new_from_fd = try_find_sym(glib, "g_mapped_file_new_from_fd");
    stub_funcs.ptr_g_mapped_file_get_length = try_find_sym(glib, "g_mapped_file_get_length");
    stub_funcs.ptr_g_mapped_file_get_contents = try_find_sym(glib, "g_mapped_file_get_contents");
    stub_funcs.ptr_g_mapped_file_get_bytes = try_find_sym(glib, "g_mapped_file_get_bytes");
    stub_funcs.ptr_g_mapped_file_ref = try_find_sym(glib, "g_mapped_file_ref");
    stub_funcs.ptr_g_mapped_file_unref = try_find_sym(glib, "g_mapped_file_unref");
    stub_funcs.ptr_g_mapped_file_free = try_find_sym(glib, "g_mapped_file_free");
    stub_funcs.ptr_g_mapped_file_new = try_find_sym(glib, "g_mapped_file_new");
    // Header /usr/include/glib-2.0/glib/gmarkup.h
    stub_funcs.ptr_g_markup_parse_context_new = try_find_sym(glib, "g_markup_parse_context_new");
    stub_funcs.ptr_g_markup_parse_context_ref = try_find_sym(glib, "g_markup_parse_context_ref");
    stub_funcs.ptr_g_markup_parse_context_unref = try_find_sym(glib, "g_markup_parse_context_unref");
    stub_funcs.ptr_g_markup_parse_context_free = try_find_sym(glib, "g_markup_parse_context_free");
    stub_funcs.ptr_g_markup_parse_context_parse = try_find_sym(glib, "g_markup_parse_context_parse");
    stub_funcs.ptr_g_markup_parse_context_push = try_find_sym(glib, "g_markup_parse_context_push");
    stub_funcs.ptr_g_markup_parse_context_pop = try_find_sym(glib, "g_markup_parse_context_pop");
    stub_funcs.ptr_g_markup_parse_context_end_parse = try_find_sym(glib, "g_markup_parse_context_end_parse");
    stub_funcs.ptr_g_markup_parse_context_get_element = try_find_sym(glib, "g_markup_parse_context_get_element");
    stub_funcs.ptr_g_markup_parse_context_get_element_stack = try_find_sym(glib, "g_markup_parse_context_get_element_stack");
    stub_funcs.ptr_g_markup_parse_context_get_position = try_find_sym(glib, "g_markup_parse_context_get_position");
    stub_funcs.ptr_g_markup_parse_context_get_user_data = try_find_sym(glib, "g_markup_parse_context_get_user_data");
    stub_funcs.ptr_g_markup_escape_text = try_find_sym(glib, "g_markup_escape_text");
    stub_funcs.ptr_g_markup_vprintf_escaped = try_find_sym(glib, "g_markup_vprintf_escaped");
    stub_funcs.ptr_g_markup_error_quark = try_find_sym(glib, "g_markup_error_quark");
    // Header /usr/include/glib-2.0/glib/gmem.h
    stub_funcs.ptr_g_free_sized = try_find_sym(glib, "g_free_sized");
    stub_funcs.ptr_g_clear_pointer = try_find_sym(glib, "g_clear_pointer");
    stub_funcs.ptr_g_malloc = try_find_sym(glib, "g_malloc");
    stub_funcs.ptr_g_malloc0 = try_find_sym(glib, "g_malloc0");
    stub_funcs.ptr_g_realloc = try_find_sym(glib, "g_realloc");
    stub_funcs.ptr_g_try_malloc = try_find_sym(glib, "g_try_malloc");
    stub_funcs.ptr_g_try_malloc0 = try_find_sym(glib, "g_try_malloc0");
    stub_funcs.ptr_g_try_realloc = try_find_sym(glib, "g_try_realloc");
    stub_funcs.ptr_g_malloc_n = try_find_sym(glib, "g_malloc_n");
    stub_funcs.ptr_g_malloc0_n = try_find_sym(glib, "g_malloc0_n");
    stub_funcs.ptr_g_realloc_n = try_find_sym(glib, "g_realloc_n");
    stub_funcs.ptr_g_try_malloc_n = try_find_sym(glib, "g_try_malloc_n");
    stub_funcs.ptr_g_try_malloc0_n = try_find_sym(glib, "g_try_malloc0_n");
    stub_funcs.ptr_g_try_realloc_n = try_find_sym(glib, "g_try_realloc_n");
    stub_funcs.ptr_g_aligned_alloc = try_find_sym(glib, "g_aligned_alloc");
    stub_funcs.ptr_g_aligned_alloc0 = try_find_sym(glib, "g_aligned_alloc0");
    stub_funcs.ptr_g_aligned_free = try_find_sym(glib, "g_aligned_free");
    stub_funcs.ptr_g_aligned_free_sized = try_find_sym(glib, "g_aligned_free_sized");
    stub_funcs.ptr_g_mem_set_vtable = try_find_sym(glib, "g_mem_set_vtable");
    stub_funcs.ptr_g_mem_is_system_malloc = try_find_sym(glib, "g_mem_is_system_malloc");
    stub_funcs.ptr_g_mem_profile = try_find_sym(glib, "g_mem_profile");
    stub_funcs.ptr_g_free = try_find_sym(glib, "g_free");
    // Header /usr/include/glib-2.0/glib/gmessages.h
    stub_funcs.ptr_g_log_set_handler = try_find_sym(glib, "g_log_set_handler");
    stub_funcs.ptr_g_log_set_handler_full = try_find_sym(glib, "g_log_set_handler_full");
    stub_funcs.ptr_g_log_default_handler = try_find_sym(glib, "g_log_default_handler");
    stub_funcs.ptr_g_log_set_default_handler = try_find_sym(glib, "g_log_set_default_handler");
    stub_funcs.ptr_g_logv = try_find_sym(glib, "g_logv");
    stub_funcs.ptr_g_log_set_fatal_mask = try_find_sym(glib, "g_log_set_fatal_mask");
    stub_funcs.ptr_g_log_set_always_fatal = try_find_sym(glib, "g_log_set_always_fatal");
    stub_funcs.ptr_g_log_structured_array = try_find_sym(glib, "g_log_structured_array");
    stub_funcs.ptr_g_log_variant = try_find_sym(glib, "g_log_variant");
    stub_funcs.ptr_g_log_set_writer_func = try_find_sym(glib, "g_log_set_writer_func");
    stub_funcs.ptr_g_log_writer_supports_color = try_find_sym(glib, "g_log_writer_supports_color");
    stub_funcs.ptr_g_log_writer_is_journald = try_find_sym(glib, "g_log_writer_is_journald");
    stub_funcs.ptr_g_log_writer_format_fields = try_find_sym(glib, "g_log_writer_format_fields");
    stub_funcs.ptr_g_log_writer_syslog = try_find_sym(glib, "g_log_writer_syslog");
    stub_funcs.ptr_g_log_writer_journald = try_find_sym(glib, "g_log_writer_journald");
    stub_funcs.ptr_g_log_writer_standard_streams = try_find_sym(glib, "g_log_writer_standard_streams");
    stub_funcs.ptr_g_log_writer_default = try_find_sym(glib, "g_log_writer_default");
    stub_funcs.ptr_g_log_writer_default_set_use_stderr = try_find_sym(glib, "g_log_writer_default_set_use_stderr");
    stub_funcs.ptr_g_log_writer_default_would_drop = try_find_sym(glib, "g_log_writer_default_would_drop");
    stub_funcs.ptr_g_log_writer_default_set_debug_domains = try_find_sym(glib, "g_log_writer_default_set_debug_domains");
    stub_funcs.ptr_g_log_get_debug_enabled = try_find_sym(glib, "g_log_get_debug_enabled");
    stub_funcs.ptr_g_log_set_debug_enabled = try_find_sym(glib, "g_log_set_debug_enabled");
    stub_funcs.ptr__g_log_fallback_handler = try_find_sym(glib, "_g_log_fallback_handler");
    stub_funcs.ptr_g_return_if_fail_warning = try_find_sym(glib, "g_return_if_fail_warning");
    stub_funcs.ptr_g_warn_message = try_find_sym(glib, "g_warn_message");
    stub_funcs.ptr_g_assert_warning = try_find_sym(glib, "g_assert_warning");
    stub_funcs.ptr_g_set_print_handler = try_find_sym(glib, "g_set_print_handler");
    stub_funcs.ptr_g_set_printerr_handler = try_find_sym(glib, "g_set_printerr_handler");
    stub_funcs.ptr_g_printf_string_upper_bound = try_find_sym(glib, "g_printf_string_upper_bound");
    // Header /usr/include/glib-2.0/glib/gnode.h
    stub_funcs.ptr_g_node_destroy = try_find_sym(glib, "g_node_destroy");
    stub_funcs.ptr_g_node_unlink = try_find_sym(glib, "g_node_unlink");
    stub_funcs.ptr_g_node_copy_deep = try_find_sym(glib, "g_node_copy_deep");
    stub_funcs.ptr_g_node_copy = try_find_sym(glib, "g_node_copy");
    stub_funcs.ptr_g_node_insert = try_find_sym(glib, "g_node_insert");
    stub_funcs.ptr_g_node_insert_before = try_find_sym(glib, "g_node_insert_before");
    stub_funcs.ptr_g_node_insert_after = try_find_sym(glib, "g_node_insert_after");
    stub_funcs.ptr_g_node_prepend = try_find_sym(glib, "g_node_prepend");
    stub_funcs.ptr_g_node_n_nodes = try_find_sym(glib, "g_node_n_nodes");
    stub_funcs.ptr_g_node_get_root = try_find_sym(glib, "g_node_get_root");
    stub_funcs.ptr_g_node_is_ancestor = try_find_sym(glib, "g_node_is_ancestor");
    stub_funcs.ptr_g_node_depth = try_find_sym(glib, "g_node_depth");
    stub_funcs.ptr_g_node_find = try_find_sym(glib, "g_node_find");
    stub_funcs.ptr_g_node_traverse = try_find_sym(glib, "g_node_traverse");
    stub_funcs.ptr_g_node_max_height = try_find_sym(glib, "g_node_max_height");
    stub_funcs.ptr_g_node_children_foreach = try_find_sym(glib, "g_node_children_foreach");
    stub_funcs.ptr_g_node_reverse_children = try_find_sym(glib, "g_node_reverse_children");
    stub_funcs.ptr_g_node_n_children = try_find_sym(glib, "g_node_n_children");
    stub_funcs.ptr_g_node_nth_child = try_find_sym(glib, "g_node_nth_child");
    stub_funcs.ptr_g_node_last_child = try_find_sym(glib, "g_node_last_child");
    stub_funcs.ptr_g_node_find_child = try_find_sym(glib, "g_node_find_child");
    stub_funcs.ptr_g_node_child_position = try_find_sym(glib, "g_node_child_position");
    stub_funcs.ptr_g_node_child_index = try_find_sym(glib, "g_node_child_index");
    stub_funcs.ptr_g_node_first_sibling = try_find_sym(glib, "g_node_first_sibling");
    stub_funcs.ptr_g_node_last_sibling = try_find_sym(glib, "g_node_last_sibling");
    stub_funcs.ptr_g_node_new = try_find_sym(glib, "g_node_new");
    // Header /usr/include/glib-2.0/glib/goption.h
    stub_funcs.ptr_g_option_context_new = try_find_sym(glib, "g_option_context_new");
    stub_funcs.ptr_g_option_context_set_summary = try_find_sym(glib, "g_option_context_set_summary");
    stub_funcs.ptr_g_option_context_get_summary = try_find_sym(glib, "g_option_context_get_summary");
    stub_funcs.ptr_g_option_context_set_description = try_find_sym(glib, "g_option_context_set_description");
    stub_funcs.ptr_g_option_context_get_description = try_find_sym(glib, "g_option_context_get_description");
    stub_funcs.ptr_g_option_context_free = try_find_sym(glib, "g_option_context_free");
    stub_funcs.ptr_g_option_context_set_help_enabled = try_find_sym(glib, "g_option_context_set_help_enabled");
    stub_funcs.ptr_g_option_context_get_help_enabled = try_find_sym(glib, "g_option_context_get_help_enabled");
    stub_funcs.ptr_g_option_context_set_ignore_unknown_options = try_find_sym(glib, "g_option_context_set_ignore_unknown_options");
    stub_funcs.ptr_g_option_context_get_ignore_unknown_options = try_find_sym(glib, "g_option_context_get_ignore_unknown_options");
    stub_funcs.ptr_g_option_context_set_strict_posix = try_find_sym(glib, "g_option_context_set_strict_posix");
    stub_funcs.ptr_g_option_context_get_strict_posix = try_find_sym(glib, "g_option_context_get_strict_posix");
    stub_funcs.ptr_g_option_context_add_main_entries = try_find_sym(glib, "g_option_context_add_main_entries");
    stub_funcs.ptr_g_option_context_parse = try_find_sym(glib, "g_option_context_parse");
    stub_funcs.ptr_g_option_context_parse_strv = try_find_sym(glib, "g_option_context_parse_strv");
    stub_funcs.ptr_g_option_context_set_translate_func = try_find_sym(glib, "g_option_context_set_translate_func");
    stub_funcs.ptr_g_option_context_set_translation_domain = try_find_sym(glib, "g_option_context_set_translation_domain");
    stub_funcs.ptr_g_option_context_add_group = try_find_sym(glib, "g_option_context_add_group");
    stub_funcs.ptr_g_option_context_set_main_group = try_find_sym(glib, "g_option_context_set_main_group");
    stub_funcs.ptr_g_option_context_get_main_group = try_find_sym(glib, "g_option_context_get_main_group");
    stub_funcs.ptr_g_option_context_get_help = try_find_sym(glib, "g_option_context_get_help");
    stub_funcs.ptr_g_option_group_new = try_find_sym(glib, "g_option_group_new");
    stub_funcs.ptr_g_option_group_set_parse_hooks = try_find_sym(glib, "g_option_group_set_parse_hooks");
    stub_funcs.ptr_g_option_group_set_error_hook = try_find_sym(glib, "g_option_group_set_error_hook");
    stub_funcs.ptr_g_option_group_free = try_find_sym(glib, "g_option_group_free");
    stub_funcs.ptr_g_option_group_ref = try_find_sym(glib, "g_option_group_ref");
    stub_funcs.ptr_g_option_group_unref = try_find_sym(glib, "g_option_group_unref");
    stub_funcs.ptr_g_option_group_add_entries = try_find_sym(glib, "g_option_group_add_entries");
    stub_funcs.ptr_g_option_group_set_translate_func = try_find_sym(glib, "g_option_group_set_translate_func");
    stub_funcs.ptr_g_option_group_set_translation_domain = try_find_sym(glib, "g_option_group_set_translation_domain");
    stub_funcs.ptr_g_option_error_quark = try_find_sym(glib, "g_option_error_quark");
    // Header /usr/include/glib-2.0/glib/gpathbuf.h
    stub_funcs.ptr_g_path_buf_new_from_path = try_find_sym(glib, "g_path_buf_new_from_path");
    stub_funcs.ptr_g_path_buf_init = try_find_sym(glib, "g_path_buf_init");
    stub_funcs.ptr_g_path_buf_init_from_path = try_find_sym(glib, "g_path_buf_init_from_path");
    stub_funcs.ptr_g_path_buf_clear = try_find_sym(glib, "g_path_buf_clear");
    stub_funcs.ptr_g_path_buf_clear_to_path = try_find_sym(glib, "g_path_buf_clear_to_path");
    stub_funcs.ptr_g_path_buf_free = try_find_sym(glib, "g_path_buf_free");
    stub_funcs.ptr_g_path_buf_free_to_path = try_find_sym(glib, "g_path_buf_free_to_path");
    stub_funcs.ptr_g_path_buf_copy = try_find_sym(glib, "g_path_buf_copy");
    stub_funcs.ptr_g_path_buf_push = try_find_sym(glib, "g_path_buf_push");
    stub_funcs.ptr_g_path_buf_pop = try_find_sym(glib, "g_path_buf_pop");
    stub_funcs.ptr_g_path_buf_set_filename = try_find_sym(glib, "g_path_buf_set_filename");
    stub_funcs.ptr_g_path_buf_set_extension = try_find_sym(glib, "g_path_buf_set_extension");
    stub_funcs.ptr_g_path_buf_to_path = try_find_sym(glib, "g_path_buf_to_path");
    stub_funcs.ptr_g_path_buf_equal = try_find_sym(glib, "g_path_buf_equal");
    stub_funcs.ptr_g_path_buf_new = try_find_sym(glib, "g_path_buf_new");
    // Header /usr/include/glib-2.0/glib/gpattern.h
    stub_funcs.ptr_g_pattern_spec_free = try_find_sym(glib, "g_pattern_spec_free");
    stub_funcs.ptr_g_pattern_spec_copy = try_find_sym(glib, "g_pattern_spec_copy");
    stub_funcs.ptr_g_pattern_spec_equal = try_find_sym(glib, "g_pattern_spec_equal");
    stub_funcs.ptr_g_pattern_spec_match = try_find_sym(glib, "g_pattern_spec_match");
    stub_funcs.ptr_g_pattern_spec_match_string = try_find_sym(glib, "g_pattern_spec_match_string");
    stub_funcs.ptr_g_pattern_match = try_find_sym(glib, "g_pattern_match");
    stub_funcs.ptr_g_pattern_match_string = try_find_sym(glib, "g_pattern_match_string");
    stub_funcs.ptr_g_pattern_match_simple = try_find_sym(glib, "g_pattern_match_simple");
    stub_funcs.ptr_g_pattern_spec_new = try_find_sym(glib, "g_pattern_spec_new");
    // Header /usr/include/glib-2.0/glib/gpoll.h
    stub_funcs.ptr_g_poll = try_find_sym(glib, "g_poll");
    // Header /usr/include/glib-2.0/glib/gprimes.h
    stub_funcs.ptr_g_spaced_primes_closest = try_find_sym(glib, "g_spaced_primes_closest");
    // Header /usr/include/glib-2.0/glib/gprintf.h
    stub_funcs.ptr_g_vprintf = try_find_sym(glib, "g_vprintf");
    stub_funcs.ptr_g_vfprintf = try_find_sym(glib, "g_vfprintf");
    stub_funcs.ptr_g_vsprintf = try_find_sym(glib, "g_vsprintf");
    stub_funcs.ptr_g_vasprintf = try_find_sym(glib, "g_vasprintf");
    // Header /usr/include/glib-2.0/glib/gqsort.h
    stub_funcs.ptr_g_qsort_with_data = try_find_sym(glib, "g_qsort_with_data");
    // Header /usr/include/glib-2.0/glib/gquark.h
    stub_funcs.ptr_g_quark_from_static_string = try_find_sym(glib, "g_quark_from_static_string");
    stub_funcs.ptr_g_quark_from_string = try_find_sym(glib, "g_quark_from_string");
    stub_funcs.ptr_g_quark_to_string = try_find_sym(glib, "g_quark_to_string");
    stub_funcs.ptr_g_intern_string = try_find_sym(glib, "g_intern_string");
    stub_funcs.ptr_g_intern_static_string = try_find_sym(glib, "g_intern_static_string");
    stub_funcs.ptr_g_quark_try_string = try_find_sym(glib, "g_quark_try_string");
    // Header /usr/include/glib-2.0/glib/gqueue.h
    stub_funcs.ptr_g_queue_free = try_find_sym(glib, "g_queue_free");
    stub_funcs.ptr_g_queue_free_full = try_find_sym(glib, "g_queue_free_full");
    stub_funcs.ptr_g_queue_init = try_find_sym(glib, "g_queue_init");
    stub_funcs.ptr_g_queue_clear = try_find_sym(glib, "g_queue_clear");
    stub_funcs.ptr_g_queue_is_empty = try_find_sym(glib, "g_queue_is_empty");
    stub_funcs.ptr_g_queue_clear_full = try_find_sym(glib, "g_queue_clear_full");
    stub_funcs.ptr_g_queue_get_length = try_find_sym(glib, "g_queue_get_length");
    stub_funcs.ptr_g_queue_reverse = try_find_sym(glib, "g_queue_reverse");
    stub_funcs.ptr_g_queue_copy = try_find_sym(glib, "g_queue_copy");
    stub_funcs.ptr_g_queue_foreach = try_find_sym(glib, "g_queue_foreach");
    stub_funcs.ptr_g_queue_find = try_find_sym(glib, "g_queue_find");
    stub_funcs.ptr_g_queue_find_custom = try_find_sym(glib, "g_queue_find_custom");
    stub_funcs.ptr_g_queue_sort = try_find_sym(glib, "g_queue_sort");
    stub_funcs.ptr_g_queue_push_head = try_find_sym(glib, "g_queue_push_head");
    stub_funcs.ptr_g_queue_push_tail = try_find_sym(glib, "g_queue_push_tail");
    stub_funcs.ptr_g_queue_push_nth = try_find_sym(glib, "g_queue_push_nth");
    stub_funcs.ptr_g_queue_pop_head = try_find_sym(glib, "g_queue_pop_head");
    stub_funcs.ptr_g_queue_pop_tail = try_find_sym(glib, "g_queue_pop_tail");
    stub_funcs.ptr_g_queue_pop_nth = try_find_sym(glib, "g_queue_pop_nth");
    stub_funcs.ptr_g_queue_peek_head = try_find_sym(glib, "g_queue_peek_head");
    stub_funcs.ptr_g_queue_peek_tail = try_find_sym(glib, "g_queue_peek_tail");
    stub_funcs.ptr_g_queue_peek_nth = try_find_sym(glib, "g_queue_peek_nth");
    stub_funcs.ptr_g_queue_index = try_find_sym(glib, "g_queue_index");
    stub_funcs.ptr_g_queue_remove = try_find_sym(glib, "g_queue_remove");
    stub_funcs.ptr_g_queue_remove_all = try_find_sym(glib, "g_queue_remove_all");
    stub_funcs.ptr_g_queue_insert_before = try_find_sym(glib, "g_queue_insert_before");
    stub_funcs.ptr_g_queue_insert_before_link = try_find_sym(glib, "g_queue_insert_before_link");
    stub_funcs.ptr_g_queue_insert_after = try_find_sym(glib, "g_queue_insert_after");
    stub_funcs.ptr_g_queue_insert_after_link = try_find_sym(glib, "g_queue_insert_after_link");
    stub_funcs.ptr_g_queue_insert_sorted = try_find_sym(glib, "g_queue_insert_sorted");
    stub_funcs.ptr_g_queue_push_head_link = try_find_sym(glib, "g_queue_push_head_link");
    stub_funcs.ptr_g_queue_push_tail_link = try_find_sym(glib, "g_queue_push_tail_link");
    stub_funcs.ptr_g_queue_push_nth_link = try_find_sym(glib, "g_queue_push_nth_link");
    stub_funcs.ptr_g_queue_pop_head_link = try_find_sym(glib, "g_queue_pop_head_link");
    stub_funcs.ptr_g_queue_pop_tail_link = try_find_sym(glib, "g_queue_pop_tail_link");
    stub_funcs.ptr_g_queue_pop_nth_link = try_find_sym(glib, "g_queue_pop_nth_link");
    stub_funcs.ptr_g_queue_peek_head_link = try_find_sym(glib, "g_queue_peek_head_link");
    stub_funcs.ptr_g_queue_peek_tail_link = try_find_sym(glib, "g_queue_peek_tail_link");
    stub_funcs.ptr_g_queue_peek_nth_link = try_find_sym(glib, "g_queue_peek_nth_link");
    stub_funcs.ptr_g_queue_link_index = try_find_sym(glib, "g_queue_link_index");
    stub_funcs.ptr_g_queue_unlink = try_find_sym(glib, "g_queue_unlink");
    stub_funcs.ptr_g_queue_delete_link = try_find_sym(glib, "g_queue_delete_link");
    stub_funcs.ptr_g_queue_new = try_find_sym(glib, "g_queue_new");
    // Header /usr/include/glib-2.0/glib/grand.h
    stub_funcs.ptr_g_rand_new_with_seed_array = try_find_sym(glib, "g_rand_new_with_seed_array");
    stub_funcs.ptr_g_rand_new = try_find_sym(glib, "g_rand_new");
    stub_funcs.ptr_g_rand_free = try_find_sym(glib, "g_rand_free");
    stub_funcs.ptr_g_rand_copy = try_find_sym(glib, "g_rand_copy");
    stub_funcs.ptr_g_rand_set_seed = try_find_sym(glib, "g_rand_set_seed");
    stub_funcs.ptr_g_rand_set_seed_array = try_find_sym(glib, "g_rand_set_seed_array");
    stub_funcs.ptr_g_rand_int = try_find_sym(glib, "g_rand_int");
    stub_funcs.ptr_g_rand_int_range = try_find_sym(glib, "g_rand_int_range");
    stub_funcs.ptr_g_rand_double = try_find_sym(glib, "g_rand_double");
    stub_funcs.ptr_g_rand_double_range = try_find_sym(glib, "g_rand_double_range");
    stub_funcs.ptr_g_random_set_seed = try_find_sym(glib, "g_random_set_seed");
    stub_funcs.ptr_g_random_int = try_find_sym(glib, "g_random_int");
    stub_funcs.ptr_g_random_int_range = try_find_sym(glib, "g_random_int_range");
    stub_funcs.ptr_g_random_double = try_find_sym(glib, "g_random_double");
    stub_funcs.ptr_g_random_double_range = try_find_sym(glib, "g_random_double_range");
    stub_funcs.ptr_g_rand_new_with_seed = try_find_sym(glib, "g_rand_new_with_seed");
    // Header /usr/include/glib-2.0/glib/grcbox.h
    stub_funcs.ptr_g_rc_box_alloc0 = try_find_sym(glib, "g_rc_box_alloc0");
    stub_funcs.ptr_g_rc_box_dup = try_find_sym(glib, "g_rc_box_dup");
    stub_funcs.ptr_g_rc_box_acquire = try_find_sym(glib, "g_rc_box_acquire");
    stub_funcs.ptr_g_rc_box_release = try_find_sym(glib, "g_rc_box_release");
    stub_funcs.ptr_g_rc_box_release_full = try_find_sym(glib, "g_rc_box_release_full");
    stub_funcs.ptr_g_rc_box_get_size = try_find_sym(glib, "g_rc_box_get_size");
    stub_funcs.ptr_g_atomic_rc_box_alloc = try_find_sym(glib, "g_atomic_rc_box_alloc");
    stub_funcs.ptr_g_atomic_rc_box_alloc0 = try_find_sym(glib, "g_atomic_rc_box_alloc0");
    stub_funcs.ptr_g_atomic_rc_box_dup = try_find_sym(glib, "g_atomic_rc_box_dup");
    stub_funcs.ptr_g_atomic_rc_box_acquire = try_find_sym(glib, "g_atomic_rc_box_acquire");
    stub_funcs.ptr_g_atomic_rc_box_release = try_find_sym(glib, "g_atomic_rc_box_release");
    stub_funcs.ptr_g_atomic_rc_box_release_full = try_find_sym(glib, "g_atomic_rc_box_release_full");
    stub_funcs.ptr_g_atomic_rc_box_get_size = try_find_sym(glib, "g_atomic_rc_box_get_size");
    stub_funcs.ptr_g_rc_box_alloc = try_find_sym(glib, "g_rc_box_alloc");
    // Header /usr/include/glib-2.0/glib/grefcount.h
    stub_funcs.ptr_g_ref_count_inc = try_find_sym(glib, "g_ref_count_inc");
    stub_funcs.ptr_g_ref_count_dec = try_find_sym(glib, "g_ref_count_dec");
    stub_funcs.ptr_g_ref_count_compare = try_find_sym(glib, "g_ref_count_compare");
    stub_funcs.ptr_g_atomic_ref_count_init = try_find_sym(glib, "g_atomic_ref_count_init");
    stub_funcs.ptr_g_atomic_ref_count_inc = try_find_sym(glib, "g_atomic_ref_count_inc");
    stub_funcs.ptr_g_atomic_ref_count_dec = try_find_sym(glib, "g_atomic_ref_count_dec");
    stub_funcs.ptr_g_atomic_ref_count_compare = try_find_sym(glib, "g_atomic_ref_count_compare");
    stub_funcs.ptr_g_ref_count_init = try_find_sym(glib, "g_ref_count_init");
    // Header /usr/include/glib-2.0/glib/grefstring.h
    stub_funcs.ptr_g_ref_string_new_len = try_find_sym(glib, "g_ref_string_new_len");
    stub_funcs.ptr_g_ref_string_new_intern = try_find_sym(glib, "g_ref_string_new_intern");
    stub_funcs.ptr_g_ref_string_acquire = try_find_sym(glib, "g_ref_string_acquire");
    stub_funcs.ptr_g_ref_string_release = try_find_sym(glib, "g_ref_string_release");
    stub_funcs.ptr_g_ref_string_length = try_find_sym(glib, "g_ref_string_length");
    stub_funcs.ptr_g_ref_string_new = try_find_sym(glib, "g_ref_string_new");
    // Header /usr/include/glib-2.0/glib/gregex.h
    stub_funcs.ptr_g_regex_new = try_find_sym(glib, "g_regex_new");
    stub_funcs.ptr_g_regex_ref = try_find_sym(glib, "g_regex_ref");
    stub_funcs.ptr_g_regex_unref = try_find_sym(glib, "g_regex_unref");
    stub_funcs.ptr_g_regex_get_pattern = try_find_sym(glib, "g_regex_get_pattern");
    stub_funcs.ptr_g_regex_get_max_backref = try_find_sym(glib, "g_regex_get_max_backref");
    stub_funcs.ptr_g_regex_get_capture_count = try_find_sym(glib, "g_regex_get_capture_count");
    stub_funcs.ptr_g_regex_get_has_cr_or_lf = try_find_sym(glib, "g_regex_get_has_cr_or_lf");
    stub_funcs.ptr_g_regex_get_max_lookbehind = try_find_sym(glib, "g_regex_get_max_lookbehind");
    stub_funcs.ptr_g_regex_get_string_number = try_find_sym(glib, "g_regex_get_string_number");
    stub_funcs.ptr_g_regex_escape_string = try_find_sym(glib, "g_regex_escape_string");
    stub_funcs.ptr_g_regex_escape_nul = try_find_sym(glib, "g_regex_escape_nul");
    stub_funcs.ptr_g_regex_get_compile_flags = try_find_sym(glib, "g_regex_get_compile_flags");
    stub_funcs.ptr_g_regex_get_match_flags = try_find_sym(glib, "g_regex_get_match_flags");
    stub_funcs.ptr_g_regex_match_simple = try_find_sym(glib, "g_regex_match_simple");
    stub_funcs.ptr_g_regex_match = try_find_sym(glib, "g_regex_match");
    stub_funcs.ptr_g_regex_match_full = try_find_sym(glib, "g_regex_match_full");
    stub_funcs.ptr_g_regex_match_all = try_find_sym(glib, "g_regex_match_all");
    stub_funcs.ptr_g_regex_match_all_full = try_find_sym(glib, "g_regex_match_all_full");
    stub_funcs.ptr_g_regex_split_simple = try_find_sym(glib, "g_regex_split_simple");
    stub_funcs.ptr_g_regex_split = try_find_sym(glib, "g_regex_split");
    stub_funcs.ptr_g_regex_split_full = try_find_sym(glib, "g_regex_split_full");
    stub_funcs.ptr_g_regex_replace = try_find_sym(glib, "g_regex_replace");
    stub_funcs.ptr_g_regex_replace_literal = try_find_sym(glib, "g_regex_replace_literal");
    stub_funcs.ptr_g_regex_replace_eval = try_find_sym(glib, "g_regex_replace_eval");
    stub_funcs.ptr_g_regex_check_replacement = try_find_sym(glib, "g_regex_check_replacement");
    stub_funcs.ptr_g_match_info_get_regex = try_find_sym(glib, "g_match_info_get_regex");
    stub_funcs.ptr_g_match_info_get_string = try_find_sym(glib, "g_match_info_get_string");
    stub_funcs.ptr_g_match_info_ref = try_find_sym(glib, "g_match_info_ref");
    stub_funcs.ptr_g_match_info_unref = try_find_sym(glib, "g_match_info_unref");
    stub_funcs.ptr_g_match_info_free = try_find_sym(glib, "g_match_info_free");
    stub_funcs.ptr_g_match_info_next = try_find_sym(glib, "g_match_info_next");
    stub_funcs.ptr_g_match_info_matches = try_find_sym(glib, "g_match_info_matches");
    stub_funcs.ptr_g_match_info_get_match_count = try_find_sym(glib, "g_match_info_get_match_count");
    stub_funcs.ptr_g_match_info_is_partial_match = try_find_sym(glib, "g_match_info_is_partial_match");
    stub_funcs.ptr_g_match_info_expand_references = try_find_sym(glib, "g_match_info_expand_references");
    stub_funcs.ptr_g_match_info_fetch = try_find_sym(glib, "g_match_info_fetch");
    stub_funcs.ptr_g_match_info_fetch_pos = try_find_sym(glib, "g_match_info_fetch_pos");
    stub_funcs.ptr_g_match_info_fetch_named = try_find_sym(glib, "g_match_info_fetch_named");
    stub_funcs.ptr_g_match_info_fetch_named_pos = try_find_sym(glib, "g_match_info_fetch_named_pos");
    stub_funcs.ptr_g_match_info_fetch_all = try_find_sym(glib, "g_match_info_fetch_all");
    stub_funcs.ptr_g_regex_error_quark = try_find_sym(glib, "g_regex_error_quark");
    // Header /usr/include/glib-2.0/glib/gscanner.h
    stub_funcs.ptr_g_scanner_destroy = try_find_sym(glib, "g_scanner_destroy");
    stub_funcs.ptr_g_scanner_input_file = try_find_sym(glib, "g_scanner_input_file");
    stub_funcs.ptr_g_scanner_sync_file_offset = try_find_sym(glib, "g_scanner_sync_file_offset");
    stub_funcs.ptr_g_scanner_input_text = try_find_sym(glib, "g_scanner_input_text");
    stub_funcs.ptr_g_scanner_get_next_token = try_find_sym(glib, "g_scanner_get_next_token");
    stub_funcs.ptr_g_scanner_peek_next_token = try_find_sym(glib, "g_scanner_peek_next_token");
    stub_funcs.ptr_g_scanner_cur_token = try_find_sym(glib, "g_scanner_cur_token");
    stub_funcs.ptr_g_scanner_cur_value = try_find_sym(glib, "g_scanner_cur_value");
    stub_funcs.ptr_g_scanner_cur_line = try_find_sym(glib, "g_scanner_cur_line");
    stub_funcs.ptr_g_scanner_cur_position = try_find_sym(glib, "g_scanner_cur_position");
    stub_funcs.ptr_g_scanner_eof = try_find_sym(glib, "g_scanner_eof");
    stub_funcs.ptr_g_scanner_set_scope = try_find_sym(glib, "g_scanner_set_scope");
    stub_funcs.ptr_g_scanner_scope_add_symbol = try_find_sym(glib, "g_scanner_scope_add_symbol");
    stub_funcs.ptr_g_scanner_scope_remove_symbol = try_find_sym(glib, "g_scanner_scope_remove_symbol");
    stub_funcs.ptr_g_scanner_scope_lookup_symbol = try_find_sym(glib, "g_scanner_scope_lookup_symbol");
    stub_funcs.ptr_g_scanner_scope_foreach_symbol = try_find_sym(glib, "g_scanner_scope_foreach_symbol");
    stub_funcs.ptr_g_scanner_lookup_symbol = try_find_sym(glib, "g_scanner_lookup_symbol");
    stub_funcs.ptr_g_scanner_unexp_token = try_find_sym(glib, "g_scanner_unexp_token");
    stub_funcs.ptr_g_scanner_new = try_find_sym(glib, "g_scanner_new");
    // Header /usr/include/glib-2.0/glib/gsequence.h
    stub_funcs.ptr_g_sequence_free = try_find_sym(glib, "g_sequence_free");
    stub_funcs.ptr_g_sequence_get_length = try_find_sym(glib, "g_sequence_get_length");
    stub_funcs.ptr_g_sequence_foreach = try_find_sym(glib, "g_sequence_foreach");
    stub_funcs.ptr_g_sequence_foreach_range = try_find_sym(glib, "g_sequence_foreach_range");
    stub_funcs.ptr_g_sequence_sort = try_find_sym(glib, "g_sequence_sort");
    stub_funcs.ptr_g_sequence_sort_iter = try_find_sym(glib, "g_sequence_sort_iter");
    stub_funcs.ptr_g_sequence_is_empty = try_find_sym(glib, "g_sequence_is_empty");
    stub_funcs.ptr_g_sequence_get_begin_iter = try_find_sym(glib, "g_sequence_get_begin_iter");
    stub_funcs.ptr_g_sequence_get_end_iter = try_find_sym(glib, "g_sequence_get_end_iter");
    stub_funcs.ptr_g_sequence_get_iter_at_pos = try_find_sym(glib, "g_sequence_get_iter_at_pos");
    stub_funcs.ptr_g_sequence_append = try_find_sym(glib, "g_sequence_append");
    stub_funcs.ptr_g_sequence_prepend = try_find_sym(glib, "g_sequence_prepend");
    stub_funcs.ptr_g_sequence_insert_before = try_find_sym(glib, "g_sequence_insert_before");
    stub_funcs.ptr_g_sequence_move = try_find_sym(glib, "g_sequence_move");
    stub_funcs.ptr_g_sequence_swap = try_find_sym(glib, "g_sequence_swap");
    stub_funcs.ptr_g_sequence_insert_sorted = try_find_sym(glib, "g_sequence_insert_sorted");
    stub_funcs.ptr_g_sequence_insert_sorted_iter = try_find_sym(glib, "g_sequence_insert_sorted_iter");
    stub_funcs.ptr_g_sequence_sort_changed = try_find_sym(glib, "g_sequence_sort_changed");
    stub_funcs.ptr_g_sequence_sort_changed_iter = try_find_sym(glib, "g_sequence_sort_changed_iter");
    stub_funcs.ptr_g_sequence_remove = try_find_sym(glib, "g_sequence_remove");
    stub_funcs.ptr_g_sequence_remove_range = try_find_sym(glib, "g_sequence_remove_range");
    stub_funcs.ptr_g_sequence_move_range = try_find_sym(glib, "g_sequence_move_range");
    stub_funcs.ptr_g_sequence_search = try_find_sym(glib, "g_sequence_search");
    stub_funcs.ptr_g_sequence_search_iter = try_find_sym(glib, "g_sequence_search_iter");
    stub_funcs.ptr_g_sequence_lookup = try_find_sym(glib, "g_sequence_lookup");
    stub_funcs.ptr_g_sequence_lookup_iter = try_find_sym(glib, "g_sequence_lookup_iter");
    stub_funcs.ptr_g_sequence_get = try_find_sym(glib, "g_sequence_get");
    stub_funcs.ptr_g_sequence_set = try_find_sym(glib, "g_sequence_set");
    stub_funcs.ptr_g_sequence_iter_is_begin = try_find_sym(glib, "g_sequence_iter_is_begin");
    stub_funcs.ptr_g_sequence_iter_is_end = try_find_sym(glib, "g_sequence_iter_is_end");
    stub_funcs.ptr_g_sequence_iter_next = try_find_sym(glib, "g_sequence_iter_next");
    stub_funcs.ptr_g_sequence_iter_prev = try_find_sym(glib, "g_sequence_iter_prev");
    stub_funcs.ptr_g_sequence_iter_get_position = try_find_sym(glib, "g_sequence_iter_get_position");
    stub_funcs.ptr_g_sequence_iter_move = try_find_sym(glib, "g_sequence_iter_move");
    stub_funcs.ptr_g_sequence_iter_get_sequence = try_find_sym(glib, "g_sequence_iter_get_sequence");
    stub_funcs.ptr_g_sequence_iter_compare = try_find_sym(glib, "g_sequence_iter_compare");
    stub_funcs.ptr_g_sequence_range_get_midpoint = try_find_sym(glib, "g_sequence_range_get_midpoint");
    stub_funcs.ptr_g_sequence_new = try_find_sym(glib, "g_sequence_new");
    // Header /usr/include/glib-2.0/glib/gshell.h
    stub_funcs.ptr_g_shell_quote = try_find_sym(glib, "g_shell_quote");
    stub_funcs.ptr_g_shell_unquote = try_find_sym(glib, "g_shell_unquote");
    stub_funcs.ptr_g_shell_parse_argv = try_find_sym(glib, "g_shell_parse_argv");
    stub_funcs.ptr_g_shell_error_quark = try_find_sym(glib, "g_shell_error_quark");
    // Header /usr/include/glib-2.0/glib/gslice.h
    stub_funcs.ptr_g_slice_alloc0 = try_find_sym(glib, "g_slice_alloc0");
    stub_funcs.ptr_g_slice_copy = try_find_sym(glib, "g_slice_copy");
    stub_funcs.ptr_g_slice_free1 = try_find_sym(glib, "g_slice_free1");
    stub_funcs.ptr_g_slice_free_chain_with_offset = try_find_sym(glib, "g_slice_free_chain_with_offset");
    stub_funcs.ptr_g_slice_set_config = try_find_sym(glib, "g_slice_set_config");
    stub_funcs.ptr_g_slice_get_config = try_find_sym(glib, "g_slice_get_config");
    stub_funcs.ptr_g_slice_debug_tree_statistics = try_find_sym(glib, "g_slice_debug_tree_statistics");
    stub_funcs.ptr_g_slice_alloc = try_find_sym(glib, "g_slice_alloc");
    // Header /usr/include/glib-2.0/glib/gslist.h
    stub_funcs.ptr_g_slist_free = try_find_sym(glib, "g_slist_free");
    stub_funcs.ptr_g_slist_free_1 = try_find_sym(glib, "g_slist_free_1");
    stub_funcs.ptr_g_slist_free_full = try_find_sym(glib, "g_slist_free_full");
    stub_funcs.ptr_g_slist_append = try_find_sym(glib, "g_slist_append");
    stub_funcs.ptr_g_slist_prepend = try_find_sym(glib, "g_slist_prepend");
    stub_funcs.ptr_g_slist_insert = try_find_sym(glib, "g_slist_insert");
    stub_funcs.ptr_g_slist_insert_sorted = try_find_sym(glib, "g_slist_insert_sorted");
    stub_funcs.ptr_g_slist_insert_sorted_with_data = try_find_sym(glib, "g_slist_insert_sorted_with_data");
    stub_funcs.ptr_g_slist_insert_before = try_find_sym(glib, "g_slist_insert_before");
    stub_funcs.ptr_g_slist_concat = try_find_sym(glib, "g_slist_concat");
    stub_funcs.ptr_g_slist_remove = try_find_sym(glib, "g_slist_remove");
    stub_funcs.ptr_g_slist_remove_all = try_find_sym(glib, "g_slist_remove_all");
    stub_funcs.ptr_g_slist_remove_link = try_find_sym(glib, "g_slist_remove_link");
    stub_funcs.ptr_g_slist_delete_link = try_find_sym(glib, "g_slist_delete_link");
    stub_funcs.ptr_g_slist_reverse = try_find_sym(glib, "g_slist_reverse");
    stub_funcs.ptr_g_slist_copy = try_find_sym(glib, "g_slist_copy");
    stub_funcs.ptr_g_slist_copy_deep = try_find_sym(glib, "g_slist_copy_deep");
    stub_funcs.ptr_g_slist_nth = try_find_sym(glib, "g_slist_nth");
    stub_funcs.ptr_g_slist_find = try_find_sym(glib, "g_slist_find");
    stub_funcs.ptr_g_slist_find_custom = try_find_sym(glib, "g_slist_find_custom");
    stub_funcs.ptr_g_slist_position = try_find_sym(glib, "g_slist_position");
    stub_funcs.ptr_g_slist_index = try_find_sym(glib, "g_slist_index");
    stub_funcs.ptr_g_slist_last = try_find_sym(glib, "g_slist_last");
    stub_funcs.ptr_g_slist_length = try_find_sym(glib, "g_slist_length");
    stub_funcs.ptr_g_slist_foreach = try_find_sym(glib, "g_slist_foreach");
    stub_funcs.ptr_g_slist_sort = try_find_sym(glib, "g_slist_sort");
    stub_funcs.ptr_g_slist_sort_with_data = try_find_sym(glib, "g_slist_sort_with_data");
    stub_funcs.ptr_g_slist_nth_data = try_find_sym(glib, "g_slist_nth_data");
    stub_funcs.ptr_g_clear_slist = try_find_sym(glib, "g_clear_slist");
    stub_funcs.ptr_g_slist_alloc = try_find_sym(glib, "g_slist_alloc");
    // Header /usr/include/glib-2.0/glib/gspawn.h
    stub_funcs.ptr_g_spawn_exit_error_quark = try_find_sym(glib, "g_spawn_exit_error_quark");
    stub_funcs.ptr_g_spawn_async = try_find_sym(glib, "g_spawn_async");
    stub_funcs.ptr_g_spawn_async_with_pipes = try_find_sym(glib, "g_spawn_async_with_pipes");
    stub_funcs.ptr_g_spawn_async_with_pipes_and_fds = try_find_sym(glib, "g_spawn_async_with_pipes_and_fds");
    stub_funcs.ptr_g_spawn_async_with_fds = try_find_sym(glib, "g_spawn_async_with_fds");
    stub_funcs.ptr_g_spawn_sync = try_find_sym(glib, "g_spawn_sync");
    stub_funcs.ptr_g_spawn_command_line_sync = try_find_sym(glib, "g_spawn_command_line_sync");
    stub_funcs.ptr_g_spawn_command_line_async = try_find_sym(glib, "g_spawn_command_line_async");
    stub_funcs.ptr_g_spawn_check_wait_status = try_find_sym(glib, "g_spawn_check_wait_status");
    stub_funcs.ptr_g_spawn_check_exit_status = try_find_sym(glib, "g_spawn_check_exit_status");
    stub_funcs.ptr_g_spawn_close_pid = try_find_sym(glib, "g_spawn_close_pid");
    stub_funcs.ptr_g_spawn_error_quark = try_find_sym(glib, "g_spawn_error_quark");
    // Header /usr/include/glib-2.0/glib/gstdio.h
    stub_funcs.ptr_g_chdir = try_find_sym(glib, "g_chdir");
    stub_funcs.ptr_g_unlink = try_find_sym(glib, "g_unlink");
    stub_funcs.ptr_g_rmdir = try_find_sym(glib, "g_rmdir");
    stub_funcs.ptr_g_access = try_find_sym(glib, "g_access");
    stub_funcs.ptr_g_close = try_find_sym(glib, "g_close");
    // Header /usr/include/glib-2.0/glib/gstrfuncs.h
    stub_funcs.ptr_g_ascii_tolower = try_find_sym(glib, "g_ascii_tolower");
    stub_funcs.ptr_g_ascii_toupper = try_find_sym(glib, "g_ascii_toupper");
    stub_funcs.ptr_g_ascii_digit_value = try_find_sym(glib, "g_ascii_digit_value");
    stub_funcs.ptr_g_ascii_xdigit_value = try_find_sym(glib, "g_ascii_xdigit_value");
    stub_funcs.ptr_g_strdelimit = try_find_sym(glib, "g_strdelimit");
    stub_funcs.ptr_g_strcanon = try_find_sym(glib, "g_strcanon");
    stub_funcs.ptr_g_strerror = try_find_sym(glib, "g_strerror");
    stub_funcs.ptr_g_strsignal = try_find_sym(glib, "g_strsignal");
    stub_funcs.ptr_g_strreverse = try_find_sym(glib, "g_strreverse");
    stub_funcs.ptr_g_strlcpy = try_find_sym(glib, "g_strlcpy");
    stub_funcs.ptr_g_strlcat = try_find_sym(glib, "g_strlcat");
    stub_funcs.ptr_g_strstr_len = try_find_sym(glib, "g_strstr_len");
    stub_funcs.ptr_g_strrstr = try_find_sym(glib, "g_strrstr");
    stub_funcs.ptr_g_strrstr_len = try_find_sym(glib, "g_strrstr_len");
    stub_funcs.ptr_g_str_has_suffix = try_find_sym(glib, "g_str_has_suffix");
    stub_funcs.ptr_g_str_has_prefix = try_find_sym(glib, "g_str_has_prefix");
    stub_funcs.ptr_g_strtod = try_find_sym(glib, "g_strtod");
    stub_funcs.ptr_g_ascii_strtod = try_find_sym(glib, "g_ascii_strtod");
    stub_funcs.ptr_g_ascii_strtoull = try_find_sym(glib, "g_ascii_strtoull");
    stub_funcs.ptr_g_ascii_strtoll = try_find_sym(glib, "g_ascii_strtoll");
    stub_funcs.ptr_g_ascii_dtostr = try_find_sym(glib, "g_ascii_dtostr");
    stub_funcs.ptr_g_ascii_formatd = try_find_sym(glib, "g_ascii_formatd");
    stub_funcs.ptr_g_strchug = try_find_sym(glib, "g_strchug");
    stub_funcs.ptr_g_strchomp = try_find_sym(glib, "g_strchomp");
    stub_funcs.ptr_g_ascii_strcasecmp = try_find_sym(glib, "g_ascii_strcasecmp");
    stub_funcs.ptr_g_ascii_strncasecmp = try_find_sym(glib, "g_ascii_strncasecmp");
    stub_funcs.ptr_g_ascii_strdown = try_find_sym(glib, "g_ascii_strdown");
    stub_funcs.ptr_g_ascii_strup = try_find_sym(glib, "g_ascii_strup");
    stub_funcs.ptr_g_str_is_ascii = try_find_sym(glib, "g_str_is_ascii");
    stub_funcs.ptr_g_strcasecmp = try_find_sym(glib, "g_strcasecmp");
    stub_funcs.ptr_g_strncasecmp = try_find_sym(glib, "g_strncasecmp");
    stub_funcs.ptr_g_strdown = try_find_sym(glib, "g_strdown");
    stub_funcs.ptr_g_strup = try_find_sym(glib, "g_strup");
    stub_funcs.ptr_g_strdup = try_find_sym(glib, "g_strdup");
    stub_funcs.ptr_g_strdup_vprintf = try_find_sym(glib, "g_strdup_vprintf");
    stub_funcs.ptr_g_strndup = try_find_sym(glib, "g_strndup");
    stub_funcs.ptr_g_strnfill = try_find_sym(glib, "g_strnfill");
    stub_funcs.ptr_g_strcompress = try_find_sym(glib, "g_strcompress");
    stub_funcs.ptr_g_strescape = try_find_sym(glib, "g_strescape");
    stub_funcs.ptr_g_memdup = try_find_sym(glib, "g_memdup");
    stub_funcs.ptr_g_memdup2 = try_find_sym(glib, "g_memdup2");
    stub_funcs.ptr_g_strsplit = try_find_sym(glib, "g_strsplit");
    stub_funcs.ptr_g_strsplit_set = try_find_sym(glib, "g_strsplit_set");
    stub_funcs.ptr_g_strjoinv = try_find_sym(glib, "g_strjoinv");
    stub_funcs.ptr_g_strfreev = try_find_sym(glib, "g_strfreev");
    stub_funcs.ptr_g_strdupv = try_find_sym(glib, "g_strdupv");
    stub_funcs.ptr_g_strv_length = try_find_sym(glib, "g_strv_length");
    stub_funcs.ptr_g_stpcpy = try_find_sym(glib, "g_stpcpy");
    stub_funcs.ptr_g_str_to_ascii = try_find_sym(glib, "g_str_to_ascii");
    stub_funcs.ptr_g_str_tokenize_and_fold = try_find_sym(glib, "g_str_tokenize_and_fold");
    stub_funcs.ptr_g_str_match_string = try_find_sym(glib, "g_str_match_string");
    stub_funcs.ptr_g_strv_contains = try_find_sym(glib, "g_strv_contains");
    stub_funcs.ptr_g_strv_equal = try_find_sym(glib, "g_strv_equal");
    stub_funcs.ptr_g_number_parser_error_quark = try_find_sym(glib, "g_number_parser_error_quark");
    stub_funcs.ptr_g_ascii_string_to_signed = try_find_sym(glib, "g_ascii_string_to_signed");
    stub_funcs.ptr_g_ascii_string_to_unsigned = try_find_sym(glib, "g_ascii_string_to_unsigned");
    // Header /usr/include/glib-2.0/glib/gstring.h
    stub_funcs.ptr_g_string_new_take = try_find_sym(glib, "g_string_new_take");
    stub_funcs.ptr_g_string_new_len = try_find_sym(glib, "g_string_new_len");
    stub_funcs.ptr_g_string_sized_new = try_find_sym(glib, "g_string_sized_new");
    stub_funcs.ptr_g_string_free = try_find_sym(glib, "g_string_free");
    stub_funcs.ptr_g_string_free_and_steal = try_find_sym(glib, "g_string_free_and_steal");
    stub_funcs.ptr_g_string_free_to_bytes = try_find_sym(glib, "g_string_free_to_bytes");
    stub_funcs.ptr_g_string_equal = try_find_sym(glib, "g_string_equal");
    stub_funcs.ptr_g_string_hash = try_find_sym(glib, "g_string_hash");
    stub_funcs.ptr_g_string_assign = try_find_sym(glib, "g_string_assign");
    stub_funcs.ptr_g_string_truncate = try_find_sym(glib, "g_string_truncate");
    stub_funcs.ptr_g_string_set_size = try_find_sym(glib, "g_string_set_size");
    stub_funcs.ptr_g_string_insert_len = try_find_sym(glib, "g_string_insert_len");
    stub_funcs.ptr_g_string_append = try_find_sym(glib, "g_string_append");
    stub_funcs.ptr_g_string_append_len = try_find_sym(glib, "g_string_append_len");
    stub_funcs.ptr_g_string_append_c = try_find_sym(glib, "g_string_append_c");
    stub_funcs.ptr_g_string_append_unichar = try_find_sym(glib, "g_string_append_unichar");
    stub_funcs.ptr_g_string_prepend = try_find_sym(glib, "g_string_prepend");
    stub_funcs.ptr_g_string_prepend_c = try_find_sym(glib, "g_string_prepend_c");
    stub_funcs.ptr_g_string_prepend_unichar = try_find_sym(glib, "g_string_prepend_unichar");
    stub_funcs.ptr_g_string_prepend_len = try_find_sym(glib, "g_string_prepend_len");
    stub_funcs.ptr_g_string_insert = try_find_sym(glib, "g_string_insert");
    stub_funcs.ptr_g_string_insert_c = try_find_sym(glib, "g_string_insert_c");
    stub_funcs.ptr_g_string_insert_unichar = try_find_sym(glib, "g_string_insert_unichar");
    stub_funcs.ptr_g_string_overwrite = try_find_sym(glib, "g_string_overwrite");
    stub_funcs.ptr_g_string_overwrite_len = try_find_sym(glib, "g_string_overwrite_len");
    stub_funcs.ptr_g_string_erase = try_find_sym(glib, "g_string_erase");
    stub_funcs.ptr_g_string_replace = try_find_sym(glib, "g_string_replace");
    stub_funcs.ptr_g_string_ascii_down = try_find_sym(glib, "g_string_ascii_down");
    stub_funcs.ptr_g_string_ascii_up = try_find_sym(glib, "g_string_ascii_up");
    stub_funcs.ptr_g_string_vprintf = try_find_sym(glib, "g_string_vprintf");
    stub_funcs.ptr_g_string_append_vprintf = try_find_sym(glib, "g_string_append_vprintf");
    stub_funcs.ptr_g_string_append_uri_escaped = try_find_sym(glib, "g_string_append_uri_escaped");
    stub_funcs.ptr_g_string_down = try_find_sym(glib, "g_string_down");
    stub_funcs.ptr_g_string_up = try_find_sym(glib, "g_string_up");
    stub_funcs.ptr_g_string_new = try_find_sym(glib, "g_string_new");
    // Header /usr/include/glib-2.0/glib/gstringchunk.h
    stub_funcs.ptr_g_string_chunk_free = try_find_sym(glib, "g_string_chunk_free");
    stub_funcs.ptr_g_string_chunk_clear = try_find_sym(glib, "g_string_chunk_clear");
    stub_funcs.ptr_g_string_chunk_insert = try_find_sym(glib, "g_string_chunk_insert");
    stub_funcs.ptr_g_string_chunk_insert_len = try_find_sym(glib, "g_string_chunk_insert_len");
    stub_funcs.ptr_g_string_chunk_insert_const = try_find_sym(glib, "g_string_chunk_insert_const");
    stub_funcs.ptr_g_string_chunk_new = try_find_sym(glib, "g_string_chunk_new");
    // Header /usr/include/glib-2.0/glib/gstrvbuilder.h
    stub_funcs.ptr_g_strv_builder_unref = try_find_sym(glib, "g_strv_builder_unref");
    stub_funcs.ptr_g_strv_builder_ref = try_find_sym(glib, "g_strv_builder_ref");
    stub_funcs.ptr_g_strv_builder_add = try_find_sym(glib, "g_strv_builder_add");
    stub_funcs.ptr_g_strv_builder_addv = try_find_sym(glib, "g_strv_builder_addv");
    stub_funcs.ptr_g_strv_builder_take = try_find_sym(glib, "g_strv_builder_take");
    stub_funcs.ptr_g_strv_builder_end = try_find_sym(glib, "g_strv_builder_end");
    stub_funcs.ptr_g_strv_builder_new = try_find_sym(glib, "g_strv_builder_new");
    // Header /usr/include/glib-2.0/glib/gtestutils.h
    stub_funcs.ptr_g_test_subprocess = try_find_sym(glib, "g_test_subprocess");
    stub_funcs.ptr_g_test_run = try_find_sym(glib, "g_test_run");
    stub_funcs.ptr_g_test_add_func = try_find_sym(glib, "g_test_add_func");
    stub_funcs.ptr_g_test_add_data_func = try_find_sym(glib, "g_test_add_data_func");
    stub_funcs.ptr_g_test_add_data_func_full = try_find_sym(glib, "g_test_add_data_func_full");
    stub_funcs.ptr_g_test_get_path = try_find_sym(glib, "g_test_get_path");
    stub_funcs.ptr_g_test_fail = try_find_sym(glib, "g_test_fail");
    stub_funcs.ptr_g_test_incomplete = try_find_sym(glib, "g_test_incomplete");
    stub_funcs.ptr_g_test_skip = try_find_sym(glib, "g_test_skip");
    stub_funcs.ptr_g_test_failed = try_find_sym(glib, "g_test_failed");
    stub_funcs.ptr_g_test_set_nonfatal_assertions = try_find_sym(glib, "g_test_set_nonfatal_assertions");
    stub_funcs.ptr_g_test_disable_crash_reporting = try_find_sym(glib, "g_test_disable_crash_reporting");
    stub_funcs.ptr_g_test_bug_base = try_find_sym(glib, "g_test_bug_base");
    stub_funcs.ptr_g_test_bug = try_find_sym(glib, "g_test_bug");
    stub_funcs.ptr_g_test_summary = try_find_sym(glib, "g_test_summary");
    stub_funcs.ptr_g_test_timer_start = try_find_sym(glib, "g_test_timer_start");
    stub_funcs.ptr_g_test_timer_elapsed = try_find_sym(glib, "g_test_timer_elapsed");
    stub_funcs.ptr_g_test_timer_last = try_find_sym(glib, "g_test_timer_last");
    stub_funcs.ptr_g_test_queue_free = try_find_sym(glib, "g_test_queue_free");
    stub_funcs.ptr_g_test_queue_destroy = try_find_sym(glib, "g_test_queue_destroy");
    stub_funcs.ptr_g_test_trap_subprocess_with_envp = try_find_sym(glib, "g_test_trap_subprocess_with_envp");
    stub_funcs.ptr_g_test_trap_has_passed = try_find_sym(glib, "g_test_trap_has_passed");
    stub_funcs.ptr_g_test_trap_reached_timeout = try_find_sym(glib, "g_test_trap_reached_timeout");
    stub_funcs.ptr_g_test_rand_int = try_find_sym(glib, "g_test_rand_int");
    stub_funcs.ptr_g_test_rand_int_range = try_find_sym(glib, "g_test_rand_int_range");
    stub_funcs.ptr_g_test_rand_double = try_find_sym(glib, "g_test_rand_double");
    stub_funcs.ptr_g_test_rand_double_range = try_find_sym(glib, "g_test_rand_double_range");
    stub_funcs.ptr_g_test_create_case = try_find_sym(glib, "g_test_create_case");
    stub_funcs.ptr_g_test_create_suite = try_find_sym(glib, "g_test_create_suite");
    stub_funcs.ptr_g_test_get_root = try_find_sym(glib, "g_test_get_root");
    stub_funcs.ptr_g_test_suite_add = try_find_sym(glib, "g_test_suite_add");
    stub_funcs.ptr_g_test_suite_add_suite = try_find_sym(glib, "g_test_suite_add_suite");
    stub_funcs.ptr_g_test_run_suite = try_find_sym(glib, "g_test_run_suite");
    stub_funcs.ptr_g_test_case_free = try_find_sym(glib, "g_test_case_free");
    stub_funcs.ptr_g_test_suite_free = try_find_sym(glib, "g_test_suite_free");
    stub_funcs.ptr_g_test_trap_assertions = try_find_sym(glib, "g_test_trap_assertions");
    stub_funcs.ptr_g_assertion_message = try_find_sym(glib, "g_assertion_message");
    stub_funcs.ptr_g_assertion_message_expr = try_find_sym(glib, "g_assertion_message_expr");
    stub_funcs.ptr_g_assertion_message_cmpstr = try_find_sym(glib, "g_assertion_message_cmpstr");
    stub_funcs.ptr_g_assertion_message_cmpstrv = try_find_sym(glib, "g_assertion_message_cmpstrv");
    stub_funcs.ptr_g_assertion_message_cmpint = try_find_sym(glib, "g_assertion_message_cmpint");
    stub_funcs.ptr_g_assertion_message_cmpnum = try_find_sym(glib, "g_assertion_message_cmpnum");
    stub_funcs.ptr_g_assertion_message_error = try_find_sym(glib, "g_assertion_message_error");
    stub_funcs.ptr_g_test_add_vtable = try_find_sym(glib, "g_test_add_vtable");
    stub_funcs.ptr_g_test_log_type_name = try_find_sym(glib, "g_test_log_type_name");
    stub_funcs.ptr_g_test_log_buffer_new = try_find_sym(glib, "g_test_log_buffer_new");
    stub_funcs.ptr_g_test_log_buffer_free = try_find_sym(glib, "g_test_log_buffer_free");
    stub_funcs.ptr_g_test_log_buffer_push = try_find_sym(glib, "g_test_log_buffer_push");
    stub_funcs.ptr_g_test_log_buffer_pop = try_find_sym(glib, "g_test_log_buffer_pop");
    stub_funcs.ptr_g_test_log_msg_free = try_find_sym(glib, "g_test_log_msg_free");
    stub_funcs.ptr_g_test_log_set_fatal_handler = try_find_sym(glib, "g_test_log_set_fatal_handler");
    stub_funcs.ptr_g_test_expect_message = try_find_sym(glib, "g_test_expect_message");
    stub_funcs.ptr_g_test_assert_expected_messages_internal = try_find_sym(glib, "g_test_assert_expected_messages_internal");
    stub_funcs.ptr_g_test_get_dir = try_find_sym(glib, "g_test_get_dir");
    stub_funcs.ptr_g_strcmp0 = try_find_sym(glib, "g_strcmp0");
    // Header /usr/include/glib-2.0/glib/gthread.h
    stub_funcs.ptr_g_thread_ref = try_find_sym(glib, "g_thread_ref");
    stub_funcs.ptr_g_thread_unref = try_find_sym(glib, "g_thread_unref");
    stub_funcs.ptr_g_thread_new = try_find_sym(glib, "g_thread_new");
    stub_funcs.ptr_g_thread_try_new = try_find_sym(glib, "g_thread_try_new");
    stub_funcs.ptr_g_thread_self = try_find_sym(glib, "g_thread_self");
    stub_funcs.ptr_g_thread_exit = try_find_sym(glib, "g_thread_exit");
    stub_funcs.ptr_g_thread_join = try_find_sym(glib, "g_thread_join");
    stub_funcs.ptr_g_thread_yield = try_find_sym(glib, "g_thread_yield");
    stub_funcs.ptr_g_mutex_init = try_find_sym(glib, "g_mutex_init");
    stub_funcs.ptr_g_mutex_clear = try_find_sym(glib, "g_mutex_clear");
    stub_funcs.ptr_g_mutex_lock = try_find_sym(glib, "g_mutex_lock");
    stub_funcs.ptr_g_mutex_trylock = try_find_sym(glib, "g_mutex_trylock");
    stub_funcs.ptr_g_mutex_unlock = try_find_sym(glib, "g_mutex_unlock");
    stub_funcs.ptr_g_rw_lock_init = try_find_sym(glib, "g_rw_lock_init");
    stub_funcs.ptr_g_rw_lock_clear = try_find_sym(glib, "g_rw_lock_clear");
    stub_funcs.ptr_g_rw_lock_writer_lock = try_find_sym(glib, "g_rw_lock_writer_lock");
    stub_funcs.ptr_g_rw_lock_writer_trylock = try_find_sym(glib, "g_rw_lock_writer_trylock");
    stub_funcs.ptr_g_rw_lock_writer_unlock = try_find_sym(glib, "g_rw_lock_writer_unlock");
    stub_funcs.ptr_g_rw_lock_reader_lock = try_find_sym(glib, "g_rw_lock_reader_lock");
    stub_funcs.ptr_g_rw_lock_reader_trylock = try_find_sym(glib, "g_rw_lock_reader_trylock");
    stub_funcs.ptr_g_rw_lock_reader_unlock = try_find_sym(glib, "g_rw_lock_reader_unlock");
    stub_funcs.ptr_g_rec_mutex_init = try_find_sym(glib, "g_rec_mutex_init");
    stub_funcs.ptr_g_rec_mutex_clear = try_find_sym(glib, "g_rec_mutex_clear");
    stub_funcs.ptr_g_rec_mutex_lock = try_find_sym(glib, "g_rec_mutex_lock");
    stub_funcs.ptr_g_rec_mutex_trylock = try_find_sym(glib, "g_rec_mutex_trylock");
    stub_funcs.ptr_g_rec_mutex_unlock = try_find_sym(glib, "g_rec_mutex_unlock");
    stub_funcs.ptr_g_cond_init = try_find_sym(glib, "g_cond_init");
    stub_funcs.ptr_g_cond_clear = try_find_sym(glib, "g_cond_clear");
    stub_funcs.ptr_g_cond_wait = try_find_sym(glib, "g_cond_wait");
    stub_funcs.ptr_g_cond_signal = try_find_sym(glib, "g_cond_signal");
    stub_funcs.ptr_g_cond_broadcast = try_find_sym(glib, "g_cond_broadcast");
    stub_funcs.ptr_g_cond_wait_until = try_find_sym(glib, "g_cond_wait_until");
    stub_funcs.ptr_g_private_get = try_find_sym(glib, "g_private_get");
    stub_funcs.ptr_g_private_set = try_find_sym(glib, "g_private_set");
    stub_funcs.ptr_g_private_replace = try_find_sym(glib, "g_private_replace");
    stub_funcs.ptr_g_once_impl = try_find_sym(glib, "g_once_impl");
    stub_funcs.ptr_g_once_init_enter = try_find_sym(glib, "g_once_init_enter");
    stub_funcs.ptr_g_once_init_leave = try_find_sym(glib, "g_once_init_leave");
    stub_funcs.ptr_g_once_init_enter_pointer = try_find_sym(glib, "g_once_init_enter_pointer");
    stub_funcs.ptr_g_once_init_leave_pointer = try_find_sym(glib, "g_once_init_leave_pointer");
    stub_funcs.ptr_g_get_num_processors = try_find_sym(glib, "g_get_num_processors");
    stub_funcs.ptr_g_thread_error_quark = try_find_sym(glib, "g_thread_error_quark");
    // Header /usr/include/glib-2.0/glib/gthreadpool.h
    stub_funcs.ptr_g_thread_pool_new_full = try_find_sym(glib, "g_thread_pool_new_full");
    stub_funcs.ptr_g_thread_pool_free = try_find_sym(glib, "g_thread_pool_free");
    stub_funcs.ptr_g_thread_pool_push = try_find_sym(glib, "g_thread_pool_push");
    stub_funcs.ptr_g_thread_pool_unprocessed = try_find_sym(glib, "g_thread_pool_unprocessed");
    stub_funcs.ptr_g_thread_pool_set_sort_function = try_find_sym(glib, "g_thread_pool_set_sort_function");
    stub_funcs.ptr_g_thread_pool_move_to_front = try_find_sym(glib, "g_thread_pool_move_to_front");
    stub_funcs.ptr_g_thread_pool_set_max_threads = try_find_sym(glib, "g_thread_pool_set_max_threads");
    stub_funcs.ptr_g_thread_pool_get_max_threads = try_find_sym(glib, "g_thread_pool_get_max_threads");
    stub_funcs.ptr_g_thread_pool_get_num_threads = try_find_sym(glib, "g_thread_pool_get_num_threads");
    stub_funcs.ptr_g_thread_pool_set_max_unused_threads = try_find_sym(glib, "g_thread_pool_set_max_unused_threads");
    stub_funcs.ptr_g_thread_pool_get_max_unused_threads = try_find_sym(glib, "g_thread_pool_get_max_unused_threads");
    stub_funcs.ptr_g_thread_pool_get_num_unused_threads = try_find_sym(glib, "g_thread_pool_get_num_unused_threads");
    stub_funcs.ptr_g_thread_pool_stop_unused_threads = try_find_sym(glib, "g_thread_pool_stop_unused_threads");
    stub_funcs.ptr_g_thread_pool_set_max_idle_time = try_find_sym(glib, "g_thread_pool_set_max_idle_time");
    stub_funcs.ptr_g_thread_pool_get_max_idle_time = try_find_sym(glib, "g_thread_pool_get_max_idle_time");
    stub_funcs.ptr_g_thread_pool_new = try_find_sym(glib, "g_thread_pool_new");
    // Header /usr/include/glib-2.0/glib/gtimer.h
    stub_funcs.ptr_g_timer_destroy = try_find_sym(glib, "g_timer_destroy");
    stub_funcs.ptr_g_timer_start = try_find_sym(glib, "g_timer_start");
    stub_funcs.ptr_g_timer_stop = try_find_sym(glib, "g_timer_stop");
    stub_funcs.ptr_g_timer_reset = try_find_sym(glib, "g_timer_reset");
    stub_funcs.ptr_g_timer_continue = try_find_sym(glib, "g_timer_continue");
    stub_funcs.ptr_g_timer_elapsed = try_find_sym(glib, "g_timer_elapsed");
    stub_funcs.ptr_g_timer_is_active = try_find_sym(glib, "g_timer_is_active");
    stub_funcs.ptr_g_usleep = try_find_sym(glib, "g_usleep");
    stub_funcs.ptr_g_time_val_from_iso8601 = try_find_sym(glib, "g_time_val_from_iso8601");
    stub_funcs.ptr_g_time_val_to_iso8601 = try_find_sym(glib, "g_time_val_to_iso8601");
    stub_funcs.ptr_g_timer_new = try_find_sym(glib, "g_timer_new");
    // Header /usr/include/glib-2.0/glib/gtimezone.h
    stub_funcs.ptr_g_time_zone_new_identifier = try_find_sym(glib, "g_time_zone_new_identifier");
    stub_funcs.ptr_g_time_zone_new_utc = try_find_sym(glib, "g_time_zone_new_utc");
    stub_funcs.ptr_g_time_zone_new_local = try_find_sym(glib, "g_time_zone_new_local");
    stub_funcs.ptr_g_time_zone_new_offset = try_find_sym(glib, "g_time_zone_new_offset");
    stub_funcs.ptr_g_time_zone_ref = try_find_sym(glib, "g_time_zone_ref");
    stub_funcs.ptr_g_time_zone_unref = try_find_sym(glib, "g_time_zone_unref");
    stub_funcs.ptr_g_time_zone_find_interval = try_find_sym(glib, "g_time_zone_find_interval");
    stub_funcs.ptr_g_time_zone_adjust_time = try_find_sym(glib, "g_time_zone_adjust_time");
    stub_funcs.ptr_g_time_zone_get_abbreviation = try_find_sym(glib, "g_time_zone_get_abbreviation");
    stub_funcs.ptr_g_time_zone_get_offset = try_find_sym(glib, "g_time_zone_get_offset");
    stub_funcs.ptr_g_time_zone_is_dst = try_find_sym(glib, "g_time_zone_is_dst");
    stub_funcs.ptr_g_time_zone_get_identifier = try_find_sym(glib, "g_time_zone_get_identifier");
    stub_funcs.ptr_g_time_zone_new = try_find_sym(glib, "g_time_zone_new");
    // Header /usr/include/glib-2.0/glib/gtrashstack.h
    stub_funcs.ptr_g_trash_stack_pop = try_find_sym(glib, "g_trash_stack_pop");
    stub_funcs.ptr_g_trash_stack_peek = try_find_sym(glib, "g_trash_stack_peek");
    stub_funcs.ptr_g_trash_stack_height = try_find_sym(glib, "g_trash_stack_height");
    // Header /usr/include/glib-2.0/glib/gtree.h
    stub_funcs.ptr_g_tree_new_with_data = try_find_sym(glib, "g_tree_new_with_data");
    stub_funcs.ptr_g_tree_new_full = try_find_sym(glib, "g_tree_new_full");
    stub_funcs.ptr_g_tree_node_first = try_find_sym(glib, "g_tree_node_first");
    stub_funcs.ptr_g_tree_node_last = try_find_sym(glib, "g_tree_node_last");
    stub_funcs.ptr_g_tree_node_previous = try_find_sym(glib, "g_tree_node_previous");
    stub_funcs.ptr_g_tree_node_next = try_find_sym(glib, "g_tree_node_next");
    stub_funcs.ptr_g_tree_ref = try_find_sym(glib, "g_tree_ref");
    stub_funcs.ptr_g_tree_unref = try_find_sym(glib, "g_tree_unref");
    stub_funcs.ptr_g_tree_destroy = try_find_sym(glib, "g_tree_destroy");
    stub_funcs.ptr_g_tree_insert_node = try_find_sym(glib, "g_tree_insert_node");
    stub_funcs.ptr_g_tree_insert = try_find_sym(glib, "g_tree_insert");
    stub_funcs.ptr_g_tree_replace_node = try_find_sym(glib, "g_tree_replace_node");
    stub_funcs.ptr_g_tree_replace = try_find_sym(glib, "g_tree_replace");
    stub_funcs.ptr_g_tree_remove = try_find_sym(glib, "g_tree_remove");
    stub_funcs.ptr_g_tree_remove_all = try_find_sym(glib, "g_tree_remove_all");
    stub_funcs.ptr_g_tree_steal = try_find_sym(glib, "g_tree_steal");
    stub_funcs.ptr_g_tree_node_key = try_find_sym(glib, "g_tree_node_key");
    stub_funcs.ptr_g_tree_node_value = try_find_sym(glib, "g_tree_node_value");
    stub_funcs.ptr_g_tree_lookup_node = try_find_sym(glib, "g_tree_lookup_node");
    stub_funcs.ptr_g_tree_lookup = try_find_sym(glib, "g_tree_lookup");
    stub_funcs.ptr_g_tree_lookup_extended = try_find_sym(glib, "g_tree_lookup_extended");
    stub_funcs.ptr_g_tree_foreach = try_find_sym(glib, "g_tree_foreach");
    stub_funcs.ptr_g_tree_foreach_node = try_find_sym(glib, "g_tree_foreach_node");
    stub_funcs.ptr_g_tree_traverse = try_find_sym(glib, "g_tree_traverse");
    stub_funcs.ptr_g_tree_search_node = try_find_sym(glib, "g_tree_search_node");
    stub_funcs.ptr_g_tree_search = try_find_sym(glib, "g_tree_search");
    stub_funcs.ptr_g_tree_lower_bound = try_find_sym(glib, "g_tree_lower_bound");
    stub_funcs.ptr_g_tree_upper_bound = try_find_sym(glib, "g_tree_upper_bound");
    stub_funcs.ptr_g_tree_height = try_find_sym(glib, "g_tree_height");
    stub_funcs.ptr_g_tree_nnodes = try_find_sym(glib, "g_tree_nnodes");
    stub_funcs.ptr_g_tree_dump = try_find_sym(glib, "g_tree_dump");
    stub_funcs.ptr_g_tree_new = try_find_sym(glib, "g_tree_new");
    // Header /usr/include/glib-2.0/glib/gtypes.h
    // Header /usr/include/glib-2.0/glib/gunicode.h
    stub_funcs.ptr_g_unicode_script_from_iso15924 = try_find_sym(glib, "g_unicode_script_from_iso15924");
    stub_funcs.ptr_g_unichar_isalnum = try_find_sym(glib, "g_unichar_isalnum");
    stub_funcs.ptr_g_unichar_isalpha = try_find_sym(glib, "g_unichar_isalpha");
    stub_funcs.ptr_g_unichar_iscntrl = try_find_sym(glib, "g_unichar_iscntrl");
    stub_funcs.ptr_g_unichar_isdigit = try_find_sym(glib, "g_unichar_isdigit");
    stub_funcs.ptr_g_unichar_isgraph = try_find_sym(glib, "g_unichar_isgraph");
    stub_funcs.ptr_g_unichar_islower = try_find_sym(glib, "g_unichar_islower");
    stub_funcs.ptr_g_unichar_isprint = try_find_sym(glib, "g_unichar_isprint");
    stub_funcs.ptr_g_unichar_ispunct = try_find_sym(glib, "g_unichar_ispunct");
    stub_funcs.ptr_g_unichar_isspace = try_find_sym(glib, "g_unichar_isspace");
    stub_funcs.ptr_g_unichar_isupper = try_find_sym(glib, "g_unichar_isupper");
    stub_funcs.ptr_g_unichar_isxdigit = try_find_sym(glib, "g_unichar_isxdigit");
    stub_funcs.ptr_g_unichar_istitle = try_find_sym(glib, "g_unichar_istitle");
    stub_funcs.ptr_g_unichar_isdefined = try_find_sym(glib, "g_unichar_isdefined");
    stub_funcs.ptr_g_unichar_iswide = try_find_sym(glib, "g_unichar_iswide");
    stub_funcs.ptr_g_unichar_iswide_cjk = try_find_sym(glib, "g_unichar_iswide_cjk");
    stub_funcs.ptr_g_unichar_iszerowidth = try_find_sym(glib, "g_unichar_iszerowidth");
    stub_funcs.ptr_g_unichar_ismark = try_find_sym(glib, "g_unichar_ismark");
    stub_funcs.ptr_g_unichar_toupper = try_find_sym(glib, "g_unichar_toupper");
    stub_funcs.ptr_g_unichar_tolower = try_find_sym(glib, "g_unichar_tolower");
    stub_funcs.ptr_g_unichar_totitle = try_find_sym(glib, "g_unichar_totitle");
    stub_funcs.ptr_g_unichar_digit_value = try_find_sym(glib, "g_unichar_digit_value");
    stub_funcs.ptr_g_unichar_xdigit_value = try_find_sym(glib, "g_unichar_xdigit_value");
    stub_funcs.ptr_g_unichar_type = try_find_sym(glib, "g_unichar_type");
    stub_funcs.ptr_g_unichar_break_type = try_find_sym(glib, "g_unichar_break_type");
    stub_funcs.ptr_g_unichar_combining_class = try_find_sym(glib, "g_unichar_combining_class");
    stub_funcs.ptr_g_unichar_get_mirror_char = try_find_sym(glib, "g_unichar_get_mirror_char");
    stub_funcs.ptr_g_unichar_get_script = try_find_sym(glib, "g_unichar_get_script");
    stub_funcs.ptr_g_unichar_validate = try_find_sym(glib, "g_unichar_validate");
    stub_funcs.ptr_g_unichar_compose = try_find_sym(glib, "g_unichar_compose");
    stub_funcs.ptr_g_unichar_decompose = try_find_sym(glib, "g_unichar_decompose");
    stub_funcs.ptr_g_unichar_fully_decompose = try_find_sym(glib, "g_unichar_fully_decompose");
    stub_funcs.ptr_g_unicode_canonical_ordering = try_find_sym(glib, "g_unicode_canonical_ordering");
    stub_funcs.ptr_g_unicode_canonical_decomposition = try_find_sym(glib, "g_unicode_canonical_decomposition");
    stub_funcs.ptr_g_utf8_get_char = try_find_sym(glib, "g_utf8_get_char");
    stub_funcs.ptr_g_utf8_get_char_validated = try_find_sym(glib, "g_utf8_get_char_validated");
    stub_funcs.ptr_g_utf8_offset_to_pointer = try_find_sym(glib, "g_utf8_offset_to_pointer");
    stub_funcs.ptr_g_utf8_pointer_to_offset = try_find_sym(glib, "g_utf8_pointer_to_offset");
    stub_funcs.ptr_g_utf8_prev_char = try_find_sym(glib, "g_utf8_prev_char");
    stub_funcs.ptr_g_utf8_find_next_char = try_find_sym(glib, "g_utf8_find_next_char");
    stub_funcs.ptr_g_utf8_find_prev_char = try_find_sym(glib, "g_utf8_find_prev_char");
    stub_funcs.ptr_g_utf8_strlen = try_find_sym(glib, "g_utf8_strlen");
    stub_funcs.ptr_g_utf8_substring = try_find_sym(glib, "g_utf8_substring");
    stub_funcs.ptr_g_utf8_strncpy = try_find_sym(glib, "g_utf8_strncpy");
    stub_funcs.ptr_g_utf8_truncate_middle = try_find_sym(glib, "g_utf8_truncate_middle");
    stub_funcs.ptr_g_utf8_strchr = try_find_sym(glib, "g_utf8_strchr");
    stub_funcs.ptr_g_utf8_strrchr = try_find_sym(glib, "g_utf8_strrchr");
    stub_funcs.ptr_g_utf8_strreverse = try_find_sym(glib, "g_utf8_strreverse");
    stub_funcs.ptr_g_utf8_to_utf16 = try_find_sym(glib, "g_utf8_to_utf16");
    stub_funcs.ptr_g_utf8_to_ucs4 = try_find_sym(glib, "g_utf8_to_ucs4");
    stub_funcs.ptr_g_utf8_to_ucs4_fast = try_find_sym(glib, "g_utf8_to_ucs4_fast");
    stub_funcs.ptr_g_utf16_to_ucs4 = try_find_sym(glib, "g_utf16_to_ucs4");
    stub_funcs.ptr_g_utf16_to_utf8 = try_find_sym(glib, "g_utf16_to_utf8");
    stub_funcs.ptr_g_ucs4_to_utf16 = try_find_sym(glib, "g_ucs4_to_utf16");
    stub_funcs.ptr_g_ucs4_to_utf8 = try_find_sym(glib, "g_ucs4_to_utf8");
    stub_funcs.ptr_g_unichar_to_utf8 = try_find_sym(glib, "g_unichar_to_utf8");
    stub_funcs.ptr_g_utf8_validate = try_find_sym(glib, "g_utf8_validate");
    stub_funcs.ptr_g_utf8_validate_len = try_find_sym(glib, "g_utf8_validate_len");
    stub_funcs.ptr_g_utf8_strup = try_find_sym(glib, "g_utf8_strup");
    stub_funcs.ptr_g_utf8_strdown = try_find_sym(glib, "g_utf8_strdown");
    stub_funcs.ptr_g_utf8_casefold = try_find_sym(glib, "g_utf8_casefold");
    stub_funcs.ptr_g_utf8_normalize = try_find_sym(glib, "g_utf8_normalize");
    stub_funcs.ptr_g_utf8_collate = try_find_sym(glib, "g_utf8_collate");
    stub_funcs.ptr_g_utf8_collate_key = try_find_sym(glib, "g_utf8_collate_key");
    stub_funcs.ptr_g_utf8_collate_key_for_filename = try_find_sym(glib, "g_utf8_collate_key_for_filename");
    stub_funcs.ptr_g_utf8_make_valid = try_find_sym(glib, "g_utf8_make_valid");
    stub_funcs.ptr_g_unicode_script_to_iso15924 = try_find_sym(glib, "g_unicode_script_to_iso15924");
    // Header /usr/include/glib-2.0/glib/guri.h
    stub_funcs.ptr_g_uri_unref = try_find_sym(glib, "g_uri_unref");
    stub_funcs.ptr_g_uri_split = try_find_sym(glib, "g_uri_split");
    stub_funcs.ptr_g_uri_split_with_user = try_find_sym(glib, "g_uri_split_with_user");
    stub_funcs.ptr_g_uri_split_network = try_find_sym(glib, "g_uri_split_network");
    stub_funcs.ptr_g_uri_is_valid = try_find_sym(glib, "g_uri_is_valid");
    stub_funcs.ptr_g_uri_join = try_find_sym(glib, "g_uri_join");
    stub_funcs.ptr_g_uri_join_with_user = try_find_sym(glib, "g_uri_join_with_user");
    stub_funcs.ptr_g_uri_parse = try_find_sym(glib, "g_uri_parse");
    stub_funcs.ptr_g_uri_parse_relative = try_find_sym(glib, "g_uri_parse_relative");
    stub_funcs.ptr_g_uri_resolve_relative = try_find_sym(glib, "g_uri_resolve_relative");
    stub_funcs.ptr_g_uri_build = try_find_sym(glib, "g_uri_build");
    stub_funcs.ptr_g_uri_build_with_user = try_find_sym(glib, "g_uri_build_with_user");
    stub_funcs.ptr_g_uri_to_string = try_find_sym(glib, "g_uri_to_string");
    stub_funcs.ptr_g_uri_to_string_partial = try_find_sym(glib, "g_uri_to_string_partial");
    stub_funcs.ptr_g_uri_get_scheme = try_find_sym(glib, "g_uri_get_scheme");
    stub_funcs.ptr_g_uri_get_userinfo = try_find_sym(glib, "g_uri_get_userinfo");
    stub_funcs.ptr_g_uri_get_user = try_find_sym(glib, "g_uri_get_user");
    stub_funcs.ptr_g_uri_get_password = try_find_sym(glib, "g_uri_get_password");
    stub_funcs.ptr_g_uri_get_auth_params = try_find_sym(glib, "g_uri_get_auth_params");
    stub_funcs.ptr_g_uri_get_host = try_find_sym(glib, "g_uri_get_host");
    stub_funcs.ptr_g_uri_get_port = try_find_sym(glib, "g_uri_get_port");
    stub_funcs.ptr_g_uri_get_path = try_find_sym(glib, "g_uri_get_path");
    stub_funcs.ptr_g_uri_get_query = try_find_sym(glib, "g_uri_get_query");
    stub_funcs.ptr_g_uri_get_fragment = try_find_sym(glib, "g_uri_get_fragment");
    stub_funcs.ptr_g_uri_get_flags = try_find_sym(glib, "g_uri_get_flags");
    stub_funcs.ptr_g_uri_parse_params = try_find_sym(glib, "g_uri_parse_params");
    stub_funcs.ptr_g_uri_params_iter_init = try_find_sym(glib, "g_uri_params_iter_init");
    stub_funcs.ptr_g_uri_params_iter_next = try_find_sym(glib, "g_uri_params_iter_next");
    stub_funcs.ptr_g_uri_error_quark = try_find_sym(glib, "g_uri_error_quark");
    stub_funcs.ptr_g_uri_unescape_string = try_find_sym(glib, "g_uri_unescape_string");
    stub_funcs.ptr_g_uri_unescape_segment = try_find_sym(glib, "g_uri_unescape_segment");
    stub_funcs.ptr_g_uri_parse_scheme = try_find_sym(glib, "g_uri_parse_scheme");
    stub_funcs.ptr_g_uri_peek_scheme = try_find_sym(glib, "g_uri_peek_scheme");
    stub_funcs.ptr_g_uri_escape_string = try_find_sym(glib, "g_uri_escape_string");
    stub_funcs.ptr_g_uri_unescape_bytes = try_find_sym(glib, "g_uri_unescape_bytes");
    stub_funcs.ptr_g_uri_escape_bytes = try_find_sym(glib, "g_uri_escape_bytes");
    // Header /usr/include/glib-2.0/glib/gutils.h
    stub_funcs.ptr_g_get_real_name = try_find_sym(glib, "g_get_real_name");
    stub_funcs.ptr_g_get_home_dir = try_find_sym(glib, "g_get_home_dir");
    stub_funcs.ptr_g_get_tmp_dir = try_find_sym(glib, "g_get_tmp_dir");
    stub_funcs.ptr_g_get_host_name = try_find_sym(glib, "g_get_host_name");
    stub_funcs.ptr_g_get_prgname = try_find_sym(glib, "g_get_prgname");
    stub_funcs.ptr_g_set_prgname = try_find_sym(glib, "g_set_prgname");
    stub_funcs.ptr_g_get_application_name = try_find_sym(glib, "g_get_application_name");
    stub_funcs.ptr_g_set_application_name = try_find_sym(glib, "g_set_application_name");
    stub_funcs.ptr_g_get_os_info = try_find_sym(glib, "g_get_os_info");
    stub_funcs.ptr_g_reload_user_special_dirs_cache = try_find_sym(glib, "g_reload_user_special_dirs_cache");
    stub_funcs.ptr_g_get_user_data_dir = try_find_sym(glib, "g_get_user_data_dir");
    stub_funcs.ptr_g_get_user_config_dir = try_find_sym(glib, "g_get_user_config_dir");
    stub_funcs.ptr_g_get_user_cache_dir = try_find_sym(glib, "g_get_user_cache_dir");
    stub_funcs.ptr_g_get_user_state_dir = try_find_sym(glib, "g_get_user_state_dir");
    stub_funcs.ptr_g_get_system_data_dirs = try_find_sym(glib, "g_get_system_data_dirs");
    stub_funcs.ptr_g_get_system_config_dirs = try_find_sym(glib, "g_get_system_config_dirs");
    stub_funcs.ptr_g_get_user_runtime_dir = try_find_sym(glib, "g_get_user_runtime_dir");
    stub_funcs.ptr_g_get_user_special_dir = try_find_sym(glib, "g_get_user_special_dir");
    stub_funcs.ptr_g_parse_debug_string = try_find_sym(glib, "g_parse_debug_string");
    stub_funcs.ptr_g_vsnprintf = try_find_sym(glib, "g_vsnprintf");
    stub_funcs.ptr_g_nullify_pointer = try_find_sym(glib, "g_nullify_pointer");
    stub_funcs.ptr_g_format_size_full = try_find_sym(glib, "g_format_size_full");
    stub_funcs.ptr_g_format_size = try_find_sym(glib, "g_format_size");
    stub_funcs.ptr_g_format_size_for_display = try_find_sym(glib, "g_format_size_for_display");
    stub_funcs.ptr_g_find_program_in_path = try_find_sym(glib, "g_find_program_in_path");
    stub_funcs.ptr_g_bit_nth_lsf = try_find_sym(glib, "g_bit_nth_lsf");
    stub_funcs.ptr_g_bit_nth_msf = try_find_sym(glib, "g_bit_nth_msf");
    stub_funcs.ptr_g_bit_storage = try_find_sym(glib, "g_bit_storage");
    stub_funcs.ptr_g_abort = try_find_sym(glib, "g_abort");
    stub_funcs.ptr_g_get_user_name = try_find_sym(glib, "g_get_user_name");
    // Header /usr/include/glib-2.0/glib/guuid.h
    stub_funcs.ptr_g_uuid_string_random = try_find_sym(glib, "g_uuid_string_random");
    stub_funcs.ptr_g_uuid_string_is_valid = try_find_sym(glib, "g_uuid_string_is_valid");
    // Header /usr/include/glib-2.0/glib/gvariant.h
    stub_funcs.ptr_g_variant_ref = try_find_sym(glib, "g_variant_ref");
    stub_funcs.ptr_g_variant_ref_sink = try_find_sym(glib, "g_variant_ref_sink");
    stub_funcs.ptr_g_variant_is_floating = try_find_sym(glib, "g_variant_is_floating");
    stub_funcs.ptr_g_variant_take_ref = try_find_sym(glib, "g_variant_take_ref");
    stub_funcs.ptr_g_variant_get_type = try_find_sym(glib, "g_variant_get_type");
    stub_funcs.ptr_g_variant_get_type_string = try_find_sym(glib, "g_variant_get_type_string");
    stub_funcs.ptr_g_variant_is_of_type = try_find_sym(glib, "g_variant_is_of_type");
    stub_funcs.ptr_g_variant_is_container = try_find_sym(glib, "g_variant_is_container");
    stub_funcs.ptr_g_variant_classify = try_find_sym(glib, "g_variant_classify");
    stub_funcs.ptr_g_variant_new_boolean = try_find_sym(glib, "g_variant_new_boolean");
    stub_funcs.ptr_g_variant_new_byte = try_find_sym(glib, "g_variant_new_byte");
    stub_funcs.ptr_g_variant_new_int16 = try_find_sym(glib, "g_variant_new_int16");
    stub_funcs.ptr_g_variant_new_uint16 = try_find_sym(glib, "g_variant_new_uint16");
    stub_funcs.ptr_g_variant_new_int32 = try_find_sym(glib, "g_variant_new_int32");
    stub_funcs.ptr_g_variant_new_uint32 = try_find_sym(glib, "g_variant_new_uint32");
    stub_funcs.ptr_g_variant_new_int64 = try_find_sym(glib, "g_variant_new_int64");
    stub_funcs.ptr_g_variant_new_uint64 = try_find_sym(glib, "g_variant_new_uint64");
    stub_funcs.ptr_g_variant_new_handle = try_find_sym(glib, "g_variant_new_handle");
    stub_funcs.ptr_g_variant_new_double = try_find_sym(glib, "g_variant_new_double");
    stub_funcs.ptr_g_variant_new_string = try_find_sym(glib, "g_variant_new_string");
    stub_funcs.ptr_g_variant_new_take_string = try_find_sym(glib, "g_variant_new_take_string");
    stub_funcs.ptr_g_variant_new_object_path = try_find_sym(glib, "g_variant_new_object_path");
    stub_funcs.ptr_g_variant_is_object_path = try_find_sym(glib, "g_variant_is_object_path");
    stub_funcs.ptr_g_variant_new_signature = try_find_sym(glib, "g_variant_new_signature");
    stub_funcs.ptr_g_variant_is_signature = try_find_sym(glib, "g_variant_is_signature");
    stub_funcs.ptr_g_variant_new_variant = try_find_sym(glib, "g_variant_new_variant");
    stub_funcs.ptr_g_variant_new_strv = try_find_sym(glib, "g_variant_new_strv");
    stub_funcs.ptr_g_variant_new_objv = try_find_sym(glib, "g_variant_new_objv");
    stub_funcs.ptr_g_variant_new_bytestring = try_find_sym(glib, "g_variant_new_bytestring");
    stub_funcs.ptr_g_variant_new_bytestring_array = try_find_sym(glib, "g_variant_new_bytestring_array");
    stub_funcs.ptr_g_variant_new_fixed_array = try_find_sym(glib, "g_variant_new_fixed_array");
    stub_funcs.ptr_g_variant_get_boolean = try_find_sym(glib, "g_variant_get_boolean");
    stub_funcs.ptr_g_variant_get_byte = try_find_sym(glib, "g_variant_get_byte");
    stub_funcs.ptr_g_variant_get_int16 = try_find_sym(glib, "g_variant_get_int16");
    stub_funcs.ptr_g_variant_get_uint16 = try_find_sym(glib, "g_variant_get_uint16");
    stub_funcs.ptr_g_variant_get_int32 = try_find_sym(glib, "g_variant_get_int32");
    stub_funcs.ptr_g_variant_get_uint32 = try_find_sym(glib, "g_variant_get_uint32");
    stub_funcs.ptr_g_variant_get_int64 = try_find_sym(glib, "g_variant_get_int64");
    stub_funcs.ptr_g_variant_get_uint64 = try_find_sym(glib, "g_variant_get_uint64");
    stub_funcs.ptr_g_variant_get_handle = try_find_sym(glib, "g_variant_get_handle");
    stub_funcs.ptr_g_variant_get_double = try_find_sym(glib, "g_variant_get_double");
    stub_funcs.ptr_g_variant_get_variant = try_find_sym(glib, "g_variant_get_variant");
    stub_funcs.ptr_g_variant_get_string = try_find_sym(glib, "g_variant_get_string");
    stub_funcs.ptr_g_variant_dup_string = try_find_sym(glib, "g_variant_dup_string");
    stub_funcs.ptr_g_variant_get_strv = try_find_sym(glib, "g_variant_get_strv");
    stub_funcs.ptr_g_variant_dup_strv = try_find_sym(glib, "g_variant_dup_strv");
    stub_funcs.ptr_g_variant_get_objv = try_find_sym(glib, "g_variant_get_objv");
    stub_funcs.ptr_g_variant_dup_objv = try_find_sym(glib, "g_variant_dup_objv");
    stub_funcs.ptr_g_variant_get_bytestring = try_find_sym(glib, "g_variant_get_bytestring");
    stub_funcs.ptr_g_variant_dup_bytestring = try_find_sym(glib, "g_variant_dup_bytestring");
    stub_funcs.ptr_g_variant_get_bytestring_array = try_find_sym(glib, "g_variant_get_bytestring_array");
    stub_funcs.ptr_g_variant_dup_bytestring_array = try_find_sym(glib, "g_variant_dup_bytestring_array");
    stub_funcs.ptr_g_variant_new_maybe = try_find_sym(glib, "g_variant_new_maybe");
    stub_funcs.ptr_g_variant_new_array = try_find_sym(glib, "g_variant_new_array");
    stub_funcs.ptr_g_variant_new_tuple = try_find_sym(glib, "g_variant_new_tuple");
    stub_funcs.ptr_g_variant_new_dict_entry = try_find_sym(glib, "g_variant_new_dict_entry");
    stub_funcs.ptr_g_variant_get_maybe = try_find_sym(glib, "g_variant_get_maybe");
    stub_funcs.ptr_g_variant_n_children = try_find_sym(glib, "g_variant_n_children");
    stub_funcs.ptr_g_variant_get_child_value = try_find_sym(glib, "g_variant_get_child_value");
    stub_funcs.ptr_g_variant_lookup_value = try_find_sym(glib, "g_variant_lookup_value");
    stub_funcs.ptr_g_variant_get_fixed_array = try_find_sym(glib, "g_variant_get_fixed_array");
    stub_funcs.ptr_g_variant_get_size = try_find_sym(glib, "g_variant_get_size");
    stub_funcs.ptr_g_variant_get_data = try_find_sym(glib, "g_variant_get_data");
    stub_funcs.ptr_g_variant_get_data_as_bytes = try_find_sym(glib, "g_variant_get_data_as_bytes");
    stub_funcs.ptr_g_variant_store = try_find_sym(glib, "g_variant_store");
    stub_funcs.ptr_g_variant_print = try_find_sym(glib, "g_variant_print");
    stub_funcs.ptr_g_variant_print_string = try_find_sym(glib, "g_variant_print_string");
    stub_funcs.ptr_g_variant_hash = try_find_sym(glib, "g_variant_hash");
    stub_funcs.ptr_g_variant_equal = try_find_sym(glib, "g_variant_equal");
    stub_funcs.ptr_g_variant_get_normal_form = try_find_sym(glib, "g_variant_get_normal_form");
    stub_funcs.ptr_g_variant_is_normal_form = try_find_sym(glib, "g_variant_is_normal_form");
    stub_funcs.ptr_g_variant_byteswap = try_find_sym(glib, "g_variant_byteswap");
    stub_funcs.ptr_g_variant_new_from_bytes = try_find_sym(glib, "g_variant_new_from_bytes");
    stub_funcs.ptr_g_variant_new_from_data = try_find_sym(glib, "g_variant_new_from_data");
    stub_funcs.ptr_g_variant_iter_new = try_find_sym(glib, "g_variant_iter_new");
    stub_funcs.ptr_g_variant_iter_init = try_find_sym(glib, "g_variant_iter_init");
    stub_funcs.ptr_g_variant_iter_copy = try_find_sym(glib, "g_variant_iter_copy");
    stub_funcs.ptr_g_variant_iter_n_children = try_find_sym(glib, "g_variant_iter_n_children");
    stub_funcs.ptr_g_variant_iter_free = try_find_sym(glib, "g_variant_iter_free");
    stub_funcs.ptr_g_variant_iter_next_value = try_find_sym(glib, "g_variant_iter_next_value");
    stub_funcs.ptr_g_variant_parser_get_error_quark = try_find_sym(glib, "g_variant_parser_get_error_quark");
    stub_funcs.ptr_g_variant_parse_error_quark = try_find_sym(glib, "g_variant_parse_error_quark");
    stub_funcs.ptr_g_variant_builder_new = try_find_sym(glib, "g_variant_builder_new");
    stub_funcs.ptr_g_variant_builder_unref = try_find_sym(glib, "g_variant_builder_unref");
    stub_funcs.ptr_g_variant_builder_ref = try_find_sym(glib, "g_variant_builder_ref");
    stub_funcs.ptr_g_variant_builder_init = try_find_sym(glib, "g_variant_builder_init");
    stub_funcs.ptr_g_variant_builder_end = try_find_sym(glib, "g_variant_builder_end");
    stub_funcs.ptr_g_variant_builder_clear = try_find_sym(glib, "g_variant_builder_clear");
    stub_funcs.ptr_g_variant_builder_open = try_find_sym(glib, "g_variant_builder_open");
    stub_funcs.ptr_g_variant_builder_close = try_find_sym(glib, "g_variant_builder_close");
    stub_funcs.ptr_g_variant_builder_add_value = try_find_sym(glib, "g_variant_builder_add_value");
    stub_funcs.ptr_g_variant_new_va = try_find_sym(glib, "g_variant_new_va");
    stub_funcs.ptr_g_variant_get_va = try_find_sym(glib, "g_variant_get_va");
    stub_funcs.ptr_g_variant_check_format_string = try_find_sym(glib, "g_variant_check_format_string");
    stub_funcs.ptr_g_variant_parse = try_find_sym(glib, "g_variant_parse");
    stub_funcs.ptr_g_variant_new_parsed_va = try_find_sym(glib, "g_variant_new_parsed_va");
    stub_funcs.ptr_g_variant_parse_error_print_context = try_find_sym(glib, "g_variant_parse_error_print_context");
    stub_funcs.ptr_g_variant_compare = try_find_sym(glib, "g_variant_compare");
    stub_funcs.ptr_g_variant_dict_new = try_find_sym(glib, "g_variant_dict_new");
    stub_funcs.ptr_g_variant_dict_init = try_find_sym(glib, "g_variant_dict_init");
    stub_funcs.ptr_g_variant_dict_lookup_value = try_find_sym(glib, "g_variant_dict_lookup_value");
    stub_funcs.ptr_g_variant_dict_contains = try_find_sym(glib, "g_variant_dict_contains");
    stub_funcs.ptr_g_variant_dict_insert_value = try_find_sym(glib, "g_variant_dict_insert_value");
    stub_funcs.ptr_g_variant_dict_remove = try_find_sym(glib, "g_variant_dict_remove");
    stub_funcs.ptr_g_variant_dict_clear = try_find_sym(glib, "g_variant_dict_clear");
    stub_funcs.ptr_g_variant_dict_end = try_find_sym(glib, "g_variant_dict_end");
    stub_funcs.ptr_g_variant_dict_ref = try_find_sym(glib, "g_variant_dict_ref");
    stub_funcs.ptr_g_variant_dict_unref = try_find_sym(glib, "g_variant_dict_unref");
    stub_funcs.ptr_g_variant_unref = try_find_sym(glib, "g_variant_unref");
    // Header /usr/include/glib-2.0/glib/gvarianttype.h
    stub_funcs.ptr_g_variant_type_string_scan = try_find_sym(glib, "g_variant_type_string_scan");
    stub_funcs.ptr_g_variant_type_free = try_find_sym(glib, "g_variant_type_free");
    stub_funcs.ptr_g_variant_type_copy = try_find_sym(glib, "g_variant_type_copy");
    stub_funcs.ptr_g_variant_type_new = try_find_sym(glib, "g_variant_type_new");
    stub_funcs.ptr_g_variant_type_get_string_length = try_find_sym(glib, "g_variant_type_get_string_length");
    stub_funcs.ptr_g_variant_type_peek_string = try_find_sym(glib, "g_variant_type_peek_string");
    stub_funcs.ptr_g_variant_type_dup_string = try_find_sym(glib, "g_variant_type_dup_string");
    stub_funcs.ptr_g_variant_type_is_definite = try_find_sym(glib, "g_variant_type_is_definite");
    stub_funcs.ptr_g_variant_type_is_container = try_find_sym(glib, "g_variant_type_is_container");
    stub_funcs.ptr_g_variant_type_is_basic = try_find_sym(glib, "g_variant_type_is_basic");
    stub_funcs.ptr_g_variant_type_is_maybe = try_find_sym(glib, "g_variant_type_is_maybe");
    stub_funcs.ptr_g_variant_type_is_array = try_find_sym(glib, "g_variant_type_is_array");
    stub_funcs.ptr_g_variant_type_is_tuple = try_find_sym(glib, "g_variant_type_is_tuple");
    stub_funcs.ptr_g_variant_type_is_dict_entry = try_find_sym(glib, "g_variant_type_is_dict_entry");
    stub_funcs.ptr_g_variant_type_is_variant = try_find_sym(glib, "g_variant_type_is_variant");
    stub_funcs.ptr_g_variant_type_hash = try_find_sym(glib, "g_variant_type_hash");
    stub_funcs.ptr_g_variant_type_equal = try_find_sym(glib, "g_variant_type_equal");
    stub_funcs.ptr_g_variant_type_is_subtype_of = try_find_sym(glib, "g_variant_type_is_subtype_of");
    stub_funcs.ptr_g_variant_type_element = try_find_sym(glib, "g_variant_type_element");
    stub_funcs.ptr_g_variant_type_first = try_find_sym(glib, "g_variant_type_first");
    stub_funcs.ptr_g_variant_type_next = try_find_sym(glib, "g_variant_type_next");
    stub_funcs.ptr_g_variant_type_n_items = try_find_sym(glib, "g_variant_type_n_items");
    stub_funcs.ptr_g_variant_type_key = try_find_sym(glib, "g_variant_type_key");
    stub_funcs.ptr_g_variant_type_value = try_find_sym(glib, "g_variant_type_value");
    stub_funcs.ptr_g_variant_type_new_array = try_find_sym(glib, "g_variant_type_new_array");
    stub_funcs.ptr_g_variant_type_new_maybe = try_find_sym(glib, "g_variant_type_new_maybe");
    stub_funcs.ptr_g_variant_type_new_tuple = try_find_sym(glib, "g_variant_type_new_tuple");
    stub_funcs.ptr_g_variant_type_new_dict_entry = try_find_sym(glib, "g_variant_type_new_dict_entry");
    stub_funcs.ptr_g_variant_type_checked_ = try_find_sym(glib, "g_variant_type_checked_");
    stub_funcs.ptr_g_variant_type_string_get_depth_ = try_find_sym(glib, "g_variant_type_string_get_depth_");
    stub_funcs.ptr_g_variant_type_string_is_valid = try_find_sym(glib, "g_variant_type_string_is_valid");
    // Header /usr/include/glib-2.0/glib/gversion.h
    stub_funcs.ptr_glib_check_version = try_find_sym(glib, "glib_check_version");
    // Header /usr/include/glib-2.0/glib-unix.h
    stub_funcs.ptr_g_unix_open_pipe = try_find_sym(glib, "g_unix_open_pipe");
    stub_funcs.ptr_g_unix_set_fd_nonblocking = try_find_sym(glib, "g_unix_set_fd_nonblocking");
    stub_funcs.ptr_g_unix_signal_source_new = try_find_sym(glib, "g_unix_signal_source_new");
    stub_funcs.ptr_g_unix_signal_add_full = try_find_sym(glib, "g_unix_signal_add_full");
    stub_funcs.ptr_g_unix_signal_add = try_find_sym(glib, "g_unix_signal_add");
    stub_funcs.ptr_g_unix_fd_source_new = try_find_sym(glib, "g_unix_fd_source_new");
    stub_funcs.ptr_g_unix_fd_add_full = try_find_sym(glib, "g_unix_fd_add_full");
    stub_funcs.ptr_g_unix_fd_add = try_find_sym(glib, "g_unix_fd_add");
    stub_funcs.ptr_g_unix_get_passwd_entry = try_find_sym(glib, "g_unix_get_passwd_entry");
    stub_funcs.ptr_g_fdwalk_set_cloexec = try_find_sym(glib, "g_fdwalk_set_cloexec");
    stub_funcs.ptr_g_unix_error_quark = try_find_sym(glib, "g_unix_error_quark");
    // Header /usr/include/glib-2.0/gobject/gbinding.h
    stub_funcs.ptr_g_binding_flags_get_type = try_find_sym(gobject, "g_binding_flags_get_type");
    stub_funcs.ptr_g_binding_get_type = try_find_sym(gobject, "g_binding_get_type");
    stub_funcs.ptr_g_binding_get_flags = try_find_sym(gobject, "g_binding_get_flags");
    stub_funcs.ptr_g_binding_get_source = try_find_sym(gobject, "g_binding_get_source");
    stub_funcs.ptr_g_binding_dup_source = try_find_sym(gobject, "g_binding_dup_source");
    stub_funcs.ptr_g_binding_get_target = try_find_sym(gobject, "g_binding_get_target");
    stub_funcs.ptr_g_binding_dup_target = try_find_sym(gobject, "g_binding_dup_target");
    stub_funcs.ptr_g_binding_get_source_property = try_find_sym(gobject, "g_binding_get_source_property");
    stub_funcs.ptr_g_binding_get_target_property = try_find_sym(gobject, "g_binding_get_target_property");
    stub_funcs.ptr_g_binding_unbind = try_find_sym(gobject, "g_binding_unbind");
    stub_funcs.ptr_g_object_bind_property = try_find_sym(gobject, "g_object_bind_property");
    stub_funcs.ptr_g_object_bind_property_full = try_find_sym(gobject, "g_object_bind_property_full");
    stub_funcs.ptr_g_object_bind_property_with_closures = try_find_sym(gobject, "g_object_bind_property_with_closures");
    // Header /usr/include/glib-2.0/gobject/gbindinggroup.h
    stub_funcs.ptr_g_binding_group_get_type = try_find_sym(gobject, "g_binding_group_get_type");
    stub_funcs.ptr_g_binding_group_new = try_find_sym(gobject, "g_binding_group_new");
    stub_funcs.ptr_g_binding_group_dup_source = try_find_sym(gobject, "g_binding_group_dup_source");
    stub_funcs.ptr_g_binding_group_set_source = try_find_sym(gobject, "g_binding_group_set_source");
    stub_funcs.ptr_g_binding_group_bind = try_find_sym(gobject, "g_binding_group_bind");
    stub_funcs.ptr_g_binding_group_bind_full = try_find_sym(gobject, "g_binding_group_bind_full");
    stub_funcs.ptr_g_binding_group_bind_with_closures = try_find_sym(gobject, "g_binding_group_bind_with_closures");
    // Header /usr/include/glib-2.0/gobject/gboxed.h
    stub_funcs.ptr_g_boxed_copy = try_find_sym(gobject, "g_boxed_copy");
    stub_funcs.ptr_g_boxed_free = try_find_sym(gobject, "g_boxed_free");
    stub_funcs.ptr_g_value_set_boxed = try_find_sym(gobject, "g_value_set_boxed");
    stub_funcs.ptr_g_value_set_static_boxed = try_find_sym(gobject, "g_value_set_static_boxed");
    stub_funcs.ptr_g_value_take_boxed = try_find_sym(gobject, "g_value_take_boxed");
    stub_funcs.ptr_g_value_set_boxed_take_ownership = try_find_sym(gobject, "g_value_set_boxed_take_ownership");
    stub_funcs.ptr_g_value_get_boxed = try_find_sym(gobject, "g_value_get_boxed");
    stub_funcs.ptr_g_value_dup_boxed = try_find_sym(gobject, "g_value_dup_boxed");
    stub_funcs.ptr_g_boxed_type_register_static = try_find_sym(gobject, "g_boxed_type_register_static");
    stub_funcs.ptr_g_closure_get_type = try_find_sym(gobject, "g_closure_get_type");
    stub_funcs.ptr_g_value_get_type = try_find_sym(gobject, "g_value_get_type");
    // Header /usr/include/glib-2.0/gobject/gclosure.h
    stub_funcs.ptr_g_cclosure_new_swap = try_find_sym(gobject, "g_cclosure_new_swap");
    stub_funcs.ptr_g_signal_type_cclosure_new = try_find_sym(gobject, "g_signal_type_cclosure_new");
    stub_funcs.ptr_g_closure_ref = try_find_sym(gobject, "g_closure_ref");
    stub_funcs.ptr_g_closure_sink = try_find_sym(gobject, "g_closure_sink");
    stub_funcs.ptr_g_closure_unref = try_find_sym(gobject, "g_closure_unref");
    stub_funcs.ptr_g_closure_new_simple = try_find_sym(gobject, "g_closure_new_simple");
    stub_funcs.ptr_g_closure_add_finalize_notifier = try_find_sym(gobject, "g_closure_add_finalize_notifier");
    stub_funcs.ptr_g_closure_remove_finalize_notifier = try_find_sym(gobject, "g_closure_remove_finalize_notifier");
    stub_funcs.ptr_g_closure_add_invalidate_notifier = try_find_sym(gobject, "g_closure_add_invalidate_notifier");
    stub_funcs.ptr_g_closure_remove_invalidate_notifier = try_find_sym(gobject, "g_closure_remove_invalidate_notifier");
    stub_funcs.ptr_g_closure_add_marshal_guards = try_find_sym(gobject, "g_closure_add_marshal_guards");
    stub_funcs.ptr_g_closure_set_marshal = try_find_sym(gobject, "g_closure_set_marshal");
    stub_funcs.ptr_g_closure_set_meta_marshal = try_find_sym(gobject, "g_closure_set_meta_marshal");
    stub_funcs.ptr_g_closure_invalidate = try_find_sym(gobject, "g_closure_invalidate");
    stub_funcs.ptr_g_closure_invoke = try_find_sym(gobject, "g_closure_invoke");
    stub_funcs.ptr_g_cclosure_marshal_generic = try_find_sym(gobject, "g_cclosure_marshal_generic");
    stub_funcs.ptr_g_cclosure_marshal_generic_va = try_find_sym(gobject, "g_cclosure_marshal_generic_va");
    stub_funcs.ptr_g_cclosure_new = try_find_sym(gobject, "g_cclosure_new");
    // Header /usr/include/glib-2.0/gobject/genums.h
    stub_funcs.ptr_g_enum_get_value = try_find_sym(gobject, "g_enum_get_value");
    stub_funcs.ptr_g_enum_get_value_by_name = try_find_sym(gobject, "g_enum_get_value_by_name");
    stub_funcs.ptr_g_enum_get_value_by_nick = try_find_sym(gobject, "g_enum_get_value_by_nick");
    stub_funcs.ptr_g_flags_get_first_value = try_find_sym(gobject, "g_flags_get_first_value");
    stub_funcs.ptr_g_flags_get_value_by_name = try_find_sym(gobject, "g_flags_get_value_by_name");
    stub_funcs.ptr_g_flags_get_value_by_nick = try_find_sym(gobject, "g_flags_get_value_by_nick");
    stub_funcs.ptr_g_enum_to_string = try_find_sym(gobject, "g_enum_to_string");
    stub_funcs.ptr_g_flags_to_string = try_find_sym(gobject, "g_flags_to_string");
    stub_funcs.ptr_g_value_set_enum = try_find_sym(gobject, "g_value_set_enum");
    stub_funcs.ptr_g_value_get_enum = try_find_sym(gobject, "g_value_get_enum");
    stub_funcs.ptr_g_value_set_flags = try_find_sym(gobject, "g_value_set_flags");
    stub_funcs.ptr_g_value_get_flags = try_find_sym(gobject, "g_value_get_flags");
    stub_funcs.ptr_g_enum_register_static = try_find_sym(gobject, "g_enum_register_static");
    stub_funcs.ptr_g_flags_register_static = try_find_sym(gobject, "g_flags_register_static");
    stub_funcs.ptr_g_enum_complete_type_info = try_find_sym(gobject, "g_enum_complete_type_info");
    stub_funcs.ptr_g_flags_complete_type_info = try_find_sym(gobject, "g_flags_complete_type_info");
    // Header /usr/include/glib-2.0/gobject/glib-enumtypes.h
    stub_funcs.ptr_g_unicode_type_get_type = try_find_sym(gobject, "g_unicode_type_get_type");
    stub_funcs.ptr_g_unicode_break_type_get_type = try_find_sym(gobject, "g_unicode_break_type_get_type");
    stub_funcs.ptr_g_unicode_script_get_type = try_find_sym(gobject, "g_unicode_script_get_type");
    stub_funcs.ptr_g_normalize_mode_get_type = try_find_sym(gobject, "g_normalize_mode_get_type");
    // Header /usr/include/glib-2.0/gobject/glib-types.h
    stub_funcs.ptr_g_date_get_type = try_find_sym(gobject, "g_date_get_type");
    stub_funcs.ptr_g_strv_get_type = try_find_sym(gobject, "g_strv_get_type");
    stub_funcs.ptr_g_gstring_get_type = try_find_sym(gobject, "g_gstring_get_type");
    stub_funcs.ptr_g_hash_table_get_type = try_find_sym(gobject, "g_hash_table_get_type");
    stub_funcs.ptr_g_regex_get_type = try_find_sym(gobject, "g_regex_get_type");
    stub_funcs.ptr_g_match_info_get_type = try_find_sym(gobject, "g_match_info_get_type");
    stub_funcs.ptr_g_array_get_type = try_find_sym(gobject, "g_array_get_type");
    stub_funcs.ptr_g_byte_array_get_type = try_find_sym(gobject, "g_byte_array_get_type");
    stub_funcs.ptr_g_ptr_array_get_type = try_find_sym(gobject, "g_ptr_array_get_type");
    stub_funcs.ptr_g_bytes_get_type = try_find_sym(gobject, "g_bytes_get_type");
    stub_funcs.ptr_g_variant_type_get_gtype = try_find_sym(gobject, "g_variant_type_get_gtype");
    stub_funcs.ptr_g_error_get_type = try_find_sym(gobject, "g_error_get_type");
    stub_funcs.ptr_g_date_time_get_type = try_find_sym(gobject, "g_date_time_get_type");
    stub_funcs.ptr_g_time_zone_get_type = try_find_sym(gobject, "g_time_zone_get_type");
    stub_funcs.ptr_g_io_channel_get_type = try_find_sym(gobject, "g_io_channel_get_type");
    stub_funcs.ptr_g_io_condition_get_type = try_find_sym(gobject, "g_io_condition_get_type");
    stub_funcs.ptr_g_variant_builder_get_type = try_find_sym(gobject, "g_variant_builder_get_type");
    stub_funcs.ptr_g_variant_dict_get_type = try_find_sym(gobject, "g_variant_dict_get_type");
    stub_funcs.ptr_g_main_loop_get_type = try_find_sym(gobject, "g_main_loop_get_type");
    stub_funcs.ptr_g_main_context_get_type = try_find_sym(gobject, "g_main_context_get_type");
    stub_funcs.ptr_g_source_get_type = try_find_sym(gobject, "g_source_get_type");
    stub_funcs.ptr_g_pollfd_get_type = try_find_sym(gobject, "g_pollfd_get_type");
    stub_funcs.ptr_g_markup_parse_context_get_type = try_find_sym(gobject, "g_markup_parse_context_get_type");
    stub_funcs.ptr_g_key_file_get_type = try_find_sym(gobject, "g_key_file_get_type");
    stub_funcs.ptr_g_mapped_file_get_type = try_find_sym(gobject, "g_mapped_file_get_type");
    stub_funcs.ptr_g_thread_get_type = try_find_sym(gobject, "g_thread_get_type");
    stub_funcs.ptr_g_option_group_get_type = try_find_sym(gobject, "g_option_group_get_type");
    stub_funcs.ptr_g_uri_get_type = try_find_sym(gobject, "g_uri_get_type");
    stub_funcs.ptr_g_tree_get_type = try_find_sym(gobject, "g_tree_get_type");
    stub_funcs.ptr_g_pattern_spec_get_type = try_find_sym(gobject, "g_pattern_spec_get_type");
    stub_funcs.ptr_g_bookmark_file_get_type = try_find_sym(gobject, "g_bookmark_file_get_type");
    stub_funcs.ptr_g_hmac_get_type = try_find_sym(gobject, "g_hmac_get_type");
    stub_funcs.ptr_g_dir_get_type = try_find_sym(gobject, "g_dir_get_type");
    stub_funcs.ptr_g_rand_get_type = try_find_sym(gobject, "g_rand_get_type");
    stub_funcs.ptr_g_strv_builder_get_type = try_find_sym(gobject, "g_strv_builder_get_type");
    stub_funcs.ptr_g_checksum_get_type = try_find_sym(gobject, "g_checksum_get_type");
    stub_funcs.ptr_g_variant_get_gtype = try_find_sym(gobject, "g_variant_get_gtype");
    // Header /usr/include/glib-2.0/gobject/gmarshal.h
    stub_funcs.ptr_g_cclosure_marshal_VOID__VOIDv = try_find_sym(gobject, "g_cclosure_marshal_VOID__VOIDv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__BOOLEAN = try_find_sym(gobject, "g_cclosure_marshal_VOID__BOOLEAN");
    stub_funcs.ptr_g_cclosure_marshal_VOID__BOOLEANv = try_find_sym(gobject, "g_cclosure_marshal_VOID__BOOLEANv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__CHAR = try_find_sym(gobject, "g_cclosure_marshal_VOID__CHAR");
    stub_funcs.ptr_g_cclosure_marshal_VOID__CHARv = try_find_sym(gobject, "g_cclosure_marshal_VOID__CHARv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__UCHAR = try_find_sym(gobject, "g_cclosure_marshal_VOID__UCHAR");
    stub_funcs.ptr_g_cclosure_marshal_VOID__UCHARv = try_find_sym(gobject, "g_cclosure_marshal_VOID__UCHARv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__INT = try_find_sym(gobject, "g_cclosure_marshal_VOID__INT");
    stub_funcs.ptr_g_cclosure_marshal_VOID__INTv = try_find_sym(gobject, "g_cclosure_marshal_VOID__INTv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__UINT = try_find_sym(gobject, "g_cclosure_marshal_VOID__UINT");
    stub_funcs.ptr_g_cclosure_marshal_VOID__UINTv = try_find_sym(gobject, "g_cclosure_marshal_VOID__UINTv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__LONG = try_find_sym(gobject, "g_cclosure_marshal_VOID__LONG");
    stub_funcs.ptr_g_cclosure_marshal_VOID__LONGv = try_find_sym(gobject, "g_cclosure_marshal_VOID__LONGv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__ULONG = try_find_sym(gobject, "g_cclosure_marshal_VOID__ULONG");
    stub_funcs.ptr_g_cclosure_marshal_VOID__ULONGv = try_find_sym(gobject, "g_cclosure_marshal_VOID__ULONGv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__ENUM = try_find_sym(gobject, "g_cclosure_marshal_VOID__ENUM");
    stub_funcs.ptr_g_cclosure_marshal_VOID__ENUMv = try_find_sym(gobject, "g_cclosure_marshal_VOID__ENUMv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__FLAGS = try_find_sym(gobject, "g_cclosure_marshal_VOID__FLAGS");
    stub_funcs.ptr_g_cclosure_marshal_VOID__FLAGSv = try_find_sym(gobject, "g_cclosure_marshal_VOID__FLAGSv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__FLOAT = try_find_sym(gobject, "g_cclosure_marshal_VOID__FLOAT");
    stub_funcs.ptr_g_cclosure_marshal_VOID__FLOATv = try_find_sym(gobject, "g_cclosure_marshal_VOID__FLOATv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__DOUBLE = try_find_sym(gobject, "g_cclosure_marshal_VOID__DOUBLE");
    stub_funcs.ptr_g_cclosure_marshal_VOID__DOUBLEv = try_find_sym(gobject, "g_cclosure_marshal_VOID__DOUBLEv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__STRING = try_find_sym(gobject, "g_cclosure_marshal_VOID__STRING");
    stub_funcs.ptr_g_cclosure_marshal_VOID__STRINGv = try_find_sym(gobject, "g_cclosure_marshal_VOID__STRINGv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__PARAM = try_find_sym(gobject, "g_cclosure_marshal_VOID__PARAM");
    stub_funcs.ptr_g_cclosure_marshal_VOID__PARAMv = try_find_sym(gobject, "g_cclosure_marshal_VOID__PARAMv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__BOXED = try_find_sym(gobject, "g_cclosure_marshal_VOID__BOXED");
    stub_funcs.ptr_g_cclosure_marshal_VOID__BOXEDv = try_find_sym(gobject, "g_cclosure_marshal_VOID__BOXEDv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__POINTER = try_find_sym(gobject, "g_cclosure_marshal_VOID__POINTER");
    stub_funcs.ptr_g_cclosure_marshal_VOID__POINTERv = try_find_sym(gobject, "g_cclosure_marshal_VOID__POINTERv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__OBJECT = try_find_sym(gobject, "g_cclosure_marshal_VOID__OBJECT");
    stub_funcs.ptr_g_cclosure_marshal_VOID__OBJECTv = try_find_sym(gobject, "g_cclosure_marshal_VOID__OBJECTv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__VARIANT = try_find_sym(gobject, "g_cclosure_marshal_VOID__VARIANT");
    stub_funcs.ptr_g_cclosure_marshal_VOID__VARIANTv = try_find_sym(gobject, "g_cclosure_marshal_VOID__VARIANTv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__UINT_POINTER = try_find_sym(gobject, "g_cclosure_marshal_VOID__UINT_POINTER");
    stub_funcs.ptr_g_cclosure_marshal_VOID__UINT_POINTERv = try_find_sym(gobject, "g_cclosure_marshal_VOID__UINT_POINTERv");
    stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__FLAGS = try_find_sym(gobject, "g_cclosure_marshal_BOOLEAN__FLAGS");
    stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__FLAGSv = try_find_sym(gobject, "g_cclosure_marshal_BOOLEAN__FLAGSv");
    stub_funcs.ptr_g_cclosure_marshal_STRING__OBJECT_POINTER = try_find_sym(gobject, "g_cclosure_marshal_STRING__OBJECT_POINTER");
    stub_funcs.ptr_g_cclosure_marshal_STRING__OBJECT_POINTERv = try_find_sym(gobject, "g_cclosure_marshal_STRING__OBJECT_POINTERv");
    stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__BOXED_BOXED = try_find_sym(gobject, "g_cclosure_marshal_BOOLEAN__BOXED_BOXED");
    stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv = try_find_sym(gobject, "g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv");
    stub_funcs.ptr_g_cclosure_marshal_VOID__VOID = try_find_sym(gobject, "g_cclosure_marshal_VOID__VOID");
    // Header /usr/include/glib-2.0/gobject/gobject.h
    stub_funcs.ptr_g_initially_unowned_get_type = try_find_sym(gobject, "g_initially_unowned_get_type");
    stub_funcs.ptr_g_object_class_install_property = try_find_sym(gobject, "g_object_class_install_property");
    stub_funcs.ptr_g_object_class_find_property = try_find_sym(gobject, "g_object_class_find_property");
    stub_funcs.ptr_g_object_class_list_properties = try_find_sym(gobject, "g_object_class_list_properties");
    stub_funcs.ptr_g_object_class_override_property = try_find_sym(gobject, "g_object_class_override_property");
    stub_funcs.ptr_g_object_class_install_properties = try_find_sym(gobject, "g_object_class_install_properties");
    stub_funcs.ptr_g_object_interface_install_property = try_find_sym(gobject, "g_object_interface_install_property");
    stub_funcs.ptr_g_object_interface_find_property = try_find_sym(gobject, "g_object_interface_find_property");
    stub_funcs.ptr_g_object_interface_list_properties = try_find_sym(gobject, "g_object_interface_list_properties");
    stub_funcs.ptr_g_object_get_type = try_find_sym(gobject, "g_object_get_type");
    stub_funcs.ptr_g_object_new_with_properties = try_find_sym(gobject, "g_object_new_with_properties");
    stub_funcs.ptr_g_object_setv = try_find_sym(gobject, "g_object_setv");
    stub_funcs.ptr_g_object_set_valist = try_find_sym(gobject, "g_object_set_valist");
    stub_funcs.ptr_g_object_getv = try_find_sym(gobject, "g_object_getv");
    stub_funcs.ptr_g_object_get_valist = try_find_sym(gobject, "g_object_get_valist");
    stub_funcs.ptr_g_object_set_property = try_find_sym(gobject, "g_object_set_property");
    stub_funcs.ptr_g_object_get_property = try_find_sym(gobject, "g_object_get_property");
    stub_funcs.ptr_g_object_freeze_notify = try_find_sym(gobject, "g_object_freeze_notify");
    stub_funcs.ptr_g_object_notify = try_find_sym(gobject, "g_object_notify");
    stub_funcs.ptr_g_object_notify_by_pspec = try_find_sym(gobject, "g_object_notify_by_pspec");
    stub_funcs.ptr_g_object_thaw_notify = try_find_sym(gobject, "g_object_thaw_notify");
    stub_funcs.ptr_g_object_is_floating = try_find_sym(gobject, "g_object_is_floating");
    stub_funcs.ptr_g_object_ref_sink = try_find_sym(gobject, "g_object_ref_sink");
    stub_funcs.ptr_g_object_take_ref = try_find_sym(gobject, "g_object_take_ref");
    stub_funcs.ptr_g_object_ref = try_find_sym(gobject, "g_object_ref");
    stub_funcs.ptr_g_object_unref = try_find_sym(gobject, "g_object_unref");
    stub_funcs.ptr_g_object_weak_ref = try_find_sym(gobject, "g_object_weak_ref");
    stub_funcs.ptr_g_object_weak_unref = try_find_sym(gobject, "g_object_weak_unref");
    stub_funcs.ptr_g_object_add_weak_pointer = try_find_sym(gobject, "g_object_add_weak_pointer");
    stub_funcs.ptr_g_object_remove_weak_pointer = try_find_sym(gobject, "g_object_remove_weak_pointer");
    stub_funcs.ptr_g_object_add_toggle_ref = try_find_sym(gobject, "g_object_add_toggle_ref");
    stub_funcs.ptr_g_object_remove_toggle_ref = try_find_sym(gobject, "g_object_remove_toggle_ref");
    stub_funcs.ptr_g_object_get_qdata = try_find_sym(gobject, "g_object_get_qdata");
    stub_funcs.ptr_g_object_set_qdata = try_find_sym(gobject, "g_object_set_qdata");
    stub_funcs.ptr_g_object_set_qdata_full = try_find_sym(gobject, "g_object_set_qdata_full");
    stub_funcs.ptr_g_object_steal_qdata = try_find_sym(gobject, "g_object_steal_qdata");
    stub_funcs.ptr_g_object_dup_qdata = try_find_sym(gobject, "g_object_dup_qdata");
    stub_funcs.ptr_g_object_replace_qdata = try_find_sym(gobject, "g_object_replace_qdata");
    stub_funcs.ptr_g_object_get_data = try_find_sym(gobject, "g_object_get_data");
    stub_funcs.ptr_g_object_set_data = try_find_sym(gobject, "g_object_set_data");
    stub_funcs.ptr_g_object_set_data_full = try_find_sym(gobject, "g_object_set_data_full");
    stub_funcs.ptr_g_object_steal_data = try_find_sym(gobject, "g_object_steal_data");
    stub_funcs.ptr_g_object_dup_data = try_find_sym(gobject, "g_object_dup_data");
    stub_funcs.ptr_g_object_replace_data = try_find_sym(gobject, "g_object_replace_data");
    stub_funcs.ptr_g_object_watch_closure = try_find_sym(gobject, "g_object_watch_closure");
    stub_funcs.ptr_g_cclosure_new_object = try_find_sym(gobject, "g_cclosure_new_object");
    stub_funcs.ptr_g_cclosure_new_object_swap = try_find_sym(gobject, "g_cclosure_new_object_swap");
    stub_funcs.ptr_g_closure_new_object = try_find_sym(gobject, "g_closure_new_object");
    stub_funcs.ptr_g_value_set_object = try_find_sym(gobject, "g_value_set_object");
    stub_funcs.ptr_g_value_get_object = try_find_sym(gobject, "g_value_get_object");
    stub_funcs.ptr_g_value_dup_object = try_find_sym(gobject, "g_value_dup_object");
    stub_funcs.ptr_g_signal_connect_object = try_find_sym(gobject, "g_signal_connect_object");
    stub_funcs.ptr_g_object_force_floating = try_find_sym(gobject, "g_object_force_floating");
    stub_funcs.ptr_g_object_run_dispose = try_find_sym(gobject, "g_object_run_dispose");
    stub_funcs.ptr_g_value_take_object = try_find_sym(gobject, "g_value_take_object");
    stub_funcs.ptr_g_value_set_object_take_ownership = try_find_sym(gobject, "g_value_set_object_take_ownership");
    stub_funcs.ptr_g_object_compat_control = try_find_sym(gobject, "g_object_compat_control");
    stub_funcs.ptr_g_clear_object = try_find_sym(gobject, "g_clear_object");
    stub_funcs.ptr_g_weak_ref_init = try_find_sym(gobject, "g_weak_ref_init");
    stub_funcs.ptr_g_weak_ref_clear = try_find_sym(gobject, "g_weak_ref_clear");
    stub_funcs.ptr_g_weak_ref_get = try_find_sym(gobject, "g_weak_ref_get");
    stub_funcs.ptr_g_weak_ref_set = try_find_sym(gobject, "g_weak_ref_set");
    // Header /usr/include/glib-2.0/gobject/gparam.h
    stub_funcs.ptr_g_param_spec_ref = try_find_sym(gobject, "g_param_spec_ref");
    stub_funcs.ptr_g_param_spec_unref = try_find_sym(gobject, "g_param_spec_unref");
    stub_funcs.ptr_g_param_spec_sink = try_find_sym(gobject, "g_param_spec_sink");
    stub_funcs.ptr_g_param_spec_ref_sink = try_find_sym(gobject, "g_param_spec_ref_sink");
    stub_funcs.ptr_g_param_spec_get_qdata = try_find_sym(gobject, "g_param_spec_get_qdata");
    stub_funcs.ptr_g_param_spec_set_qdata = try_find_sym(gobject, "g_param_spec_set_qdata");
    stub_funcs.ptr_g_param_spec_set_qdata_full = try_find_sym(gobject, "g_param_spec_set_qdata_full");
    stub_funcs.ptr_g_param_spec_steal_qdata = try_find_sym(gobject, "g_param_spec_steal_qdata");
    stub_funcs.ptr_g_param_spec_get_redirect_target = try_find_sym(gobject, "g_param_spec_get_redirect_target");
    stub_funcs.ptr_g_param_value_set_default = try_find_sym(gobject, "g_param_value_set_default");
    stub_funcs.ptr_g_param_value_defaults = try_find_sym(gobject, "g_param_value_defaults");
    stub_funcs.ptr_g_param_value_validate = try_find_sym(gobject, "g_param_value_validate");
    stub_funcs.ptr_g_param_value_is_valid = try_find_sym(gobject, "g_param_value_is_valid");
    stub_funcs.ptr_g_param_value_convert = try_find_sym(gobject, "g_param_value_convert");
    stub_funcs.ptr_g_param_values_cmp = try_find_sym(gobject, "g_param_values_cmp");
    stub_funcs.ptr_g_param_spec_get_name = try_find_sym(gobject, "g_param_spec_get_name");
    stub_funcs.ptr_g_param_spec_get_nick = try_find_sym(gobject, "g_param_spec_get_nick");
    stub_funcs.ptr_g_param_spec_get_blurb = try_find_sym(gobject, "g_param_spec_get_blurb");
    stub_funcs.ptr_g_value_set_param = try_find_sym(gobject, "g_value_set_param");
    stub_funcs.ptr_g_value_get_param = try_find_sym(gobject, "g_value_get_param");
    stub_funcs.ptr_g_value_dup_param = try_find_sym(gobject, "g_value_dup_param");
    stub_funcs.ptr_g_value_take_param = try_find_sym(gobject, "g_value_take_param");
    stub_funcs.ptr_g_value_set_param_take_ownership = try_find_sym(gobject, "g_value_set_param_take_ownership");
    stub_funcs.ptr_g_param_spec_get_default_value = try_find_sym(gobject, "g_param_spec_get_default_value");
    stub_funcs.ptr_g_param_spec_get_name_quark = try_find_sym(gobject, "g_param_spec_get_name_quark");
    stub_funcs.ptr_g_param_type_register_static = try_find_sym(gobject, "g_param_type_register_static");
    stub_funcs.ptr_g_param_spec_is_valid_name = try_find_sym(gobject, "g_param_spec_is_valid_name");
    stub_funcs.ptr__g_param_type_register_static_constant = try_find_sym(gobject, "_g_param_type_register_static_constant");
    stub_funcs.ptr_g_param_spec_internal = try_find_sym(gobject, "g_param_spec_internal");
    stub_funcs.ptr_g_param_spec_pool_new = try_find_sym(gobject, "g_param_spec_pool_new");
    stub_funcs.ptr_g_param_spec_pool_insert = try_find_sym(gobject, "g_param_spec_pool_insert");
    stub_funcs.ptr_g_param_spec_pool_remove = try_find_sym(gobject, "g_param_spec_pool_remove");
    stub_funcs.ptr_g_param_spec_pool_lookup = try_find_sym(gobject, "g_param_spec_pool_lookup");
    stub_funcs.ptr_g_param_spec_pool_list_owned = try_find_sym(gobject, "g_param_spec_pool_list_owned");
    stub_funcs.ptr_g_param_spec_pool_list = try_find_sym(gobject, "g_param_spec_pool_list");
    stub_funcs.ptr_g_param_spec_pool_free = try_find_sym(gobject, "g_param_spec_pool_free");
    // Header /usr/include/glib-2.0/gobject/gparamspecs.h
    stub_funcs.ptr_g_param_spec_char = try_find_sym(gobject, "g_param_spec_char");
    stub_funcs.ptr_g_param_spec_uchar = try_find_sym(gobject, "g_param_spec_uchar");
    stub_funcs.ptr_g_param_spec_boolean = try_find_sym(gobject, "g_param_spec_boolean");
    stub_funcs.ptr_g_param_spec_int = try_find_sym(gobject, "g_param_spec_int");
    stub_funcs.ptr_g_param_spec_uint = try_find_sym(gobject, "g_param_spec_uint");
    stub_funcs.ptr_g_param_spec_long = try_find_sym(gobject, "g_param_spec_long");
    stub_funcs.ptr_g_param_spec_ulong = try_find_sym(gobject, "g_param_spec_ulong");
    stub_funcs.ptr_g_param_spec_int64 = try_find_sym(gobject, "g_param_spec_int64");
    stub_funcs.ptr_g_param_spec_uint64 = try_find_sym(gobject, "g_param_spec_uint64");
    stub_funcs.ptr_g_param_spec_unichar = try_find_sym(gobject, "g_param_spec_unichar");
    stub_funcs.ptr_g_param_spec_enum = try_find_sym(gobject, "g_param_spec_enum");
    stub_funcs.ptr_g_param_spec_flags = try_find_sym(gobject, "g_param_spec_flags");
    stub_funcs.ptr_g_param_spec_float = try_find_sym(gobject, "g_param_spec_float");
    stub_funcs.ptr_g_param_spec_double = try_find_sym(gobject, "g_param_spec_double");
    stub_funcs.ptr_g_param_spec_string = try_find_sym(gobject, "g_param_spec_string");
    stub_funcs.ptr_g_param_spec_param = try_find_sym(gobject, "g_param_spec_param");
    stub_funcs.ptr_g_param_spec_boxed = try_find_sym(gobject, "g_param_spec_boxed");
    stub_funcs.ptr_g_param_spec_pointer = try_find_sym(gobject, "g_param_spec_pointer");
    stub_funcs.ptr_g_param_spec_value_array = try_find_sym(gobject, "g_param_spec_value_array");
    stub_funcs.ptr_g_param_spec_object = try_find_sym(gobject, "g_param_spec_object");
    stub_funcs.ptr_g_param_spec_override = try_find_sym(gobject, "g_param_spec_override");
    stub_funcs.ptr_g_param_spec_gtype = try_find_sym(gobject, "g_param_spec_gtype");
    stub_funcs.ptr_g_param_spec_variant = try_find_sym(gobject, "g_param_spec_variant");
    // Header /usr/include/glib-2.0/gobject/gsignal.h
    stub_funcs.ptr_g_signal_new_valist = try_find_sym(gobject, "g_signal_new_valist");
    stub_funcs.ptr_g_signal_set_va_marshaller = try_find_sym(gobject, "g_signal_set_va_marshaller");
    stub_funcs.ptr_g_signal_emitv = try_find_sym(gobject, "g_signal_emitv");
    stub_funcs.ptr_g_signal_emit_valist = try_find_sym(gobject, "g_signal_emit_valist");
    stub_funcs.ptr_g_signal_lookup = try_find_sym(gobject, "g_signal_lookup");
    stub_funcs.ptr_g_signal_name = try_find_sym(gobject, "g_signal_name");
    stub_funcs.ptr_g_signal_query = try_find_sym(gobject, "g_signal_query");
    stub_funcs.ptr_g_signal_list_ids = try_find_sym(gobject, "g_signal_list_ids");
    stub_funcs.ptr_g_signal_is_valid_name = try_find_sym(gobject, "g_signal_is_valid_name");
    stub_funcs.ptr_g_signal_parse_name = try_find_sym(gobject, "g_signal_parse_name");
    stub_funcs.ptr_g_signal_get_invocation_hint = try_find_sym(gobject, "g_signal_get_invocation_hint");
    stub_funcs.ptr_g_signal_stop_emission = try_find_sym(gobject, "g_signal_stop_emission");
    stub_funcs.ptr_g_signal_stop_emission_by_name = try_find_sym(gobject, "g_signal_stop_emission_by_name");
    stub_funcs.ptr_g_signal_add_emission_hook = try_find_sym(gobject, "g_signal_add_emission_hook");
    stub_funcs.ptr_g_signal_remove_emission_hook = try_find_sym(gobject, "g_signal_remove_emission_hook");
    stub_funcs.ptr_g_signal_has_handler_pending = try_find_sym(gobject, "g_signal_has_handler_pending");
    stub_funcs.ptr_g_signal_connect_closure_by_id = try_find_sym(gobject, "g_signal_connect_closure_by_id");
    stub_funcs.ptr_g_signal_connect_closure = try_find_sym(gobject, "g_signal_connect_closure");
    stub_funcs.ptr_g_signal_connect_data = try_find_sym(gobject, "g_signal_connect_data");
    stub_funcs.ptr_g_signal_handler_block = try_find_sym(gobject, "g_signal_handler_block");
    stub_funcs.ptr_g_signal_handler_unblock = try_find_sym(gobject, "g_signal_handler_unblock");
    stub_funcs.ptr_g_signal_handler_disconnect = try_find_sym(gobject, "g_signal_handler_disconnect");
    stub_funcs.ptr_g_signal_handler_is_connected = try_find_sym(gobject, "g_signal_handler_is_connected");
    stub_funcs.ptr_g_signal_handler_find = try_find_sym(gobject, "g_signal_handler_find");
    stub_funcs.ptr_g_signal_handlers_block_matched = try_find_sym(gobject, "g_signal_handlers_block_matched");
    stub_funcs.ptr_g_signal_handlers_unblock_matched = try_find_sym(gobject, "g_signal_handlers_unblock_matched");
    stub_funcs.ptr_g_signal_handlers_disconnect_matched = try_find_sym(gobject, "g_signal_handlers_disconnect_matched");
    stub_funcs.ptr_g_clear_signal_handler = try_find_sym(gobject, "g_clear_signal_handler");
    stub_funcs.ptr_g_signal_override_class_closure = try_find_sym(gobject, "g_signal_override_class_closure");
    stub_funcs.ptr_g_signal_override_class_handler = try_find_sym(gobject, "g_signal_override_class_handler");
    stub_funcs.ptr_g_signal_chain_from_overridden = try_find_sym(gobject, "g_signal_chain_from_overridden");
    stub_funcs.ptr_g_signal_accumulator_true_handled = try_find_sym(gobject, "g_signal_accumulator_true_handled");
    stub_funcs.ptr_g_signal_accumulator_first_wins = try_find_sym(gobject, "g_signal_accumulator_first_wins");
    stub_funcs.ptr_g_signal_handlers_destroy = try_find_sym(gobject, "g_signal_handlers_destroy");
    stub_funcs.ptr__g_signals_destroy = try_find_sym(gobject, "_g_signals_destroy");
    stub_funcs.ptr_g_signal_newv = try_find_sym(gobject, "g_signal_newv");
    // Header /usr/include/glib-2.0/gobject/gsignalgroup.h
    stub_funcs.ptr_g_signal_group_get_type = try_find_sym(gobject, "g_signal_group_get_type");
    stub_funcs.ptr_g_signal_group_new = try_find_sym(gobject, "g_signal_group_new");
    stub_funcs.ptr_g_signal_group_set_target = try_find_sym(gobject, "g_signal_group_set_target");
    stub_funcs.ptr_g_signal_group_dup_target = try_find_sym(gobject, "g_signal_group_dup_target");
    stub_funcs.ptr_g_signal_group_block = try_find_sym(gobject, "g_signal_group_block");
    stub_funcs.ptr_g_signal_group_unblock = try_find_sym(gobject, "g_signal_group_unblock");
    stub_funcs.ptr_g_signal_group_connect_closure = try_find_sym(gobject, "g_signal_group_connect_closure");
    stub_funcs.ptr_g_signal_group_connect_object = try_find_sym(gobject, "g_signal_group_connect_object");
    stub_funcs.ptr_g_signal_group_connect_data = try_find_sym(gobject, "g_signal_group_connect_data");
    stub_funcs.ptr_g_signal_group_connect = try_find_sym(gobject, "g_signal_group_connect");
    stub_funcs.ptr_g_signal_group_connect_after = try_find_sym(gobject, "g_signal_group_connect_after");
    stub_funcs.ptr_g_signal_group_connect_swapped = try_find_sym(gobject, "g_signal_group_connect_swapped");
    // Header /usr/include/glib-2.0/gobject/gsourceclosure.h
    stub_funcs.ptr_g_source_set_dummy_callback = try_find_sym(gobject, "g_source_set_dummy_callback");
    stub_funcs.ptr_g_source_set_closure = try_find_sym(gobject, "g_source_set_closure");
    // Header /usr/include/glib-2.0/gobject/gtype.h
    stub_funcs.ptr_g_type_init_with_debug_flags = try_find_sym(gobject, "g_type_init_with_debug_flags");
    stub_funcs.ptr_g_type_qname = try_find_sym(gobject, "g_type_qname");
    stub_funcs.ptr_g_type_from_name = try_find_sym(gobject, "g_type_from_name");
    stub_funcs.ptr_g_type_parent = try_find_sym(gobject, "g_type_parent");
    stub_funcs.ptr_g_type_depth = try_find_sym(gobject, "g_type_depth");
    stub_funcs.ptr_g_type_next_base = try_find_sym(gobject, "g_type_next_base");
    stub_funcs.ptr_g_type_is_a = try_find_sym(gobject, "g_type_is_a");
    stub_funcs.ptr_g_type_class_ref = try_find_sym(gobject, "g_type_class_ref");
    stub_funcs.ptr_g_type_class_peek = try_find_sym(gobject, "g_type_class_peek");
    stub_funcs.ptr_g_type_class_peek_static = try_find_sym(gobject, "g_type_class_peek_static");
    stub_funcs.ptr_g_type_class_unref = try_find_sym(gobject, "g_type_class_unref");
    stub_funcs.ptr_g_type_class_peek_parent = try_find_sym(gobject, "g_type_class_peek_parent");
    stub_funcs.ptr_g_type_interface_peek = try_find_sym(gobject, "g_type_interface_peek");
    stub_funcs.ptr_g_type_interface_peek_parent = try_find_sym(gobject, "g_type_interface_peek_parent");
    stub_funcs.ptr_g_type_default_interface_ref = try_find_sym(gobject, "g_type_default_interface_ref");
    stub_funcs.ptr_g_type_default_interface_peek = try_find_sym(gobject, "g_type_default_interface_peek");
    stub_funcs.ptr_g_type_default_interface_unref = try_find_sym(gobject, "g_type_default_interface_unref");
    stub_funcs.ptr_g_type_children = try_find_sym(gobject, "g_type_children");
    stub_funcs.ptr_g_type_interfaces = try_find_sym(gobject, "g_type_interfaces");
    stub_funcs.ptr_g_type_set_qdata = try_find_sym(gobject, "g_type_set_qdata");
    stub_funcs.ptr_g_type_get_qdata = try_find_sym(gobject, "g_type_get_qdata");
    stub_funcs.ptr_g_type_query = try_find_sym(gobject, "g_type_query");
    stub_funcs.ptr_g_type_get_instance_count = try_find_sym(gobject, "g_type_get_instance_count");
    stub_funcs.ptr_g_type_register_static_simple = try_find_sym(gobject, "g_type_register_static_simple");
    stub_funcs.ptr_g_type_register_dynamic = try_find_sym(gobject, "g_type_register_dynamic");
    stub_funcs.ptr_g_type_register_fundamental = try_find_sym(gobject, "g_type_register_fundamental");
    stub_funcs.ptr_g_type_add_interface_static = try_find_sym(gobject, "g_type_add_interface_static");
    stub_funcs.ptr_g_type_add_interface_dynamic = try_find_sym(gobject, "g_type_add_interface_dynamic");
    stub_funcs.ptr_g_type_interface_add_prerequisite = try_find_sym(gobject, "g_type_interface_add_prerequisite");
    stub_funcs.ptr_g_type_interface_prerequisites = try_find_sym(gobject, "g_type_interface_prerequisites");
    stub_funcs.ptr_g_type_interface_instantiatable_prerequisite = try_find_sym(gobject, "g_type_interface_instantiatable_prerequisite");
    stub_funcs.ptr_g_type_class_add_private = try_find_sym(gobject, "g_type_class_add_private");
    stub_funcs.ptr_g_type_add_instance_private = try_find_sym(gobject, "g_type_add_instance_private");
    stub_funcs.ptr_g_type_instance_get_private = try_find_sym(gobject, "g_type_instance_get_private");
    stub_funcs.ptr_g_type_class_adjust_private_offset = try_find_sym(gobject, "g_type_class_adjust_private_offset");
    stub_funcs.ptr_g_type_add_class_private = try_find_sym(gobject, "g_type_add_class_private");
    stub_funcs.ptr_g_type_class_get_private = try_find_sym(gobject, "g_type_class_get_private");
    stub_funcs.ptr_g_type_class_get_instance_private_offset = try_find_sym(gobject, "g_type_class_get_instance_private_offset");
    stub_funcs.ptr_g_type_ensure = try_find_sym(gobject, "g_type_ensure");
    stub_funcs.ptr_g_type_get_type_registration_serial = try_find_sym(gobject, "g_type_get_type_registration_serial");
    stub_funcs.ptr_g_type_get_plugin = try_find_sym(gobject, "g_type_get_plugin");
    stub_funcs.ptr_g_type_interface_get_plugin = try_find_sym(gobject, "g_type_interface_get_plugin");
    stub_funcs.ptr_g_type_fundamental_next = try_find_sym(gobject, "g_type_fundamental_next");
    stub_funcs.ptr_g_type_fundamental = try_find_sym(gobject, "g_type_fundamental");
    stub_funcs.ptr_g_type_create_instance = try_find_sym(gobject, "g_type_create_instance");
    stub_funcs.ptr_g_type_free_instance = try_find_sym(gobject, "g_type_free_instance");
    stub_funcs.ptr_g_type_add_class_cache_func = try_find_sym(gobject, "g_type_add_class_cache_func");
    stub_funcs.ptr_g_type_remove_class_cache_func = try_find_sym(gobject, "g_type_remove_class_cache_func");
    stub_funcs.ptr_g_type_class_unref_uncached = try_find_sym(gobject, "g_type_class_unref_uncached");
    stub_funcs.ptr_g_type_add_interface_check = try_find_sym(gobject, "g_type_add_interface_check");
    stub_funcs.ptr_g_type_remove_interface_check = try_find_sym(gobject, "g_type_remove_interface_check");
    stub_funcs.ptr_g_type_value_table_peek = try_find_sym(gobject, "g_type_value_table_peek");
    stub_funcs.ptr_g_type_check_instance = try_find_sym(gobject, "g_type_check_instance");
    stub_funcs.ptr_g_type_check_instance_cast = try_find_sym(gobject, "g_type_check_instance_cast");
    stub_funcs.ptr_g_type_check_instance_is_a = try_find_sym(gobject, "g_type_check_instance_is_a");
    stub_funcs.ptr_g_type_check_instance_is_fundamentally_a = try_find_sym(gobject, "g_type_check_instance_is_fundamentally_a");
    stub_funcs.ptr_g_type_check_class_cast = try_find_sym(gobject, "g_type_check_class_cast");
    stub_funcs.ptr_g_type_check_class_is_a = try_find_sym(gobject, "g_type_check_class_is_a");
    stub_funcs.ptr_g_type_check_is_value_type = try_find_sym(gobject, "g_type_check_is_value_type");
    stub_funcs.ptr_g_type_check_value = try_find_sym(gobject, "g_type_check_value");
    stub_funcs.ptr_g_type_check_value_holds = try_find_sym(gobject, "g_type_check_value_holds");
    stub_funcs.ptr_g_type_test_flags = try_find_sym(gobject, "g_type_test_flags");
    stub_funcs.ptr_g_type_name_from_instance = try_find_sym(gobject, "g_type_name_from_instance");
    stub_funcs.ptr_g_type_name_from_class = try_find_sym(gobject, "g_type_name_from_class");
    // Header /usr/include/glib-2.0/gobject/gtypemodule.h
    stub_funcs.ptr_g_type_module_get_type = try_find_sym(gobject, "g_type_module_get_type");
    stub_funcs.ptr_g_type_module_use = try_find_sym(gobject, "g_type_module_use");
    stub_funcs.ptr_g_type_module_unuse = try_find_sym(gobject, "g_type_module_unuse");
    stub_funcs.ptr_g_type_module_set_name = try_find_sym(gobject, "g_type_module_set_name");
    stub_funcs.ptr_g_type_module_register_type = try_find_sym(gobject, "g_type_module_register_type");
    stub_funcs.ptr_g_type_module_add_interface = try_find_sym(gobject, "g_type_module_add_interface");
    stub_funcs.ptr_g_type_module_register_enum = try_find_sym(gobject, "g_type_module_register_enum");
    stub_funcs.ptr_g_type_module_register_flags = try_find_sym(gobject, "g_type_module_register_flags");
    // Header /usr/include/glib-2.0/gobject/gtypeplugin.h
    stub_funcs.ptr_g_type_plugin_get_type = try_find_sym(gobject, "g_type_plugin_get_type");
    stub_funcs.ptr_g_type_plugin_use = try_find_sym(gobject, "g_type_plugin_use");
    stub_funcs.ptr_g_type_plugin_unuse = try_find_sym(gobject, "g_type_plugin_unuse");
    stub_funcs.ptr_g_type_plugin_complete_type_info = try_find_sym(gobject, "g_type_plugin_complete_type_info");
    stub_funcs.ptr_g_type_plugin_complete_interface_info = try_find_sym(gobject, "g_type_plugin_complete_interface_info");
    // Header /usr/include/glib-2.0/gobject/gvalue.h
    stub_funcs.ptr_g_value_copy = try_find_sym(gobject, "g_value_copy");
    stub_funcs.ptr_g_value_reset = try_find_sym(gobject, "g_value_reset");
    stub_funcs.ptr_g_value_unset = try_find_sym(gobject, "g_value_unset");
    stub_funcs.ptr_g_value_set_instance = try_find_sym(gobject, "g_value_set_instance");
    stub_funcs.ptr_g_value_init_from_instance = try_find_sym(gobject, "g_value_init_from_instance");
    stub_funcs.ptr_g_value_fits_pointer = try_find_sym(gobject, "g_value_fits_pointer");
    stub_funcs.ptr_g_value_peek_pointer = try_find_sym(gobject, "g_value_peek_pointer");
    stub_funcs.ptr_g_value_type_compatible = try_find_sym(gobject, "g_value_type_compatible");
    stub_funcs.ptr_g_value_type_transformable = try_find_sym(gobject, "g_value_type_transformable");
    stub_funcs.ptr_g_value_transform = try_find_sym(gobject, "g_value_transform");
    stub_funcs.ptr_g_value_register_transform_func = try_find_sym(gobject, "g_value_register_transform_func");
    stub_funcs.ptr_g_value_init = try_find_sym(gobject, "g_value_init");
    // Header /usr/include/glib-2.0/gobject/gvaluearray.h
    stub_funcs.ptr_g_value_array_get_type = try_find_sym(gobject, "g_value_array_get_type");
    stub_funcs.ptr_g_value_array_get_nth = try_find_sym(gobject, "g_value_array_get_nth");
    stub_funcs.ptr_g_value_array_new = try_find_sym(gobject, "g_value_array_new");
    stub_funcs.ptr_g_value_array_free = try_find_sym(gobject, "g_value_array_free");
    stub_funcs.ptr_g_value_array_copy = try_find_sym(gobject, "g_value_array_copy");
    stub_funcs.ptr_g_value_array_prepend = try_find_sym(gobject, "g_value_array_prepend");
    stub_funcs.ptr_g_value_array_append = try_find_sym(gobject, "g_value_array_append");
    stub_funcs.ptr_g_value_array_insert = try_find_sym(gobject, "g_value_array_insert");
    stub_funcs.ptr_g_value_array_remove = try_find_sym(gobject, "g_value_array_remove");
    stub_funcs.ptr_g_value_array_sort = try_find_sym(gobject, "g_value_array_sort");
    stub_funcs.ptr_g_value_array_sort_with_data = try_find_sym(gobject, "g_value_array_sort_with_data");
    // Header /usr/include/glib-2.0/gobject/gvaluecollector.h
    // Header /usr/include/glib-2.0/gobject/gvaluetypes.h
    stub_funcs.ptr_g_value_get_char = try_find_sym(gobject, "g_value_get_char");
    stub_funcs.ptr_g_value_set_schar = try_find_sym(gobject, "g_value_set_schar");
    stub_funcs.ptr_g_value_get_schar = try_find_sym(gobject, "g_value_get_schar");
    stub_funcs.ptr_g_value_set_uchar = try_find_sym(gobject, "g_value_set_uchar");
    stub_funcs.ptr_g_value_get_uchar = try_find_sym(gobject, "g_value_get_uchar");
    stub_funcs.ptr_g_value_set_boolean = try_find_sym(gobject, "g_value_set_boolean");
    stub_funcs.ptr_g_value_get_boolean = try_find_sym(gobject, "g_value_get_boolean");
    stub_funcs.ptr_g_value_set_int = try_find_sym(gobject, "g_value_set_int");
    stub_funcs.ptr_g_value_get_int = try_find_sym(gobject, "g_value_get_int");
    stub_funcs.ptr_g_value_set_uint = try_find_sym(gobject, "g_value_set_uint");
    stub_funcs.ptr_g_value_get_uint = try_find_sym(gobject, "g_value_get_uint");
    stub_funcs.ptr_g_value_set_long = try_find_sym(gobject, "g_value_set_long");
    stub_funcs.ptr_g_value_get_long = try_find_sym(gobject, "g_value_get_long");
    stub_funcs.ptr_g_value_set_ulong = try_find_sym(gobject, "g_value_set_ulong");
    stub_funcs.ptr_g_value_get_ulong = try_find_sym(gobject, "g_value_get_ulong");
    stub_funcs.ptr_g_value_set_int64 = try_find_sym(gobject, "g_value_set_int64");
    stub_funcs.ptr_g_value_get_int64 = try_find_sym(gobject, "g_value_get_int64");
    stub_funcs.ptr_g_value_set_uint64 = try_find_sym(gobject, "g_value_set_uint64");
    stub_funcs.ptr_g_value_get_uint64 = try_find_sym(gobject, "g_value_get_uint64");
    stub_funcs.ptr_g_value_set_float = try_find_sym(gobject, "g_value_set_float");
    stub_funcs.ptr_g_value_get_float = try_find_sym(gobject, "g_value_get_float");
    stub_funcs.ptr_g_value_set_double = try_find_sym(gobject, "g_value_set_double");
    stub_funcs.ptr_g_value_get_double = try_find_sym(gobject, "g_value_get_double");
    stub_funcs.ptr_g_value_set_string = try_find_sym(gobject, "g_value_set_string");
    stub_funcs.ptr_g_value_set_static_string = try_find_sym(gobject, "g_value_set_static_string");
    stub_funcs.ptr_g_value_set_interned_string = try_find_sym(gobject, "g_value_set_interned_string");
    stub_funcs.ptr_g_value_get_string = try_find_sym(gobject, "g_value_get_string");
    stub_funcs.ptr_g_value_dup_string = try_find_sym(gobject, "g_value_dup_string");
    stub_funcs.ptr_g_value_steal_string = try_find_sym(gobject, "g_value_steal_string");
    stub_funcs.ptr_g_value_set_pointer = try_find_sym(gobject, "g_value_set_pointer");
    stub_funcs.ptr_g_value_get_pointer = try_find_sym(gobject, "g_value_get_pointer");
    stub_funcs.ptr_g_gtype_get_type = try_find_sym(gobject, "g_gtype_get_type");
    stub_funcs.ptr_g_value_set_gtype = try_find_sym(gobject, "g_value_set_gtype");
    stub_funcs.ptr_g_value_get_gtype = try_find_sym(gobject, "g_value_get_gtype");
    stub_funcs.ptr_g_value_set_variant = try_find_sym(gobject, "g_value_set_variant");
    stub_funcs.ptr_g_value_take_variant = try_find_sym(gobject, "g_value_take_variant");
    stub_funcs.ptr_g_value_get_variant = try_find_sym(gobject, "g_value_get_variant");
    stub_funcs.ptr_g_value_dup_variant = try_find_sym(gobject, "g_value_dup_variant");
    stub_funcs.ptr_g_pointer_type_register_static = try_find_sym(gobject, "g_pointer_type_register_static");
    stub_funcs.ptr_g_strdup_value_contents = try_find_sym(gobject, "g_strdup_value_contents");
    stub_funcs.ptr_g_value_take_string = try_find_sym(gobject, "g_value_take_string");
    stub_funcs.ptr_g_value_set_string_take_ownership = try_find_sym(gobject, "g_value_set_string_take_ownership");
    stub_funcs.ptr_g_value_set_char = try_find_sym(gobject, "g_value_set_char");
    // Header /usr/include/glib-2.0/gio/gaction.h
    stub_funcs.ptr_g_action_get_type = try_find_sym(gio, "g_action_get_type");
    stub_funcs.ptr_g_action_get_name = try_find_sym(gio, "g_action_get_name");
    stub_funcs.ptr_g_action_get_parameter_type = try_find_sym(gio, "g_action_get_parameter_type");
    stub_funcs.ptr_g_action_get_state_type = try_find_sym(gio, "g_action_get_state_type");
    stub_funcs.ptr_g_action_get_state_hint = try_find_sym(gio, "g_action_get_state_hint");
    stub_funcs.ptr_g_action_get_enabled = try_find_sym(gio, "g_action_get_enabled");
    stub_funcs.ptr_g_action_get_state = try_find_sym(gio, "g_action_get_state");
    stub_funcs.ptr_g_action_change_state = try_find_sym(gio, "g_action_change_state");
    stub_funcs.ptr_g_action_activate = try_find_sym(gio, "g_action_activate");
    stub_funcs.ptr_g_action_name_is_valid = try_find_sym(gio, "g_action_name_is_valid");
    stub_funcs.ptr_g_action_parse_detailed_name = try_find_sym(gio, "g_action_parse_detailed_name");
    stub_funcs.ptr_g_action_print_detailed_name = try_find_sym(gio, "g_action_print_detailed_name");
    // Header /usr/include/glib-2.0/gio/gactiongroup.h
    stub_funcs.ptr_g_action_group_get_type = try_find_sym(gio, "g_action_group_get_type");
    stub_funcs.ptr_g_action_group_has_action = try_find_sym(gio, "g_action_group_has_action");
    stub_funcs.ptr_g_action_group_list_actions = try_find_sym(gio, "g_action_group_list_actions");
    stub_funcs.ptr_g_action_group_get_action_parameter_type = try_find_sym(gio, "g_action_group_get_action_parameter_type");
    stub_funcs.ptr_g_action_group_get_action_state_type = try_find_sym(gio, "g_action_group_get_action_state_type");
    stub_funcs.ptr_g_action_group_get_action_state_hint = try_find_sym(gio, "g_action_group_get_action_state_hint");
    stub_funcs.ptr_g_action_group_get_action_enabled = try_find_sym(gio, "g_action_group_get_action_enabled");
    stub_funcs.ptr_g_action_group_get_action_state = try_find_sym(gio, "g_action_group_get_action_state");
    stub_funcs.ptr_g_action_group_change_action_state = try_find_sym(gio, "g_action_group_change_action_state");
    stub_funcs.ptr_g_action_group_activate_action = try_find_sym(gio, "g_action_group_activate_action");
    stub_funcs.ptr_g_action_group_action_added = try_find_sym(gio, "g_action_group_action_added");
    stub_funcs.ptr_g_action_group_action_removed = try_find_sym(gio, "g_action_group_action_removed");
    stub_funcs.ptr_g_action_group_action_enabled_changed = try_find_sym(gio, "g_action_group_action_enabled_changed");
    stub_funcs.ptr_g_action_group_action_state_changed = try_find_sym(gio, "g_action_group_action_state_changed");
    stub_funcs.ptr_g_action_group_query_action = try_find_sym(gio, "g_action_group_query_action");
    // Header /usr/include/glib-2.0/gio/gactiongroupexporter.h
    stub_funcs.ptr_g_dbus_connection_unexport_action_group = try_find_sym(gio, "g_dbus_connection_unexport_action_group");
    stub_funcs.ptr_g_dbus_connection_export_action_group = try_find_sym(gio, "g_dbus_connection_export_action_group");
    // Header /usr/include/glib-2.0/gio/gactionmap.h
    stub_funcs.ptr_g_action_map_get_type = try_find_sym(gio, "g_action_map_get_type");
    stub_funcs.ptr_g_action_map_lookup_action = try_find_sym(gio, "g_action_map_lookup_action");
    stub_funcs.ptr_g_action_map_add_action = try_find_sym(gio, "g_action_map_add_action");
    stub_funcs.ptr_g_action_map_remove_action = try_find_sym(gio, "g_action_map_remove_action");
    stub_funcs.ptr_g_action_map_add_action_entries = try_find_sym(gio, "g_action_map_add_action_entries");
    stub_funcs.ptr_g_action_map_remove_action_entries = try_find_sym(gio, "g_action_map_remove_action_entries");
    // Header /usr/include/glib-2.0/gio/gappinfo.h
    stub_funcs.ptr_g_app_info_get_type = try_find_sym(gio, "g_app_info_get_type");
    stub_funcs.ptr_g_app_launch_context_get_type = try_find_sym(gio, "g_app_launch_context_get_type");
    stub_funcs.ptr_g_app_info_create_from_commandline = try_find_sym(gio, "g_app_info_create_from_commandline");
    stub_funcs.ptr_g_app_info_dup = try_find_sym(gio, "g_app_info_dup");
    stub_funcs.ptr_g_app_info_equal = try_find_sym(gio, "g_app_info_equal");
    stub_funcs.ptr_g_app_info_get_id = try_find_sym(gio, "g_app_info_get_id");
    stub_funcs.ptr_g_app_info_get_name = try_find_sym(gio, "g_app_info_get_name");
    stub_funcs.ptr_g_app_info_get_display_name = try_find_sym(gio, "g_app_info_get_display_name");
    stub_funcs.ptr_g_app_info_get_description = try_find_sym(gio, "g_app_info_get_description");
    stub_funcs.ptr_g_app_info_get_executable = try_find_sym(gio, "g_app_info_get_executable");
    stub_funcs.ptr_g_app_info_get_commandline = try_find_sym(gio, "g_app_info_get_commandline");
    stub_funcs.ptr_g_app_info_get_icon = try_find_sym(gio, "g_app_info_get_icon");
    stub_funcs.ptr_g_app_info_launch = try_find_sym(gio, "g_app_info_launch");
    stub_funcs.ptr_g_app_info_supports_uris = try_find_sym(gio, "g_app_info_supports_uris");
    stub_funcs.ptr_g_app_info_supports_files = try_find_sym(gio, "g_app_info_supports_files");
    stub_funcs.ptr_g_app_info_launch_uris = try_find_sym(gio, "g_app_info_launch_uris");
    stub_funcs.ptr_g_app_info_launch_uris_async = try_find_sym(gio, "g_app_info_launch_uris_async");
    stub_funcs.ptr_g_app_info_launch_uris_finish = try_find_sym(gio, "g_app_info_launch_uris_finish");
    stub_funcs.ptr_g_app_info_should_show = try_find_sym(gio, "g_app_info_should_show");
    stub_funcs.ptr_g_app_info_set_as_default_for_type = try_find_sym(gio, "g_app_info_set_as_default_for_type");
    stub_funcs.ptr_g_app_info_set_as_default_for_extension = try_find_sym(gio, "g_app_info_set_as_default_for_extension");
    stub_funcs.ptr_g_app_info_add_supports_type = try_find_sym(gio, "g_app_info_add_supports_type");
    stub_funcs.ptr_g_app_info_can_remove_supports_type = try_find_sym(gio, "g_app_info_can_remove_supports_type");
    stub_funcs.ptr_g_app_info_remove_supports_type = try_find_sym(gio, "g_app_info_remove_supports_type");
    stub_funcs.ptr_g_app_info_get_supported_types = try_find_sym(gio, "g_app_info_get_supported_types");
    stub_funcs.ptr_g_app_info_can_delete = try_find_sym(gio, "g_app_info_can_delete");
    stub_funcs.ptr_g_app_info_delete = try_find_sym(gio, "g_app_info_delete");
    stub_funcs.ptr_g_app_info_set_as_last_used_for_type = try_find_sym(gio, "g_app_info_set_as_last_used_for_type");
    stub_funcs.ptr_g_app_info_get_all = try_find_sym(gio, "g_app_info_get_all");
    stub_funcs.ptr_g_app_info_get_all_for_type = try_find_sym(gio, "g_app_info_get_all_for_type");
    stub_funcs.ptr_g_app_info_get_recommended_for_type = try_find_sym(gio, "g_app_info_get_recommended_for_type");
    stub_funcs.ptr_g_app_info_get_fallback_for_type = try_find_sym(gio, "g_app_info_get_fallback_for_type");
    stub_funcs.ptr_g_app_info_reset_type_associations = try_find_sym(gio, "g_app_info_reset_type_associations");
    stub_funcs.ptr_g_app_info_get_default_for_type = try_find_sym(gio, "g_app_info_get_default_for_type");
    stub_funcs.ptr_g_app_info_get_default_for_type_async = try_find_sym(gio, "g_app_info_get_default_for_type_async");
    stub_funcs.ptr_g_app_info_get_default_for_type_finish = try_find_sym(gio, "g_app_info_get_default_for_type_finish");
    stub_funcs.ptr_g_app_info_get_default_for_uri_scheme = try_find_sym(gio, "g_app_info_get_default_for_uri_scheme");
    stub_funcs.ptr_g_app_info_get_default_for_uri_scheme_async = try_find_sym(gio, "g_app_info_get_default_for_uri_scheme_async");
    stub_funcs.ptr_g_app_info_get_default_for_uri_scheme_finish = try_find_sym(gio, "g_app_info_get_default_for_uri_scheme_finish");
    stub_funcs.ptr_g_app_info_launch_default_for_uri = try_find_sym(gio, "g_app_info_launch_default_for_uri");
    stub_funcs.ptr_g_app_info_launch_default_for_uri_async = try_find_sym(gio, "g_app_info_launch_default_for_uri_async");
    stub_funcs.ptr_g_app_info_launch_default_for_uri_finish = try_find_sym(gio, "g_app_info_launch_default_for_uri_finish");
    stub_funcs.ptr_g_app_launch_context_new = try_find_sym(gio, "g_app_launch_context_new");
    stub_funcs.ptr_g_app_launch_context_setenv = try_find_sym(gio, "g_app_launch_context_setenv");
    stub_funcs.ptr_g_app_launch_context_unsetenv = try_find_sym(gio, "g_app_launch_context_unsetenv");
    stub_funcs.ptr_g_app_launch_context_get_environment = try_find_sym(gio, "g_app_launch_context_get_environment");
    stub_funcs.ptr_g_app_launch_context_get_display = try_find_sym(gio, "g_app_launch_context_get_display");
    stub_funcs.ptr_g_app_launch_context_get_startup_notify_id = try_find_sym(gio, "g_app_launch_context_get_startup_notify_id");
    stub_funcs.ptr_g_app_launch_context_launch_failed = try_find_sym(gio, "g_app_launch_context_launch_failed");
    stub_funcs.ptr_g_app_info_monitor_get_type = try_find_sym(gio, "g_app_info_monitor_get_type");
    stub_funcs.ptr_g_app_info_monitor_get = try_find_sym(gio, "g_app_info_monitor_get");
    // Header /usr/include/glib-2.0/gio/gapplication.h
    stub_funcs.ptr_g_application_get_type = try_find_sym(gio, "g_application_get_type");
    stub_funcs.ptr_g_application_id_is_valid = try_find_sym(gio, "g_application_id_is_valid");
    stub_funcs.ptr_g_application_new = try_find_sym(gio, "g_application_new");
    stub_funcs.ptr_g_application_get_application_id = try_find_sym(gio, "g_application_get_application_id");
    stub_funcs.ptr_g_application_set_application_id = try_find_sym(gio, "g_application_set_application_id");
    stub_funcs.ptr_g_application_get_version = try_find_sym(gio, "g_application_get_version");
    stub_funcs.ptr_g_application_set_version = try_find_sym(gio, "g_application_set_version");
    stub_funcs.ptr_g_application_get_dbus_connection = try_find_sym(gio, "g_application_get_dbus_connection");
    stub_funcs.ptr_g_application_get_dbus_object_path = try_find_sym(gio, "g_application_get_dbus_object_path");
    stub_funcs.ptr_g_application_get_inactivity_timeout = try_find_sym(gio, "g_application_get_inactivity_timeout");
    stub_funcs.ptr_g_application_set_inactivity_timeout = try_find_sym(gio, "g_application_set_inactivity_timeout");
    stub_funcs.ptr_g_application_get_flags = try_find_sym(gio, "g_application_get_flags");
    stub_funcs.ptr_g_application_set_flags = try_find_sym(gio, "g_application_set_flags");
    stub_funcs.ptr_g_application_get_resource_base_path = try_find_sym(gio, "g_application_get_resource_base_path");
    stub_funcs.ptr_g_application_set_resource_base_path = try_find_sym(gio, "g_application_set_resource_base_path");
    stub_funcs.ptr_g_application_set_action_group = try_find_sym(gio, "g_application_set_action_group");
    stub_funcs.ptr_g_application_add_main_option_entries = try_find_sym(gio, "g_application_add_main_option_entries");
    stub_funcs.ptr_g_application_add_main_option = try_find_sym(gio, "g_application_add_main_option");
    stub_funcs.ptr_g_application_add_option_group = try_find_sym(gio, "g_application_add_option_group");
    stub_funcs.ptr_g_application_set_option_context_parameter_string = try_find_sym(gio, "g_application_set_option_context_parameter_string");
    stub_funcs.ptr_g_application_set_option_context_summary = try_find_sym(gio, "g_application_set_option_context_summary");
    stub_funcs.ptr_g_application_set_option_context_description = try_find_sym(gio, "g_application_set_option_context_description");
    stub_funcs.ptr_g_application_get_is_registered = try_find_sym(gio, "g_application_get_is_registered");
    stub_funcs.ptr_g_application_get_is_remote = try_find_sym(gio, "g_application_get_is_remote");
    stub_funcs.ptr_g_application_register = try_find_sym(gio, "g_application_register");
    stub_funcs.ptr_g_application_hold = try_find_sym(gio, "g_application_hold");
    stub_funcs.ptr_g_application_release = try_find_sym(gio, "g_application_release");
    stub_funcs.ptr_g_application_activate = try_find_sym(gio, "g_application_activate");
    stub_funcs.ptr_g_application_open = try_find_sym(gio, "g_application_open");
    stub_funcs.ptr_g_application_run = try_find_sym(gio, "g_application_run");
    stub_funcs.ptr_g_application_quit = try_find_sym(gio, "g_application_quit");
    stub_funcs.ptr_g_application_get_default = try_find_sym(gio, "g_application_get_default");
    stub_funcs.ptr_g_application_set_default = try_find_sym(gio, "g_application_set_default");
    stub_funcs.ptr_g_application_mark_busy = try_find_sym(gio, "g_application_mark_busy");
    stub_funcs.ptr_g_application_unmark_busy = try_find_sym(gio, "g_application_unmark_busy");
    stub_funcs.ptr_g_application_get_is_busy = try_find_sym(gio, "g_application_get_is_busy");
    stub_funcs.ptr_g_application_send_notification = try_find_sym(gio, "g_application_send_notification");
    stub_funcs.ptr_g_application_withdraw_notification = try_find_sym(gio, "g_application_withdraw_notification");
    stub_funcs.ptr_g_application_bind_busy_property = try_find_sym(gio, "g_application_bind_busy_property");
    stub_funcs.ptr_g_application_unbind_busy_property = try_find_sym(gio, "g_application_unbind_busy_property");
    // Header /usr/include/glib-2.0/gio/gapplicationcommandline.h
    stub_funcs.ptr_g_application_command_line_get_type = try_find_sym(gio, "g_application_command_line_get_type");
    stub_funcs.ptr_g_application_command_line_get_arguments = try_find_sym(gio, "g_application_command_line_get_arguments");
    stub_funcs.ptr_g_application_command_line_get_options_dict = try_find_sym(gio, "g_application_command_line_get_options_dict");
    stub_funcs.ptr_g_application_command_line_get_stdin = try_find_sym(gio, "g_application_command_line_get_stdin");
    stub_funcs.ptr_g_application_command_line_get_environ = try_find_sym(gio, "g_application_command_line_get_environ");
    stub_funcs.ptr_g_application_command_line_getenv = try_find_sym(gio, "g_application_command_line_getenv");
    stub_funcs.ptr_g_application_command_line_get_cwd = try_find_sym(gio, "g_application_command_line_get_cwd");
    stub_funcs.ptr_g_application_command_line_get_is_remote = try_find_sym(gio, "g_application_command_line_get_is_remote");
    stub_funcs.ptr_g_application_command_line_print_literal = try_find_sym(gio, "g_application_command_line_print_literal");
    stub_funcs.ptr_g_application_command_line_printerr_literal = try_find_sym(gio, "g_application_command_line_printerr_literal");
    stub_funcs.ptr_g_application_command_line_get_exit_status = try_find_sym(gio, "g_application_command_line_get_exit_status");
    stub_funcs.ptr_g_application_command_line_set_exit_status = try_find_sym(gio, "g_application_command_line_set_exit_status");
    stub_funcs.ptr_g_application_command_line_get_platform_data = try_find_sym(gio, "g_application_command_line_get_platform_data");
    stub_funcs.ptr_g_application_command_line_create_file_for_arg = try_find_sym(gio, "g_application_command_line_create_file_for_arg");
    stub_funcs.ptr_g_application_command_line_done = try_find_sym(gio, "g_application_command_line_done");
    // Header /usr/include/glib-2.0/gio/gasyncinitable.h
    stub_funcs.ptr_g_async_initable_get_type = try_find_sym(gio, "g_async_initable_get_type");
    stub_funcs.ptr_g_async_initable_init_async = try_find_sym(gio, "g_async_initable_init_async");
    stub_funcs.ptr_g_async_initable_init_finish = try_find_sym(gio, "g_async_initable_init_finish");
    stub_funcs.ptr_g_async_initable_new_finish = try_find_sym(gio, "g_async_initable_new_finish");
    // Header /usr/include/glib-2.0/gio/gasyncresult.h
    stub_funcs.ptr_g_async_result_get_type = try_find_sym(gio, "g_async_result_get_type");
    stub_funcs.ptr_g_async_result_get_user_data = try_find_sym(gio, "g_async_result_get_user_data");
    stub_funcs.ptr_g_async_result_get_source_object = try_find_sym(gio, "g_async_result_get_source_object");
    stub_funcs.ptr_g_async_result_legacy_propagate_error = try_find_sym(gio, "g_async_result_legacy_propagate_error");
    stub_funcs.ptr_g_async_result_is_tagged = try_find_sym(gio, "g_async_result_is_tagged");
    // Header /usr/include/glib-2.0/gio/gbufferedinputstream.h
    stub_funcs.ptr_g_buffered_input_stream_get_type = try_find_sym(gio, "g_buffered_input_stream_get_type");
    stub_funcs.ptr_g_buffered_input_stream_new = try_find_sym(gio, "g_buffered_input_stream_new");
    stub_funcs.ptr_g_buffered_input_stream_new_sized = try_find_sym(gio, "g_buffered_input_stream_new_sized");
    stub_funcs.ptr_g_buffered_input_stream_get_buffer_size = try_find_sym(gio, "g_buffered_input_stream_get_buffer_size");
    stub_funcs.ptr_g_buffered_input_stream_set_buffer_size = try_find_sym(gio, "g_buffered_input_stream_set_buffer_size");
    stub_funcs.ptr_g_buffered_input_stream_get_available = try_find_sym(gio, "g_buffered_input_stream_get_available");
    stub_funcs.ptr_g_buffered_input_stream_peek = try_find_sym(gio, "g_buffered_input_stream_peek");
    stub_funcs.ptr_g_buffered_input_stream_peek_buffer = try_find_sym(gio, "g_buffered_input_stream_peek_buffer");
    stub_funcs.ptr_g_buffered_input_stream_fill = try_find_sym(gio, "g_buffered_input_stream_fill");
    stub_funcs.ptr_g_buffered_input_stream_fill_async = try_find_sym(gio, "g_buffered_input_stream_fill_async");
    stub_funcs.ptr_g_buffered_input_stream_fill_finish = try_find_sym(gio, "g_buffered_input_stream_fill_finish");
    stub_funcs.ptr_g_buffered_input_stream_read_byte = try_find_sym(gio, "g_buffered_input_stream_read_byte");
    // Header /usr/include/glib-2.0/gio/gbufferedoutputstream.h
    stub_funcs.ptr_g_buffered_output_stream_get_type = try_find_sym(gio, "g_buffered_output_stream_get_type");
    stub_funcs.ptr_g_buffered_output_stream_new = try_find_sym(gio, "g_buffered_output_stream_new");
    stub_funcs.ptr_g_buffered_output_stream_new_sized = try_find_sym(gio, "g_buffered_output_stream_new_sized");
    stub_funcs.ptr_g_buffered_output_stream_get_buffer_size = try_find_sym(gio, "g_buffered_output_stream_get_buffer_size");
    stub_funcs.ptr_g_buffered_output_stream_set_buffer_size = try_find_sym(gio, "g_buffered_output_stream_set_buffer_size");
    stub_funcs.ptr_g_buffered_output_stream_get_auto_grow = try_find_sym(gio, "g_buffered_output_stream_get_auto_grow");
    stub_funcs.ptr_g_buffered_output_stream_set_auto_grow = try_find_sym(gio, "g_buffered_output_stream_set_auto_grow");
    // Header /usr/include/glib-2.0/gio/gbytesicon.h
    stub_funcs.ptr_g_bytes_icon_get_type = try_find_sym(gio, "g_bytes_icon_get_type");
    stub_funcs.ptr_g_bytes_icon_new = try_find_sym(gio, "g_bytes_icon_new");
    stub_funcs.ptr_g_bytes_icon_get_bytes = try_find_sym(gio, "g_bytes_icon_get_bytes");
    // Header /usr/include/glib-2.0/gio/gcancellable.h
    stub_funcs.ptr_g_cancellable_get_type = try_find_sym(gio, "g_cancellable_get_type");
    stub_funcs.ptr_g_cancellable_new = try_find_sym(gio, "g_cancellable_new");
    stub_funcs.ptr_g_cancellable_is_cancelled = try_find_sym(gio, "g_cancellable_is_cancelled");
    stub_funcs.ptr_g_cancellable_set_error_if_cancelled = try_find_sym(gio, "g_cancellable_set_error_if_cancelled");
    stub_funcs.ptr_g_cancellable_get_fd = try_find_sym(gio, "g_cancellable_get_fd");
    stub_funcs.ptr_g_cancellable_make_pollfd = try_find_sym(gio, "g_cancellable_make_pollfd");
    stub_funcs.ptr_g_cancellable_release_fd = try_find_sym(gio, "g_cancellable_release_fd");
    stub_funcs.ptr_g_cancellable_source_new = try_find_sym(gio, "g_cancellable_source_new");
    stub_funcs.ptr_g_cancellable_get_current = try_find_sym(gio, "g_cancellable_get_current");
    stub_funcs.ptr_g_cancellable_push_current = try_find_sym(gio, "g_cancellable_push_current");
    stub_funcs.ptr_g_cancellable_pop_current = try_find_sym(gio, "g_cancellable_pop_current");
    stub_funcs.ptr_g_cancellable_reset = try_find_sym(gio, "g_cancellable_reset");
    stub_funcs.ptr_g_cancellable_connect = try_find_sym(gio, "g_cancellable_connect");
    stub_funcs.ptr_g_cancellable_disconnect = try_find_sym(gio, "g_cancellable_disconnect");
    stub_funcs.ptr_g_cancellable_cancel = try_find_sym(gio, "g_cancellable_cancel");
    // Header /usr/include/glib-2.0/gio/gcharsetconverter.h
    stub_funcs.ptr_g_charset_converter_get_type = try_find_sym(gio, "g_charset_converter_get_type");
    stub_funcs.ptr_g_charset_converter_new = try_find_sym(gio, "g_charset_converter_new");
    stub_funcs.ptr_g_charset_converter_set_use_fallback = try_find_sym(gio, "g_charset_converter_set_use_fallback");
    stub_funcs.ptr_g_charset_converter_get_use_fallback = try_find_sym(gio, "g_charset_converter_get_use_fallback");
    stub_funcs.ptr_g_charset_converter_get_num_fallbacks = try_find_sym(gio, "g_charset_converter_get_num_fallbacks");
    // Header /usr/include/glib-2.0/gio/gcontenttype.h
    stub_funcs.ptr_g_content_type_is_a = try_find_sym(gio, "g_content_type_is_a");
    stub_funcs.ptr_g_content_type_is_mime_type = try_find_sym(gio, "g_content_type_is_mime_type");
    stub_funcs.ptr_g_content_type_is_unknown = try_find_sym(gio, "g_content_type_is_unknown");
    stub_funcs.ptr_g_content_type_get_description = try_find_sym(gio, "g_content_type_get_description");
    stub_funcs.ptr_g_content_type_get_mime_type = try_find_sym(gio, "g_content_type_get_mime_type");
    stub_funcs.ptr_g_content_type_get_icon = try_find_sym(gio, "g_content_type_get_icon");
    stub_funcs.ptr_g_content_type_get_symbolic_icon = try_find_sym(gio, "g_content_type_get_symbolic_icon");
    stub_funcs.ptr_g_content_type_get_generic_icon_name = try_find_sym(gio, "g_content_type_get_generic_icon_name");
    stub_funcs.ptr_g_content_type_can_be_executable = try_find_sym(gio, "g_content_type_can_be_executable");
    stub_funcs.ptr_g_content_type_from_mime_type = try_find_sym(gio, "g_content_type_from_mime_type");
    stub_funcs.ptr_g_content_type_guess = try_find_sym(gio, "g_content_type_guess");
    stub_funcs.ptr_g_content_type_guess_for_tree = try_find_sym(gio, "g_content_type_guess_for_tree");
    stub_funcs.ptr_g_content_types_get_registered = try_find_sym(gio, "g_content_types_get_registered");
    stub_funcs.ptr_g_content_type_get_mime_dirs = try_find_sym(gio, "g_content_type_get_mime_dirs");
    stub_funcs.ptr_g_content_type_set_mime_dirs = try_find_sym(gio, "g_content_type_set_mime_dirs");
    stub_funcs.ptr_g_content_type_equals = try_find_sym(gio, "g_content_type_equals");
    // Header /usr/include/glib-2.0/gio/gconverter.h
    stub_funcs.ptr_g_converter_get_type = try_find_sym(gio, "g_converter_get_type");
    stub_funcs.ptr_g_converter_convert = try_find_sym(gio, "g_converter_convert");
    stub_funcs.ptr_g_converter_reset = try_find_sym(gio, "g_converter_reset");
    // Header /usr/include/glib-2.0/gio/gconverterinputstream.h
    stub_funcs.ptr_g_converter_input_stream_get_type = try_find_sym(gio, "g_converter_input_stream_get_type");
    stub_funcs.ptr_g_converter_input_stream_new = try_find_sym(gio, "g_converter_input_stream_new");
    stub_funcs.ptr_g_converter_input_stream_get_converter = try_find_sym(gio, "g_converter_input_stream_get_converter");
    // Header /usr/include/glib-2.0/gio/gconverteroutputstream.h
    stub_funcs.ptr_g_converter_output_stream_get_type = try_find_sym(gio, "g_converter_output_stream_get_type");
    stub_funcs.ptr_g_converter_output_stream_new = try_find_sym(gio, "g_converter_output_stream_new");
    stub_funcs.ptr_g_converter_output_stream_get_converter = try_find_sym(gio, "g_converter_output_stream_get_converter");
    // Header /usr/include/glib-2.0/gio/gcredentials.h
    stub_funcs.ptr_g_credentials_get_type = try_find_sym(gio, "g_credentials_get_type");
    stub_funcs.ptr_g_credentials_new = try_find_sym(gio, "g_credentials_new");
    stub_funcs.ptr_g_credentials_to_string = try_find_sym(gio, "g_credentials_to_string");
    stub_funcs.ptr_g_credentials_get_native = try_find_sym(gio, "g_credentials_get_native");
    stub_funcs.ptr_g_credentials_set_native = try_find_sym(gio, "g_credentials_set_native");
    stub_funcs.ptr_g_credentials_is_same_user = try_find_sym(gio, "g_credentials_is_same_user");
    stub_funcs.ptr_g_credentials_get_unix_pid = try_find_sym(gio, "g_credentials_get_unix_pid");
    stub_funcs.ptr_g_credentials_get_unix_user = try_find_sym(gio, "g_credentials_get_unix_user");
    stub_funcs.ptr_g_credentials_set_unix_user = try_find_sym(gio, "g_credentials_set_unix_user");
    // Header /usr/include/glib-2.0/gio/gdatagrambased.h
    stub_funcs.ptr_g_datagram_based_get_type = try_find_sym(gio, "g_datagram_based_get_type");
    stub_funcs.ptr_g_datagram_based_receive_messages = try_find_sym(gio, "g_datagram_based_receive_messages");
    stub_funcs.ptr_g_datagram_based_send_messages = try_find_sym(gio, "g_datagram_based_send_messages");
    stub_funcs.ptr_g_datagram_based_create_source = try_find_sym(gio, "g_datagram_based_create_source");
    stub_funcs.ptr_g_datagram_based_condition_check = try_find_sym(gio, "g_datagram_based_condition_check");
    stub_funcs.ptr_g_datagram_based_condition_wait = try_find_sym(gio, "g_datagram_based_condition_wait");
    // Header /usr/include/glib-2.0/gio/gdatainputstream.h
    stub_funcs.ptr_g_data_input_stream_get_type = try_find_sym(gio, "g_data_input_stream_get_type");
    stub_funcs.ptr_g_data_input_stream_new = try_find_sym(gio, "g_data_input_stream_new");
    stub_funcs.ptr_g_data_input_stream_set_byte_order = try_find_sym(gio, "g_data_input_stream_set_byte_order");
    stub_funcs.ptr_g_data_input_stream_get_byte_order = try_find_sym(gio, "g_data_input_stream_get_byte_order");
    stub_funcs.ptr_g_data_input_stream_set_newline_type = try_find_sym(gio, "g_data_input_stream_set_newline_type");
    stub_funcs.ptr_g_data_input_stream_get_newline_type = try_find_sym(gio, "g_data_input_stream_get_newline_type");
    stub_funcs.ptr_g_data_input_stream_read_byte = try_find_sym(gio, "g_data_input_stream_read_byte");
    stub_funcs.ptr_g_data_input_stream_read_int16 = try_find_sym(gio, "g_data_input_stream_read_int16");
    stub_funcs.ptr_g_data_input_stream_read_uint16 = try_find_sym(gio, "g_data_input_stream_read_uint16");
    stub_funcs.ptr_g_data_input_stream_read_int32 = try_find_sym(gio, "g_data_input_stream_read_int32");
    stub_funcs.ptr_g_data_input_stream_read_uint32 = try_find_sym(gio, "g_data_input_stream_read_uint32");
    stub_funcs.ptr_g_data_input_stream_read_int64 = try_find_sym(gio, "g_data_input_stream_read_int64");
    stub_funcs.ptr_g_data_input_stream_read_uint64 = try_find_sym(gio, "g_data_input_stream_read_uint64");
    stub_funcs.ptr_g_data_input_stream_read_line = try_find_sym(gio, "g_data_input_stream_read_line");
    stub_funcs.ptr_g_data_input_stream_read_line_utf8 = try_find_sym(gio, "g_data_input_stream_read_line_utf8");
    stub_funcs.ptr_g_data_input_stream_read_line_async = try_find_sym(gio, "g_data_input_stream_read_line_async");
    stub_funcs.ptr_g_data_input_stream_read_line_finish = try_find_sym(gio, "g_data_input_stream_read_line_finish");
    stub_funcs.ptr_g_data_input_stream_read_line_finish_utf8 = try_find_sym(gio, "g_data_input_stream_read_line_finish_utf8");
    stub_funcs.ptr_g_data_input_stream_read_until = try_find_sym(gio, "g_data_input_stream_read_until");
    stub_funcs.ptr_g_data_input_stream_read_until_async = try_find_sym(gio, "g_data_input_stream_read_until_async");
    stub_funcs.ptr_g_data_input_stream_read_until_finish = try_find_sym(gio, "g_data_input_stream_read_until_finish");
    stub_funcs.ptr_g_data_input_stream_read_upto = try_find_sym(gio, "g_data_input_stream_read_upto");
    stub_funcs.ptr_g_data_input_stream_read_upto_async = try_find_sym(gio, "g_data_input_stream_read_upto_async");
    stub_funcs.ptr_g_data_input_stream_read_upto_finish = try_find_sym(gio, "g_data_input_stream_read_upto_finish");
    // Header /usr/include/glib-2.0/gio/gdataoutputstream.h
    stub_funcs.ptr_g_data_output_stream_get_type = try_find_sym(gio, "g_data_output_stream_get_type");
    stub_funcs.ptr_g_data_output_stream_new = try_find_sym(gio, "g_data_output_stream_new");
    stub_funcs.ptr_g_data_output_stream_set_byte_order = try_find_sym(gio, "g_data_output_stream_set_byte_order");
    stub_funcs.ptr_g_data_output_stream_get_byte_order = try_find_sym(gio, "g_data_output_stream_get_byte_order");
    stub_funcs.ptr_g_data_output_stream_put_byte = try_find_sym(gio, "g_data_output_stream_put_byte");
    stub_funcs.ptr_g_data_output_stream_put_int16 = try_find_sym(gio, "g_data_output_stream_put_int16");
    stub_funcs.ptr_g_data_output_stream_put_uint16 = try_find_sym(gio, "g_data_output_stream_put_uint16");
    stub_funcs.ptr_g_data_output_stream_put_int32 = try_find_sym(gio, "g_data_output_stream_put_int32");
    stub_funcs.ptr_g_data_output_stream_put_uint32 = try_find_sym(gio, "g_data_output_stream_put_uint32");
    stub_funcs.ptr_g_data_output_stream_put_int64 = try_find_sym(gio, "g_data_output_stream_put_int64");
    stub_funcs.ptr_g_data_output_stream_put_uint64 = try_find_sym(gio, "g_data_output_stream_put_uint64");
    stub_funcs.ptr_g_data_output_stream_put_string = try_find_sym(gio, "g_data_output_stream_put_string");
    // Header /usr/include/glib-2.0/gio/gdbusactiongroup.h
    stub_funcs.ptr_g_dbus_action_group_get_type = try_find_sym(gio, "g_dbus_action_group_get_type");
    stub_funcs.ptr_g_dbus_action_group_get = try_find_sym(gio, "g_dbus_action_group_get");
    // Header /usr/include/glib-2.0/gio/gdbusaddress.h
    stub_funcs.ptr_g_dbus_is_address = try_find_sym(gio, "g_dbus_is_address");
    stub_funcs.ptr_g_dbus_is_supported_address = try_find_sym(gio, "g_dbus_is_supported_address");
    stub_funcs.ptr_g_dbus_address_get_stream = try_find_sym(gio, "g_dbus_address_get_stream");
    stub_funcs.ptr_g_dbus_address_get_stream_finish = try_find_sym(gio, "g_dbus_address_get_stream_finish");
    stub_funcs.ptr_g_dbus_address_get_stream_sync = try_find_sym(gio, "g_dbus_address_get_stream_sync");
    stub_funcs.ptr_g_dbus_address_get_for_bus_sync = try_find_sym(gio, "g_dbus_address_get_for_bus_sync");
    stub_funcs.ptr_g_dbus_address_escape_value = try_find_sym(gio, "g_dbus_address_escape_value");
    // Header /usr/include/glib-2.0/gio/gdbusauthobserver.h
    stub_funcs.ptr_g_dbus_auth_observer_get_type = try_find_sym(gio, "g_dbus_auth_observer_get_type");
    stub_funcs.ptr_g_dbus_auth_observer_new = try_find_sym(gio, "g_dbus_auth_observer_new");
    stub_funcs.ptr_g_dbus_auth_observer_authorize_authenticated_peer = try_find_sym(gio, "g_dbus_auth_observer_authorize_authenticated_peer");
    stub_funcs.ptr_g_dbus_auth_observer_allow_mechanism = try_find_sym(gio, "g_dbus_auth_observer_allow_mechanism");
    // Header /usr/include/glib-2.0/gio/gdbusconnection.h
    stub_funcs.ptr_g_dbus_connection_get_type = try_find_sym(gio, "g_dbus_connection_get_type");
    stub_funcs.ptr_g_bus_get = try_find_sym(gio, "g_bus_get");
    stub_funcs.ptr_g_bus_get_finish = try_find_sym(gio, "g_bus_get_finish");
    stub_funcs.ptr_g_bus_get_sync = try_find_sym(gio, "g_bus_get_sync");
    stub_funcs.ptr_g_dbus_connection_new = try_find_sym(gio, "g_dbus_connection_new");
    stub_funcs.ptr_g_dbus_connection_new_finish = try_find_sym(gio, "g_dbus_connection_new_finish");
    stub_funcs.ptr_g_dbus_connection_new_sync = try_find_sym(gio, "g_dbus_connection_new_sync");
    stub_funcs.ptr_g_dbus_connection_new_for_address = try_find_sym(gio, "g_dbus_connection_new_for_address");
    stub_funcs.ptr_g_dbus_connection_new_for_address_finish = try_find_sym(gio, "g_dbus_connection_new_for_address_finish");
    stub_funcs.ptr_g_dbus_connection_new_for_address_sync = try_find_sym(gio, "g_dbus_connection_new_for_address_sync");
    stub_funcs.ptr_g_dbus_connection_start_message_processing = try_find_sym(gio, "g_dbus_connection_start_message_processing");
    stub_funcs.ptr_g_dbus_connection_is_closed = try_find_sym(gio, "g_dbus_connection_is_closed");
    stub_funcs.ptr_g_dbus_connection_get_stream = try_find_sym(gio, "g_dbus_connection_get_stream");
    stub_funcs.ptr_g_dbus_connection_get_guid = try_find_sym(gio, "g_dbus_connection_get_guid");
    stub_funcs.ptr_g_dbus_connection_get_unique_name = try_find_sym(gio, "g_dbus_connection_get_unique_name");
    stub_funcs.ptr_g_dbus_connection_get_peer_credentials = try_find_sym(gio, "g_dbus_connection_get_peer_credentials");
    stub_funcs.ptr_g_dbus_connection_get_last_serial = try_find_sym(gio, "g_dbus_connection_get_last_serial");
    stub_funcs.ptr_g_dbus_connection_get_exit_on_close = try_find_sym(gio, "g_dbus_connection_get_exit_on_close");
    stub_funcs.ptr_g_dbus_connection_set_exit_on_close = try_find_sym(gio, "g_dbus_connection_set_exit_on_close");
    stub_funcs.ptr_g_dbus_connection_get_capabilities = try_find_sym(gio, "g_dbus_connection_get_capabilities");
    stub_funcs.ptr_g_dbus_connection_get_flags = try_find_sym(gio, "g_dbus_connection_get_flags");
    stub_funcs.ptr_g_dbus_connection_close = try_find_sym(gio, "g_dbus_connection_close");
    stub_funcs.ptr_g_dbus_connection_close_finish = try_find_sym(gio, "g_dbus_connection_close_finish");
    stub_funcs.ptr_g_dbus_connection_close_sync = try_find_sym(gio, "g_dbus_connection_close_sync");
    stub_funcs.ptr_g_dbus_connection_flush = try_find_sym(gio, "g_dbus_connection_flush");
    stub_funcs.ptr_g_dbus_connection_flush_finish = try_find_sym(gio, "g_dbus_connection_flush_finish");
    stub_funcs.ptr_g_dbus_connection_flush_sync = try_find_sym(gio, "g_dbus_connection_flush_sync");
    stub_funcs.ptr_g_dbus_connection_send_message = try_find_sym(gio, "g_dbus_connection_send_message");
    stub_funcs.ptr_g_dbus_connection_send_message_with_reply = try_find_sym(gio, "g_dbus_connection_send_message_with_reply");
    stub_funcs.ptr_g_dbus_connection_send_message_with_reply_finish = try_find_sym(gio, "g_dbus_connection_send_message_with_reply_finish");
    stub_funcs.ptr_g_dbus_connection_send_message_with_reply_sync = try_find_sym(gio, "g_dbus_connection_send_message_with_reply_sync");
    stub_funcs.ptr_g_dbus_connection_emit_signal = try_find_sym(gio, "g_dbus_connection_emit_signal");
    stub_funcs.ptr_g_dbus_connection_call = try_find_sym(gio, "g_dbus_connection_call");
    stub_funcs.ptr_g_dbus_connection_call_finish = try_find_sym(gio, "g_dbus_connection_call_finish");
    stub_funcs.ptr_g_dbus_connection_call_sync = try_find_sym(gio, "g_dbus_connection_call_sync");
    stub_funcs.ptr_g_dbus_connection_call_with_unix_fd_list = try_find_sym(gio, "g_dbus_connection_call_with_unix_fd_list");
    stub_funcs.ptr_g_dbus_connection_call_with_unix_fd_list_finish = try_find_sym(gio, "g_dbus_connection_call_with_unix_fd_list_finish");
    stub_funcs.ptr_g_dbus_connection_call_with_unix_fd_list_sync = try_find_sym(gio, "g_dbus_connection_call_with_unix_fd_list_sync");
    stub_funcs.ptr_g_dbus_connection_register_object = try_find_sym(gio, "g_dbus_connection_register_object");
    stub_funcs.ptr_g_dbus_connection_register_object_with_closures = try_find_sym(gio, "g_dbus_connection_register_object_with_closures");
    stub_funcs.ptr_g_dbus_connection_unregister_object = try_find_sym(gio, "g_dbus_connection_unregister_object");
    stub_funcs.ptr_g_dbus_connection_register_subtree = try_find_sym(gio, "g_dbus_connection_register_subtree");
    stub_funcs.ptr_g_dbus_connection_unregister_subtree = try_find_sym(gio, "g_dbus_connection_unregister_subtree");
    stub_funcs.ptr_g_dbus_connection_signal_subscribe = try_find_sym(gio, "g_dbus_connection_signal_subscribe");
    stub_funcs.ptr_g_dbus_connection_signal_unsubscribe = try_find_sym(gio, "g_dbus_connection_signal_unsubscribe");
    stub_funcs.ptr_g_dbus_connection_add_filter = try_find_sym(gio, "g_dbus_connection_add_filter");
    stub_funcs.ptr_g_dbus_connection_remove_filter = try_find_sym(gio, "g_dbus_connection_remove_filter");
    // Header /usr/include/glib-2.0/gio/gdbuserror.h
    stub_funcs.ptr_g_dbus_error_is_remote_error = try_find_sym(gio, "g_dbus_error_is_remote_error");
    stub_funcs.ptr_g_dbus_error_get_remote_error = try_find_sym(gio, "g_dbus_error_get_remote_error");
    stub_funcs.ptr_g_dbus_error_strip_remote_error = try_find_sym(gio, "g_dbus_error_strip_remote_error");
    stub_funcs.ptr_g_dbus_error_register_error = try_find_sym(gio, "g_dbus_error_register_error");
    stub_funcs.ptr_g_dbus_error_unregister_error = try_find_sym(gio, "g_dbus_error_unregister_error");
    stub_funcs.ptr_g_dbus_error_register_error_domain = try_find_sym(gio, "g_dbus_error_register_error_domain");
    stub_funcs.ptr_g_dbus_error_new_for_dbus_error = try_find_sym(gio, "g_dbus_error_new_for_dbus_error");
    stub_funcs.ptr_g_dbus_error_set_dbus_error_valist = try_find_sym(gio, "g_dbus_error_set_dbus_error_valist");
    stub_funcs.ptr_g_dbus_error_encode_gerror = try_find_sym(gio, "g_dbus_error_encode_gerror");
    stub_funcs.ptr_g_dbus_error_quark = try_find_sym(gio, "g_dbus_error_quark");
    // Header /usr/include/glib-2.0/gio/gdbusinterface.h
    stub_funcs.ptr_g_dbus_interface_get_type = try_find_sym(gio, "g_dbus_interface_get_type");
    stub_funcs.ptr_g_dbus_interface_get_info = try_find_sym(gio, "g_dbus_interface_get_info");
    stub_funcs.ptr_g_dbus_interface_get_object = try_find_sym(gio, "g_dbus_interface_get_object");
    stub_funcs.ptr_g_dbus_interface_set_object = try_find_sym(gio, "g_dbus_interface_set_object");
    stub_funcs.ptr_g_dbus_interface_dup_object = try_find_sym(gio, "g_dbus_interface_dup_object");
    // Header /usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h
    stub_funcs.ptr_g_dbus_interface_skeleton_get_type = try_find_sym(gio, "g_dbus_interface_skeleton_get_type");
    stub_funcs.ptr_g_dbus_interface_skeleton_get_flags = try_find_sym(gio, "g_dbus_interface_skeleton_get_flags");
    stub_funcs.ptr_g_dbus_interface_skeleton_set_flags = try_find_sym(gio, "g_dbus_interface_skeleton_set_flags");
    stub_funcs.ptr_g_dbus_interface_skeleton_get_info = try_find_sym(gio, "g_dbus_interface_skeleton_get_info");
    stub_funcs.ptr_g_dbus_interface_skeleton_get_vtable = try_find_sym(gio, "g_dbus_interface_skeleton_get_vtable");
    stub_funcs.ptr_g_dbus_interface_skeleton_get_properties = try_find_sym(gio, "g_dbus_interface_skeleton_get_properties");
    stub_funcs.ptr_g_dbus_interface_skeleton_flush = try_find_sym(gio, "g_dbus_interface_skeleton_flush");
    stub_funcs.ptr_g_dbus_interface_skeleton_export = try_find_sym(gio, "g_dbus_interface_skeleton_export");
    stub_funcs.ptr_g_dbus_interface_skeleton_unexport = try_find_sym(gio, "g_dbus_interface_skeleton_unexport");
    stub_funcs.ptr_g_dbus_interface_skeleton_unexport_from_connection = try_find_sym(gio, "g_dbus_interface_skeleton_unexport_from_connection");
    stub_funcs.ptr_g_dbus_interface_skeleton_get_connection = try_find_sym(gio, "g_dbus_interface_skeleton_get_connection");
    stub_funcs.ptr_g_dbus_interface_skeleton_get_connections = try_find_sym(gio, "g_dbus_interface_skeleton_get_connections");
    stub_funcs.ptr_g_dbus_interface_skeleton_has_connection = try_find_sym(gio, "g_dbus_interface_skeleton_has_connection");
    stub_funcs.ptr_g_dbus_interface_skeleton_get_object_path = try_find_sym(gio, "g_dbus_interface_skeleton_get_object_path");
    // Header /usr/include/glib-2.0/gio/gdbusintrospection.h
    stub_funcs.ptr_g_dbus_interface_info_lookup_method = try_find_sym(gio, "g_dbus_interface_info_lookup_method");
    stub_funcs.ptr_g_dbus_interface_info_lookup_signal = try_find_sym(gio, "g_dbus_interface_info_lookup_signal");
    stub_funcs.ptr_g_dbus_interface_info_lookup_property = try_find_sym(gio, "g_dbus_interface_info_lookup_property");
    stub_funcs.ptr_g_dbus_interface_info_cache_build = try_find_sym(gio, "g_dbus_interface_info_cache_build");
    stub_funcs.ptr_g_dbus_interface_info_cache_release = try_find_sym(gio, "g_dbus_interface_info_cache_release");
    stub_funcs.ptr_g_dbus_interface_info_generate_xml = try_find_sym(gio, "g_dbus_interface_info_generate_xml");
    stub_funcs.ptr_g_dbus_node_info_new_for_xml = try_find_sym(gio, "g_dbus_node_info_new_for_xml");
    stub_funcs.ptr_g_dbus_node_info_lookup_interface = try_find_sym(gio, "g_dbus_node_info_lookup_interface");
    stub_funcs.ptr_g_dbus_node_info_generate_xml = try_find_sym(gio, "g_dbus_node_info_generate_xml");
    stub_funcs.ptr_g_dbus_node_info_ref = try_find_sym(gio, "g_dbus_node_info_ref");
    stub_funcs.ptr_g_dbus_interface_info_ref = try_find_sym(gio, "g_dbus_interface_info_ref");
    stub_funcs.ptr_g_dbus_method_info_ref = try_find_sym(gio, "g_dbus_method_info_ref");
    stub_funcs.ptr_g_dbus_signal_info_ref = try_find_sym(gio, "g_dbus_signal_info_ref");
    stub_funcs.ptr_g_dbus_property_info_ref = try_find_sym(gio, "g_dbus_property_info_ref");
    stub_funcs.ptr_g_dbus_arg_info_ref = try_find_sym(gio, "g_dbus_arg_info_ref");
    stub_funcs.ptr_g_dbus_annotation_info_ref = try_find_sym(gio, "g_dbus_annotation_info_ref");
    stub_funcs.ptr_g_dbus_node_info_unref = try_find_sym(gio, "g_dbus_node_info_unref");
    stub_funcs.ptr_g_dbus_interface_info_unref = try_find_sym(gio, "g_dbus_interface_info_unref");
    stub_funcs.ptr_g_dbus_method_info_unref = try_find_sym(gio, "g_dbus_method_info_unref");
    stub_funcs.ptr_g_dbus_signal_info_unref = try_find_sym(gio, "g_dbus_signal_info_unref");
    stub_funcs.ptr_g_dbus_property_info_unref = try_find_sym(gio, "g_dbus_property_info_unref");
    stub_funcs.ptr_g_dbus_arg_info_unref = try_find_sym(gio, "g_dbus_arg_info_unref");
    stub_funcs.ptr_g_dbus_annotation_info_unref = try_find_sym(gio, "g_dbus_annotation_info_unref");
    stub_funcs.ptr_g_dbus_node_info_get_type = try_find_sym(gio, "g_dbus_node_info_get_type");
    stub_funcs.ptr_g_dbus_interface_info_get_type = try_find_sym(gio, "g_dbus_interface_info_get_type");
    stub_funcs.ptr_g_dbus_method_info_get_type = try_find_sym(gio, "g_dbus_method_info_get_type");
    stub_funcs.ptr_g_dbus_signal_info_get_type = try_find_sym(gio, "g_dbus_signal_info_get_type");
    stub_funcs.ptr_g_dbus_property_info_get_type = try_find_sym(gio, "g_dbus_property_info_get_type");
    stub_funcs.ptr_g_dbus_arg_info_get_type = try_find_sym(gio, "g_dbus_arg_info_get_type");
    stub_funcs.ptr_g_dbus_annotation_info_get_type = try_find_sym(gio, "g_dbus_annotation_info_get_type");
    stub_funcs.ptr_g_dbus_annotation_info_lookup = try_find_sym(gio, "g_dbus_annotation_info_lookup");
    // Header /usr/include/glib-2.0/gio/gdbusmenumodel.h
    stub_funcs.ptr_g_dbus_menu_model_get_type = try_find_sym(gio, "g_dbus_menu_model_get_type");
    stub_funcs.ptr_g_dbus_menu_model_get = try_find_sym(gio, "g_dbus_menu_model_get");
    // Header /usr/include/glib-2.0/gio/gdbusmessage.h
    stub_funcs.ptr_g_dbus_message_get_type = try_find_sym(gio, "g_dbus_message_get_type");
    stub_funcs.ptr_g_dbus_message_new = try_find_sym(gio, "g_dbus_message_new");
    stub_funcs.ptr_g_dbus_message_new_signal = try_find_sym(gio, "g_dbus_message_new_signal");
    stub_funcs.ptr_g_dbus_message_new_method_call = try_find_sym(gio, "g_dbus_message_new_method_call");
    stub_funcs.ptr_g_dbus_message_new_method_reply = try_find_sym(gio, "g_dbus_message_new_method_reply");
    stub_funcs.ptr_g_dbus_message_new_method_error_valist = try_find_sym(gio, "g_dbus_message_new_method_error_valist");
    stub_funcs.ptr_g_dbus_message_new_method_error_literal = try_find_sym(gio, "g_dbus_message_new_method_error_literal");
    stub_funcs.ptr_g_dbus_message_print = try_find_sym(gio, "g_dbus_message_print");
    stub_funcs.ptr_g_dbus_message_get_locked = try_find_sym(gio, "g_dbus_message_get_locked");
    stub_funcs.ptr_g_dbus_message_lock = try_find_sym(gio, "g_dbus_message_lock");
    stub_funcs.ptr_g_dbus_message_copy = try_find_sym(gio, "g_dbus_message_copy");
    stub_funcs.ptr_g_dbus_message_get_byte_order = try_find_sym(gio, "g_dbus_message_get_byte_order");
    stub_funcs.ptr_g_dbus_message_set_byte_order = try_find_sym(gio, "g_dbus_message_set_byte_order");
    stub_funcs.ptr_g_dbus_message_get_message_type = try_find_sym(gio, "g_dbus_message_get_message_type");
    stub_funcs.ptr_g_dbus_message_set_message_type = try_find_sym(gio, "g_dbus_message_set_message_type");
    stub_funcs.ptr_g_dbus_message_get_flags = try_find_sym(gio, "g_dbus_message_get_flags");
    stub_funcs.ptr_g_dbus_message_set_flags = try_find_sym(gio, "g_dbus_message_set_flags");
    stub_funcs.ptr_g_dbus_message_get_serial = try_find_sym(gio, "g_dbus_message_get_serial");
    stub_funcs.ptr_g_dbus_message_set_serial = try_find_sym(gio, "g_dbus_message_set_serial");
    stub_funcs.ptr_g_dbus_message_get_header = try_find_sym(gio, "g_dbus_message_get_header");
    stub_funcs.ptr_g_dbus_message_set_header = try_find_sym(gio, "g_dbus_message_set_header");
    stub_funcs.ptr_g_dbus_message_get_header_fields = try_find_sym(gio, "g_dbus_message_get_header_fields");
    stub_funcs.ptr_g_dbus_message_get_body = try_find_sym(gio, "g_dbus_message_get_body");
    stub_funcs.ptr_g_dbus_message_set_body = try_find_sym(gio, "g_dbus_message_set_body");
    stub_funcs.ptr_g_dbus_message_get_unix_fd_list = try_find_sym(gio, "g_dbus_message_get_unix_fd_list");
    stub_funcs.ptr_g_dbus_message_set_unix_fd_list = try_find_sym(gio, "g_dbus_message_set_unix_fd_list");
    stub_funcs.ptr_g_dbus_message_get_reply_serial = try_find_sym(gio, "g_dbus_message_get_reply_serial");
    stub_funcs.ptr_g_dbus_message_set_reply_serial = try_find_sym(gio, "g_dbus_message_set_reply_serial");
    stub_funcs.ptr_g_dbus_message_get_interface = try_find_sym(gio, "g_dbus_message_get_interface");
    stub_funcs.ptr_g_dbus_message_set_interface = try_find_sym(gio, "g_dbus_message_set_interface");
    stub_funcs.ptr_g_dbus_message_get_member = try_find_sym(gio, "g_dbus_message_get_member");
    stub_funcs.ptr_g_dbus_message_set_member = try_find_sym(gio, "g_dbus_message_set_member");
    stub_funcs.ptr_g_dbus_message_get_path = try_find_sym(gio, "g_dbus_message_get_path");
    stub_funcs.ptr_g_dbus_message_set_path = try_find_sym(gio, "g_dbus_message_set_path");
    stub_funcs.ptr_g_dbus_message_get_sender = try_find_sym(gio, "g_dbus_message_get_sender");
    stub_funcs.ptr_g_dbus_message_set_sender = try_find_sym(gio, "g_dbus_message_set_sender");
    stub_funcs.ptr_g_dbus_message_get_destination = try_find_sym(gio, "g_dbus_message_get_destination");
    stub_funcs.ptr_g_dbus_message_set_destination = try_find_sym(gio, "g_dbus_message_set_destination");
    stub_funcs.ptr_g_dbus_message_get_error_name = try_find_sym(gio, "g_dbus_message_get_error_name");
    stub_funcs.ptr_g_dbus_message_set_error_name = try_find_sym(gio, "g_dbus_message_set_error_name");
    stub_funcs.ptr_g_dbus_message_get_signature = try_find_sym(gio, "g_dbus_message_get_signature");
    stub_funcs.ptr_g_dbus_message_set_signature = try_find_sym(gio, "g_dbus_message_set_signature");
    stub_funcs.ptr_g_dbus_message_get_num_unix_fds = try_find_sym(gio, "g_dbus_message_get_num_unix_fds");
    stub_funcs.ptr_g_dbus_message_set_num_unix_fds = try_find_sym(gio, "g_dbus_message_set_num_unix_fds");
    stub_funcs.ptr_g_dbus_message_get_arg0 = try_find_sym(gio, "g_dbus_message_get_arg0");
    stub_funcs.ptr_g_dbus_message_get_arg0_path = try_find_sym(gio, "g_dbus_message_get_arg0_path");
    stub_funcs.ptr_g_dbus_message_new_from_blob = try_find_sym(gio, "g_dbus_message_new_from_blob");
    stub_funcs.ptr_g_dbus_message_bytes_needed = try_find_sym(gio, "g_dbus_message_bytes_needed");
    stub_funcs.ptr_g_dbus_message_to_blob = try_find_sym(gio, "g_dbus_message_to_blob");
    stub_funcs.ptr_g_dbus_message_to_gerror = try_find_sym(gio, "g_dbus_message_to_gerror");
    // Header /usr/include/glib-2.0/gio/gdbusmethodinvocation.h
    stub_funcs.ptr_g_dbus_method_invocation_get_type = try_find_sym(gio, "g_dbus_method_invocation_get_type");
    stub_funcs.ptr_g_dbus_method_invocation_get_sender = try_find_sym(gio, "g_dbus_method_invocation_get_sender");
    stub_funcs.ptr_g_dbus_method_invocation_get_object_path = try_find_sym(gio, "g_dbus_method_invocation_get_object_path");
    stub_funcs.ptr_g_dbus_method_invocation_get_interface_name = try_find_sym(gio, "g_dbus_method_invocation_get_interface_name");
    stub_funcs.ptr_g_dbus_method_invocation_get_method_name = try_find_sym(gio, "g_dbus_method_invocation_get_method_name");
    stub_funcs.ptr_g_dbus_method_invocation_get_method_info = try_find_sym(gio, "g_dbus_method_invocation_get_method_info");
    stub_funcs.ptr_g_dbus_method_invocation_get_property_info = try_find_sym(gio, "g_dbus_method_invocation_get_property_info");
    stub_funcs.ptr_g_dbus_method_invocation_get_connection = try_find_sym(gio, "g_dbus_method_invocation_get_connection");
    stub_funcs.ptr_g_dbus_method_invocation_get_message = try_find_sym(gio, "g_dbus_method_invocation_get_message");
    stub_funcs.ptr_g_dbus_method_invocation_get_parameters = try_find_sym(gio, "g_dbus_method_invocation_get_parameters");
    stub_funcs.ptr_g_dbus_method_invocation_get_user_data = try_find_sym(gio, "g_dbus_method_invocation_get_user_data");
    stub_funcs.ptr_g_dbus_method_invocation_return_value = try_find_sym(gio, "g_dbus_method_invocation_return_value");
    stub_funcs.ptr_g_dbus_method_invocation_return_value_with_unix_fd_list = try_find_sym(gio, "g_dbus_method_invocation_return_value_with_unix_fd_list");
    stub_funcs.ptr_g_dbus_method_invocation_return_error_valist = try_find_sym(gio, "g_dbus_method_invocation_return_error_valist");
    stub_funcs.ptr_g_dbus_method_invocation_return_error_literal = try_find_sym(gio, "g_dbus_method_invocation_return_error_literal");
    stub_funcs.ptr_g_dbus_method_invocation_return_gerror = try_find_sym(gio, "g_dbus_method_invocation_return_gerror");
    stub_funcs.ptr_g_dbus_method_invocation_take_error = try_find_sym(gio, "g_dbus_method_invocation_take_error");
    stub_funcs.ptr_g_dbus_method_invocation_return_dbus_error = try_find_sym(gio, "g_dbus_method_invocation_return_dbus_error");
    // Header /usr/include/glib-2.0/gio/gdbusnameowning.h
    stub_funcs.ptr_g_bus_own_name_on_connection = try_find_sym(gio, "g_bus_own_name_on_connection");
    stub_funcs.ptr_g_bus_own_name_with_closures = try_find_sym(gio, "g_bus_own_name_with_closures");
    stub_funcs.ptr_g_bus_own_name_on_connection_with_closures = try_find_sym(gio, "g_bus_own_name_on_connection_with_closures");
    stub_funcs.ptr_g_bus_unown_name = try_find_sym(gio, "g_bus_unown_name");
    stub_funcs.ptr_g_bus_own_name = try_find_sym(gio, "g_bus_own_name");
    // Header /usr/include/glib-2.0/gio/gdbusnamewatching.h
    stub_funcs.ptr_g_bus_watch_name_on_connection = try_find_sym(gio, "g_bus_watch_name_on_connection");
    stub_funcs.ptr_g_bus_watch_name_with_closures = try_find_sym(gio, "g_bus_watch_name_with_closures");
    stub_funcs.ptr_g_bus_watch_name_on_connection_with_closures = try_find_sym(gio, "g_bus_watch_name_on_connection_with_closures");
    stub_funcs.ptr_g_bus_unwatch_name = try_find_sym(gio, "g_bus_unwatch_name");
    stub_funcs.ptr_g_bus_watch_name = try_find_sym(gio, "g_bus_watch_name");
    // Header /usr/include/glib-2.0/gio/gdbusobject.h
    stub_funcs.ptr_g_dbus_object_get_type = try_find_sym(gio, "g_dbus_object_get_type");
    stub_funcs.ptr_g_dbus_object_get_object_path = try_find_sym(gio, "g_dbus_object_get_object_path");
    stub_funcs.ptr_g_dbus_object_get_interfaces = try_find_sym(gio, "g_dbus_object_get_interfaces");
    stub_funcs.ptr_g_dbus_object_get_interface = try_find_sym(gio, "g_dbus_object_get_interface");
    // Header /usr/include/glib-2.0/gio/gdbusobjectmanager.h
    stub_funcs.ptr_g_dbus_object_manager_get_type = try_find_sym(gio, "g_dbus_object_manager_get_type");
    stub_funcs.ptr_g_dbus_object_manager_get_object_path = try_find_sym(gio, "g_dbus_object_manager_get_object_path");
    stub_funcs.ptr_g_dbus_object_manager_get_objects = try_find_sym(gio, "g_dbus_object_manager_get_objects");
    stub_funcs.ptr_g_dbus_object_manager_get_object = try_find_sym(gio, "g_dbus_object_manager_get_object");
    stub_funcs.ptr_g_dbus_object_manager_get_interface = try_find_sym(gio, "g_dbus_object_manager_get_interface");
    // Header /usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h
    stub_funcs.ptr_g_dbus_object_manager_client_get_type = try_find_sym(gio, "g_dbus_object_manager_client_get_type");
    stub_funcs.ptr_g_dbus_object_manager_client_new = try_find_sym(gio, "g_dbus_object_manager_client_new");
    stub_funcs.ptr_g_dbus_object_manager_client_new_finish = try_find_sym(gio, "g_dbus_object_manager_client_new_finish");
    stub_funcs.ptr_g_dbus_object_manager_client_new_sync = try_find_sym(gio, "g_dbus_object_manager_client_new_sync");
    stub_funcs.ptr_g_dbus_object_manager_client_new_for_bus = try_find_sym(gio, "g_dbus_object_manager_client_new_for_bus");
    stub_funcs.ptr_g_dbus_object_manager_client_new_for_bus_finish = try_find_sym(gio, "g_dbus_object_manager_client_new_for_bus_finish");
    stub_funcs.ptr_g_dbus_object_manager_client_new_for_bus_sync = try_find_sym(gio, "g_dbus_object_manager_client_new_for_bus_sync");
    stub_funcs.ptr_g_dbus_object_manager_client_get_connection = try_find_sym(gio, "g_dbus_object_manager_client_get_connection");
    stub_funcs.ptr_g_dbus_object_manager_client_get_flags = try_find_sym(gio, "g_dbus_object_manager_client_get_flags");
    stub_funcs.ptr_g_dbus_object_manager_client_get_name = try_find_sym(gio, "g_dbus_object_manager_client_get_name");
    stub_funcs.ptr_g_dbus_object_manager_client_get_name_owner = try_find_sym(gio, "g_dbus_object_manager_client_get_name_owner");
    // Header /usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h
    stub_funcs.ptr_g_dbus_object_manager_server_get_type = try_find_sym(gio, "g_dbus_object_manager_server_get_type");
    stub_funcs.ptr_g_dbus_object_manager_server_new = try_find_sym(gio, "g_dbus_object_manager_server_new");
    stub_funcs.ptr_g_dbus_object_manager_server_get_connection = try_find_sym(gio, "g_dbus_object_manager_server_get_connection");
    stub_funcs.ptr_g_dbus_object_manager_server_set_connection = try_find_sym(gio, "g_dbus_object_manager_server_set_connection");
    stub_funcs.ptr_g_dbus_object_manager_server_export = try_find_sym(gio, "g_dbus_object_manager_server_export");
    stub_funcs.ptr_g_dbus_object_manager_server_export_uniquely = try_find_sym(gio, "g_dbus_object_manager_server_export_uniquely");
    stub_funcs.ptr_g_dbus_object_manager_server_is_exported = try_find_sym(gio, "g_dbus_object_manager_server_is_exported");
    stub_funcs.ptr_g_dbus_object_manager_server_unexport = try_find_sym(gio, "g_dbus_object_manager_server_unexport");
    // Header /usr/include/glib-2.0/gio/gdbusobjectproxy.h
    stub_funcs.ptr_g_dbus_object_proxy_get_type = try_find_sym(gio, "g_dbus_object_proxy_get_type");
    stub_funcs.ptr_g_dbus_object_proxy_new = try_find_sym(gio, "g_dbus_object_proxy_new");
    stub_funcs.ptr_g_dbus_object_proxy_get_connection = try_find_sym(gio, "g_dbus_object_proxy_get_connection");
    // Header /usr/include/glib-2.0/gio/gdbusobjectskeleton.h
    stub_funcs.ptr_g_dbus_object_skeleton_get_type = try_find_sym(gio, "g_dbus_object_skeleton_get_type");
    stub_funcs.ptr_g_dbus_object_skeleton_new = try_find_sym(gio, "g_dbus_object_skeleton_new");
    stub_funcs.ptr_g_dbus_object_skeleton_flush = try_find_sym(gio, "g_dbus_object_skeleton_flush");
    stub_funcs.ptr_g_dbus_object_skeleton_add_interface = try_find_sym(gio, "g_dbus_object_skeleton_add_interface");
    stub_funcs.ptr_g_dbus_object_skeleton_remove_interface = try_find_sym(gio, "g_dbus_object_skeleton_remove_interface");
    stub_funcs.ptr_g_dbus_object_skeleton_remove_interface_by_name = try_find_sym(gio, "g_dbus_object_skeleton_remove_interface_by_name");
    stub_funcs.ptr_g_dbus_object_skeleton_set_object_path = try_find_sym(gio, "g_dbus_object_skeleton_set_object_path");
    // Header /usr/include/glib-2.0/gio/gdbusproxy.h
    stub_funcs.ptr_g_dbus_proxy_get_type = try_find_sym(gio, "g_dbus_proxy_get_type");
    stub_funcs.ptr_g_dbus_proxy_new = try_find_sym(gio, "g_dbus_proxy_new");
    stub_funcs.ptr_g_dbus_proxy_new_finish = try_find_sym(gio, "g_dbus_proxy_new_finish");
    stub_funcs.ptr_g_dbus_proxy_new_sync = try_find_sym(gio, "g_dbus_proxy_new_sync");
    stub_funcs.ptr_g_dbus_proxy_new_for_bus = try_find_sym(gio, "g_dbus_proxy_new_for_bus");
    stub_funcs.ptr_g_dbus_proxy_new_for_bus_finish = try_find_sym(gio, "g_dbus_proxy_new_for_bus_finish");
    stub_funcs.ptr_g_dbus_proxy_new_for_bus_sync = try_find_sym(gio, "g_dbus_proxy_new_for_bus_sync");
    stub_funcs.ptr_g_dbus_proxy_get_connection = try_find_sym(gio, "g_dbus_proxy_get_connection");
    stub_funcs.ptr_g_dbus_proxy_get_flags = try_find_sym(gio, "g_dbus_proxy_get_flags");
    stub_funcs.ptr_g_dbus_proxy_get_name = try_find_sym(gio, "g_dbus_proxy_get_name");
    stub_funcs.ptr_g_dbus_proxy_get_name_owner = try_find_sym(gio, "g_dbus_proxy_get_name_owner");
    stub_funcs.ptr_g_dbus_proxy_get_object_path = try_find_sym(gio, "g_dbus_proxy_get_object_path");
    stub_funcs.ptr_g_dbus_proxy_get_interface_name = try_find_sym(gio, "g_dbus_proxy_get_interface_name");
    stub_funcs.ptr_g_dbus_proxy_get_default_timeout = try_find_sym(gio, "g_dbus_proxy_get_default_timeout");
    stub_funcs.ptr_g_dbus_proxy_set_default_timeout = try_find_sym(gio, "g_dbus_proxy_set_default_timeout");
    stub_funcs.ptr_g_dbus_proxy_get_interface_info = try_find_sym(gio, "g_dbus_proxy_get_interface_info");
    stub_funcs.ptr_g_dbus_proxy_set_interface_info = try_find_sym(gio, "g_dbus_proxy_set_interface_info");
    stub_funcs.ptr_g_dbus_proxy_get_cached_property = try_find_sym(gio, "g_dbus_proxy_get_cached_property");
    stub_funcs.ptr_g_dbus_proxy_set_cached_property = try_find_sym(gio, "g_dbus_proxy_set_cached_property");
    stub_funcs.ptr_g_dbus_proxy_get_cached_property_names = try_find_sym(gio, "g_dbus_proxy_get_cached_property_names");
    stub_funcs.ptr_g_dbus_proxy_call = try_find_sym(gio, "g_dbus_proxy_call");
    stub_funcs.ptr_g_dbus_proxy_call_finish = try_find_sym(gio, "g_dbus_proxy_call_finish");
    stub_funcs.ptr_g_dbus_proxy_call_sync = try_find_sym(gio, "g_dbus_proxy_call_sync");
    stub_funcs.ptr_g_dbus_proxy_call_with_unix_fd_list = try_find_sym(gio, "g_dbus_proxy_call_with_unix_fd_list");
    stub_funcs.ptr_g_dbus_proxy_call_with_unix_fd_list_finish = try_find_sym(gio, "g_dbus_proxy_call_with_unix_fd_list_finish");
    stub_funcs.ptr_g_dbus_proxy_call_with_unix_fd_list_sync = try_find_sym(gio, "g_dbus_proxy_call_with_unix_fd_list_sync");
    // Header /usr/include/glib-2.0/gio/gdbusserver.h
    stub_funcs.ptr_g_dbus_server_get_type = try_find_sym(gio, "g_dbus_server_get_type");
    stub_funcs.ptr_g_dbus_server_new_sync = try_find_sym(gio, "g_dbus_server_new_sync");
    stub_funcs.ptr_g_dbus_server_get_client_address = try_find_sym(gio, "g_dbus_server_get_client_address");
    stub_funcs.ptr_g_dbus_server_get_guid = try_find_sym(gio, "g_dbus_server_get_guid");
    stub_funcs.ptr_g_dbus_server_get_flags = try_find_sym(gio, "g_dbus_server_get_flags");
    stub_funcs.ptr_g_dbus_server_start = try_find_sym(gio, "g_dbus_server_start");
    stub_funcs.ptr_g_dbus_server_stop = try_find_sym(gio, "g_dbus_server_stop");
    stub_funcs.ptr_g_dbus_server_is_active = try_find_sym(gio, "g_dbus_server_is_active");
    // Header /usr/include/glib-2.0/gio/gdbusutils.h
    stub_funcs.ptr_g_dbus_generate_guid = try_find_sym(gio, "g_dbus_generate_guid");
    stub_funcs.ptr_g_dbus_is_name = try_find_sym(gio, "g_dbus_is_name");
    stub_funcs.ptr_g_dbus_is_unique_name = try_find_sym(gio, "g_dbus_is_unique_name");
    stub_funcs.ptr_g_dbus_is_member_name = try_find_sym(gio, "g_dbus_is_member_name");
    stub_funcs.ptr_g_dbus_is_interface_name = try_find_sym(gio, "g_dbus_is_interface_name");
    stub_funcs.ptr_g_dbus_is_error_name = try_find_sym(gio, "g_dbus_is_error_name");
    stub_funcs.ptr_g_dbus_gvariant_to_gvalue = try_find_sym(gio, "g_dbus_gvariant_to_gvalue");
    stub_funcs.ptr_g_dbus_gvalue_to_gvariant = try_find_sym(gio, "g_dbus_gvalue_to_gvariant");
    stub_funcs.ptr_g_dbus_escape_object_path_bytestring = try_find_sym(gio, "g_dbus_escape_object_path_bytestring");
    stub_funcs.ptr_g_dbus_escape_object_path = try_find_sym(gio, "g_dbus_escape_object_path");
    stub_funcs.ptr_g_dbus_unescape_object_path = try_find_sym(gio, "g_dbus_unescape_object_path");
    stub_funcs.ptr_g_dbus_is_guid = try_find_sym(gio, "g_dbus_is_guid");
    // Header /usr/include/glib-2.0/gio/gdebugcontroller.h
    stub_funcs.ptr_g_debug_controller_get_type = try_find_sym(gio, "g_debug_controller_get_type");
    stub_funcs.ptr_g_debug_controller_set_debug_enabled = try_find_sym(gio, "g_debug_controller_set_debug_enabled");
    // Header /usr/include/glib-2.0/gio/gdebugcontrollerdbus.h
    stub_funcs.ptr_g_debug_controller_dbus_get_type = try_find_sym(gio, "g_debug_controller_dbus_get_type");
    stub_funcs.ptr_g_debug_controller_dbus_new = try_find_sym(gio, "g_debug_controller_dbus_new");
    stub_funcs.ptr_g_debug_controller_dbus_stop = try_find_sym(gio, "g_debug_controller_dbus_stop");
    // Header /usr/include/glib-2.0/gio/gdrive.h
    stub_funcs.ptr_g_drive_get_type = try_find_sym(gio, "g_drive_get_type");
    stub_funcs.ptr_g_drive_get_name = try_find_sym(gio, "g_drive_get_name");
    stub_funcs.ptr_g_drive_get_icon = try_find_sym(gio, "g_drive_get_icon");
    stub_funcs.ptr_g_drive_get_symbolic_icon = try_find_sym(gio, "g_drive_get_symbolic_icon");
    stub_funcs.ptr_g_drive_has_volumes = try_find_sym(gio, "g_drive_has_volumes");
    stub_funcs.ptr_g_drive_get_volumes = try_find_sym(gio, "g_drive_get_volumes");
    stub_funcs.ptr_g_drive_is_removable = try_find_sym(gio, "g_drive_is_removable");
    stub_funcs.ptr_g_drive_is_media_removable = try_find_sym(gio, "g_drive_is_media_removable");
    stub_funcs.ptr_g_drive_has_media = try_find_sym(gio, "g_drive_has_media");
    stub_funcs.ptr_g_drive_is_media_check_automatic = try_find_sym(gio, "g_drive_is_media_check_automatic");
    stub_funcs.ptr_g_drive_can_poll_for_media = try_find_sym(gio, "g_drive_can_poll_for_media");
    stub_funcs.ptr_g_drive_can_eject = try_find_sym(gio, "g_drive_can_eject");
    stub_funcs.ptr_g_drive_eject = try_find_sym(gio, "g_drive_eject");
    stub_funcs.ptr_g_drive_eject_finish = try_find_sym(gio, "g_drive_eject_finish");
    stub_funcs.ptr_g_drive_poll_for_media = try_find_sym(gio, "g_drive_poll_for_media");
    stub_funcs.ptr_g_drive_poll_for_media_finish = try_find_sym(gio, "g_drive_poll_for_media_finish");
    stub_funcs.ptr_g_drive_get_identifier = try_find_sym(gio, "g_drive_get_identifier");
    stub_funcs.ptr_g_drive_enumerate_identifiers = try_find_sym(gio, "g_drive_enumerate_identifiers");
    stub_funcs.ptr_g_drive_get_start_stop_type = try_find_sym(gio, "g_drive_get_start_stop_type");
    stub_funcs.ptr_g_drive_can_start = try_find_sym(gio, "g_drive_can_start");
    stub_funcs.ptr_g_drive_can_start_degraded = try_find_sym(gio, "g_drive_can_start_degraded");
    stub_funcs.ptr_g_drive_start = try_find_sym(gio, "g_drive_start");
    stub_funcs.ptr_g_drive_start_finish = try_find_sym(gio, "g_drive_start_finish");
    stub_funcs.ptr_g_drive_can_stop = try_find_sym(gio, "g_drive_can_stop");
    stub_funcs.ptr_g_drive_stop = try_find_sym(gio, "g_drive_stop");
    stub_funcs.ptr_g_drive_stop_finish = try_find_sym(gio, "g_drive_stop_finish");
    stub_funcs.ptr_g_drive_eject_with_operation = try_find_sym(gio, "g_drive_eject_with_operation");
    stub_funcs.ptr_g_drive_eject_with_operation_finish = try_find_sym(gio, "g_drive_eject_with_operation_finish");
    stub_funcs.ptr_g_drive_get_sort_key = try_find_sym(gio, "g_drive_get_sort_key");
    // Header /usr/include/glib-2.0/gio/gdtlsclientconnection.h
    stub_funcs.ptr_g_dtls_client_connection_get_type = try_find_sym(gio, "g_dtls_client_connection_get_type");
    stub_funcs.ptr_g_dtls_client_connection_new = try_find_sym(gio, "g_dtls_client_connection_new");
    stub_funcs.ptr_g_dtls_client_connection_get_validation_flags = try_find_sym(gio, "g_dtls_client_connection_get_validation_flags");
    stub_funcs.ptr_g_dtls_client_connection_set_validation_flags = try_find_sym(gio, "g_dtls_client_connection_set_validation_flags");
    stub_funcs.ptr_g_dtls_client_connection_get_server_identity = try_find_sym(gio, "g_dtls_client_connection_get_server_identity");
    stub_funcs.ptr_g_dtls_client_connection_set_server_identity = try_find_sym(gio, "g_dtls_client_connection_set_server_identity");
    stub_funcs.ptr_g_dtls_client_connection_get_accepted_cas = try_find_sym(gio, "g_dtls_client_connection_get_accepted_cas");
    // Header /usr/include/glib-2.0/gio/gdtlsconnection.h
    stub_funcs.ptr_g_dtls_connection_get_type = try_find_sym(gio, "g_dtls_connection_get_type");
    stub_funcs.ptr_g_dtls_connection_set_database = try_find_sym(gio, "g_dtls_connection_set_database");
    stub_funcs.ptr_g_dtls_connection_get_database = try_find_sym(gio, "g_dtls_connection_get_database");
    stub_funcs.ptr_g_dtls_connection_set_certificate = try_find_sym(gio, "g_dtls_connection_set_certificate");
    stub_funcs.ptr_g_dtls_connection_get_certificate = try_find_sym(gio, "g_dtls_connection_get_certificate");
    stub_funcs.ptr_g_dtls_connection_set_interaction = try_find_sym(gio, "g_dtls_connection_set_interaction");
    stub_funcs.ptr_g_dtls_connection_get_interaction = try_find_sym(gio, "g_dtls_connection_get_interaction");
    stub_funcs.ptr_g_dtls_connection_get_peer_certificate = try_find_sym(gio, "g_dtls_connection_get_peer_certificate");
    stub_funcs.ptr_g_dtls_connection_get_peer_certificate_errors = try_find_sym(gio, "g_dtls_connection_get_peer_certificate_errors");
    stub_funcs.ptr_g_dtls_connection_set_require_close_notify = try_find_sym(gio, "g_dtls_connection_set_require_close_notify");
    stub_funcs.ptr_g_dtls_connection_get_require_close_notify = try_find_sym(gio, "g_dtls_connection_get_require_close_notify");
    stub_funcs.ptr_g_dtls_connection_get_rehandshake_mode = try_find_sym(gio, "g_dtls_connection_get_rehandshake_mode");
    stub_funcs.ptr_g_dtls_connection_handshake_async = try_find_sym(gio, "g_dtls_connection_handshake_async");
    stub_funcs.ptr_g_dtls_connection_handshake_finish = try_find_sym(gio, "g_dtls_connection_handshake_finish");
    stub_funcs.ptr_g_dtls_connection_shutdown = try_find_sym(gio, "g_dtls_connection_shutdown");
    stub_funcs.ptr_g_dtls_connection_shutdown_async = try_find_sym(gio, "g_dtls_connection_shutdown_async");
    stub_funcs.ptr_g_dtls_connection_shutdown_finish = try_find_sym(gio, "g_dtls_connection_shutdown_finish");
    stub_funcs.ptr_g_dtls_connection_close = try_find_sym(gio, "g_dtls_connection_close");
    stub_funcs.ptr_g_dtls_connection_close_async = try_find_sym(gio, "g_dtls_connection_close_async");
    stub_funcs.ptr_g_dtls_connection_close_finish = try_find_sym(gio, "g_dtls_connection_close_finish");
    stub_funcs.ptr_g_dtls_connection_emit_accept_certificate = try_find_sym(gio, "g_dtls_connection_emit_accept_certificate");
    stub_funcs.ptr_g_dtls_connection_set_advertised_protocols = try_find_sym(gio, "g_dtls_connection_set_advertised_protocols");
    stub_funcs.ptr_g_dtls_connection_get_negotiated_protocol = try_find_sym(gio, "g_dtls_connection_get_negotiated_protocol");
    stub_funcs.ptr_g_dtls_connection_get_ciphersuite_name = try_find_sym(gio, "g_dtls_connection_get_ciphersuite_name");
    // Header /usr/include/glib-2.0/gio/gdtlsserverconnection.h
    stub_funcs.ptr_g_dtls_server_connection_get_type = try_find_sym(gio, "g_dtls_server_connection_get_type");
    stub_funcs.ptr_g_dtls_server_connection_new = try_find_sym(gio, "g_dtls_server_connection_new");
    // Header /usr/include/glib-2.0/gio/gemblem.h
    stub_funcs.ptr_g_emblem_get_type = try_find_sym(gio, "g_emblem_get_type");
    stub_funcs.ptr_g_emblem_new = try_find_sym(gio, "g_emblem_new");
    stub_funcs.ptr_g_emblem_new_with_origin = try_find_sym(gio, "g_emblem_new_with_origin");
    stub_funcs.ptr_g_emblem_get_icon = try_find_sym(gio, "g_emblem_get_icon");
    stub_funcs.ptr_g_emblem_get_origin = try_find_sym(gio, "g_emblem_get_origin");
    // Header /usr/include/glib-2.0/gio/gemblemedicon.h
    stub_funcs.ptr_g_emblemed_icon_get_type = try_find_sym(gio, "g_emblemed_icon_get_type");
    stub_funcs.ptr_g_emblemed_icon_new = try_find_sym(gio, "g_emblemed_icon_new");
    stub_funcs.ptr_g_emblemed_icon_get_icon = try_find_sym(gio, "g_emblemed_icon_get_icon");
    stub_funcs.ptr_g_emblemed_icon_get_emblems = try_find_sym(gio, "g_emblemed_icon_get_emblems");
    stub_funcs.ptr_g_emblemed_icon_add_emblem = try_find_sym(gio, "g_emblemed_icon_add_emblem");
    stub_funcs.ptr_g_emblemed_icon_clear_emblems = try_find_sym(gio, "g_emblemed_icon_clear_emblems");
    // Header /usr/include/glib-2.0/gio/gfile.h
    stub_funcs.ptr_g_file_get_type = try_find_sym(gio, "g_file_get_type");
    stub_funcs.ptr_g_file_new_for_path = try_find_sym(gio, "g_file_new_for_path");
    stub_funcs.ptr_g_file_new_for_uri = try_find_sym(gio, "g_file_new_for_uri");
    stub_funcs.ptr_g_file_new_for_commandline_arg = try_find_sym(gio, "g_file_new_for_commandline_arg");
    stub_funcs.ptr_g_file_new_for_commandline_arg_and_cwd = try_find_sym(gio, "g_file_new_for_commandline_arg_and_cwd");
    stub_funcs.ptr_g_file_new_tmp = try_find_sym(gio, "g_file_new_tmp");
    stub_funcs.ptr_g_file_new_tmp_async = try_find_sym(gio, "g_file_new_tmp_async");
    stub_funcs.ptr_g_file_new_tmp_finish = try_find_sym(gio, "g_file_new_tmp_finish");
    stub_funcs.ptr_g_file_new_tmp_dir_async = try_find_sym(gio, "g_file_new_tmp_dir_async");
    stub_funcs.ptr_g_file_new_tmp_dir_finish = try_find_sym(gio, "g_file_new_tmp_dir_finish");
    stub_funcs.ptr_g_file_parse_name = try_find_sym(gio, "g_file_parse_name");
    stub_funcs.ptr_g_file_new_build_filenamev = try_find_sym(gio, "g_file_new_build_filenamev");
    stub_funcs.ptr_g_file_dup = try_find_sym(gio, "g_file_dup");
    stub_funcs.ptr_g_file_hash = try_find_sym(gio, "g_file_hash");
    stub_funcs.ptr_g_file_equal = try_find_sym(gio, "g_file_equal");
    stub_funcs.ptr_g_file_get_basename = try_find_sym(gio, "g_file_get_basename");
    stub_funcs.ptr_g_file_get_path = try_find_sym(gio, "g_file_get_path");
    stub_funcs.ptr_g_file_peek_path = try_find_sym(gio, "g_file_peek_path");
    stub_funcs.ptr_g_file_get_uri = try_find_sym(gio, "g_file_get_uri");
    stub_funcs.ptr_g_file_get_parse_name = try_find_sym(gio, "g_file_get_parse_name");
    stub_funcs.ptr_g_file_get_parent = try_find_sym(gio, "g_file_get_parent");
    stub_funcs.ptr_g_file_has_parent = try_find_sym(gio, "g_file_has_parent");
    stub_funcs.ptr_g_file_get_child = try_find_sym(gio, "g_file_get_child");
    stub_funcs.ptr_g_file_get_child_for_display_name = try_find_sym(gio, "g_file_get_child_for_display_name");
    stub_funcs.ptr_g_file_has_prefix = try_find_sym(gio, "g_file_has_prefix");
    stub_funcs.ptr_g_file_get_relative_path = try_find_sym(gio, "g_file_get_relative_path");
    stub_funcs.ptr_g_file_resolve_relative_path = try_find_sym(gio, "g_file_resolve_relative_path");
    stub_funcs.ptr_g_file_is_native = try_find_sym(gio, "g_file_is_native");
    stub_funcs.ptr_g_file_has_uri_scheme = try_find_sym(gio, "g_file_has_uri_scheme");
    stub_funcs.ptr_g_file_get_uri_scheme = try_find_sym(gio, "g_file_get_uri_scheme");
    stub_funcs.ptr_g_file_read = try_find_sym(gio, "g_file_read");
    stub_funcs.ptr_g_file_read_async = try_find_sym(gio, "g_file_read_async");
    stub_funcs.ptr_g_file_read_finish = try_find_sym(gio, "g_file_read_finish");
    stub_funcs.ptr_g_file_append_to = try_find_sym(gio, "g_file_append_to");
    stub_funcs.ptr_g_file_create = try_find_sym(gio, "g_file_create");
    stub_funcs.ptr_g_file_replace = try_find_sym(gio, "g_file_replace");
    stub_funcs.ptr_g_file_append_to_async = try_find_sym(gio, "g_file_append_to_async");
    stub_funcs.ptr_g_file_append_to_finish = try_find_sym(gio, "g_file_append_to_finish");
    stub_funcs.ptr_g_file_create_async = try_find_sym(gio, "g_file_create_async");
    stub_funcs.ptr_g_file_create_finish = try_find_sym(gio, "g_file_create_finish");
    stub_funcs.ptr_g_file_replace_async = try_find_sym(gio, "g_file_replace_async");
    stub_funcs.ptr_g_file_replace_finish = try_find_sym(gio, "g_file_replace_finish");
    stub_funcs.ptr_g_file_open_readwrite = try_find_sym(gio, "g_file_open_readwrite");
    stub_funcs.ptr_g_file_open_readwrite_async = try_find_sym(gio, "g_file_open_readwrite_async");
    stub_funcs.ptr_g_file_open_readwrite_finish = try_find_sym(gio, "g_file_open_readwrite_finish");
    stub_funcs.ptr_g_file_create_readwrite = try_find_sym(gio, "g_file_create_readwrite");
    stub_funcs.ptr_g_file_create_readwrite_async = try_find_sym(gio, "g_file_create_readwrite_async");
    stub_funcs.ptr_g_file_create_readwrite_finish = try_find_sym(gio, "g_file_create_readwrite_finish");
    stub_funcs.ptr_g_file_replace_readwrite = try_find_sym(gio, "g_file_replace_readwrite");
    stub_funcs.ptr_g_file_replace_readwrite_async = try_find_sym(gio, "g_file_replace_readwrite_async");
    stub_funcs.ptr_g_file_replace_readwrite_finish = try_find_sym(gio, "g_file_replace_readwrite_finish");
    stub_funcs.ptr_g_file_query_exists = try_find_sym(gio, "g_file_query_exists");
    stub_funcs.ptr_g_file_query_file_type = try_find_sym(gio, "g_file_query_file_type");
    stub_funcs.ptr_g_file_query_info = try_find_sym(gio, "g_file_query_info");
    stub_funcs.ptr_g_file_query_info_async = try_find_sym(gio, "g_file_query_info_async");
    stub_funcs.ptr_g_file_query_info_finish = try_find_sym(gio, "g_file_query_info_finish");
    stub_funcs.ptr_g_file_query_filesystem_info = try_find_sym(gio, "g_file_query_filesystem_info");
    stub_funcs.ptr_g_file_query_filesystem_info_async = try_find_sym(gio, "g_file_query_filesystem_info_async");
    stub_funcs.ptr_g_file_query_filesystem_info_finish = try_find_sym(gio, "g_file_query_filesystem_info_finish");
    stub_funcs.ptr_g_file_find_enclosing_mount = try_find_sym(gio, "g_file_find_enclosing_mount");
    stub_funcs.ptr_g_file_find_enclosing_mount_async = try_find_sym(gio, "g_file_find_enclosing_mount_async");
    stub_funcs.ptr_g_file_find_enclosing_mount_finish = try_find_sym(gio, "g_file_find_enclosing_mount_finish");
    stub_funcs.ptr_g_file_enumerate_children = try_find_sym(gio, "g_file_enumerate_children");
    stub_funcs.ptr_g_file_enumerate_children_async = try_find_sym(gio, "g_file_enumerate_children_async");
    stub_funcs.ptr_g_file_enumerate_children_finish = try_find_sym(gio, "g_file_enumerate_children_finish");
    stub_funcs.ptr_g_file_set_display_name = try_find_sym(gio, "g_file_set_display_name");
    stub_funcs.ptr_g_file_set_display_name_async = try_find_sym(gio, "g_file_set_display_name_async");
    stub_funcs.ptr_g_file_set_display_name_finish = try_find_sym(gio, "g_file_set_display_name_finish");
    stub_funcs.ptr_g_file_delete = try_find_sym(gio, "g_file_delete");
    stub_funcs.ptr_g_file_delete_async = try_find_sym(gio, "g_file_delete_async");
    stub_funcs.ptr_g_file_delete_finish = try_find_sym(gio, "g_file_delete_finish");
    stub_funcs.ptr_g_file_trash = try_find_sym(gio, "g_file_trash");
    stub_funcs.ptr_g_file_trash_async = try_find_sym(gio, "g_file_trash_async");
    stub_funcs.ptr_g_file_trash_finish = try_find_sym(gio, "g_file_trash_finish");
    stub_funcs.ptr_g_file_copy = try_find_sym(gio, "g_file_copy");
    stub_funcs.ptr_g_file_copy_async = try_find_sym(gio, "g_file_copy_async");
    stub_funcs.ptr_g_file_copy_finish = try_find_sym(gio, "g_file_copy_finish");
    stub_funcs.ptr_g_file_move = try_find_sym(gio, "g_file_move");
    stub_funcs.ptr_g_file_move_async = try_find_sym(gio, "g_file_move_async");
    stub_funcs.ptr_g_file_move_finish = try_find_sym(gio, "g_file_move_finish");
    stub_funcs.ptr_g_file_make_directory = try_find_sym(gio, "g_file_make_directory");
    stub_funcs.ptr_g_file_make_directory_async = try_find_sym(gio, "g_file_make_directory_async");
    stub_funcs.ptr_g_file_make_directory_finish = try_find_sym(gio, "g_file_make_directory_finish");
    stub_funcs.ptr_g_file_make_directory_with_parents = try_find_sym(gio, "g_file_make_directory_with_parents");
    stub_funcs.ptr_g_file_make_symbolic_link = try_find_sym(gio, "g_file_make_symbolic_link");
    stub_funcs.ptr_g_file_make_symbolic_link_async = try_find_sym(gio, "g_file_make_symbolic_link_async");
    stub_funcs.ptr_g_file_make_symbolic_link_finish = try_find_sym(gio, "g_file_make_symbolic_link_finish");
    stub_funcs.ptr_g_file_query_settable_attributes = try_find_sym(gio, "g_file_query_settable_attributes");
    stub_funcs.ptr_g_file_query_writable_namespaces = try_find_sym(gio, "g_file_query_writable_namespaces");
    stub_funcs.ptr_g_file_set_attribute = try_find_sym(gio, "g_file_set_attribute");
    stub_funcs.ptr_g_file_set_attributes_from_info = try_find_sym(gio, "g_file_set_attributes_from_info");
    stub_funcs.ptr_g_file_set_attributes_async = try_find_sym(gio, "g_file_set_attributes_async");
    stub_funcs.ptr_g_file_set_attributes_finish = try_find_sym(gio, "g_file_set_attributes_finish");
    stub_funcs.ptr_g_file_set_attribute_string = try_find_sym(gio, "g_file_set_attribute_string");
    stub_funcs.ptr_g_file_set_attribute_byte_string = try_find_sym(gio, "g_file_set_attribute_byte_string");
    stub_funcs.ptr_g_file_set_attribute_uint32 = try_find_sym(gio, "g_file_set_attribute_uint32");
    stub_funcs.ptr_g_file_set_attribute_int32 = try_find_sym(gio, "g_file_set_attribute_int32");
    stub_funcs.ptr_g_file_set_attribute_uint64 = try_find_sym(gio, "g_file_set_attribute_uint64");
    stub_funcs.ptr_g_file_set_attribute_int64 = try_find_sym(gio, "g_file_set_attribute_int64");
    stub_funcs.ptr_g_file_mount_enclosing_volume = try_find_sym(gio, "g_file_mount_enclosing_volume");
    stub_funcs.ptr_g_file_mount_enclosing_volume_finish = try_find_sym(gio, "g_file_mount_enclosing_volume_finish");
    stub_funcs.ptr_g_file_mount_mountable = try_find_sym(gio, "g_file_mount_mountable");
    stub_funcs.ptr_g_file_mount_mountable_finish = try_find_sym(gio, "g_file_mount_mountable_finish");
    stub_funcs.ptr_g_file_unmount_mountable = try_find_sym(gio, "g_file_unmount_mountable");
    stub_funcs.ptr_g_file_unmount_mountable_finish = try_find_sym(gio, "g_file_unmount_mountable_finish");
    stub_funcs.ptr_g_file_unmount_mountable_with_operation = try_find_sym(gio, "g_file_unmount_mountable_with_operation");
    stub_funcs.ptr_g_file_unmount_mountable_with_operation_finish = try_find_sym(gio, "g_file_unmount_mountable_with_operation_finish");
    stub_funcs.ptr_g_file_eject_mountable = try_find_sym(gio, "g_file_eject_mountable");
    stub_funcs.ptr_g_file_eject_mountable_finish = try_find_sym(gio, "g_file_eject_mountable_finish");
    stub_funcs.ptr_g_file_eject_mountable_with_operation = try_find_sym(gio, "g_file_eject_mountable_with_operation");
    stub_funcs.ptr_g_file_eject_mountable_with_operation_finish = try_find_sym(gio, "g_file_eject_mountable_with_operation_finish");
    stub_funcs.ptr_g_file_build_attribute_list_for_copy = try_find_sym(gio, "g_file_build_attribute_list_for_copy");
    stub_funcs.ptr_g_file_copy_attributes = try_find_sym(gio, "g_file_copy_attributes");
    stub_funcs.ptr_g_file_monitor_directory = try_find_sym(gio, "g_file_monitor_directory");
    stub_funcs.ptr_g_file_monitor_file = try_find_sym(gio, "g_file_monitor_file");
    stub_funcs.ptr_g_file_monitor = try_find_sym(gio, "g_file_monitor");
    stub_funcs.ptr_g_file_measure_disk_usage = try_find_sym(gio, "g_file_measure_disk_usage");
    stub_funcs.ptr_g_file_measure_disk_usage_async = try_find_sym(gio, "g_file_measure_disk_usage_async");
    stub_funcs.ptr_g_file_measure_disk_usage_finish = try_find_sym(gio, "g_file_measure_disk_usage_finish");
    stub_funcs.ptr_g_file_start_mountable = try_find_sym(gio, "g_file_start_mountable");
    stub_funcs.ptr_g_file_start_mountable_finish = try_find_sym(gio, "g_file_start_mountable_finish");
    stub_funcs.ptr_g_file_stop_mountable = try_find_sym(gio, "g_file_stop_mountable");
    stub_funcs.ptr_g_file_stop_mountable_finish = try_find_sym(gio, "g_file_stop_mountable_finish");
    stub_funcs.ptr_g_file_poll_mountable = try_find_sym(gio, "g_file_poll_mountable");
    stub_funcs.ptr_g_file_poll_mountable_finish = try_find_sym(gio, "g_file_poll_mountable_finish");
    stub_funcs.ptr_g_file_query_default_handler = try_find_sym(gio, "g_file_query_default_handler");
    stub_funcs.ptr_g_file_query_default_handler_async = try_find_sym(gio, "g_file_query_default_handler_async");
    stub_funcs.ptr_g_file_query_default_handler_finish = try_find_sym(gio, "g_file_query_default_handler_finish");
    stub_funcs.ptr_g_file_load_contents = try_find_sym(gio, "g_file_load_contents");
    stub_funcs.ptr_g_file_load_contents_async = try_find_sym(gio, "g_file_load_contents_async");
    stub_funcs.ptr_g_file_load_contents_finish = try_find_sym(gio, "g_file_load_contents_finish");
    stub_funcs.ptr_g_file_load_partial_contents_async = try_find_sym(gio, "g_file_load_partial_contents_async");
    stub_funcs.ptr_g_file_load_partial_contents_finish = try_find_sym(gio, "g_file_load_partial_contents_finish");
    stub_funcs.ptr_g_file_replace_contents = try_find_sym(gio, "g_file_replace_contents");
    stub_funcs.ptr_g_file_replace_contents_async = try_find_sym(gio, "g_file_replace_contents_async");
    stub_funcs.ptr_g_file_replace_contents_bytes_async = try_find_sym(gio, "g_file_replace_contents_bytes_async");
    stub_funcs.ptr_g_file_replace_contents_finish = try_find_sym(gio, "g_file_replace_contents_finish");
    stub_funcs.ptr_g_file_supports_thread_contexts = try_find_sym(gio, "g_file_supports_thread_contexts");
    stub_funcs.ptr_g_file_load_bytes = try_find_sym(gio, "g_file_load_bytes");
    stub_funcs.ptr_g_file_load_bytes_async = try_find_sym(gio, "g_file_load_bytes_async");
    stub_funcs.ptr_g_file_load_bytes_finish = try_find_sym(gio, "g_file_load_bytes_finish");
    // Header /usr/include/glib-2.0/gio/gfileattribute.h
    stub_funcs.ptr_g_file_attribute_info_list_get_type = try_find_sym(gio, "g_file_attribute_info_list_get_type");
    stub_funcs.ptr_g_file_attribute_info_list_new = try_find_sym(gio, "g_file_attribute_info_list_new");
    stub_funcs.ptr_g_file_attribute_info_list_ref = try_find_sym(gio, "g_file_attribute_info_list_ref");
    stub_funcs.ptr_g_file_attribute_info_list_unref = try_find_sym(gio, "g_file_attribute_info_list_unref");
    stub_funcs.ptr_g_file_attribute_info_list_dup = try_find_sym(gio, "g_file_attribute_info_list_dup");
    stub_funcs.ptr_g_file_attribute_info_list_lookup = try_find_sym(gio, "g_file_attribute_info_list_lookup");
    stub_funcs.ptr_g_file_attribute_info_list_add = try_find_sym(gio, "g_file_attribute_info_list_add");
    // Header /usr/include/glib-2.0/gio/gfileenumerator.h
    stub_funcs.ptr_g_file_enumerator_get_type = try_find_sym(gio, "g_file_enumerator_get_type");
    stub_funcs.ptr_g_file_enumerator_next_file = try_find_sym(gio, "g_file_enumerator_next_file");
    stub_funcs.ptr_g_file_enumerator_close = try_find_sym(gio, "g_file_enumerator_close");
    stub_funcs.ptr_g_file_enumerator_next_files_async = try_find_sym(gio, "g_file_enumerator_next_files_async");
    stub_funcs.ptr_g_file_enumerator_next_files_finish = try_find_sym(gio, "g_file_enumerator_next_files_finish");
    stub_funcs.ptr_g_file_enumerator_close_async = try_find_sym(gio, "g_file_enumerator_close_async");
    stub_funcs.ptr_g_file_enumerator_close_finish = try_find_sym(gio, "g_file_enumerator_close_finish");
    stub_funcs.ptr_g_file_enumerator_is_closed = try_find_sym(gio, "g_file_enumerator_is_closed");
    stub_funcs.ptr_g_file_enumerator_has_pending = try_find_sym(gio, "g_file_enumerator_has_pending");
    stub_funcs.ptr_g_file_enumerator_set_pending = try_find_sym(gio, "g_file_enumerator_set_pending");
    stub_funcs.ptr_g_file_enumerator_get_container = try_find_sym(gio, "g_file_enumerator_get_container");
    stub_funcs.ptr_g_file_enumerator_get_child = try_find_sym(gio, "g_file_enumerator_get_child");
    stub_funcs.ptr_g_file_enumerator_iterate = try_find_sym(gio, "g_file_enumerator_iterate");
    // Header /usr/include/glib-2.0/gio/gfileicon.h
    stub_funcs.ptr_g_file_icon_get_type = try_find_sym(gio, "g_file_icon_get_type");
    stub_funcs.ptr_g_file_icon_new = try_find_sym(gio, "g_file_icon_new");
    stub_funcs.ptr_g_file_icon_get_file = try_find_sym(gio, "g_file_icon_get_file");
    // Header /usr/include/glib-2.0/gio/gfileinfo.h
    stub_funcs.ptr_g_file_info_get_type = try_find_sym(gio, "g_file_info_get_type");
    stub_funcs.ptr_g_file_info_new = try_find_sym(gio, "g_file_info_new");
    stub_funcs.ptr_g_file_info_dup = try_find_sym(gio, "g_file_info_dup");
    stub_funcs.ptr_g_file_info_copy_into = try_find_sym(gio, "g_file_info_copy_into");
    stub_funcs.ptr_g_file_info_has_attribute = try_find_sym(gio, "g_file_info_has_attribute");
    stub_funcs.ptr_g_file_info_has_namespace = try_find_sym(gio, "g_file_info_has_namespace");
    stub_funcs.ptr_g_file_info_list_attributes = try_find_sym(gio, "g_file_info_list_attributes");
    stub_funcs.ptr_g_file_info_get_attribute_data = try_find_sym(gio, "g_file_info_get_attribute_data");
    stub_funcs.ptr_g_file_info_get_attribute_type = try_find_sym(gio, "g_file_info_get_attribute_type");
    stub_funcs.ptr_g_file_info_remove_attribute = try_find_sym(gio, "g_file_info_remove_attribute");
    stub_funcs.ptr_g_file_info_get_attribute_status = try_find_sym(gio, "g_file_info_get_attribute_status");
    stub_funcs.ptr_g_file_info_set_attribute_status = try_find_sym(gio, "g_file_info_set_attribute_status");
    stub_funcs.ptr_g_file_info_get_attribute_as_string = try_find_sym(gio, "g_file_info_get_attribute_as_string");
    stub_funcs.ptr_g_file_info_get_attribute_string = try_find_sym(gio, "g_file_info_get_attribute_string");
    stub_funcs.ptr_g_file_info_get_attribute_byte_string = try_find_sym(gio, "g_file_info_get_attribute_byte_string");
    stub_funcs.ptr_g_file_info_get_attribute_boolean = try_find_sym(gio, "g_file_info_get_attribute_boolean");
    stub_funcs.ptr_g_file_info_get_attribute_uint32 = try_find_sym(gio, "g_file_info_get_attribute_uint32");
    stub_funcs.ptr_g_file_info_get_attribute_int32 = try_find_sym(gio, "g_file_info_get_attribute_int32");
    stub_funcs.ptr_g_file_info_get_attribute_uint64 = try_find_sym(gio, "g_file_info_get_attribute_uint64");
    stub_funcs.ptr_g_file_info_get_attribute_int64 = try_find_sym(gio, "g_file_info_get_attribute_int64");
    stub_funcs.ptr_g_file_info_get_attribute_object = try_find_sym(gio, "g_file_info_get_attribute_object");
    stub_funcs.ptr_g_file_info_get_attribute_stringv = try_find_sym(gio, "g_file_info_get_attribute_stringv");
    stub_funcs.ptr_g_file_info_get_attribute_file_path = try_find_sym(gio, "g_file_info_get_attribute_file_path");
    stub_funcs.ptr_g_file_info_set_attribute = try_find_sym(gio, "g_file_info_set_attribute");
    stub_funcs.ptr_g_file_info_set_attribute_string = try_find_sym(gio, "g_file_info_set_attribute_string");
    stub_funcs.ptr_g_file_info_set_attribute_byte_string = try_find_sym(gio, "g_file_info_set_attribute_byte_string");
    stub_funcs.ptr_g_file_info_set_attribute_boolean = try_find_sym(gio, "g_file_info_set_attribute_boolean");
    stub_funcs.ptr_g_file_info_set_attribute_uint32 = try_find_sym(gio, "g_file_info_set_attribute_uint32");
    stub_funcs.ptr_g_file_info_set_attribute_int32 = try_find_sym(gio, "g_file_info_set_attribute_int32");
    stub_funcs.ptr_g_file_info_set_attribute_uint64 = try_find_sym(gio, "g_file_info_set_attribute_uint64");
    stub_funcs.ptr_g_file_info_set_attribute_int64 = try_find_sym(gio, "g_file_info_set_attribute_int64");
    stub_funcs.ptr_g_file_info_set_attribute_object = try_find_sym(gio, "g_file_info_set_attribute_object");
    stub_funcs.ptr_g_file_info_set_attribute_stringv = try_find_sym(gio, "g_file_info_set_attribute_stringv");
    stub_funcs.ptr_g_file_info_set_attribute_file_path = try_find_sym(gio, "g_file_info_set_attribute_file_path");
    stub_funcs.ptr_g_file_info_clear_status = try_find_sym(gio, "g_file_info_clear_status");
    stub_funcs.ptr_g_file_info_get_deletion_date = try_find_sym(gio, "g_file_info_get_deletion_date");
    stub_funcs.ptr_g_file_info_get_file_type = try_find_sym(gio, "g_file_info_get_file_type");
    stub_funcs.ptr_g_file_info_get_is_hidden = try_find_sym(gio, "g_file_info_get_is_hidden");
    stub_funcs.ptr_g_file_info_get_is_backup = try_find_sym(gio, "g_file_info_get_is_backup");
    stub_funcs.ptr_g_file_info_get_is_symlink = try_find_sym(gio, "g_file_info_get_is_symlink");
    stub_funcs.ptr_g_file_info_get_name = try_find_sym(gio, "g_file_info_get_name");
    stub_funcs.ptr_g_file_info_get_display_name = try_find_sym(gio, "g_file_info_get_display_name");
    stub_funcs.ptr_g_file_info_get_edit_name = try_find_sym(gio, "g_file_info_get_edit_name");
    stub_funcs.ptr_g_file_info_get_icon = try_find_sym(gio, "g_file_info_get_icon");
    stub_funcs.ptr_g_file_info_get_symbolic_icon = try_find_sym(gio, "g_file_info_get_symbolic_icon");
    stub_funcs.ptr_g_file_info_get_content_type = try_find_sym(gio, "g_file_info_get_content_type");
    stub_funcs.ptr_g_file_info_get_size = try_find_sym(gio, "g_file_info_get_size");
    stub_funcs.ptr_g_file_info_get_access_date_time = try_find_sym(gio, "g_file_info_get_access_date_time");
    stub_funcs.ptr_g_file_info_get_creation_date_time = try_find_sym(gio, "g_file_info_get_creation_date_time");
    stub_funcs.ptr_g_file_info_get_symlink_target = try_find_sym(gio, "g_file_info_get_symlink_target");
    stub_funcs.ptr_g_file_info_get_etag = try_find_sym(gio, "g_file_info_get_etag");
    stub_funcs.ptr_g_file_info_get_sort_order = try_find_sym(gio, "g_file_info_get_sort_order");
    stub_funcs.ptr_g_file_info_set_attribute_mask = try_find_sym(gio, "g_file_info_set_attribute_mask");
    stub_funcs.ptr_g_file_info_unset_attribute_mask = try_find_sym(gio, "g_file_info_unset_attribute_mask");
    stub_funcs.ptr_g_file_info_set_file_type = try_find_sym(gio, "g_file_info_set_file_type");
    stub_funcs.ptr_g_file_info_set_is_hidden = try_find_sym(gio, "g_file_info_set_is_hidden");
    stub_funcs.ptr_g_file_info_set_is_symlink = try_find_sym(gio, "g_file_info_set_is_symlink");
    stub_funcs.ptr_g_file_info_set_name = try_find_sym(gio, "g_file_info_set_name");
    stub_funcs.ptr_g_file_info_set_display_name = try_find_sym(gio, "g_file_info_set_display_name");
    stub_funcs.ptr_g_file_info_set_edit_name = try_find_sym(gio, "g_file_info_set_edit_name");
    stub_funcs.ptr_g_file_info_set_icon = try_find_sym(gio, "g_file_info_set_icon");
    stub_funcs.ptr_g_file_info_set_symbolic_icon = try_find_sym(gio, "g_file_info_set_symbolic_icon");
    stub_funcs.ptr_g_file_info_set_content_type = try_find_sym(gio, "g_file_info_set_content_type");
    stub_funcs.ptr_g_file_info_set_size = try_find_sym(gio, "g_file_info_set_size");
    stub_funcs.ptr_g_file_info_set_access_date_time = try_find_sym(gio, "g_file_info_set_access_date_time");
    stub_funcs.ptr_g_file_info_set_creation_date_time = try_find_sym(gio, "g_file_info_set_creation_date_time");
    stub_funcs.ptr_g_file_info_set_symlink_target = try_find_sym(gio, "g_file_info_set_symlink_target");
    stub_funcs.ptr_g_file_info_set_sort_order = try_find_sym(gio, "g_file_info_set_sort_order");
    stub_funcs.ptr_g_file_attribute_matcher_get_type = try_find_sym(gio, "g_file_attribute_matcher_get_type");
    stub_funcs.ptr_g_file_attribute_matcher_new = try_find_sym(gio, "g_file_attribute_matcher_new");
    stub_funcs.ptr_g_file_attribute_matcher_ref = try_find_sym(gio, "g_file_attribute_matcher_ref");
    stub_funcs.ptr_g_file_attribute_matcher_unref = try_find_sym(gio, "g_file_attribute_matcher_unref");
    stub_funcs.ptr_g_file_attribute_matcher_subtract = try_find_sym(gio, "g_file_attribute_matcher_subtract");
    stub_funcs.ptr_g_file_attribute_matcher_matches = try_find_sym(gio, "g_file_attribute_matcher_matches");
    stub_funcs.ptr_g_file_attribute_matcher_matches_only = try_find_sym(gio, "g_file_attribute_matcher_matches_only");
    stub_funcs.ptr_g_file_attribute_matcher_enumerate_namespace = try_find_sym(gio, "g_file_attribute_matcher_enumerate_namespace");
    stub_funcs.ptr_g_file_attribute_matcher_enumerate_next = try_find_sym(gio, "g_file_attribute_matcher_enumerate_next");
    stub_funcs.ptr_g_file_attribute_matcher_to_string = try_find_sym(gio, "g_file_attribute_matcher_to_string");
    // Header /usr/include/glib-2.0/gio/gfileinputstream.h
    stub_funcs.ptr_g_file_input_stream_get_type = try_find_sym(gio, "g_file_input_stream_get_type");
    stub_funcs.ptr_g_file_input_stream_query_info = try_find_sym(gio, "g_file_input_stream_query_info");
    stub_funcs.ptr_g_file_input_stream_query_info_async = try_find_sym(gio, "g_file_input_stream_query_info_async");
    stub_funcs.ptr_g_file_input_stream_query_info_finish = try_find_sym(gio, "g_file_input_stream_query_info_finish");
    // Header /usr/include/glib-2.0/gio/gfileiostream.h
    stub_funcs.ptr_g_file_io_stream_get_type = try_find_sym(gio, "g_file_io_stream_get_type");
    stub_funcs.ptr_g_file_io_stream_query_info = try_find_sym(gio, "g_file_io_stream_query_info");
    stub_funcs.ptr_g_file_io_stream_query_info_async = try_find_sym(gio, "g_file_io_stream_query_info_async");
    stub_funcs.ptr_g_file_io_stream_query_info_finish = try_find_sym(gio, "g_file_io_stream_query_info_finish");
    stub_funcs.ptr_g_file_io_stream_get_etag = try_find_sym(gio, "g_file_io_stream_get_etag");
    // Header /usr/include/glib-2.0/gio/gfilemonitor.h
    stub_funcs.ptr_g_file_monitor_get_type = try_find_sym(gio, "g_file_monitor_get_type");
    stub_funcs.ptr_g_file_monitor_cancel = try_find_sym(gio, "g_file_monitor_cancel");
    stub_funcs.ptr_g_file_monitor_is_cancelled = try_find_sym(gio, "g_file_monitor_is_cancelled");
    stub_funcs.ptr_g_file_monitor_set_rate_limit = try_find_sym(gio, "g_file_monitor_set_rate_limit");
    stub_funcs.ptr_g_file_monitor_emit_event = try_find_sym(gio, "g_file_monitor_emit_event");
    // Header /usr/include/glib-2.0/gio/gfilenamecompleter.h
    stub_funcs.ptr_g_filename_completer_get_type = try_find_sym(gio, "g_filename_completer_get_type");
    stub_funcs.ptr_g_filename_completer_new = try_find_sym(gio, "g_filename_completer_new");
    stub_funcs.ptr_g_filename_completer_get_completion_suffix = try_find_sym(gio, "g_filename_completer_get_completion_suffix");
    stub_funcs.ptr_g_filename_completer_get_completions = try_find_sym(gio, "g_filename_completer_get_completions");
    stub_funcs.ptr_g_filename_completer_set_dirs_only = try_find_sym(gio, "g_filename_completer_set_dirs_only");
    // Header /usr/include/glib-2.0/gio/gfileoutputstream.h
    stub_funcs.ptr_g_file_output_stream_get_type = try_find_sym(gio, "g_file_output_stream_get_type");
    stub_funcs.ptr_g_file_output_stream_query_info = try_find_sym(gio, "g_file_output_stream_query_info");
    stub_funcs.ptr_g_file_output_stream_query_info_async = try_find_sym(gio, "g_file_output_stream_query_info_async");
    stub_funcs.ptr_g_file_output_stream_query_info_finish = try_find_sym(gio, "g_file_output_stream_query_info_finish");
    stub_funcs.ptr_g_file_output_stream_get_etag = try_find_sym(gio, "g_file_output_stream_get_etag");
    // Header /usr/include/glib-2.0/gio/gfilterinputstream.h
    stub_funcs.ptr_g_filter_input_stream_get_type = try_find_sym(gio, "g_filter_input_stream_get_type");
    stub_funcs.ptr_g_filter_input_stream_get_base_stream = try_find_sym(gio, "g_filter_input_stream_get_base_stream");
    stub_funcs.ptr_g_filter_input_stream_get_close_base_stream = try_find_sym(gio, "g_filter_input_stream_get_close_base_stream");
    stub_funcs.ptr_g_filter_input_stream_set_close_base_stream = try_find_sym(gio, "g_filter_input_stream_set_close_base_stream");
    // Header /usr/include/glib-2.0/gio/gfilteroutputstream.h
    stub_funcs.ptr_g_filter_output_stream_get_type = try_find_sym(gio, "g_filter_output_stream_get_type");
    stub_funcs.ptr_g_filter_output_stream_get_base_stream = try_find_sym(gio, "g_filter_output_stream_get_base_stream");
    stub_funcs.ptr_g_filter_output_stream_get_close_base_stream = try_find_sym(gio, "g_filter_output_stream_get_close_base_stream");
    stub_funcs.ptr_g_filter_output_stream_set_close_base_stream = try_find_sym(gio, "g_filter_output_stream_set_close_base_stream");
    // Header /usr/include/glib-2.0/gio/gicon.h
    stub_funcs.ptr_g_icon_get_type = try_find_sym(gio, "g_icon_get_type");
    stub_funcs.ptr_g_icon_hash = try_find_sym(gio, "g_icon_hash");
    stub_funcs.ptr_g_icon_equal = try_find_sym(gio, "g_icon_equal");
    stub_funcs.ptr_g_icon_to_string = try_find_sym(gio, "g_icon_to_string");
    stub_funcs.ptr_g_icon_new_for_string = try_find_sym(gio, "g_icon_new_for_string");
    stub_funcs.ptr_g_icon_serialize = try_find_sym(gio, "g_icon_serialize");
    stub_funcs.ptr_g_icon_deserialize = try_find_sym(gio, "g_icon_deserialize");
    // Header /usr/include/glib-2.0/gio/ginetaddress.h
    stub_funcs.ptr_g_inet_address_get_type = try_find_sym(gio, "g_inet_address_get_type");
    stub_funcs.ptr_g_inet_address_new_from_string = try_find_sym(gio, "g_inet_address_new_from_string");
    stub_funcs.ptr_g_inet_address_new_from_bytes = try_find_sym(gio, "g_inet_address_new_from_bytes");
    stub_funcs.ptr_g_inet_address_new_loopback = try_find_sym(gio, "g_inet_address_new_loopback");
    stub_funcs.ptr_g_inet_address_new_any = try_find_sym(gio, "g_inet_address_new_any");
    stub_funcs.ptr_g_inet_address_equal = try_find_sym(gio, "g_inet_address_equal");
    stub_funcs.ptr_g_inet_address_to_string = try_find_sym(gio, "g_inet_address_to_string");
    stub_funcs.ptr_g_inet_address_to_bytes = try_find_sym(gio, "g_inet_address_to_bytes");
    stub_funcs.ptr_g_inet_address_get_native_size = try_find_sym(gio, "g_inet_address_get_native_size");
    stub_funcs.ptr_g_inet_address_get_family = try_find_sym(gio, "g_inet_address_get_family");
    stub_funcs.ptr_g_inet_address_get_is_any = try_find_sym(gio, "g_inet_address_get_is_any");
    stub_funcs.ptr_g_inet_address_get_is_loopback = try_find_sym(gio, "g_inet_address_get_is_loopback");
    stub_funcs.ptr_g_inet_address_get_is_link_local = try_find_sym(gio, "g_inet_address_get_is_link_local");
    stub_funcs.ptr_g_inet_address_get_is_site_local = try_find_sym(gio, "g_inet_address_get_is_site_local");
    stub_funcs.ptr_g_inet_address_get_is_multicast = try_find_sym(gio, "g_inet_address_get_is_multicast");
    stub_funcs.ptr_g_inet_address_get_is_mc_global = try_find_sym(gio, "g_inet_address_get_is_mc_global");
    stub_funcs.ptr_g_inet_address_get_is_mc_link_local = try_find_sym(gio, "g_inet_address_get_is_mc_link_local");
    stub_funcs.ptr_g_inet_address_get_is_mc_node_local = try_find_sym(gio, "g_inet_address_get_is_mc_node_local");
    stub_funcs.ptr_g_inet_address_get_is_mc_org_local = try_find_sym(gio, "g_inet_address_get_is_mc_org_local");
    stub_funcs.ptr_g_inet_address_get_is_mc_site_local = try_find_sym(gio, "g_inet_address_get_is_mc_site_local");
    // Header /usr/include/glib-2.0/gio/ginetaddressmask.h
    stub_funcs.ptr_g_inet_address_mask_get_type = try_find_sym(gio, "g_inet_address_mask_get_type");
    stub_funcs.ptr_g_inet_address_mask_new = try_find_sym(gio, "g_inet_address_mask_new");
    stub_funcs.ptr_g_inet_address_mask_new_from_string = try_find_sym(gio, "g_inet_address_mask_new_from_string");
    stub_funcs.ptr_g_inet_address_mask_to_string = try_find_sym(gio, "g_inet_address_mask_to_string");
    stub_funcs.ptr_g_inet_address_mask_get_family = try_find_sym(gio, "g_inet_address_mask_get_family");
    stub_funcs.ptr_g_inet_address_mask_get_address = try_find_sym(gio, "g_inet_address_mask_get_address");
    stub_funcs.ptr_g_inet_address_mask_get_length = try_find_sym(gio, "g_inet_address_mask_get_length");
    stub_funcs.ptr_g_inet_address_mask_matches = try_find_sym(gio, "g_inet_address_mask_matches");
    stub_funcs.ptr_g_inet_address_mask_equal = try_find_sym(gio, "g_inet_address_mask_equal");
    // Header /usr/include/glib-2.0/gio/ginetsocketaddress.h
    stub_funcs.ptr_g_inet_socket_address_get_type = try_find_sym(gio, "g_inet_socket_address_get_type");
    stub_funcs.ptr_g_inet_socket_address_new = try_find_sym(gio, "g_inet_socket_address_new");
    stub_funcs.ptr_g_inet_socket_address_new_from_string = try_find_sym(gio, "g_inet_socket_address_new_from_string");
    stub_funcs.ptr_g_inet_socket_address_get_address = try_find_sym(gio, "g_inet_socket_address_get_address");
    stub_funcs.ptr_g_inet_socket_address_get_port = try_find_sym(gio, "g_inet_socket_address_get_port");
    stub_funcs.ptr_g_inet_socket_address_get_flowinfo = try_find_sym(gio, "g_inet_socket_address_get_flowinfo");
    stub_funcs.ptr_g_inet_socket_address_get_scope_id = try_find_sym(gio, "g_inet_socket_address_get_scope_id");
    // Header /usr/include/glib-2.0/gio/ginitable.h
    stub_funcs.ptr_g_initable_get_type = try_find_sym(gio, "g_initable_get_type");
    stub_funcs.ptr_g_initable_init = try_find_sym(gio, "g_initable_init");
    // Header /usr/include/glib-2.0/gio/ginputstream.h
    stub_funcs.ptr_g_input_stream_get_type = try_find_sym(gio, "g_input_stream_get_type");
    stub_funcs.ptr_g_input_stream_read = try_find_sym(gio, "g_input_stream_read");
    stub_funcs.ptr_g_input_stream_read_all = try_find_sym(gio, "g_input_stream_read_all");
    stub_funcs.ptr_g_input_stream_read_bytes = try_find_sym(gio, "g_input_stream_read_bytes");
    stub_funcs.ptr_g_input_stream_skip = try_find_sym(gio, "g_input_stream_skip");
    stub_funcs.ptr_g_input_stream_close = try_find_sym(gio, "g_input_stream_close");
    stub_funcs.ptr_g_input_stream_read_async = try_find_sym(gio, "g_input_stream_read_async");
    stub_funcs.ptr_g_input_stream_read_finish = try_find_sym(gio, "g_input_stream_read_finish");
    stub_funcs.ptr_g_input_stream_read_all_async = try_find_sym(gio, "g_input_stream_read_all_async");
    stub_funcs.ptr_g_input_stream_read_all_finish = try_find_sym(gio, "g_input_stream_read_all_finish");
    stub_funcs.ptr_g_input_stream_read_bytes_async = try_find_sym(gio, "g_input_stream_read_bytes_async");
    stub_funcs.ptr_g_input_stream_read_bytes_finish = try_find_sym(gio, "g_input_stream_read_bytes_finish");
    stub_funcs.ptr_g_input_stream_skip_async = try_find_sym(gio, "g_input_stream_skip_async");
    stub_funcs.ptr_g_input_stream_skip_finish = try_find_sym(gio, "g_input_stream_skip_finish");
    stub_funcs.ptr_g_input_stream_close_async = try_find_sym(gio, "g_input_stream_close_async");
    stub_funcs.ptr_g_input_stream_close_finish = try_find_sym(gio, "g_input_stream_close_finish");
    stub_funcs.ptr_g_input_stream_is_closed = try_find_sym(gio, "g_input_stream_is_closed");
    stub_funcs.ptr_g_input_stream_has_pending = try_find_sym(gio, "g_input_stream_has_pending");
    stub_funcs.ptr_g_input_stream_set_pending = try_find_sym(gio, "g_input_stream_set_pending");
    stub_funcs.ptr_g_input_stream_clear_pending = try_find_sym(gio, "g_input_stream_clear_pending");
    // Header /usr/include/glib-2.0/gio/gioenums.h
    // Header /usr/include/glib-2.0/gio/gioenumtypes.h
    stub_funcs.ptr_g_app_info_create_flags_get_type = try_find_sym(gio, "g_app_info_create_flags_get_type");
    stub_funcs.ptr_g_converter_flags_get_type = try_find_sym(gio, "g_converter_flags_get_type");
    stub_funcs.ptr_g_converter_result_get_type = try_find_sym(gio, "g_converter_result_get_type");
    stub_funcs.ptr_g_data_stream_byte_order_get_type = try_find_sym(gio, "g_data_stream_byte_order_get_type");
    stub_funcs.ptr_g_data_stream_newline_type_get_type = try_find_sym(gio, "g_data_stream_newline_type_get_type");
    stub_funcs.ptr_g_file_attribute_type_get_type = try_find_sym(gio, "g_file_attribute_type_get_type");
    stub_funcs.ptr_g_file_attribute_info_flags_get_type = try_find_sym(gio, "g_file_attribute_info_flags_get_type");
    stub_funcs.ptr_g_file_attribute_status_get_type = try_find_sym(gio, "g_file_attribute_status_get_type");
    stub_funcs.ptr_g_file_query_info_flags_get_type = try_find_sym(gio, "g_file_query_info_flags_get_type");
    stub_funcs.ptr_g_file_create_flags_get_type = try_find_sym(gio, "g_file_create_flags_get_type");
    stub_funcs.ptr_g_file_measure_flags_get_type = try_find_sym(gio, "g_file_measure_flags_get_type");
    stub_funcs.ptr_g_mount_mount_flags_get_type = try_find_sym(gio, "g_mount_mount_flags_get_type");
    stub_funcs.ptr_g_mount_unmount_flags_get_type = try_find_sym(gio, "g_mount_unmount_flags_get_type");
    stub_funcs.ptr_g_drive_start_flags_get_type = try_find_sym(gio, "g_drive_start_flags_get_type");
    stub_funcs.ptr_g_drive_start_stop_type_get_type = try_find_sym(gio, "g_drive_start_stop_type_get_type");
    stub_funcs.ptr_g_file_copy_flags_get_type = try_find_sym(gio, "g_file_copy_flags_get_type");
    stub_funcs.ptr_g_file_monitor_flags_get_type = try_find_sym(gio, "g_file_monitor_flags_get_type");
    stub_funcs.ptr_g_file_type_get_type = try_find_sym(gio, "g_file_type_get_type");
    stub_funcs.ptr_g_filesystem_preview_type_get_type = try_find_sym(gio, "g_filesystem_preview_type_get_type");
    stub_funcs.ptr_g_file_monitor_event_get_type = try_find_sym(gio, "g_file_monitor_event_get_type");
    stub_funcs.ptr_g_io_error_enum_get_type = try_find_sym(gio, "g_io_error_enum_get_type");
    stub_funcs.ptr_g_ask_password_flags_get_type = try_find_sym(gio, "g_ask_password_flags_get_type");
    stub_funcs.ptr_g_password_save_get_type = try_find_sym(gio, "g_password_save_get_type");
    stub_funcs.ptr_g_mount_operation_result_get_type = try_find_sym(gio, "g_mount_operation_result_get_type");
    stub_funcs.ptr_g_output_stream_splice_flags_get_type = try_find_sym(gio, "g_output_stream_splice_flags_get_type");
    stub_funcs.ptr_g_io_stream_splice_flags_get_type = try_find_sym(gio, "g_io_stream_splice_flags_get_type");
    stub_funcs.ptr_g_emblem_origin_get_type = try_find_sym(gio, "g_emblem_origin_get_type");
    stub_funcs.ptr_g_resolver_error_get_type = try_find_sym(gio, "g_resolver_error_get_type");
    stub_funcs.ptr_g_resolver_record_type_get_type = try_find_sym(gio, "g_resolver_record_type_get_type");
    stub_funcs.ptr_g_resource_error_get_type = try_find_sym(gio, "g_resource_error_get_type");
    stub_funcs.ptr_g_resource_flags_get_type = try_find_sym(gio, "g_resource_flags_get_type");
    stub_funcs.ptr_g_resource_lookup_flags_get_type = try_find_sym(gio, "g_resource_lookup_flags_get_type");
    stub_funcs.ptr_g_socket_family_get_type = try_find_sym(gio, "g_socket_family_get_type");
    stub_funcs.ptr_g_socket_type_get_type = try_find_sym(gio, "g_socket_type_get_type");
    stub_funcs.ptr_g_socket_msg_flags_get_type = try_find_sym(gio, "g_socket_msg_flags_get_type");
    stub_funcs.ptr_g_socket_protocol_get_type = try_find_sym(gio, "g_socket_protocol_get_type");
    stub_funcs.ptr_g_zlib_compressor_format_get_type = try_find_sym(gio, "g_zlib_compressor_format_get_type");
    stub_funcs.ptr_g_unix_socket_address_type_get_type = try_find_sym(gio, "g_unix_socket_address_type_get_type");
    stub_funcs.ptr_g_bus_type_get_type = try_find_sym(gio, "g_bus_type_get_type");
    stub_funcs.ptr_g_bus_name_owner_flags_get_type = try_find_sym(gio, "g_bus_name_owner_flags_get_type");
    stub_funcs.ptr_g_bus_name_watcher_flags_get_type = try_find_sym(gio, "g_bus_name_watcher_flags_get_type");
    stub_funcs.ptr_g_dbus_proxy_flags_get_type = try_find_sym(gio, "g_dbus_proxy_flags_get_type");
    stub_funcs.ptr_g_dbus_error_get_type = try_find_sym(gio, "g_dbus_error_get_type");
    stub_funcs.ptr_g_dbus_connection_flags_get_type = try_find_sym(gio, "g_dbus_connection_flags_get_type");
    stub_funcs.ptr_g_dbus_capability_flags_get_type = try_find_sym(gio, "g_dbus_capability_flags_get_type");
    stub_funcs.ptr_g_dbus_call_flags_get_type = try_find_sym(gio, "g_dbus_call_flags_get_type");
    stub_funcs.ptr_g_dbus_message_type_get_type = try_find_sym(gio, "g_dbus_message_type_get_type");
    stub_funcs.ptr_g_dbus_message_flags_get_type = try_find_sym(gio, "g_dbus_message_flags_get_type");
    stub_funcs.ptr_g_dbus_message_header_field_get_type = try_find_sym(gio, "g_dbus_message_header_field_get_type");
    stub_funcs.ptr_g_dbus_property_info_flags_get_type = try_find_sym(gio, "g_dbus_property_info_flags_get_type");
    stub_funcs.ptr_g_dbus_subtree_flags_get_type = try_find_sym(gio, "g_dbus_subtree_flags_get_type");
    stub_funcs.ptr_g_dbus_server_flags_get_type = try_find_sym(gio, "g_dbus_server_flags_get_type");
    stub_funcs.ptr_g_dbus_signal_flags_get_type = try_find_sym(gio, "g_dbus_signal_flags_get_type");
    stub_funcs.ptr_g_dbus_send_message_flags_get_type = try_find_sym(gio, "g_dbus_send_message_flags_get_type");
    stub_funcs.ptr_g_credentials_type_get_type = try_find_sym(gio, "g_credentials_type_get_type");
    stub_funcs.ptr_g_dbus_message_byte_order_get_type = try_find_sym(gio, "g_dbus_message_byte_order_get_type");
    stub_funcs.ptr_g_application_flags_get_type = try_find_sym(gio, "g_application_flags_get_type");
    stub_funcs.ptr_g_tls_error_get_type = try_find_sym(gio, "g_tls_error_get_type");
    stub_funcs.ptr_g_tls_certificate_flags_get_type = try_find_sym(gio, "g_tls_certificate_flags_get_type");
    stub_funcs.ptr_g_tls_authentication_mode_get_type = try_find_sym(gio, "g_tls_authentication_mode_get_type");
    stub_funcs.ptr_g_tls_channel_binding_type_get_type = try_find_sym(gio, "g_tls_channel_binding_type_get_type");
    stub_funcs.ptr_g_tls_channel_binding_error_get_type = try_find_sym(gio, "g_tls_channel_binding_error_get_type");
    stub_funcs.ptr_g_tls_rehandshake_mode_get_type = try_find_sym(gio, "g_tls_rehandshake_mode_get_type");
    stub_funcs.ptr_g_tls_password_flags_get_type = try_find_sym(gio, "g_tls_password_flags_get_type");
    stub_funcs.ptr_g_tls_interaction_result_get_type = try_find_sym(gio, "g_tls_interaction_result_get_type");
    stub_funcs.ptr_g_dbus_interface_skeleton_flags_get_type = try_find_sym(gio, "g_dbus_interface_skeleton_flags_get_type");
    stub_funcs.ptr_g_dbus_object_manager_client_flags_get_type = try_find_sym(gio, "g_dbus_object_manager_client_flags_get_type");
    stub_funcs.ptr_g_tls_database_verify_flags_get_type = try_find_sym(gio, "g_tls_database_verify_flags_get_type");
    stub_funcs.ptr_g_tls_database_lookup_flags_get_type = try_find_sym(gio, "g_tls_database_lookup_flags_get_type");
    stub_funcs.ptr_g_tls_certificate_request_flags_get_type = try_find_sym(gio, "g_tls_certificate_request_flags_get_type");
    stub_funcs.ptr_g_tls_protocol_version_get_type = try_find_sym(gio, "g_tls_protocol_version_get_type");
    stub_funcs.ptr_g_io_module_scope_flags_get_type = try_find_sym(gio, "g_io_module_scope_flags_get_type");
    stub_funcs.ptr_g_socket_client_event_get_type = try_find_sym(gio, "g_socket_client_event_get_type");
    stub_funcs.ptr_g_socket_listener_event_get_type = try_find_sym(gio, "g_socket_listener_event_get_type");
    stub_funcs.ptr_g_test_dbus_flags_get_type = try_find_sym(gio, "g_test_dbus_flags_get_type");
    stub_funcs.ptr_g_subprocess_flags_get_type = try_find_sym(gio, "g_subprocess_flags_get_type");
    stub_funcs.ptr_g_notification_priority_get_type = try_find_sym(gio, "g_notification_priority_get_type");
    stub_funcs.ptr_g_network_connectivity_get_type = try_find_sym(gio, "g_network_connectivity_get_type");
    stub_funcs.ptr_g_pollable_return_get_type = try_find_sym(gio, "g_pollable_return_get_type");
    stub_funcs.ptr_g_memory_monitor_warning_level_get_type = try_find_sym(gio, "g_memory_monitor_warning_level_get_type");
    stub_funcs.ptr_g_resolver_name_lookup_flags_get_type = try_find_sym(gio, "g_resolver_name_lookup_flags_get_type");
    stub_funcs.ptr_g_settings_bind_flags_get_type = try_find_sym(gio, "g_settings_bind_flags_get_type");
    // Header /usr/include/glib-2.0/gio/gioerror.h
    stub_funcs.ptr_g_io_error_from_errno = try_find_sym(gio, "g_io_error_from_errno");
    stub_funcs.ptr_g_io_error_from_file_error = try_find_sym(gio, "g_io_error_from_file_error");
    stub_funcs.ptr_g_io_error_from_win32_error = try_find_sym(gio, "g_io_error_from_win32_error");
    stub_funcs.ptr_g_io_error_quark = try_find_sym(gio, "g_io_error_quark");
    // Header /usr/include/glib-2.0/gio/giomodule.h
    stub_funcs.ptr_g_io_module_scope_free = try_find_sym(gio, "g_io_module_scope_free");
    stub_funcs.ptr_g_io_module_scope_block = try_find_sym(gio, "g_io_module_scope_block");
    stub_funcs.ptr_g_io_module_get_type = try_find_sym(gio, "g_io_module_get_type");
    stub_funcs.ptr_g_io_module_new = try_find_sym(gio, "g_io_module_new");
    stub_funcs.ptr_g_io_modules_scan_all_in_directory = try_find_sym(gio, "g_io_modules_scan_all_in_directory");
    stub_funcs.ptr_g_io_modules_load_all_in_directory = try_find_sym(gio, "g_io_modules_load_all_in_directory");
    stub_funcs.ptr_g_io_modules_scan_all_in_directory_with_scope = try_find_sym(gio, "g_io_modules_scan_all_in_directory_with_scope");
    stub_funcs.ptr_g_io_modules_load_all_in_directory_with_scope = try_find_sym(gio, "g_io_modules_load_all_in_directory_with_scope");
    stub_funcs.ptr_g_io_extension_point_register = try_find_sym(gio, "g_io_extension_point_register");
    stub_funcs.ptr_g_io_extension_point_lookup = try_find_sym(gio, "g_io_extension_point_lookup");
    stub_funcs.ptr_g_io_extension_point_set_required_type = try_find_sym(gio, "g_io_extension_point_set_required_type");
    stub_funcs.ptr_g_io_extension_point_get_required_type = try_find_sym(gio, "g_io_extension_point_get_required_type");
    stub_funcs.ptr_g_io_extension_point_get_extensions = try_find_sym(gio, "g_io_extension_point_get_extensions");
    stub_funcs.ptr_g_io_extension_point_get_extension_by_name = try_find_sym(gio, "g_io_extension_point_get_extension_by_name");
    stub_funcs.ptr_g_io_extension_point_implement = try_find_sym(gio, "g_io_extension_point_implement");
    stub_funcs.ptr_g_io_extension_get_type = try_find_sym(gio, "g_io_extension_get_type");
    stub_funcs.ptr_g_io_extension_get_name = try_find_sym(gio, "g_io_extension_get_name");
    stub_funcs.ptr_g_io_extension_get_priority = try_find_sym(gio, "g_io_extension_get_priority");
    stub_funcs.ptr_g_io_extension_ref_class = try_find_sym(gio, "g_io_extension_ref_class");
    stub_funcs.ptr_g_io_module_load = try_find_sym(gio, "g_io_module_load");
    stub_funcs.ptr_g_io_module_unload = try_find_sym(gio, "g_io_module_unload");
    stub_funcs.ptr_g_io_module_query = try_find_sym(gio, "g_io_module_query");
    stub_funcs.ptr_g_io_module_scope_new = try_find_sym(gio, "g_io_module_scope_new");
    // Header /usr/include/glib-2.0/gio/gioscheduler.h
    stub_funcs.ptr_g_io_scheduler_cancel_all_jobs = try_find_sym(gio, "g_io_scheduler_cancel_all_jobs");
    stub_funcs.ptr_g_io_scheduler_job_send_to_mainloop = try_find_sym(gio, "g_io_scheduler_job_send_to_mainloop");
    stub_funcs.ptr_g_io_scheduler_job_send_to_mainloop_async = try_find_sym(gio, "g_io_scheduler_job_send_to_mainloop_async");
    stub_funcs.ptr_g_io_scheduler_push_job = try_find_sym(gio, "g_io_scheduler_push_job");
    // Header /usr/include/glib-2.0/gio/giostream.h
    stub_funcs.ptr_g_io_stream_get_type = try_find_sym(gio, "g_io_stream_get_type");
    stub_funcs.ptr_g_io_stream_get_input_stream = try_find_sym(gio, "g_io_stream_get_input_stream");
    stub_funcs.ptr_g_io_stream_get_output_stream = try_find_sym(gio, "g_io_stream_get_output_stream");
    stub_funcs.ptr_g_io_stream_splice_async = try_find_sym(gio, "g_io_stream_splice_async");
    stub_funcs.ptr_g_io_stream_splice_finish = try_find_sym(gio, "g_io_stream_splice_finish");
    stub_funcs.ptr_g_io_stream_close = try_find_sym(gio, "g_io_stream_close");
    stub_funcs.ptr_g_io_stream_close_async = try_find_sym(gio, "g_io_stream_close_async");
    stub_funcs.ptr_g_io_stream_close_finish = try_find_sym(gio, "g_io_stream_close_finish");
    stub_funcs.ptr_g_io_stream_is_closed = try_find_sym(gio, "g_io_stream_is_closed");
    stub_funcs.ptr_g_io_stream_has_pending = try_find_sym(gio, "g_io_stream_has_pending");
    stub_funcs.ptr_g_io_stream_set_pending = try_find_sym(gio, "g_io_stream_set_pending");
    stub_funcs.ptr_g_io_stream_clear_pending = try_find_sym(gio, "g_io_stream_clear_pending");
    // Header /usr/include/glib-2.0/gio/giotypes.h
    // Header /usr/include/glib-2.0/gio/glistmodel.h
    stub_funcs.ptr_g_list_model_get_type = try_find_sym(gio, "g_list_model_get_type");
    stub_funcs.ptr_g_list_model_get_n_items = try_find_sym(gio, "g_list_model_get_n_items");
    stub_funcs.ptr_g_list_model_get_item = try_find_sym(gio, "g_list_model_get_item");
    stub_funcs.ptr_g_list_model_get_object = try_find_sym(gio, "g_list_model_get_object");
    stub_funcs.ptr_g_list_model_items_changed = try_find_sym(gio, "g_list_model_items_changed");
    // Header /usr/include/glib-2.0/gio/gliststore.h
    stub_funcs.ptr_g_list_store_get_type = try_find_sym(gio, "g_list_store_get_type");
    stub_funcs.ptr_g_list_store_new = try_find_sym(gio, "g_list_store_new");
    stub_funcs.ptr_g_list_store_insert = try_find_sym(gio, "g_list_store_insert");
    stub_funcs.ptr_g_list_store_insert_sorted = try_find_sym(gio, "g_list_store_insert_sorted");
    stub_funcs.ptr_g_list_store_sort = try_find_sym(gio, "g_list_store_sort");
    stub_funcs.ptr_g_list_store_append = try_find_sym(gio, "g_list_store_append");
    stub_funcs.ptr_g_list_store_remove = try_find_sym(gio, "g_list_store_remove");
    stub_funcs.ptr_g_list_store_remove_all = try_find_sym(gio, "g_list_store_remove_all");
    stub_funcs.ptr_g_list_store_splice = try_find_sym(gio, "g_list_store_splice");
    stub_funcs.ptr_g_list_store_find = try_find_sym(gio, "g_list_store_find");
    stub_funcs.ptr_g_list_store_find_with_equal_func = try_find_sym(gio, "g_list_store_find_with_equal_func");
    stub_funcs.ptr_g_list_store_find_with_equal_func_full = try_find_sym(gio, "g_list_store_find_with_equal_func_full");
    // Header /usr/include/glib-2.0/gio/gloadableicon.h
    stub_funcs.ptr_g_loadable_icon_get_type = try_find_sym(gio, "g_loadable_icon_get_type");
    stub_funcs.ptr_g_loadable_icon_load = try_find_sym(gio, "g_loadable_icon_load");
    stub_funcs.ptr_g_loadable_icon_load_async = try_find_sym(gio, "g_loadable_icon_load_async");
    stub_funcs.ptr_g_loadable_icon_load_finish = try_find_sym(gio, "g_loadable_icon_load_finish");
    // Header /usr/include/glib-2.0/gio/gmemoryinputstream.h
    stub_funcs.ptr_g_memory_input_stream_get_type = try_find_sym(gio, "g_memory_input_stream_get_type");
    stub_funcs.ptr_g_memory_input_stream_new = try_find_sym(gio, "g_memory_input_stream_new");
    stub_funcs.ptr_g_memory_input_stream_new_from_data = try_find_sym(gio, "g_memory_input_stream_new_from_data");
    stub_funcs.ptr_g_memory_input_stream_new_from_bytes = try_find_sym(gio, "g_memory_input_stream_new_from_bytes");
    stub_funcs.ptr_g_memory_input_stream_add_data = try_find_sym(gio, "g_memory_input_stream_add_data");
    stub_funcs.ptr_g_memory_input_stream_add_bytes = try_find_sym(gio, "g_memory_input_stream_add_bytes");
    // Header /usr/include/glib-2.0/gio/gmemorymonitor.h
    stub_funcs.ptr_g_memory_monitor_get_type = try_find_sym(gio, "g_memory_monitor_get_type");
    // Header /usr/include/glib-2.0/gio/gmemoryoutputstream.h
    stub_funcs.ptr_g_memory_output_stream_get_type = try_find_sym(gio, "g_memory_output_stream_get_type");
    stub_funcs.ptr_g_memory_output_stream_new = try_find_sym(gio, "g_memory_output_stream_new");
    stub_funcs.ptr_g_memory_output_stream_new_resizable = try_find_sym(gio, "g_memory_output_stream_new_resizable");
    stub_funcs.ptr_g_memory_output_stream_get_data = try_find_sym(gio, "g_memory_output_stream_get_data");
    stub_funcs.ptr_g_memory_output_stream_get_size = try_find_sym(gio, "g_memory_output_stream_get_size");
    stub_funcs.ptr_g_memory_output_stream_get_data_size = try_find_sym(gio, "g_memory_output_stream_get_data_size");
    stub_funcs.ptr_g_memory_output_stream_steal_data = try_find_sym(gio, "g_memory_output_stream_steal_data");
    stub_funcs.ptr_g_memory_output_stream_steal_as_bytes = try_find_sym(gio, "g_memory_output_stream_steal_as_bytes");
    // Header /usr/include/glib-2.0/gio/gmenu.h
    stub_funcs.ptr_g_menu_get_type = try_find_sym(gio, "g_menu_get_type");
    stub_funcs.ptr_g_menu_item_get_type = try_find_sym(gio, "g_menu_item_get_type");
    stub_funcs.ptr_g_menu_new = try_find_sym(gio, "g_menu_new");
    stub_funcs.ptr_g_menu_freeze = try_find_sym(gio, "g_menu_freeze");
    stub_funcs.ptr_g_menu_insert_item = try_find_sym(gio, "g_menu_insert_item");
    stub_funcs.ptr_g_menu_prepend_item = try_find_sym(gio, "g_menu_prepend_item");
    stub_funcs.ptr_g_menu_append_item = try_find_sym(gio, "g_menu_append_item");
    stub_funcs.ptr_g_menu_remove = try_find_sym(gio, "g_menu_remove");
    stub_funcs.ptr_g_menu_remove_all = try_find_sym(gio, "g_menu_remove_all");
    stub_funcs.ptr_g_menu_insert = try_find_sym(gio, "g_menu_insert");
    stub_funcs.ptr_g_menu_prepend = try_find_sym(gio, "g_menu_prepend");
    stub_funcs.ptr_g_menu_append = try_find_sym(gio, "g_menu_append");
    stub_funcs.ptr_g_menu_insert_section = try_find_sym(gio, "g_menu_insert_section");
    stub_funcs.ptr_g_menu_prepend_section = try_find_sym(gio, "g_menu_prepend_section");
    stub_funcs.ptr_g_menu_append_section = try_find_sym(gio, "g_menu_append_section");
    stub_funcs.ptr_g_menu_insert_submenu = try_find_sym(gio, "g_menu_insert_submenu");
    stub_funcs.ptr_g_menu_prepend_submenu = try_find_sym(gio, "g_menu_prepend_submenu");
    stub_funcs.ptr_g_menu_append_submenu = try_find_sym(gio, "g_menu_append_submenu");
    stub_funcs.ptr_g_menu_item_new = try_find_sym(gio, "g_menu_item_new");
    stub_funcs.ptr_g_menu_item_new_from_model = try_find_sym(gio, "g_menu_item_new_from_model");
    stub_funcs.ptr_g_menu_item_new_submenu = try_find_sym(gio, "g_menu_item_new_submenu");
    stub_funcs.ptr_g_menu_item_new_section = try_find_sym(gio, "g_menu_item_new_section");
    stub_funcs.ptr_g_menu_item_get_attribute_value = try_find_sym(gio, "g_menu_item_get_attribute_value");
    stub_funcs.ptr_g_menu_item_get_link = try_find_sym(gio, "g_menu_item_get_link");
    stub_funcs.ptr_g_menu_item_set_attribute_value = try_find_sym(gio, "g_menu_item_set_attribute_value");
    stub_funcs.ptr_g_menu_item_set_link = try_find_sym(gio, "g_menu_item_set_link");
    stub_funcs.ptr_g_menu_item_set_label = try_find_sym(gio, "g_menu_item_set_label");
    stub_funcs.ptr_g_menu_item_set_submenu = try_find_sym(gio, "g_menu_item_set_submenu");
    stub_funcs.ptr_g_menu_item_set_section = try_find_sym(gio, "g_menu_item_set_section");
    stub_funcs.ptr_g_menu_item_set_action_and_target_value = try_find_sym(gio, "g_menu_item_set_action_and_target_value");
    stub_funcs.ptr_g_menu_item_set_detailed_action = try_find_sym(gio, "g_menu_item_set_detailed_action");
    stub_funcs.ptr_g_menu_item_set_icon = try_find_sym(gio, "g_menu_item_set_icon");
    // Header /usr/include/glib-2.0/gio/gmenuexporter.h
    stub_funcs.ptr_g_dbus_connection_unexport_menu_model = try_find_sym(gio, "g_dbus_connection_unexport_menu_model");
    stub_funcs.ptr_g_dbus_connection_export_menu_model = try_find_sym(gio, "g_dbus_connection_export_menu_model");
    // Header /usr/include/glib-2.0/gio/gmenumodel.h
    stub_funcs.ptr_g_menu_model_get_type = try_find_sym(gio, "g_menu_model_get_type");
    stub_funcs.ptr_g_menu_model_is_mutable = try_find_sym(gio, "g_menu_model_is_mutable");
    stub_funcs.ptr_g_menu_model_get_n_items = try_find_sym(gio, "g_menu_model_get_n_items");
    stub_funcs.ptr_g_menu_model_iterate_item_attributes = try_find_sym(gio, "g_menu_model_iterate_item_attributes");
    stub_funcs.ptr_g_menu_model_get_item_attribute_value = try_find_sym(gio, "g_menu_model_get_item_attribute_value");
    stub_funcs.ptr_g_menu_model_iterate_item_links = try_find_sym(gio, "g_menu_model_iterate_item_links");
    stub_funcs.ptr_g_menu_model_get_item_link = try_find_sym(gio, "g_menu_model_get_item_link");
    stub_funcs.ptr_g_menu_model_items_changed = try_find_sym(gio, "g_menu_model_items_changed");
    stub_funcs.ptr_g_menu_attribute_iter_get_type = try_find_sym(gio, "g_menu_attribute_iter_get_type");
    stub_funcs.ptr_g_menu_attribute_iter_get_next = try_find_sym(gio, "g_menu_attribute_iter_get_next");
    stub_funcs.ptr_g_menu_attribute_iter_next = try_find_sym(gio, "g_menu_attribute_iter_next");
    stub_funcs.ptr_g_menu_attribute_iter_get_name = try_find_sym(gio, "g_menu_attribute_iter_get_name");
    stub_funcs.ptr_g_menu_attribute_iter_get_value = try_find_sym(gio, "g_menu_attribute_iter_get_value");
    stub_funcs.ptr_g_menu_link_iter_get_type = try_find_sym(gio, "g_menu_link_iter_get_type");
    stub_funcs.ptr_g_menu_link_iter_get_next = try_find_sym(gio, "g_menu_link_iter_get_next");
    stub_funcs.ptr_g_menu_link_iter_next = try_find_sym(gio, "g_menu_link_iter_next");
    stub_funcs.ptr_g_menu_link_iter_get_name = try_find_sym(gio, "g_menu_link_iter_get_name");
    stub_funcs.ptr_g_menu_link_iter_get_value = try_find_sym(gio, "g_menu_link_iter_get_value");
    // Header /usr/include/glib-2.0/gio/gmount.h
    stub_funcs.ptr_g_mount_get_type = try_find_sym(gio, "g_mount_get_type");
    stub_funcs.ptr_g_mount_get_root = try_find_sym(gio, "g_mount_get_root");
    stub_funcs.ptr_g_mount_get_default_location = try_find_sym(gio, "g_mount_get_default_location");
    stub_funcs.ptr_g_mount_get_name = try_find_sym(gio, "g_mount_get_name");
    stub_funcs.ptr_g_mount_get_icon = try_find_sym(gio, "g_mount_get_icon");
    stub_funcs.ptr_g_mount_get_symbolic_icon = try_find_sym(gio, "g_mount_get_symbolic_icon");
    stub_funcs.ptr_g_mount_get_uuid = try_find_sym(gio, "g_mount_get_uuid");
    stub_funcs.ptr_g_mount_get_volume = try_find_sym(gio, "g_mount_get_volume");
    stub_funcs.ptr_g_mount_get_drive = try_find_sym(gio, "g_mount_get_drive");
    stub_funcs.ptr_g_mount_can_unmount = try_find_sym(gio, "g_mount_can_unmount");
    stub_funcs.ptr_g_mount_can_eject = try_find_sym(gio, "g_mount_can_eject");
    stub_funcs.ptr_g_mount_unmount = try_find_sym(gio, "g_mount_unmount");
    stub_funcs.ptr_g_mount_unmount_finish = try_find_sym(gio, "g_mount_unmount_finish");
    stub_funcs.ptr_g_mount_eject = try_find_sym(gio, "g_mount_eject");
    stub_funcs.ptr_g_mount_eject_finish = try_find_sym(gio, "g_mount_eject_finish");
    stub_funcs.ptr_g_mount_remount = try_find_sym(gio, "g_mount_remount");
    stub_funcs.ptr_g_mount_remount_finish = try_find_sym(gio, "g_mount_remount_finish");
    stub_funcs.ptr_g_mount_guess_content_type = try_find_sym(gio, "g_mount_guess_content_type");
    stub_funcs.ptr_g_mount_guess_content_type_finish = try_find_sym(gio, "g_mount_guess_content_type_finish");
    stub_funcs.ptr_g_mount_guess_content_type_sync = try_find_sym(gio, "g_mount_guess_content_type_sync");
    stub_funcs.ptr_g_mount_is_shadowed = try_find_sym(gio, "g_mount_is_shadowed");
    stub_funcs.ptr_g_mount_shadow = try_find_sym(gio, "g_mount_shadow");
    stub_funcs.ptr_g_mount_unshadow = try_find_sym(gio, "g_mount_unshadow");
    stub_funcs.ptr_g_mount_unmount_with_operation = try_find_sym(gio, "g_mount_unmount_with_operation");
    stub_funcs.ptr_g_mount_unmount_with_operation_finish = try_find_sym(gio, "g_mount_unmount_with_operation_finish");
    stub_funcs.ptr_g_mount_eject_with_operation = try_find_sym(gio, "g_mount_eject_with_operation");
    stub_funcs.ptr_g_mount_eject_with_operation_finish = try_find_sym(gio, "g_mount_eject_with_operation_finish");
    stub_funcs.ptr_g_mount_get_sort_key = try_find_sym(gio, "g_mount_get_sort_key");
    // Header /usr/include/glib-2.0/gio/gmountoperation.h
    stub_funcs.ptr_g_mount_operation_get_type = try_find_sym(gio, "g_mount_operation_get_type");
    stub_funcs.ptr_g_mount_operation_new = try_find_sym(gio, "g_mount_operation_new");
    stub_funcs.ptr_g_mount_operation_get_username = try_find_sym(gio, "g_mount_operation_get_username");
    stub_funcs.ptr_g_mount_operation_set_username = try_find_sym(gio, "g_mount_operation_set_username");
    stub_funcs.ptr_g_mount_operation_get_password = try_find_sym(gio, "g_mount_operation_get_password");
    stub_funcs.ptr_g_mount_operation_set_password = try_find_sym(gio, "g_mount_operation_set_password");
    stub_funcs.ptr_g_mount_operation_get_anonymous = try_find_sym(gio, "g_mount_operation_get_anonymous");
    stub_funcs.ptr_g_mount_operation_set_anonymous = try_find_sym(gio, "g_mount_operation_set_anonymous");
    stub_funcs.ptr_g_mount_operation_get_domain = try_find_sym(gio, "g_mount_operation_get_domain");
    stub_funcs.ptr_g_mount_operation_set_domain = try_find_sym(gio, "g_mount_operation_set_domain");
    stub_funcs.ptr_g_mount_operation_get_password_save = try_find_sym(gio, "g_mount_operation_get_password_save");
    stub_funcs.ptr_g_mount_operation_set_password_save = try_find_sym(gio, "g_mount_operation_set_password_save");
    stub_funcs.ptr_g_mount_operation_get_choice = try_find_sym(gio, "g_mount_operation_get_choice");
    stub_funcs.ptr_g_mount_operation_set_choice = try_find_sym(gio, "g_mount_operation_set_choice");
    stub_funcs.ptr_g_mount_operation_reply = try_find_sym(gio, "g_mount_operation_reply");
    stub_funcs.ptr_g_mount_operation_get_is_tcrypt_hidden_volume = try_find_sym(gio, "g_mount_operation_get_is_tcrypt_hidden_volume");
    stub_funcs.ptr_g_mount_operation_set_is_tcrypt_hidden_volume = try_find_sym(gio, "g_mount_operation_set_is_tcrypt_hidden_volume");
    stub_funcs.ptr_g_mount_operation_get_is_tcrypt_system_volume = try_find_sym(gio, "g_mount_operation_get_is_tcrypt_system_volume");
    stub_funcs.ptr_g_mount_operation_set_is_tcrypt_system_volume = try_find_sym(gio, "g_mount_operation_set_is_tcrypt_system_volume");
    stub_funcs.ptr_g_mount_operation_get_pim = try_find_sym(gio, "g_mount_operation_get_pim");
    stub_funcs.ptr_g_mount_operation_set_pim = try_find_sym(gio, "g_mount_operation_set_pim");
    // Header /usr/include/glib-2.0/gio/gnativesocketaddress.h
    stub_funcs.ptr_g_native_socket_address_get_type = try_find_sym(gio, "g_native_socket_address_get_type");
    stub_funcs.ptr_g_native_socket_address_new = try_find_sym(gio, "g_native_socket_address_new");
    // Header /usr/include/glib-2.0/gio/gnativevolumemonitor.h
    stub_funcs.ptr_g_native_volume_monitor_get_type = try_find_sym(gio, "g_native_volume_monitor_get_type");
    // Header /usr/include/glib-2.0/gio/gnetworkaddress.h
    stub_funcs.ptr_g_network_address_get_type = try_find_sym(gio, "g_network_address_get_type");
    stub_funcs.ptr_g_network_address_new = try_find_sym(gio, "g_network_address_new");
    stub_funcs.ptr_g_network_address_new_loopback = try_find_sym(gio, "g_network_address_new_loopback");
    stub_funcs.ptr_g_network_address_parse = try_find_sym(gio, "g_network_address_parse");
    stub_funcs.ptr_g_network_address_parse_uri = try_find_sym(gio, "g_network_address_parse_uri");
    stub_funcs.ptr_g_network_address_get_hostname = try_find_sym(gio, "g_network_address_get_hostname");
    stub_funcs.ptr_g_network_address_get_port = try_find_sym(gio, "g_network_address_get_port");
    stub_funcs.ptr_g_network_address_get_scheme = try_find_sym(gio, "g_network_address_get_scheme");
    // Header /usr/include/glib-2.0/gio/gnetworking.h
    stub_funcs.ptr_g_networking_init = try_find_sym(gio, "g_networking_init");
    // Header /usr/include/glib-2.0/gio/gnetworkmonitor.h
    stub_funcs.ptr_g_network_monitor_get_type = try_find_sym(gio, "g_network_monitor_get_type");
    stub_funcs.ptr_g_network_monitor_get_default = try_find_sym(gio, "g_network_monitor_get_default");
    stub_funcs.ptr_g_network_monitor_get_network_available = try_find_sym(gio, "g_network_monitor_get_network_available");
    stub_funcs.ptr_g_network_monitor_get_network_metered = try_find_sym(gio, "g_network_monitor_get_network_metered");
    stub_funcs.ptr_g_network_monitor_get_connectivity = try_find_sym(gio, "g_network_monitor_get_connectivity");
    stub_funcs.ptr_g_network_monitor_can_reach = try_find_sym(gio, "g_network_monitor_can_reach");
    stub_funcs.ptr_g_network_monitor_can_reach_async = try_find_sym(gio, "g_network_monitor_can_reach_async");
    stub_funcs.ptr_g_network_monitor_can_reach_finish = try_find_sym(gio, "g_network_monitor_can_reach_finish");
    // Header /usr/include/glib-2.0/gio/gnetworkservice.h
    stub_funcs.ptr_g_network_service_get_type = try_find_sym(gio, "g_network_service_get_type");
    stub_funcs.ptr_g_network_service_new = try_find_sym(gio, "g_network_service_new");
    stub_funcs.ptr_g_network_service_get_service = try_find_sym(gio, "g_network_service_get_service");
    stub_funcs.ptr_g_network_service_get_protocol = try_find_sym(gio, "g_network_service_get_protocol");
    stub_funcs.ptr_g_network_service_get_domain = try_find_sym(gio, "g_network_service_get_domain");
    stub_funcs.ptr_g_network_service_get_scheme = try_find_sym(gio, "g_network_service_get_scheme");
    stub_funcs.ptr_g_network_service_set_scheme = try_find_sym(gio, "g_network_service_set_scheme");
    // Header /usr/include/glib-2.0/gio/gnotification.h
    stub_funcs.ptr_g_notification_get_type = try_find_sym(gio, "g_notification_get_type");
    stub_funcs.ptr_g_notification_new = try_find_sym(gio, "g_notification_new");
    stub_funcs.ptr_g_notification_set_title = try_find_sym(gio, "g_notification_set_title");
    stub_funcs.ptr_g_notification_set_body = try_find_sym(gio, "g_notification_set_body");
    stub_funcs.ptr_g_notification_set_icon = try_find_sym(gio, "g_notification_set_icon");
    stub_funcs.ptr_g_notification_set_urgent = try_find_sym(gio, "g_notification_set_urgent");
    stub_funcs.ptr_g_notification_set_priority = try_find_sym(gio, "g_notification_set_priority");
    stub_funcs.ptr_g_notification_set_category = try_find_sym(gio, "g_notification_set_category");
    stub_funcs.ptr_g_notification_add_button = try_find_sym(gio, "g_notification_add_button");
    stub_funcs.ptr_g_notification_add_button_with_target_value = try_find_sym(gio, "g_notification_add_button_with_target_value");
    stub_funcs.ptr_g_notification_set_default_action = try_find_sym(gio, "g_notification_set_default_action");
    stub_funcs.ptr_g_notification_set_default_action_and_target_value = try_find_sym(gio, "g_notification_set_default_action_and_target_value");
    // Header /usr/include/glib-2.0/gio/goutputstream.h
    stub_funcs.ptr_g_output_stream_get_type = try_find_sym(gio, "g_output_stream_get_type");
    stub_funcs.ptr_g_output_stream_write = try_find_sym(gio, "g_output_stream_write");
    stub_funcs.ptr_g_output_stream_write_all = try_find_sym(gio, "g_output_stream_write_all");
    stub_funcs.ptr_g_output_stream_writev = try_find_sym(gio, "g_output_stream_writev");
    stub_funcs.ptr_g_output_stream_writev_all = try_find_sym(gio, "g_output_stream_writev_all");
    stub_funcs.ptr_g_output_stream_vprintf = try_find_sym(gio, "g_output_stream_vprintf");
    stub_funcs.ptr_g_output_stream_write_bytes = try_find_sym(gio, "g_output_stream_write_bytes");
    stub_funcs.ptr_g_output_stream_splice = try_find_sym(gio, "g_output_stream_splice");
    stub_funcs.ptr_g_output_stream_flush = try_find_sym(gio, "g_output_stream_flush");
    stub_funcs.ptr_g_output_stream_close = try_find_sym(gio, "g_output_stream_close");
    stub_funcs.ptr_g_output_stream_write_async = try_find_sym(gio, "g_output_stream_write_async");
    stub_funcs.ptr_g_output_stream_write_finish = try_find_sym(gio, "g_output_stream_write_finish");
    stub_funcs.ptr_g_output_stream_write_all_async = try_find_sym(gio, "g_output_stream_write_all_async");
    stub_funcs.ptr_g_output_stream_write_all_finish = try_find_sym(gio, "g_output_stream_write_all_finish");
    stub_funcs.ptr_g_output_stream_writev_async = try_find_sym(gio, "g_output_stream_writev_async");
    stub_funcs.ptr_g_output_stream_writev_finish = try_find_sym(gio, "g_output_stream_writev_finish");
    stub_funcs.ptr_g_output_stream_writev_all_async = try_find_sym(gio, "g_output_stream_writev_all_async");
    stub_funcs.ptr_g_output_stream_writev_all_finish = try_find_sym(gio, "g_output_stream_writev_all_finish");
    stub_funcs.ptr_g_output_stream_write_bytes_async = try_find_sym(gio, "g_output_stream_write_bytes_async");
    stub_funcs.ptr_g_output_stream_write_bytes_finish = try_find_sym(gio, "g_output_stream_write_bytes_finish");
    stub_funcs.ptr_g_output_stream_splice_async = try_find_sym(gio, "g_output_stream_splice_async");
    stub_funcs.ptr_g_output_stream_splice_finish = try_find_sym(gio, "g_output_stream_splice_finish");
    stub_funcs.ptr_g_output_stream_flush_async = try_find_sym(gio, "g_output_stream_flush_async");
    stub_funcs.ptr_g_output_stream_flush_finish = try_find_sym(gio, "g_output_stream_flush_finish");
    stub_funcs.ptr_g_output_stream_close_async = try_find_sym(gio, "g_output_stream_close_async");
    stub_funcs.ptr_g_output_stream_close_finish = try_find_sym(gio, "g_output_stream_close_finish");
    stub_funcs.ptr_g_output_stream_is_closed = try_find_sym(gio, "g_output_stream_is_closed");
    stub_funcs.ptr_g_output_stream_is_closing = try_find_sym(gio, "g_output_stream_is_closing");
    stub_funcs.ptr_g_output_stream_has_pending = try_find_sym(gio, "g_output_stream_has_pending");
    stub_funcs.ptr_g_output_stream_set_pending = try_find_sym(gio, "g_output_stream_set_pending");
    stub_funcs.ptr_g_output_stream_clear_pending = try_find_sym(gio, "g_output_stream_clear_pending");
    // Header /usr/include/glib-2.0/gio/gpermission.h
    stub_funcs.ptr_g_permission_get_type = try_find_sym(gio, "g_permission_get_type");
    stub_funcs.ptr_g_permission_acquire = try_find_sym(gio, "g_permission_acquire");
    stub_funcs.ptr_g_permission_acquire_async = try_find_sym(gio, "g_permission_acquire_async");
    stub_funcs.ptr_g_permission_acquire_finish = try_find_sym(gio, "g_permission_acquire_finish");
    stub_funcs.ptr_g_permission_release = try_find_sym(gio, "g_permission_release");
    stub_funcs.ptr_g_permission_release_async = try_find_sym(gio, "g_permission_release_async");
    stub_funcs.ptr_g_permission_release_finish = try_find_sym(gio, "g_permission_release_finish");
    stub_funcs.ptr_g_permission_get_allowed = try_find_sym(gio, "g_permission_get_allowed");
    stub_funcs.ptr_g_permission_get_can_acquire = try_find_sym(gio, "g_permission_get_can_acquire");
    stub_funcs.ptr_g_permission_get_can_release = try_find_sym(gio, "g_permission_get_can_release");
    stub_funcs.ptr_g_permission_impl_update = try_find_sym(gio, "g_permission_impl_update");
    // Header /usr/include/glib-2.0/gio/gpollableinputstream.h
    stub_funcs.ptr_g_pollable_input_stream_get_type = try_find_sym(gio, "g_pollable_input_stream_get_type");
    stub_funcs.ptr_g_pollable_input_stream_can_poll = try_find_sym(gio, "g_pollable_input_stream_can_poll");
    stub_funcs.ptr_g_pollable_input_stream_is_readable = try_find_sym(gio, "g_pollable_input_stream_is_readable");
    stub_funcs.ptr_g_pollable_input_stream_create_source = try_find_sym(gio, "g_pollable_input_stream_create_source");
    stub_funcs.ptr_g_pollable_input_stream_read_nonblocking = try_find_sym(gio, "g_pollable_input_stream_read_nonblocking");
    // Header /usr/include/glib-2.0/gio/gpollableoutputstream.h
    stub_funcs.ptr_g_pollable_output_stream_get_type = try_find_sym(gio, "g_pollable_output_stream_get_type");
    stub_funcs.ptr_g_pollable_output_stream_can_poll = try_find_sym(gio, "g_pollable_output_stream_can_poll");
    stub_funcs.ptr_g_pollable_output_stream_is_writable = try_find_sym(gio, "g_pollable_output_stream_is_writable");
    stub_funcs.ptr_g_pollable_output_stream_create_source = try_find_sym(gio, "g_pollable_output_stream_create_source");
    stub_funcs.ptr_g_pollable_output_stream_write_nonblocking = try_find_sym(gio, "g_pollable_output_stream_write_nonblocking");
    stub_funcs.ptr_g_pollable_output_stream_writev_nonblocking = try_find_sym(gio, "g_pollable_output_stream_writev_nonblocking");
    // Header /usr/include/glib-2.0/gio/gpollableutils.h
    stub_funcs.ptr_g_pollable_source_new_full = try_find_sym(gio, "g_pollable_source_new_full");
    stub_funcs.ptr_g_pollable_stream_read = try_find_sym(gio, "g_pollable_stream_read");
    stub_funcs.ptr_g_pollable_stream_write = try_find_sym(gio, "g_pollable_stream_write");
    stub_funcs.ptr_g_pollable_stream_write_all = try_find_sym(gio, "g_pollable_stream_write_all");
    stub_funcs.ptr_g_pollable_source_new = try_find_sym(gio, "g_pollable_source_new");
    // Header /usr/include/glib-2.0/gio/gpowerprofilemonitor.h
    stub_funcs.ptr_g_power_profile_monitor_get_type = try_find_sym(gio, "g_power_profile_monitor_get_type");
    stub_funcs.ptr_g_power_profile_monitor_get_power_saver_enabled = try_find_sym(gio, "g_power_profile_monitor_get_power_saver_enabled");
    // Header /usr/include/glib-2.0/gio/gpropertyaction.h
    stub_funcs.ptr_g_property_action_get_type = try_find_sym(gio, "g_property_action_get_type");
    stub_funcs.ptr_g_property_action_new = try_find_sym(gio, "g_property_action_new");
    // Header /usr/include/glib-2.0/gio/gproxy.h
    stub_funcs.ptr_g_proxy_get_type = try_find_sym(gio, "g_proxy_get_type");
    stub_funcs.ptr_g_proxy_get_default_for_protocol = try_find_sym(gio, "g_proxy_get_default_for_protocol");
    stub_funcs.ptr_g_proxy_connect = try_find_sym(gio, "g_proxy_connect");
    stub_funcs.ptr_g_proxy_connect_async = try_find_sym(gio, "g_proxy_connect_async");
    stub_funcs.ptr_g_proxy_connect_finish = try_find_sym(gio, "g_proxy_connect_finish");
    stub_funcs.ptr_g_proxy_supports_hostname = try_find_sym(gio, "g_proxy_supports_hostname");
    // Header /usr/include/glib-2.0/gio/gproxyaddress.h
    stub_funcs.ptr_g_proxy_address_get_type = try_find_sym(gio, "g_proxy_address_get_type");
    stub_funcs.ptr_g_proxy_address_new = try_find_sym(gio, "g_proxy_address_new");
    stub_funcs.ptr_g_proxy_address_get_protocol = try_find_sym(gio, "g_proxy_address_get_protocol");
    stub_funcs.ptr_g_proxy_address_get_destination_protocol = try_find_sym(gio, "g_proxy_address_get_destination_protocol");
    stub_funcs.ptr_g_proxy_address_get_destination_hostname = try_find_sym(gio, "g_proxy_address_get_destination_hostname");
    stub_funcs.ptr_g_proxy_address_get_destination_port = try_find_sym(gio, "g_proxy_address_get_destination_port");
    stub_funcs.ptr_g_proxy_address_get_username = try_find_sym(gio, "g_proxy_address_get_username");
    stub_funcs.ptr_g_proxy_address_get_password = try_find_sym(gio, "g_proxy_address_get_password");
    stub_funcs.ptr_g_proxy_address_get_uri = try_find_sym(gio, "g_proxy_address_get_uri");
    // Header /usr/include/glib-2.0/gio/gproxyaddressenumerator.h
    stub_funcs.ptr_g_proxy_address_enumerator_get_type = try_find_sym(gio, "g_proxy_address_enumerator_get_type");
    // Header /usr/include/glib-2.0/gio/gproxyresolver.h
    stub_funcs.ptr_g_proxy_resolver_get_type = try_find_sym(gio, "g_proxy_resolver_get_type");
    stub_funcs.ptr_g_proxy_resolver_get_default = try_find_sym(gio, "g_proxy_resolver_get_default");
    stub_funcs.ptr_g_proxy_resolver_is_supported = try_find_sym(gio, "g_proxy_resolver_is_supported");
    stub_funcs.ptr_g_proxy_resolver_lookup = try_find_sym(gio, "g_proxy_resolver_lookup");
    stub_funcs.ptr_g_proxy_resolver_lookup_async = try_find_sym(gio, "g_proxy_resolver_lookup_async");
    stub_funcs.ptr_g_proxy_resolver_lookup_finish = try_find_sym(gio, "g_proxy_resolver_lookup_finish");
    // Header /usr/include/glib-2.0/gio/gremoteactiongroup.h
    stub_funcs.ptr_g_remote_action_group_get_type = try_find_sym(gio, "g_remote_action_group_get_type");
    stub_funcs.ptr_g_remote_action_group_activate_action_full = try_find_sym(gio, "g_remote_action_group_activate_action_full");
    stub_funcs.ptr_g_remote_action_group_change_action_state_full = try_find_sym(gio, "g_remote_action_group_change_action_state_full");
    // Header /usr/include/glib-2.0/gio/gresolver.h
    stub_funcs.ptr_g_resolver_get_type = try_find_sym(gio, "g_resolver_get_type");
    stub_funcs.ptr_g_resolver_get_default = try_find_sym(gio, "g_resolver_get_default");
    stub_funcs.ptr_g_resolver_set_default = try_find_sym(gio, "g_resolver_set_default");
    stub_funcs.ptr_g_resolver_lookup_by_name = try_find_sym(gio, "g_resolver_lookup_by_name");
    stub_funcs.ptr_g_resolver_lookup_by_name_async = try_find_sym(gio, "g_resolver_lookup_by_name_async");
    stub_funcs.ptr_g_resolver_lookup_by_name_finish = try_find_sym(gio, "g_resolver_lookup_by_name_finish");
    stub_funcs.ptr_g_resolver_lookup_by_name_with_flags_async = try_find_sym(gio, "g_resolver_lookup_by_name_with_flags_async");
    stub_funcs.ptr_g_resolver_lookup_by_name_with_flags_finish = try_find_sym(gio, "g_resolver_lookup_by_name_with_flags_finish");
    stub_funcs.ptr_g_resolver_lookup_by_name_with_flags = try_find_sym(gio, "g_resolver_lookup_by_name_with_flags");
    stub_funcs.ptr_g_resolver_free_addresses = try_find_sym(gio, "g_resolver_free_addresses");
    stub_funcs.ptr_g_resolver_lookup_by_address = try_find_sym(gio, "g_resolver_lookup_by_address");
    stub_funcs.ptr_g_resolver_lookup_by_address_async = try_find_sym(gio, "g_resolver_lookup_by_address_async");
    stub_funcs.ptr_g_resolver_lookup_by_address_finish = try_find_sym(gio, "g_resolver_lookup_by_address_finish");
    stub_funcs.ptr_g_resolver_lookup_service = try_find_sym(gio, "g_resolver_lookup_service");
    stub_funcs.ptr_g_resolver_lookup_service_async = try_find_sym(gio, "g_resolver_lookup_service_async");
    stub_funcs.ptr_g_resolver_lookup_service_finish = try_find_sym(gio, "g_resolver_lookup_service_finish");
    stub_funcs.ptr_g_resolver_lookup_records = try_find_sym(gio, "g_resolver_lookup_records");
    stub_funcs.ptr_g_resolver_lookup_records_async = try_find_sym(gio, "g_resolver_lookup_records_async");
    stub_funcs.ptr_g_resolver_lookup_records_finish = try_find_sym(gio, "g_resolver_lookup_records_finish");
    stub_funcs.ptr_g_resolver_free_targets = try_find_sym(gio, "g_resolver_free_targets");
    stub_funcs.ptr_g_resolver_get_timeout = try_find_sym(gio, "g_resolver_get_timeout");
    stub_funcs.ptr_g_resolver_set_timeout = try_find_sym(gio, "g_resolver_set_timeout");
    stub_funcs.ptr_g_resolver_error_quark = try_find_sym(gio, "g_resolver_error_quark");
    // Header /usr/include/glib-2.0/gio/gresource.h
    stub_funcs.ptr_g_resource_get_type = try_find_sym(gio, "g_resource_get_type");
    stub_funcs.ptr_g_resource_error_quark = try_find_sym(gio, "g_resource_error_quark");
    stub_funcs.ptr_g_resource_new_from_data = try_find_sym(gio, "g_resource_new_from_data");
    stub_funcs.ptr_g_resource_ref = try_find_sym(gio, "g_resource_ref");
    stub_funcs.ptr_g_resource_unref = try_find_sym(gio, "g_resource_unref");
    stub_funcs.ptr_g_resource_load = try_find_sym(gio, "g_resource_load");
    stub_funcs.ptr_g_resource_open_stream = try_find_sym(gio, "g_resource_open_stream");
    stub_funcs.ptr_g_resource_lookup_data = try_find_sym(gio, "g_resource_lookup_data");
    stub_funcs.ptr_g_resource_enumerate_children = try_find_sym(gio, "g_resource_enumerate_children");
    stub_funcs.ptr_g_resource_get_info = try_find_sym(gio, "g_resource_get_info");
    stub_funcs.ptr_g_resources_register = try_find_sym(gio, "g_resources_register");
    stub_funcs.ptr_g_resources_unregister = try_find_sym(gio, "g_resources_unregister");
    stub_funcs.ptr_g_resources_open_stream = try_find_sym(gio, "g_resources_open_stream");
    stub_funcs.ptr_g_resources_lookup_data = try_find_sym(gio, "g_resources_lookup_data");
    stub_funcs.ptr_g_resources_enumerate_children = try_find_sym(gio, "g_resources_enumerate_children");
    stub_funcs.ptr_g_resources_get_info = try_find_sym(gio, "g_resources_get_info");
    // Header /usr/include/glib-2.0/gio/gseekable.h
    stub_funcs.ptr_g_seekable_get_type = try_find_sym(gio, "g_seekable_get_type");
    stub_funcs.ptr_g_seekable_tell = try_find_sym(gio, "g_seekable_tell");
    stub_funcs.ptr_g_seekable_can_seek = try_find_sym(gio, "g_seekable_can_seek");
    stub_funcs.ptr_g_seekable_seek = try_find_sym(gio, "g_seekable_seek");
    stub_funcs.ptr_g_seekable_can_truncate = try_find_sym(gio, "g_seekable_can_truncate");
    stub_funcs.ptr_g_seekable_truncate = try_find_sym(gio, "g_seekable_truncate");
    // Header /usr/include/glib-2.0/gio/gsettings.h
    stub_funcs.ptr_g_settings_get_type = try_find_sym(gio, "g_settings_get_type");
    stub_funcs.ptr_g_settings_list_schemas = try_find_sym(gio, "g_settings_list_schemas");
    stub_funcs.ptr_g_settings_list_relocatable_schemas = try_find_sym(gio, "g_settings_list_relocatable_schemas");
    stub_funcs.ptr_g_settings_new = try_find_sym(gio, "g_settings_new");
    stub_funcs.ptr_g_settings_new_with_path = try_find_sym(gio, "g_settings_new_with_path");
    stub_funcs.ptr_g_settings_new_with_backend = try_find_sym(gio, "g_settings_new_with_backend");
    stub_funcs.ptr_g_settings_new_with_backend_and_path = try_find_sym(gio, "g_settings_new_with_backend_and_path");
    stub_funcs.ptr_g_settings_new_full = try_find_sym(gio, "g_settings_new_full");
    stub_funcs.ptr_g_settings_list_children = try_find_sym(gio, "g_settings_list_children");
    stub_funcs.ptr_g_settings_list_keys = try_find_sym(gio, "g_settings_list_keys");
    stub_funcs.ptr_g_settings_get_range = try_find_sym(gio, "g_settings_get_range");
    stub_funcs.ptr_g_settings_range_check = try_find_sym(gio, "g_settings_range_check");
    stub_funcs.ptr_g_settings_set_value = try_find_sym(gio, "g_settings_set_value");
    stub_funcs.ptr_g_settings_get_value = try_find_sym(gio, "g_settings_get_value");
    stub_funcs.ptr_g_settings_get_user_value = try_find_sym(gio, "g_settings_get_user_value");
    stub_funcs.ptr_g_settings_get_default_value = try_find_sym(gio, "g_settings_get_default_value");
    stub_funcs.ptr_g_settings_reset = try_find_sym(gio, "g_settings_reset");
    stub_funcs.ptr_g_settings_get_int = try_find_sym(gio, "g_settings_get_int");
    stub_funcs.ptr_g_settings_set_int = try_find_sym(gio, "g_settings_set_int");
    stub_funcs.ptr_g_settings_get_int64 = try_find_sym(gio, "g_settings_get_int64");
    stub_funcs.ptr_g_settings_set_int64 = try_find_sym(gio, "g_settings_set_int64");
    stub_funcs.ptr_g_settings_get_uint = try_find_sym(gio, "g_settings_get_uint");
    stub_funcs.ptr_g_settings_set_uint = try_find_sym(gio, "g_settings_set_uint");
    stub_funcs.ptr_g_settings_get_uint64 = try_find_sym(gio, "g_settings_get_uint64");
    stub_funcs.ptr_g_settings_set_uint64 = try_find_sym(gio, "g_settings_set_uint64");
    stub_funcs.ptr_g_settings_get_string = try_find_sym(gio, "g_settings_get_string");
    stub_funcs.ptr_g_settings_set_string = try_find_sym(gio, "g_settings_set_string");
    stub_funcs.ptr_g_settings_get_boolean = try_find_sym(gio, "g_settings_get_boolean");
    stub_funcs.ptr_g_settings_set_boolean = try_find_sym(gio, "g_settings_set_boolean");
    stub_funcs.ptr_g_settings_get_double = try_find_sym(gio, "g_settings_get_double");
    stub_funcs.ptr_g_settings_set_double = try_find_sym(gio, "g_settings_set_double");
    stub_funcs.ptr_g_settings_get_strv = try_find_sym(gio, "g_settings_get_strv");
    stub_funcs.ptr_g_settings_set_strv = try_find_sym(gio, "g_settings_set_strv");
    stub_funcs.ptr_g_settings_get_enum = try_find_sym(gio, "g_settings_get_enum");
    stub_funcs.ptr_g_settings_set_enum = try_find_sym(gio, "g_settings_set_enum");
    stub_funcs.ptr_g_settings_get_flags = try_find_sym(gio, "g_settings_get_flags");
    stub_funcs.ptr_g_settings_set_flags = try_find_sym(gio, "g_settings_set_flags");
    stub_funcs.ptr_g_settings_get_child = try_find_sym(gio, "g_settings_get_child");
    stub_funcs.ptr_g_settings_is_writable = try_find_sym(gio, "g_settings_is_writable");
    stub_funcs.ptr_g_settings_delay = try_find_sym(gio, "g_settings_delay");
    stub_funcs.ptr_g_settings_apply = try_find_sym(gio, "g_settings_apply");
    stub_funcs.ptr_g_settings_revert = try_find_sym(gio, "g_settings_revert");
    stub_funcs.ptr_g_settings_get_has_unapplied = try_find_sym(gio, "g_settings_get_has_unapplied");
    stub_funcs.ptr_g_settings_sync = try_find_sym(gio, "g_settings_sync");
    stub_funcs.ptr_g_settings_bind = try_find_sym(gio, "g_settings_bind");
    stub_funcs.ptr_g_settings_bind_with_mapping = try_find_sym(gio, "g_settings_bind_with_mapping");
    stub_funcs.ptr_g_settings_bind_writable = try_find_sym(gio, "g_settings_bind_writable");
    stub_funcs.ptr_g_settings_unbind = try_find_sym(gio, "g_settings_unbind");
    stub_funcs.ptr_g_settings_create_action = try_find_sym(gio, "g_settings_create_action");
    stub_funcs.ptr_g_settings_get_mapped = try_find_sym(gio, "g_settings_get_mapped");
    // Header /usr/include/glib-2.0/gio/gsettingsbackend.h
    stub_funcs.ptr_g_settings_backend_get_type = try_find_sym(gio, "g_settings_backend_get_type");
    stub_funcs.ptr_g_settings_backend_changed = try_find_sym(gio, "g_settings_backend_changed");
    stub_funcs.ptr_g_settings_backend_path_changed = try_find_sym(gio, "g_settings_backend_path_changed");
    stub_funcs.ptr_g_settings_backend_flatten_tree = try_find_sym(gio, "g_settings_backend_flatten_tree");
    stub_funcs.ptr_g_settings_backend_keys_changed = try_find_sym(gio, "g_settings_backend_keys_changed");
    stub_funcs.ptr_g_settings_backend_path_writable_changed = try_find_sym(gio, "g_settings_backend_path_writable_changed");
    stub_funcs.ptr_g_settings_backend_writable_changed = try_find_sym(gio, "g_settings_backend_writable_changed");
    stub_funcs.ptr_g_settings_backend_changed_tree = try_find_sym(gio, "g_settings_backend_changed_tree");
    stub_funcs.ptr_g_settings_backend_get_default = try_find_sym(gio, "g_settings_backend_get_default");
    stub_funcs.ptr_g_keyfile_settings_backend_new = try_find_sym(gio, "g_keyfile_settings_backend_new");
    stub_funcs.ptr_g_null_settings_backend_new = try_find_sym(gio, "g_null_settings_backend_new");
    stub_funcs.ptr_g_memory_settings_backend_new = try_find_sym(gio, "g_memory_settings_backend_new");
    // Header /usr/include/glib-2.0/gio/gsettingsschema.h
    stub_funcs.ptr_g_settings_schema_source_get_default = try_find_sym(gio, "g_settings_schema_source_get_default");
    stub_funcs.ptr_g_settings_schema_source_ref = try_find_sym(gio, "g_settings_schema_source_ref");
    stub_funcs.ptr_g_settings_schema_source_unref = try_find_sym(gio, "g_settings_schema_source_unref");
    stub_funcs.ptr_g_settings_schema_source_new_from_directory = try_find_sym(gio, "g_settings_schema_source_new_from_directory");
    stub_funcs.ptr_g_settings_schema_source_lookup = try_find_sym(gio, "g_settings_schema_source_lookup");
    stub_funcs.ptr_g_settings_schema_source_list_schemas = try_find_sym(gio, "g_settings_schema_source_list_schemas");
    stub_funcs.ptr_g_settings_schema_get_type = try_find_sym(gio, "g_settings_schema_get_type");
    stub_funcs.ptr_g_settings_schema_ref = try_find_sym(gio, "g_settings_schema_ref");
    stub_funcs.ptr_g_settings_schema_unref = try_find_sym(gio, "g_settings_schema_unref");
    stub_funcs.ptr_g_settings_schema_get_id = try_find_sym(gio, "g_settings_schema_get_id");
    stub_funcs.ptr_g_settings_schema_get_path = try_find_sym(gio, "g_settings_schema_get_path");
    stub_funcs.ptr_g_settings_schema_get_key = try_find_sym(gio, "g_settings_schema_get_key");
    stub_funcs.ptr_g_settings_schema_has_key = try_find_sym(gio, "g_settings_schema_has_key");
    stub_funcs.ptr_g_settings_schema_list_keys = try_find_sym(gio, "g_settings_schema_list_keys");
    stub_funcs.ptr_g_settings_schema_list_children = try_find_sym(gio, "g_settings_schema_list_children");
    stub_funcs.ptr_g_settings_schema_key_get_type = try_find_sym(gio, "g_settings_schema_key_get_type");
    stub_funcs.ptr_g_settings_schema_key_ref = try_find_sym(gio, "g_settings_schema_key_ref");
    stub_funcs.ptr_g_settings_schema_key_unref = try_find_sym(gio, "g_settings_schema_key_unref");
    stub_funcs.ptr_g_settings_schema_key_get_value_type = try_find_sym(gio, "g_settings_schema_key_get_value_type");
    stub_funcs.ptr_g_settings_schema_key_get_default_value = try_find_sym(gio, "g_settings_schema_key_get_default_value");
    stub_funcs.ptr_g_settings_schema_key_get_range = try_find_sym(gio, "g_settings_schema_key_get_range");
    stub_funcs.ptr_g_settings_schema_key_range_check = try_find_sym(gio, "g_settings_schema_key_range_check");
    stub_funcs.ptr_g_settings_schema_key_get_name = try_find_sym(gio, "g_settings_schema_key_get_name");
    stub_funcs.ptr_g_settings_schema_key_get_summary = try_find_sym(gio, "g_settings_schema_key_get_summary");
    stub_funcs.ptr_g_settings_schema_key_get_description = try_find_sym(gio, "g_settings_schema_key_get_description");
    stub_funcs.ptr_g_settings_schema_source_get_type = try_find_sym(gio, "g_settings_schema_source_get_type");
    // Header /usr/include/glib-2.0/gio/gsimpleaction.h
    stub_funcs.ptr_g_simple_action_get_type = try_find_sym(gio, "g_simple_action_get_type");
    stub_funcs.ptr_g_simple_action_new = try_find_sym(gio, "g_simple_action_new");
    stub_funcs.ptr_g_simple_action_new_stateful = try_find_sym(gio, "g_simple_action_new_stateful");
    stub_funcs.ptr_g_simple_action_set_enabled = try_find_sym(gio, "g_simple_action_set_enabled");
    stub_funcs.ptr_g_simple_action_set_state = try_find_sym(gio, "g_simple_action_set_state");
    stub_funcs.ptr_g_simple_action_set_state_hint = try_find_sym(gio, "g_simple_action_set_state_hint");
    // Header /usr/include/glib-2.0/gio/gsimpleactiongroup.h
    stub_funcs.ptr_g_simple_action_group_get_type = try_find_sym(gio, "g_simple_action_group_get_type");
    stub_funcs.ptr_g_simple_action_group_new = try_find_sym(gio, "g_simple_action_group_new");
    stub_funcs.ptr_g_simple_action_group_lookup = try_find_sym(gio, "g_simple_action_group_lookup");
    stub_funcs.ptr_g_simple_action_group_insert = try_find_sym(gio, "g_simple_action_group_insert");
    stub_funcs.ptr_g_simple_action_group_remove = try_find_sym(gio, "g_simple_action_group_remove");
    stub_funcs.ptr_g_simple_action_group_add_entries = try_find_sym(gio, "g_simple_action_group_add_entries");
    // Header /usr/include/glib-2.0/gio/gsimpleasyncresult.h
    stub_funcs.ptr_g_simple_async_result_get_type = try_find_sym(gio, "g_simple_async_result_get_type");
    stub_funcs.ptr_g_simple_async_result_new = try_find_sym(gio, "g_simple_async_result_new");
    stub_funcs.ptr_g_simple_async_result_new_from_error = try_find_sym(gio, "g_simple_async_result_new_from_error");
    stub_funcs.ptr_g_simple_async_result_new_take_error = try_find_sym(gio, "g_simple_async_result_new_take_error");
    stub_funcs.ptr_g_simple_async_result_set_op_res_gpointer = try_find_sym(gio, "g_simple_async_result_set_op_res_gpointer");
    stub_funcs.ptr_g_simple_async_result_get_op_res_gpointer = try_find_sym(gio, "g_simple_async_result_get_op_res_gpointer");
    stub_funcs.ptr_g_simple_async_result_set_op_res_gssize = try_find_sym(gio, "g_simple_async_result_set_op_res_gssize");
    stub_funcs.ptr_g_simple_async_result_get_op_res_gssize = try_find_sym(gio, "g_simple_async_result_get_op_res_gssize");
    stub_funcs.ptr_g_simple_async_result_set_op_res_gboolean = try_find_sym(gio, "g_simple_async_result_set_op_res_gboolean");
    stub_funcs.ptr_g_simple_async_result_get_op_res_gboolean = try_find_sym(gio, "g_simple_async_result_get_op_res_gboolean");
    stub_funcs.ptr_g_simple_async_result_set_check_cancellable = try_find_sym(gio, "g_simple_async_result_set_check_cancellable");
    stub_funcs.ptr_g_simple_async_result_get_source_tag = try_find_sym(gio, "g_simple_async_result_get_source_tag");
    stub_funcs.ptr_g_simple_async_result_set_handle_cancellation = try_find_sym(gio, "g_simple_async_result_set_handle_cancellation");
    stub_funcs.ptr_g_simple_async_result_complete = try_find_sym(gio, "g_simple_async_result_complete");
    stub_funcs.ptr_g_simple_async_result_complete_in_idle = try_find_sym(gio, "g_simple_async_result_complete_in_idle");
    stub_funcs.ptr_g_simple_async_result_run_in_thread = try_find_sym(gio, "g_simple_async_result_run_in_thread");
    stub_funcs.ptr_g_simple_async_result_set_from_error = try_find_sym(gio, "g_simple_async_result_set_from_error");
    stub_funcs.ptr_g_simple_async_result_take_error = try_find_sym(gio, "g_simple_async_result_take_error");
    stub_funcs.ptr_g_simple_async_result_propagate_error = try_find_sym(gio, "g_simple_async_result_propagate_error");
    stub_funcs.ptr_g_simple_async_result_set_error_va = try_find_sym(gio, "g_simple_async_result_set_error_va");
    stub_funcs.ptr_g_simple_async_result_is_valid = try_find_sym(gio, "g_simple_async_result_is_valid");
    stub_funcs.ptr_g_simple_async_report_gerror_in_idle = try_find_sym(gio, "g_simple_async_report_gerror_in_idle");
    stub_funcs.ptr_g_simple_async_report_take_gerror_in_idle = try_find_sym(gio, "g_simple_async_report_take_gerror_in_idle");
    // Header /usr/include/glib-2.0/gio/gsimpleiostream.h
    stub_funcs.ptr_g_simple_io_stream_get_type = try_find_sym(gio, "g_simple_io_stream_get_type");
    stub_funcs.ptr_g_simple_io_stream_new = try_find_sym(gio, "g_simple_io_stream_new");
    // Header /usr/include/glib-2.0/gio/gsimplepermission.h
    stub_funcs.ptr_g_simple_permission_get_type = try_find_sym(gio, "g_simple_permission_get_type");
    stub_funcs.ptr_g_simple_permission_new = try_find_sym(gio, "g_simple_permission_new");
    // Header /usr/include/glib-2.0/gio/gsimpleproxyresolver.h
    stub_funcs.ptr_g_simple_proxy_resolver_get_type = try_find_sym(gio, "g_simple_proxy_resolver_get_type");
    stub_funcs.ptr_g_simple_proxy_resolver_new = try_find_sym(gio, "g_simple_proxy_resolver_new");
    stub_funcs.ptr_g_simple_proxy_resolver_set_default_proxy = try_find_sym(gio, "g_simple_proxy_resolver_set_default_proxy");
    stub_funcs.ptr_g_simple_proxy_resolver_set_ignore_hosts = try_find_sym(gio, "g_simple_proxy_resolver_set_ignore_hosts");
    stub_funcs.ptr_g_simple_proxy_resolver_set_uri_proxy = try_find_sym(gio, "g_simple_proxy_resolver_set_uri_proxy");
    // Header /usr/include/glib-2.0/gio/gsocket.h
    stub_funcs.ptr_g_socket_get_type = try_find_sym(gio, "g_socket_get_type");
    stub_funcs.ptr_g_socket_new = try_find_sym(gio, "g_socket_new");
    stub_funcs.ptr_g_socket_new_from_fd = try_find_sym(gio, "g_socket_new_from_fd");
    stub_funcs.ptr_g_socket_get_fd = try_find_sym(gio, "g_socket_get_fd");
    stub_funcs.ptr_g_socket_get_family = try_find_sym(gio, "g_socket_get_family");
    stub_funcs.ptr_g_socket_get_socket_type = try_find_sym(gio, "g_socket_get_socket_type");
    stub_funcs.ptr_g_socket_get_protocol = try_find_sym(gio, "g_socket_get_protocol");
    stub_funcs.ptr_g_socket_get_local_address = try_find_sym(gio, "g_socket_get_local_address");
    stub_funcs.ptr_g_socket_get_remote_address = try_find_sym(gio, "g_socket_get_remote_address");
    stub_funcs.ptr_g_socket_set_blocking = try_find_sym(gio, "g_socket_set_blocking");
    stub_funcs.ptr_g_socket_get_blocking = try_find_sym(gio, "g_socket_get_blocking");
    stub_funcs.ptr_g_socket_set_keepalive = try_find_sym(gio, "g_socket_set_keepalive");
    stub_funcs.ptr_g_socket_get_keepalive = try_find_sym(gio, "g_socket_get_keepalive");
    stub_funcs.ptr_g_socket_get_listen_backlog = try_find_sym(gio, "g_socket_get_listen_backlog");
    stub_funcs.ptr_g_socket_set_listen_backlog = try_find_sym(gio, "g_socket_set_listen_backlog");
    stub_funcs.ptr_g_socket_get_timeout = try_find_sym(gio, "g_socket_get_timeout");
    stub_funcs.ptr_g_socket_set_timeout = try_find_sym(gio, "g_socket_set_timeout");
    stub_funcs.ptr_g_socket_get_ttl = try_find_sym(gio, "g_socket_get_ttl");
    stub_funcs.ptr_g_socket_set_ttl = try_find_sym(gio, "g_socket_set_ttl");
    stub_funcs.ptr_g_socket_get_broadcast = try_find_sym(gio, "g_socket_get_broadcast");
    stub_funcs.ptr_g_socket_set_broadcast = try_find_sym(gio, "g_socket_set_broadcast");
    stub_funcs.ptr_g_socket_get_multicast_loopback = try_find_sym(gio, "g_socket_get_multicast_loopback");
    stub_funcs.ptr_g_socket_set_multicast_loopback = try_find_sym(gio, "g_socket_set_multicast_loopback");
    stub_funcs.ptr_g_socket_get_multicast_ttl = try_find_sym(gio, "g_socket_get_multicast_ttl");
    stub_funcs.ptr_g_socket_set_multicast_ttl = try_find_sym(gio, "g_socket_set_multicast_ttl");
    stub_funcs.ptr_g_socket_is_connected = try_find_sym(gio, "g_socket_is_connected");
    stub_funcs.ptr_g_socket_bind = try_find_sym(gio, "g_socket_bind");
    stub_funcs.ptr_g_socket_join_multicast_group = try_find_sym(gio, "g_socket_join_multicast_group");
    stub_funcs.ptr_g_socket_leave_multicast_group = try_find_sym(gio, "g_socket_leave_multicast_group");
    stub_funcs.ptr_g_socket_join_multicast_group_ssm = try_find_sym(gio, "g_socket_join_multicast_group_ssm");
    stub_funcs.ptr_g_socket_leave_multicast_group_ssm = try_find_sym(gio, "g_socket_leave_multicast_group_ssm");
    stub_funcs.ptr_g_socket_connect = try_find_sym(gio, "g_socket_connect");
    stub_funcs.ptr_g_socket_check_connect_result = try_find_sym(gio, "g_socket_check_connect_result");
    stub_funcs.ptr_g_socket_get_available_bytes = try_find_sym(gio, "g_socket_get_available_bytes");
    stub_funcs.ptr_g_socket_condition_check = try_find_sym(gio, "g_socket_condition_check");
    stub_funcs.ptr_g_socket_condition_wait = try_find_sym(gio, "g_socket_condition_wait");
    stub_funcs.ptr_g_socket_condition_timed_wait = try_find_sym(gio, "g_socket_condition_timed_wait");
    stub_funcs.ptr_g_socket_accept = try_find_sym(gio, "g_socket_accept");
    stub_funcs.ptr_g_socket_listen = try_find_sym(gio, "g_socket_listen");
    stub_funcs.ptr_g_socket_receive = try_find_sym(gio, "g_socket_receive");
    stub_funcs.ptr_g_socket_receive_bytes = try_find_sym(gio, "g_socket_receive_bytes");
    stub_funcs.ptr_g_socket_receive_from = try_find_sym(gio, "g_socket_receive_from");
    stub_funcs.ptr_g_socket_receive_bytes_from = try_find_sym(gio, "g_socket_receive_bytes_from");
    stub_funcs.ptr_g_socket_send = try_find_sym(gio, "g_socket_send");
    stub_funcs.ptr_g_socket_send_to = try_find_sym(gio, "g_socket_send_to");
    stub_funcs.ptr_g_socket_receive_message = try_find_sym(gio, "g_socket_receive_message");
    stub_funcs.ptr_g_socket_send_message = try_find_sym(gio, "g_socket_send_message");
    stub_funcs.ptr_g_socket_receive_messages = try_find_sym(gio, "g_socket_receive_messages");
    stub_funcs.ptr_g_socket_send_messages = try_find_sym(gio, "g_socket_send_messages");
    stub_funcs.ptr_g_socket_close = try_find_sym(gio, "g_socket_close");
    stub_funcs.ptr_g_socket_shutdown = try_find_sym(gio, "g_socket_shutdown");
    stub_funcs.ptr_g_socket_is_closed = try_find_sym(gio, "g_socket_is_closed");
    stub_funcs.ptr_g_socket_create_source = try_find_sym(gio, "g_socket_create_source");
    stub_funcs.ptr_g_socket_speaks_ipv4 = try_find_sym(gio, "g_socket_speaks_ipv4");
    stub_funcs.ptr_g_socket_get_credentials = try_find_sym(gio, "g_socket_get_credentials");
    stub_funcs.ptr_g_socket_receive_with_blocking = try_find_sym(gio, "g_socket_receive_with_blocking");
    stub_funcs.ptr_g_socket_send_with_blocking = try_find_sym(gio, "g_socket_send_with_blocking");
    stub_funcs.ptr_g_socket_send_message_with_timeout = try_find_sym(gio, "g_socket_send_message_with_timeout");
    stub_funcs.ptr_g_socket_get_option = try_find_sym(gio, "g_socket_get_option");
    stub_funcs.ptr_g_socket_set_option = try_find_sym(gio, "g_socket_set_option");
    // Header /usr/include/glib-2.0/gio/gsocketaddress.h
    stub_funcs.ptr_g_socket_address_get_type = try_find_sym(gio, "g_socket_address_get_type");
    stub_funcs.ptr_g_socket_address_get_family = try_find_sym(gio, "g_socket_address_get_family");
    stub_funcs.ptr_g_socket_address_new_from_native = try_find_sym(gio, "g_socket_address_new_from_native");
    stub_funcs.ptr_g_socket_address_to_native = try_find_sym(gio, "g_socket_address_to_native");
    stub_funcs.ptr_g_socket_address_get_native_size = try_find_sym(gio, "g_socket_address_get_native_size");
    // Header /usr/include/glib-2.0/gio/gsocketaddressenumerator.h
    stub_funcs.ptr_g_socket_address_enumerator_get_type = try_find_sym(gio, "g_socket_address_enumerator_get_type");
    stub_funcs.ptr_g_socket_address_enumerator_next = try_find_sym(gio, "g_socket_address_enumerator_next");
    stub_funcs.ptr_g_socket_address_enumerator_next_async = try_find_sym(gio, "g_socket_address_enumerator_next_async");
    stub_funcs.ptr_g_socket_address_enumerator_next_finish = try_find_sym(gio, "g_socket_address_enumerator_next_finish");
    // Header /usr/include/glib-2.0/gio/gsocketclient.h
    stub_funcs.ptr_g_socket_client_get_type = try_find_sym(gio, "g_socket_client_get_type");
    stub_funcs.ptr_g_socket_client_new = try_find_sym(gio, "g_socket_client_new");
    stub_funcs.ptr_g_socket_client_get_family = try_find_sym(gio, "g_socket_client_get_family");
    stub_funcs.ptr_g_socket_client_set_family = try_find_sym(gio, "g_socket_client_set_family");
    stub_funcs.ptr_g_socket_client_get_socket_type = try_find_sym(gio, "g_socket_client_get_socket_type");
    stub_funcs.ptr_g_socket_client_set_socket_type = try_find_sym(gio, "g_socket_client_set_socket_type");
    stub_funcs.ptr_g_socket_client_get_protocol = try_find_sym(gio, "g_socket_client_get_protocol");
    stub_funcs.ptr_g_socket_client_set_protocol = try_find_sym(gio, "g_socket_client_set_protocol");
    stub_funcs.ptr_g_socket_client_get_local_address = try_find_sym(gio, "g_socket_client_get_local_address");
    stub_funcs.ptr_g_socket_client_set_local_address = try_find_sym(gio, "g_socket_client_set_local_address");
    stub_funcs.ptr_g_socket_client_get_timeout = try_find_sym(gio, "g_socket_client_get_timeout");
    stub_funcs.ptr_g_socket_client_set_timeout = try_find_sym(gio, "g_socket_client_set_timeout");
    stub_funcs.ptr_g_socket_client_get_enable_proxy = try_find_sym(gio, "g_socket_client_get_enable_proxy");
    stub_funcs.ptr_g_socket_client_set_enable_proxy = try_find_sym(gio, "g_socket_client_set_enable_proxy");
    stub_funcs.ptr_g_socket_client_get_tls = try_find_sym(gio, "g_socket_client_get_tls");
    stub_funcs.ptr_g_socket_client_set_tls = try_find_sym(gio, "g_socket_client_set_tls");
    stub_funcs.ptr_g_socket_client_get_tls_validation_flags = try_find_sym(gio, "g_socket_client_get_tls_validation_flags");
    stub_funcs.ptr_g_socket_client_set_tls_validation_flags = try_find_sym(gio, "g_socket_client_set_tls_validation_flags");
    stub_funcs.ptr_g_socket_client_get_proxy_resolver = try_find_sym(gio, "g_socket_client_get_proxy_resolver");
    stub_funcs.ptr_g_socket_client_set_proxy_resolver = try_find_sym(gio, "g_socket_client_set_proxy_resolver");
    stub_funcs.ptr_g_socket_client_connect = try_find_sym(gio, "g_socket_client_connect");
    stub_funcs.ptr_g_socket_client_connect_to_host = try_find_sym(gio, "g_socket_client_connect_to_host");
    stub_funcs.ptr_g_socket_client_connect_to_service = try_find_sym(gio, "g_socket_client_connect_to_service");
    stub_funcs.ptr_g_socket_client_connect_to_uri = try_find_sym(gio, "g_socket_client_connect_to_uri");
    stub_funcs.ptr_g_socket_client_connect_async = try_find_sym(gio, "g_socket_client_connect_async");
    stub_funcs.ptr_g_socket_client_connect_finish = try_find_sym(gio, "g_socket_client_connect_finish");
    stub_funcs.ptr_g_socket_client_connect_to_host_async = try_find_sym(gio, "g_socket_client_connect_to_host_async");
    stub_funcs.ptr_g_socket_client_connect_to_host_finish = try_find_sym(gio, "g_socket_client_connect_to_host_finish");
    stub_funcs.ptr_g_socket_client_connect_to_service_async = try_find_sym(gio, "g_socket_client_connect_to_service_async");
    stub_funcs.ptr_g_socket_client_connect_to_service_finish = try_find_sym(gio, "g_socket_client_connect_to_service_finish");
    stub_funcs.ptr_g_socket_client_connect_to_uri_async = try_find_sym(gio, "g_socket_client_connect_to_uri_async");
    stub_funcs.ptr_g_socket_client_connect_to_uri_finish = try_find_sym(gio, "g_socket_client_connect_to_uri_finish");
    stub_funcs.ptr_g_socket_client_add_application_proxy = try_find_sym(gio, "g_socket_client_add_application_proxy");
    // Header /usr/include/glib-2.0/gio/gsocketconnectable.h
    stub_funcs.ptr_g_socket_connectable_get_type = try_find_sym(gio, "g_socket_connectable_get_type");
    stub_funcs.ptr_g_socket_connectable_enumerate = try_find_sym(gio, "g_socket_connectable_enumerate");
    stub_funcs.ptr_g_socket_connectable_proxy_enumerate = try_find_sym(gio, "g_socket_connectable_proxy_enumerate");
    stub_funcs.ptr_g_socket_connectable_to_string = try_find_sym(gio, "g_socket_connectable_to_string");
    // Header /usr/include/glib-2.0/gio/gsocketconnection.h
    stub_funcs.ptr_g_socket_connection_get_type = try_find_sym(gio, "g_socket_connection_get_type");
    stub_funcs.ptr_g_socket_connection_is_connected = try_find_sym(gio, "g_socket_connection_is_connected");
    stub_funcs.ptr_g_socket_connection_connect = try_find_sym(gio, "g_socket_connection_connect");
    stub_funcs.ptr_g_socket_connection_connect_async = try_find_sym(gio, "g_socket_connection_connect_async");
    stub_funcs.ptr_g_socket_connection_connect_finish = try_find_sym(gio, "g_socket_connection_connect_finish");
    stub_funcs.ptr_g_socket_connection_get_socket = try_find_sym(gio, "g_socket_connection_get_socket");
    stub_funcs.ptr_g_socket_connection_get_local_address = try_find_sym(gio, "g_socket_connection_get_local_address");
    stub_funcs.ptr_g_socket_connection_get_remote_address = try_find_sym(gio, "g_socket_connection_get_remote_address");
    stub_funcs.ptr_g_socket_connection_factory_register_type = try_find_sym(gio, "g_socket_connection_factory_register_type");
    stub_funcs.ptr_g_socket_connection_factory_lookup_type = try_find_sym(gio, "g_socket_connection_factory_lookup_type");
    stub_funcs.ptr_g_socket_connection_factory_create_connection = try_find_sym(gio, "g_socket_connection_factory_create_connection");
    // Header /usr/include/glib-2.0/gio/gsocketcontrolmessage.h
    stub_funcs.ptr_g_socket_control_message_get_type = try_find_sym(gio, "g_socket_control_message_get_type");
    stub_funcs.ptr_g_socket_control_message_get_size = try_find_sym(gio, "g_socket_control_message_get_size");
    stub_funcs.ptr_g_socket_control_message_get_level = try_find_sym(gio, "g_socket_control_message_get_level");
    stub_funcs.ptr_g_socket_control_message_get_msg_type = try_find_sym(gio, "g_socket_control_message_get_msg_type");
    stub_funcs.ptr_g_socket_control_message_serialize = try_find_sym(gio, "g_socket_control_message_serialize");
    stub_funcs.ptr_g_socket_control_message_deserialize = try_find_sym(gio, "g_socket_control_message_deserialize");
    // Header /usr/include/glib-2.0/gio/gsocketlistener.h
    stub_funcs.ptr_g_socket_listener_get_type = try_find_sym(gio, "g_socket_listener_get_type");
    stub_funcs.ptr_g_socket_listener_new = try_find_sym(gio, "g_socket_listener_new");
    stub_funcs.ptr_g_socket_listener_set_backlog = try_find_sym(gio, "g_socket_listener_set_backlog");
    stub_funcs.ptr_g_socket_listener_add_socket = try_find_sym(gio, "g_socket_listener_add_socket");
    stub_funcs.ptr_g_socket_listener_add_address = try_find_sym(gio, "g_socket_listener_add_address");
    stub_funcs.ptr_g_socket_listener_add_inet_port = try_find_sym(gio, "g_socket_listener_add_inet_port");
    stub_funcs.ptr_g_socket_listener_add_any_inet_port = try_find_sym(gio, "g_socket_listener_add_any_inet_port");
    stub_funcs.ptr_g_socket_listener_accept_socket = try_find_sym(gio, "g_socket_listener_accept_socket");
    stub_funcs.ptr_g_socket_listener_accept_socket_async = try_find_sym(gio, "g_socket_listener_accept_socket_async");
    stub_funcs.ptr_g_socket_listener_accept_socket_finish = try_find_sym(gio, "g_socket_listener_accept_socket_finish");
    stub_funcs.ptr_g_socket_listener_accept = try_find_sym(gio, "g_socket_listener_accept");
    stub_funcs.ptr_g_socket_listener_accept_async = try_find_sym(gio, "g_socket_listener_accept_async");
    stub_funcs.ptr_g_socket_listener_accept_finish = try_find_sym(gio, "g_socket_listener_accept_finish");
    stub_funcs.ptr_g_socket_listener_close = try_find_sym(gio, "g_socket_listener_close");
    // Header /usr/include/glib-2.0/gio/gsocketservice.h
    stub_funcs.ptr_g_socket_service_get_type = try_find_sym(gio, "g_socket_service_get_type");
    stub_funcs.ptr_g_socket_service_new = try_find_sym(gio, "g_socket_service_new");
    stub_funcs.ptr_g_socket_service_start = try_find_sym(gio, "g_socket_service_start");
    stub_funcs.ptr_g_socket_service_stop = try_find_sym(gio, "g_socket_service_stop");
    stub_funcs.ptr_g_socket_service_is_active = try_find_sym(gio, "g_socket_service_is_active");
    // Header /usr/include/glib-2.0/gio/gsrvtarget.h
    stub_funcs.ptr_g_srv_target_get_type = try_find_sym(gio, "g_srv_target_get_type");
    stub_funcs.ptr_g_srv_target_new = try_find_sym(gio, "g_srv_target_new");
    stub_funcs.ptr_g_srv_target_copy = try_find_sym(gio, "g_srv_target_copy");
    stub_funcs.ptr_g_srv_target_free = try_find_sym(gio, "g_srv_target_free");
    stub_funcs.ptr_g_srv_target_get_hostname = try_find_sym(gio, "g_srv_target_get_hostname");
    stub_funcs.ptr_g_srv_target_get_port = try_find_sym(gio, "g_srv_target_get_port");
    stub_funcs.ptr_g_srv_target_get_priority = try_find_sym(gio, "g_srv_target_get_priority");
    stub_funcs.ptr_g_srv_target_get_weight = try_find_sym(gio, "g_srv_target_get_weight");
    stub_funcs.ptr_g_srv_target_list_sort = try_find_sym(gio, "g_srv_target_list_sort");
    // Header /usr/include/glib-2.0/gio/gsubprocess.h
    stub_funcs.ptr_g_subprocess_get_type = try_find_sym(gio, "g_subprocess_get_type");
    stub_funcs.ptr_g_subprocess_newv = try_find_sym(gio, "g_subprocess_newv");
    stub_funcs.ptr_g_subprocess_get_stdin_pipe = try_find_sym(gio, "g_subprocess_get_stdin_pipe");
    stub_funcs.ptr_g_subprocess_get_stdout_pipe = try_find_sym(gio, "g_subprocess_get_stdout_pipe");
    stub_funcs.ptr_g_subprocess_get_stderr_pipe = try_find_sym(gio, "g_subprocess_get_stderr_pipe");
    stub_funcs.ptr_g_subprocess_get_identifier = try_find_sym(gio, "g_subprocess_get_identifier");
    stub_funcs.ptr_g_subprocess_send_signal = try_find_sym(gio, "g_subprocess_send_signal");
    stub_funcs.ptr_g_subprocess_force_exit = try_find_sym(gio, "g_subprocess_force_exit");
    stub_funcs.ptr_g_subprocess_wait = try_find_sym(gio, "g_subprocess_wait");
    stub_funcs.ptr_g_subprocess_wait_async = try_find_sym(gio, "g_subprocess_wait_async");
    stub_funcs.ptr_g_subprocess_wait_finish = try_find_sym(gio, "g_subprocess_wait_finish");
    stub_funcs.ptr_g_subprocess_wait_check = try_find_sym(gio, "g_subprocess_wait_check");
    stub_funcs.ptr_g_subprocess_wait_check_async = try_find_sym(gio, "g_subprocess_wait_check_async");
    stub_funcs.ptr_g_subprocess_wait_check_finish = try_find_sym(gio, "g_subprocess_wait_check_finish");
    stub_funcs.ptr_g_subprocess_get_status = try_find_sym(gio, "g_subprocess_get_status");
    stub_funcs.ptr_g_subprocess_get_successful = try_find_sym(gio, "g_subprocess_get_successful");
    stub_funcs.ptr_g_subprocess_get_if_exited = try_find_sym(gio, "g_subprocess_get_if_exited");
    stub_funcs.ptr_g_subprocess_get_exit_status = try_find_sym(gio, "g_subprocess_get_exit_status");
    stub_funcs.ptr_g_subprocess_get_if_signaled = try_find_sym(gio, "g_subprocess_get_if_signaled");
    stub_funcs.ptr_g_subprocess_get_term_sig = try_find_sym(gio, "g_subprocess_get_term_sig");
    stub_funcs.ptr_g_subprocess_communicate = try_find_sym(gio, "g_subprocess_communicate");
    stub_funcs.ptr_g_subprocess_communicate_async = try_find_sym(gio, "g_subprocess_communicate_async");
    stub_funcs.ptr_g_subprocess_communicate_finish = try_find_sym(gio, "g_subprocess_communicate_finish");
    stub_funcs.ptr_g_subprocess_communicate_utf8 = try_find_sym(gio, "g_subprocess_communicate_utf8");
    stub_funcs.ptr_g_subprocess_communicate_utf8_async = try_find_sym(gio, "g_subprocess_communicate_utf8_async");
    stub_funcs.ptr_g_subprocess_communicate_utf8_finish = try_find_sym(gio, "g_subprocess_communicate_utf8_finish");
    // Header /usr/include/glib-2.0/gio/gsubprocesslauncher.h
    stub_funcs.ptr_g_subprocess_launcher_get_type = try_find_sym(gio, "g_subprocess_launcher_get_type");
    stub_funcs.ptr_g_subprocess_launcher_new = try_find_sym(gio, "g_subprocess_launcher_new");
    stub_funcs.ptr_g_subprocess_launcher_spawnv = try_find_sym(gio, "g_subprocess_launcher_spawnv");
    stub_funcs.ptr_g_subprocess_launcher_set_environ = try_find_sym(gio, "g_subprocess_launcher_set_environ");
    stub_funcs.ptr_g_subprocess_launcher_setenv = try_find_sym(gio, "g_subprocess_launcher_setenv");
    stub_funcs.ptr_g_subprocess_launcher_unsetenv = try_find_sym(gio, "g_subprocess_launcher_unsetenv");
    stub_funcs.ptr_g_subprocess_launcher_getenv = try_find_sym(gio, "g_subprocess_launcher_getenv");
    stub_funcs.ptr_g_subprocess_launcher_set_cwd = try_find_sym(gio, "g_subprocess_launcher_set_cwd");
    stub_funcs.ptr_g_subprocess_launcher_set_flags = try_find_sym(gio, "g_subprocess_launcher_set_flags");
    stub_funcs.ptr_g_subprocess_launcher_set_stdin_file_path = try_find_sym(gio, "g_subprocess_launcher_set_stdin_file_path");
    stub_funcs.ptr_g_subprocess_launcher_take_stdin_fd = try_find_sym(gio, "g_subprocess_launcher_take_stdin_fd");
    stub_funcs.ptr_g_subprocess_launcher_set_stdout_file_path = try_find_sym(gio, "g_subprocess_launcher_set_stdout_file_path");
    stub_funcs.ptr_g_subprocess_launcher_take_stdout_fd = try_find_sym(gio, "g_subprocess_launcher_take_stdout_fd");
    stub_funcs.ptr_g_subprocess_launcher_set_stderr_file_path = try_find_sym(gio, "g_subprocess_launcher_set_stderr_file_path");
    stub_funcs.ptr_g_subprocess_launcher_take_stderr_fd = try_find_sym(gio, "g_subprocess_launcher_take_stderr_fd");
    stub_funcs.ptr_g_subprocess_launcher_take_fd = try_find_sym(gio, "g_subprocess_launcher_take_fd");
    stub_funcs.ptr_g_subprocess_launcher_close = try_find_sym(gio, "g_subprocess_launcher_close");
    stub_funcs.ptr_g_subprocess_launcher_set_child_setup = try_find_sym(gio, "g_subprocess_launcher_set_child_setup");
    // Header /usr/include/glib-2.0/gio/gtask.h
    stub_funcs.ptr_g_task_get_type = try_find_sym(gio, "g_task_get_type");
    stub_funcs.ptr_g_task_new = try_find_sym(gio, "g_task_new");
    stub_funcs.ptr_g_task_report_error = try_find_sym(gio, "g_task_report_error");
    stub_funcs.ptr_g_task_set_task_data = try_find_sym(gio, "g_task_set_task_data");
    stub_funcs.ptr_g_task_set_priority = try_find_sym(gio, "g_task_set_priority");
    stub_funcs.ptr_g_task_set_check_cancellable = try_find_sym(gio, "g_task_set_check_cancellable");
    stub_funcs.ptr_g_task_set_source_tag = try_find_sym(gio, "g_task_set_source_tag");
    stub_funcs.ptr_g_task_set_name = try_find_sym(gio, "g_task_set_name");
    stub_funcs.ptr_g_task_set_static_name = try_find_sym(gio, "g_task_set_static_name");
    stub_funcs.ptr_g_task_get_source_object = try_find_sym(gio, "g_task_get_source_object");
    stub_funcs.ptr_g_task_get_task_data = try_find_sym(gio, "g_task_get_task_data");
    stub_funcs.ptr_g_task_get_priority = try_find_sym(gio, "g_task_get_priority");
    stub_funcs.ptr_g_task_get_context = try_find_sym(gio, "g_task_get_context");
    stub_funcs.ptr_g_task_get_cancellable = try_find_sym(gio, "g_task_get_cancellable");
    stub_funcs.ptr_g_task_get_check_cancellable = try_find_sym(gio, "g_task_get_check_cancellable");
    stub_funcs.ptr_g_task_get_source_tag = try_find_sym(gio, "g_task_get_source_tag");
    stub_funcs.ptr_g_task_get_name = try_find_sym(gio, "g_task_get_name");
    stub_funcs.ptr_g_task_is_valid = try_find_sym(gio, "g_task_is_valid");
    stub_funcs.ptr_g_task_run_in_thread = try_find_sym(gio, "g_task_run_in_thread");
    stub_funcs.ptr_g_task_run_in_thread_sync = try_find_sym(gio, "g_task_run_in_thread_sync");
    stub_funcs.ptr_g_task_set_return_on_cancel = try_find_sym(gio, "g_task_set_return_on_cancel");
    stub_funcs.ptr_g_task_get_return_on_cancel = try_find_sym(gio, "g_task_get_return_on_cancel");
    stub_funcs.ptr_g_task_attach_source = try_find_sym(gio, "g_task_attach_source");
    stub_funcs.ptr_g_task_return_pointer = try_find_sym(gio, "g_task_return_pointer");
    stub_funcs.ptr_g_task_return_boolean = try_find_sym(gio, "g_task_return_boolean");
    stub_funcs.ptr_g_task_return_int = try_find_sym(gio, "g_task_return_int");
    stub_funcs.ptr_g_task_return_error = try_find_sym(gio, "g_task_return_error");
    stub_funcs.ptr_g_task_return_new_error_literal = try_find_sym(gio, "g_task_return_new_error_literal");
    stub_funcs.ptr_g_task_return_value = try_find_sym(gio, "g_task_return_value");
    stub_funcs.ptr_g_task_return_error_if_cancelled = try_find_sym(gio, "g_task_return_error_if_cancelled");
    stub_funcs.ptr_g_task_propagate_pointer = try_find_sym(gio, "g_task_propagate_pointer");
    stub_funcs.ptr_g_task_propagate_boolean = try_find_sym(gio, "g_task_propagate_boolean");
    stub_funcs.ptr_g_task_propagate_int = try_find_sym(gio, "g_task_propagate_int");
    stub_funcs.ptr_g_task_propagate_value = try_find_sym(gio, "g_task_propagate_value");
    stub_funcs.ptr_g_task_had_error = try_find_sym(gio, "g_task_had_error");
    stub_funcs.ptr_g_task_get_completed = try_find_sym(gio, "g_task_get_completed");
    stub_funcs.ptr_g_task_print_alive_tasks = try_find_sym(gio, "g_task_print_alive_tasks");
    // Header /usr/include/glib-2.0/gio/gtcpconnection.h
    stub_funcs.ptr_g_tcp_connection_get_type = try_find_sym(gio, "g_tcp_connection_get_type");
    stub_funcs.ptr_g_tcp_connection_set_graceful_disconnect = try_find_sym(gio, "g_tcp_connection_set_graceful_disconnect");
    stub_funcs.ptr_g_tcp_connection_get_graceful_disconnect = try_find_sym(gio, "g_tcp_connection_get_graceful_disconnect");
    // Header /usr/include/glib-2.0/gio/gtcpwrapperconnection.h
    stub_funcs.ptr_g_tcp_wrapper_connection_get_type = try_find_sym(gio, "g_tcp_wrapper_connection_get_type");
    stub_funcs.ptr_g_tcp_wrapper_connection_new = try_find_sym(gio, "g_tcp_wrapper_connection_new");
    stub_funcs.ptr_g_tcp_wrapper_connection_get_base_io_stream = try_find_sym(gio, "g_tcp_wrapper_connection_get_base_io_stream");
    // Header /usr/include/glib-2.0/gio/gtestdbus.h
    stub_funcs.ptr_g_test_dbus_get_type = try_find_sym(gio, "g_test_dbus_get_type");
    stub_funcs.ptr_g_test_dbus_new = try_find_sym(gio, "g_test_dbus_new");
    stub_funcs.ptr_g_test_dbus_get_flags = try_find_sym(gio, "g_test_dbus_get_flags");
    stub_funcs.ptr_g_test_dbus_get_bus_address = try_find_sym(gio, "g_test_dbus_get_bus_address");
    stub_funcs.ptr_g_test_dbus_add_service_dir = try_find_sym(gio, "g_test_dbus_add_service_dir");
    stub_funcs.ptr_g_test_dbus_up = try_find_sym(gio, "g_test_dbus_up");
    stub_funcs.ptr_g_test_dbus_stop = try_find_sym(gio, "g_test_dbus_stop");
    stub_funcs.ptr_g_test_dbus_down = try_find_sym(gio, "g_test_dbus_down");
    stub_funcs.ptr_g_test_dbus_unset = try_find_sym(gio, "g_test_dbus_unset");
    // Header /usr/include/glib-2.0/gio/gthemedicon.h
    stub_funcs.ptr_g_themed_icon_get_type = try_find_sym(gio, "g_themed_icon_get_type");
    stub_funcs.ptr_g_themed_icon_new = try_find_sym(gio, "g_themed_icon_new");
    stub_funcs.ptr_g_themed_icon_new_with_default_fallbacks = try_find_sym(gio, "g_themed_icon_new_with_default_fallbacks");
    stub_funcs.ptr_g_themed_icon_new_from_names = try_find_sym(gio, "g_themed_icon_new_from_names");
    stub_funcs.ptr_g_themed_icon_prepend_name = try_find_sym(gio, "g_themed_icon_prepend_name");
    stub_funcs.ptr_g_themed_icon_append_name = try_find_sym(gio, "g_themed_icon_append_name");
    stub_funcs.ptr_g_themed_icon_get_names = try_find_sym(gio, "g_themed_icon_get_names");
    // Header /usr/include/glib-2.0/gio/gthreadedsocketservice.h
    stub_funcs.ptr_g_threaded_socket_service_get_type = try_find_sym(gio, "g_threaded_socket_service_get_type");
    stub_funcs.ptr_g_threaded_socket_service_new = try_find_sym(gio, "g_threaded_socket_service_new");
    // Header /usr/include/glib-2.0/gio/gtlsbackend.h
    stub_funcs.ptr_g_tls_backend_get_type = try_find_sym(gio, "g_tls_backend_get_type");
    stub_funcs.ptr_g_tls_backend_get_default = try_find_sym(gio, "g_tls_backend_get_default");
    stub_funcs.ptr_g_tls_backend_get_default_database = try_find_sym(gio, "g_tls_backend_get_default_database");
    stub_funcs.ptr_g_tls_backend_set_default_database = try_find_sym(gio, "g_tls_backend_set_default_database");
    stub_funcs.ptr_g_tls_backend_supports_tls = try_find_sym(gio, "g_tls_backend_supports_tls");
    stub_funcs.ptr_g_tls_backend_supports_dtls = try_find_sym(gio, "g_tls_backend_supports_dtls");
    stub_funcs.ptr_g_tls_backend_get_certificate_type = try_find_sym(gio, "g_tls_backend_get_certificate_type");
    stub_funcs.ptr_g_tls_backend_get_client_connection_type = try_find_sym(gio, "g_tls_backend_get_client_connection_type");
    stub_funcs.ptr_g_tls_backend_get_server_connection_type = try_find_sym(gio, "g_tls_backend_get_server_connection_type");
    stub_funcs.ptr_g_tls_backend_get_file_database_type = try_find_sym(gio, "g_tls_backend_get_file_database_type");
    stub_funcs.ptr_g_tls_backend_get_dtls_client_connection_type = try_find_sym(gio, "g_tls_backend_get_dtls_client_connection_type");
    stub_funcs.ptr_g_tls_backend_get_dtls_server_connection_type = try_find_sym(gio, "g_tls_backend_get_dtls_server_connection_type");
    // Header /usr/include/glib-2.0/gio/gtlscertificate.h
    stub_funcs.ptr_g_tls_certificate_get_type = try_find_sym(gio, "g_tls_certificate_get_type");
    stub_funcs.ptr_g_tls_certificate_new_from_pem = try_find_sym(gio, "g_tls_certificate_new_from_pem");
    stub_funcs.ptr_g_tls_certificate_new_from_pkcs12 = try_find_sym(gio, "g_tls_certificate_new_from_pkcs12");
    stub_funcs.ptr_g_tls_certificate_new_from_file_with_password = try_find_sym(gio, "g_tls_certificate_new_from_file_with_password");
    stub_funcs.ptr_g_tls_certificate_new_from_file = try_find_sym(gio, "g_tls_certificate_new_from_file");
    stub_funcs.ptr_g_tls_certificate_new_from_files = try_find_sym(gio, "g_tls_certificate_new_from_files");
    stub_funcs.ptr_g_tls_certificate_new_from_pkcs11_uris = try_find_sym(gio, "g_tls_certificate_new_from_pkcs11_uris");
    stub_funcs.ptr_g_tls_certificate_list_new_from_file = try_find_sym(gio, "g_tls_certificate_list_new_from_file");
    stub_funcs.ptr_g_tls_certificate_get_issuer = try_find_sym(gio, "g_tls_certificate_get_issuer");
    stub_funcs.ptr_g_tls_certificate_verify = try_find_sym(gio, "g_tls_certificate_verify");
    stub_funcs.ptr_g_tls_certificate_is_same = try_find_sym(gio, "g_tls_certificate_is_same");
    stub_funcs.ptr_g_tls_certificate_get_not_valid_before = try_find_sym(gio, "g_tls_certificate_get_not_valid_before");
    stub_funcs.ptr_g_tls_certificate_get_not_valid_after = try_find_sym(gio, "g_tls_certificate_get_not_valid_after");
    stub_funcs.ptr_g_tls_certificate_get_subject_name = try_find_sym(gio, "g_tls_certificate_get_subject_name");
    stub_funcs.ptr_g_tls_certificate_get_issuer_name = try_find_sym(gio, "g_tls_certificate_get_issuer_name");
    stub_funcs.ptr_g_tls_certificate_get_dns_names = try_find_sym(gio, "g_tls_certificate_get_dns_names");
    stub_funcs.ptr_g_tls_certificate_get_ip_addresses = try_find_sym(gio, "g_tls_certificate_get_ip_addresses");
    // Header /usr/include/glib-2.0/gio/gtlsclientconnection.h
    stub_funcs.ptr_g_tls_client_connection_get_type = try_find_sym(gio, "g_tls_client_connection_get_type");
    stub_funcs.ptr_g_tls_client_connection_new = try_find_sym(gio, "g_tls_client_connection_new");
    stub_funcs.ptr_g_tls_client_connection_get_validation_flags = try_find_sym(gio, "g_tls_client_connection_get_validation_flags");
    stub_funcs.ptr_g_tls_client_connection_set_validation_flags = try_find_sym(gio, "g_tls_client_connection_set_validation_flags");
    stub_funcs.ptr_g_tls_client_connection_get_server_identity = try_find_sym(gio, "g_tls_client_connection_get_server_identity");
    stub_funcs.ptr_g_tls_client_connection_set_server_identity = try_find_sym(gio, "g_tls_client_connection_set_server_identity");
    stub_funcs.ptr_g_tls_client_connection_get_use_ssl3 = try_find_sym(gio, "g_tls_client_connection_get_use_ssl3");
    stub_funcs.ptr_g_tls_client_connection_set_use_ssl3 = try_find_sym(gio, "g_tls_client_connection_set_use_ssl3");
    stub_funcs.ptr_g_tls_client_connection_get_accepted_cas = try_find_sym(gio, "g_tls_client_connection_get_accepted_cas");
    stub_funcs.ptr_g_tls_client_connection_copy_session_state = try_find_sym(gio, "g_tls_client_connection_copy_session_state");
    // Header /usr/include/glib-2.0/gio/gtlsconnection.h
    stub_funcs.ptr_g_tls_connection_get_type = try_find_sym(gio, "g_tls_connection_get_type");
    stub_funcs.ptr_g_tls_connection_set_use_system_certdb = try_find_sym(gio, "g_tls_connection_set_use_system_certdb");
    stub_funcs.ptr_g_tls_connection_get_use_system_certdb = try_find_sym(gio, "g_tls_connection_get_use_system_certdb");
    stub_funcs.ptr_g_tls_connection_set_database = try_find_sym(gio, "g_tls_connection_set_database");
    stub_funcs.ptr_g_tls_connection_get_database = try_find_sym(gio, "g_tls_connection_get_database");
    stub_funcs.ptr_g_tls_connection_set_certificate = try_find_sym(gio, "g_tls_connection_set_certificate");
    stub_funcs.ptr_g_tls_connection_get_certificate = try_find_sym(gio, "g_tls_connection_get_certificate");
    stub_funcs.ptr_g_tls_connection_set_interaction = try_find_sym(gio, "g_tls_connection_set_interaction");
    stub_funcs.ptr_g_tls_connection_get_interaction = try_find_sym(gio, "g_tls_connection_get_interaction");
    stub_funcs.ptr_g_tls_connection_get_peer_certificate = try_find_sym(gio, "g_tls_connection_get_peer_certificate");
    stub_funcs.ptr_g_tls_connection_get_peer_certificate_errors = try_find_sym(gio, "g_tls_connection_get_peer_certificate_errors");
    stub_funcs.ptr_g_tls_connection_set_require_close_notify = try_find_sym(gio, "g_tls_connection_set_require_close_notify");
    stub_funcs.ptr_g_tls_connection_get_require_close_notify = try_find_sym(gio, "g_tls_connection_get_require_close_notify");
    stub_funcs.ptr_g_tls_connection_get_rehandshake_mode = try_find_sym(gio, "g_tls_connection_get_rehandshake_mode");
    stub_funcs.ptr_g_tls_connection_get_negotiated_protocol = try_find_sym(gio, "g_tls_connection_get_negotiated_protocol");
    stub_funcs.ptr_g_tls_connection_handshake_async = try_find_sym(gio, "g_tls_connection_handshake_async");
    stub_funcs.ptr_g_tls_connection_handshake_finish = try_find_sym(gio, "g_tls_connection_handshake_finish");
    stub_funcs.ptr_g_tls_connection_get_protocol_version = try_find_sym(gio, "g_tls_connection_get_protocol_version");
    stub_funcs.ptr_g_tls_connection_get_ciphersuite_name = try_find_sym(gio, "g_tls_connection_get_ciphersuite_name");
    stub_funcs.ptr_g_tls_error_quark = try_find_sym(gio, "g_tls_error_quark");
    stub_funcs.ptr_g_tls_channel_binding_error_quark = try_find_sym(gio, "g_tls_channel_binding_error_quark");
    stub_funcs.ptr_g_tls_connection_emit_accept_certificate = try_find_sym(gio, "g_tls_connection_emit_accept_certificate");
    // Header /usr/include/glib-2.0/gio/gtlsdatabase.h
    stub_funcs.ptr_g_tls_database_get_type = try_find_sym(gio, "g_tls_database_get_type");
    stub_funcs.ptr_g_tls_database_verify_chain = try_find_sym(gio, "g_tls_database_verify_chain");
    stub_funcs.ptr_g_tls_database_verify_chain_async = try_find_sym(gio, "g_tls_database_verify_chain_async");
    stub_funcs.ptr_g_tls_database_verify_chain_finish = try_find_sym(gio, "g_tls_database_verify_chain_finish");
    stub_funcs.ptr_g_tls_database_create_certificate_handle = try_find_sym(gio, "g_tls_database_create_certificate_handle");
    stub_funcs.ptr_g_tls_database_lookup_certificate_for_handle = try_find_sym(gio, "g_tls_database_lookup_certificate_for_handle");
    stub_funcs.ptr_g_tls_database_lookup_certificate_for_handle_async = try_find_sym(gio, "g_tls_database_lookup_certificate_for_handle_async");
    stub_funcs.ptr_g_tls_database_lookup_certificate_for_handle_finish = try_find_sym(gio, "g_tls_database_lookup_certificate_for_handle_finish");
    stub_funcs.ptr_g_tls_database_lookup_certificate_issuer = try_find_sym(gio, "g_tls_database_lookup_certificate_issuer");
    stub_funcs.ptr_g_tls_database_lookup_certificate_issuer_async = try_find_sym(gio, "g_tls_database_lookup_certificate_issuer_async");
    stub_funcs.ptr_g_tls_database_lookup_certificate_issuer_finish = try_find_sym(gio, "g_tls_database_lookup_certificate_issuer_finish");
    stub_funcs.ptr_g_tls_database_lookup_certificates_issued_by = try_find_sym(gio, "g_tls_database_lookup_certificates_issued_by");
    stub_funcs.ptr_g_tls_database_lookup_certificates_issued_by_async = try_find_sym(gio, "g_tls_database_lookup_certificates_issued_by_async");
    stub_funcs.ptr_g_tls_database_lookup_certificates_issued_by_finish = try_find_sym(gio, "g_tls_database_lookup_certificates_issued_by_finish");
    // Header /usr/include/glib-2.0/gio/gtlsfiledatabase.h
    stub_funcs.ptr_g_tls_file_database_get_type = try_find_sym(gio, "g_tls_file_database_get_type");
    stub_funcs.ptr_g_tls_file_database_new = try_find_sym(gio, "g_tls_file_database_new");
    // Header /usr/include/glib-2.0/gio/gtlsinteraction.h
    stub_funcs.ptr_g_tls_interaction_get_type = try_find_sym(gio, "g_tls_interaction_get_type");
    stub_funcs.ptr_g_tls_interaction_invoke_ask_password = try_find_sym(gio, "g_tls_interaction_invoke_ask_password");
    stub_funcs.ptr_g_tls_interaction_ask_password = try_find_sym(gio, "g_tls_interaction_ask_password");
    stub_funcs.ptr_g_tls_interaction_ask_password_async = try_find_sym(gio, "g_tls_interaction_ask_password_async");
    stub_funcs.ptr_g_tls_interaction_ask_password_finish = try_find_sym(gio, "g_tls_interaction_ask_password_finish");
    stub_funcs.ptr_g_tls_interaction_invoke_request_certificate = try_find_sym(gio, "g_tls_interaction_invoke_request_certificate");
    stub_funcs.ptr_g_tls_interaction_request_certificate = try_find_sym(gio, "g_tls_interaction_request_certificate");
    stub_funcs.ptr_g_tls_interaction_request_certificate_async = try_find_sym(gio, "g_tls_interaction_request_certificate_async");
    stub_funcs.ptr_g_tls_interaction_request_certificate_finish = try_find_sym(gio, "g_tls_interaction_request_certificate_finish");
    // Header /usr/include/glib-2.0/gio/gtlspassword.h
    stub_funcs.ptr_g_tls_password_get_type = try_find_sym(gio, "g_tls_password_get_type");
    stub_funcs.ptr_g_tls_password_new = try_find_sym(gio, "g_tls_password_new");
    stub_funcs.ptr_g_tls_password_get_value = try_find_sym(gio, "g_tls_password_get_value");
    stub_funcs.ptr_g_tls_password_set_value = try_find_sym(gio, "g_tls_password_set_value");
    stub_funcs.ptr_g_tls_password_set_value_full = try_find_sym(gio, "g_tls_password_set_value_full");
    stub_funcs.ptr_g_tls_password_get_flags = try_find_sym(gio, "g_tls_password_get_flags");
    stub_funcs.ptr_g_tls_password_set_flags = try_find_sym(gio, "g_tls_password_set_flags");
    stub_funcs.ptr_g_tls_password_get_description = try_find_sym(gio, "g_tls_password_get_description");
    stub_funcs.ptr_g_tls_password_set_description = try_find_sym(gio, "g_tls_password_set_description");
    stub_funcs.ptr_g_tls_password_get_warning = try_find_sym(gio, "g_tls_password_get_warning");
    stub_funcs.ptr_g_tls_password_set_warning = try_find_sym(gio, "g_tls_password_set_warning");
    // Header /usr/include/glib-2.0/gio/gtlsserverconnection.h
    stub_funcs.ptr_g_tls_server_connection_get_type = try_find_sym(gio, "g_tls_server_connection_get_type");
    stub_funcs.ptr_g_tls_server_connection_new = try_find_sym(gio, "g_tls_server_connection_new");
    // Header /usr/include/glib-2.0/gio/gunixconnection.h
    stub_funcs.ptr_g_unix_connection_get_type = try_find_sym(gio, "g_unix_connection_get_type");
    stub_funcs.ptr_g_unix_connection_send_fd = try_find_sym(gio, "g_unix_connection_send_fd");
    stub_funcs.ptr_g_unix_connection_receive_fd = try_find_sym(gio, "g_unix_connection_receive_fd");
    stub_funcs.ptr_g_unix_connection_send_credentials = try_find_sym(gio, "g_unix_connection_send_credentials");
    stub_funcs.ptr_g_unix_connection_send_credentials_async = try_find_sym(gio, "g_unix_connection_send_credentials_async");
    stub_funcs.ptr_g_unix_connection_send_credentials_finish = try_find_sym(gio, "g_unix_connection_send_credentials_finish");
    stub_funcs.ptr_g_unix_connection_receive_credentials = try_find_sym(gio, "g_unix_connection_receive_credentials");
    stub_funcs.ptr_g_unix_connection_receive_credentials_async = try_find_sym(gio, "g_unix_connection_receive_credentials_async");
    stub_funcs.ptr_g_unix_connection_receive_credentials_finish = try_find_sym(gio, "g_unix_connection_receive_credentials_finish");
    // Header /usr/include/glib-2.0/gio/gunixcredentialsmessage.h
    stub_funcs.ptr_g_unix_credentials_message_get_type = try_find_sym(gio, "g_unix_credentials_message_get_type");
    stub_funcs.ptr_g_unix_credentials_message_new = try_find_sym(gio, "g_unix_credentials_message_new");
    stub_funcs.ptr_g_unix_credentials_message_new_with_credentials = try_find_sym(gio, "g_unix_credentials_message_new_with_credentials");
    stub_funcs.ptr_g_unix_credentials_message_get_credentials = try_find_sym(gio, "g_unix_credentials_message_get_credentials");
    stub_funcs.ptr_g_unix_credentials_message_is_supported = try_find_sym(gio, "g_unix_credentials_message_is_supported");
    // Header /usr/include/glib-2.0/gio/gunixfdlist.h
    stub_funcs.ptr_g_unix_fd_list_get_type = try_find_sym(gio, "g_unix_fd_list_get_type");
    stub_funcs.ptr_g_unix_fd_list_new = try_find_sym(gio, "g_unix_fd_list_new");
    stub_funcs.ptr_g_unix_fd_list_new_from_array = try_find_sym(gio, "g_unix_fd_list_new_from_array");
    stub_funcs.ptr_g_unix_fd_list_append = try_find_sym(gio, "g_unix_fd_list_append");
    stub_funcs.ptr_g_unix_fd_list_get_length = try_find_sym(gio, "g_unix_fd_list_get_length");
    stub_funcs.ptr_g_unix_fd_list_get = try_find_sym(gio, "g_unix_fd_list_get");
    stub_funcs.ptr_g_unix_fd_list_peek_fds = try_find_sym(gio, "g_unix_fd_list_peek_fds");
    stub_funcs.ptr_g_unix_fd_list_steal_fds = try_find_sym(gio, "g_unix_fd_list_steal_fds");
    // Header /usr/include/glib-2.0/gio/gunixsocketaddress.h
    stub_funcs.ptr_g_unix_socket_address_get_type = try_find_sym(gio, "g_unix_socket_address_get_type");
    stub_funcs.ptr_g_unix_socket_address_new = try_find_sym(gio, "g_unix_socket_address_new");
    stub_funcs.ptr_g_unix_socket_address_new_abstract = try_find_sym(gio, "g_unix_socket_address_new_abstract");
    stub_funcs.ptr_g_unix_socket_address_new_with_type = try_find_sym(gio, "g_unix_socket_address_new_with_type");
    stub_funcs.ptr_g_unix_socket_address_get_path = try_find_sym(gio, "g_unix_socket_address_get_path");
    stub_funcs.ptr_g_unix_socket_address_get_path_len = try_find_sym(gio, "g_unix_socket_address_get_path_len");
    stub_funcs.ptr_g_unix_socket_address_get_address_type = try_find_sym(gio, "g_unix_socket_address_get_address_type");
    stub_funcs.ptr_g_unix_socket_address_get_is_abstract = try_find_sym(gio, "g_unix_socket_address_get_is_abstract");
    stub_funcs.ptr_g_unix_socket_address_abstract_names_supported = try_find_sym(gio, "g_unix_socket_address_abstract_names_supported");
    // Header /usr/include/glib-2.0/gio/gvfs.h
    stub_funcs.ptr_g_vfs_get_type = try_find_sym(gio, "g_vfs_get_type");
    stub_funcs.ptr_g_vfs_is_active = try_find_sym(gio, "g_vfs_is_active");
    stub_funcs.ptr_g_vfs_get_file_for_path = try_find_sym(gio, "g_vfs_get_file_for_path");
    stub_funcs.ptr_g_vfs_get_file_for_uri = try_find_sym(gio, "g_vfs_get_file_for_uri");
    stub_funcs.ptr_g_vfs_get_supported_uri_schemes = try_find_sym(gio, "g_vfs_get_supported_uri_schemes");
    stub_funcs.ptr_g_vfs_parse_name = try_find_sym(gio, "g_vfs_parse_name");
    stub_funcs.ptr_g_vfs_get_default = try_find_sym(gio, "g_vfs_get_default");
    stub_funcs.ptr_g_vfs_get_local = try_find_sym(gio, "g_vfs_get_local");
    stub_funcs.ptr_g_vfs_register_uri_scheme = try_find_sym(gio, "g_vfs_register_uri_scheme");
    stub_funcs.ptr_g_vfs_unregister_uri_scheme = try_find_sym(gio, "g_vfs_unregister_uri_scheme");
    // Header /usr/include/glib-2.0/gio/gvolume.h
    stub_funcs.ptr_g_volume_get_type = try_find_sym(gio, "g_volume_get_type");
    stub_funcs.ptr_g_volume_get_name = try_find_sym(gio, "g_volume_get_name");
    stub_funcs.ptr_g_volume_get_icon = try_find_sym(gio, "g_volume_get_icon");
    stub_funcs.ptr_g_volume_get_symbolic_icon = try_find_sym(gio, "g_volume_get_symbolic_icon");
    stub_funcs.ptr_g_volume_get_uuid = try_find_sym(gio, "g_volume_get_uuid");
    stub_funcs.ptr_g_volume_get_drive = try_find_sym(gio, "g_volume_get_drive");
    stub_funcs.ptr_g_volume_get_mount = try_find_sym(gio, "g_volume_get_mount");
    stub_funcs.ptr_g_volume_can_mount = try_find_sym(gio, "g_volume_can_mount");
    stub_funcs.ptr_g_volume_can_eject = try_find_sym(gio, "g_volume_can_eject");
    stub_funcs.ptr_g_volume_should_automount = try_find_sym(gio, "g_volume_should_automount");
    stub_funcs.ptr_g_volume_mount = try_find_sym(gio, "g_volume_mount");
    stub_funcs.ptr_g_volume_mount_finish = try_find_sym(gio, "g_volume_mount_finish");
    stub_funcs.ptr_g_volume_eject = try_find_sym(gio, "g_volume_eject");
    stub_funcs.ptr_g_volume_eject_finish = try_find_sym(gio, "g_volume_eject_finish");
    stub_funcs.ptr_g_volume_get_identifier = try_find_sym(gio, "g_volume_get_identifier");
    stub_funcs.ptr_g_volume_enumerate_identifiers = try_find_sym(gio, "g_volume_enumerate_identifiers");
    stub_funcs.ptr_g_volume_get_activation_root = try_find_sym(gio, "g_volume_get_activation_root");
    stub_funcs.ptr_g_volume_eject_with_operation = try_find_sym(gio, "g_volume_eject_with_operation");
    stub_funcs.ptr_g_volume_eject_with_operation_finish = try_find_sym(gio, "g_volume_eject_with_operation_finish");
    stub_funcs.ptr_g_volume_get_sort_key = try_find_sym(gio, "g_volume_get_sort_key");
    // Header /usr/include/glib-2.0/gio/gvolumemonitor.h
    stub_funcs.ptr_g_volume_monitor_get_type = try_find_sym(gio, "g_volume_monitor_get_type");
    stub_funcs.ptr_g_volume_monitor_get = try_find_sym(gio, "g_volume_monitor_get");
    stub_funcs.ptr_g_volume_monitor_get_connected_drives = try_find_sym(gio, "g_volume_monitor_get_connected_drives");
    stub_funcs.ptr_g_volume_monitor_get_volumes = try_find_sym(gio, "g_volume_monitor_get_volumes");
    stub_funcs.ptr_g_volume_monitor_get_mounts = try_find_sym(gio, "g_volume_monitor_get_mounts");
    stub_funcs.ptr_g_volume_monitor_get_volume_for_uuid = try_find_sym(gio, "g_volume_monitor_get_volume_for_uuid");
    stub_funcs.ptr_g_volume_monitor_get_mount_for_uuid = try_find_sym(gio, "g_volume_monitor_get_mount_for_uuid");
    stub_funcs.ptr_g_volume_monitor_adopt_orphan_mount = try_find_sym(gio, "g_volume_monitor_adopt_orphan_mount");
    // Header /usr/include/glib-2.0/gio/gzlibcompressor.h
    stub_funcs.ptr_g_zlib_compressor_get_type = try_find_sym(gio, "g_zlib_compressor_get_type");
    stub_funcs.ptr_g_zlib_compressor_new = try_find_sym(gio, "g_zlib_compressor_new");
    stub_funcs.ptr_g_zlib_compressor_get_file_info = try_find_sym(gio, "g_zlib_compressor_get_file_info");
    stub_funcs.ptr_g_zlib_compressor_set_file_info = try_find_sym(gio, "g_zlib_compressor_set_file_info");
    // Header /usr/include/glib-2.0/gio/gzlibdecompressor.h
    stub_funcs.ptr_g_zlib_decompressor_get_type = try_find_sym(gio, "g_zlib_decompressor_get_type");
    stub_funcs.ptr_g_zlib_decompressor_new = try_find_sym(gio, "g_zlib_decompressor_new");
    stub_funcs.ptr_g_zlib_decompressor_get_file_info = try_find_sym(gio, "g_zlib_decompressor_get_file_info");
    // Header /usr/include/glib-2.0/gmodule.h
    stub_funcs.ptr_g_module_supported = try_find_sym(gmodule, "g_module_supported");
    stub_funcs.ptr_g_module_open = try_find_sym(gmodule, "g_module_open");
    stub_funcs.ptr_g_module_open_full = try_find_sym(gmodule, "g_module_open_full");
    stub_funcs.ptr_g_module_close = try_find_sym(gmodule, "g_module_close");
    stub_funcs.ptr_g_module_make_resident = try_find_sym(gmodule, "g_module_make_resident");
    stub_funcs.ptr_g_module_error = try_find_sym(gmodule, "g_module_error");
    stub_funcs.ptr_g_module_symbol = try_find_sym(gmodule, "g_module_symbol");
    stub_funcs.ptr_g_module_name = try_find_sym(gmodule, "g_module_name");
    stub_funcs.ptr_g_module_build_path = try_find_sym(gmodule, "g_module_build_path");
    stub_funcs.ptr_g_module_error_quark = try_find_sym(gmodule, "g_module_error_quark");
    // Header /usr/include/glib-2.0/girepository/girepository.h
    stub_funcs.ptr_gi_repository_get_type = try_find_sym(girepository, "gi_repository_get_type");
    stub_funcs.ptr_gi_repository_new = try_find_sym(girepository, "gi_repository_new");
    stub_funcs.ptr_gi_repository_prepend_search_path = try_find_sym(girepository, "gi_repository_prepend_search_path");
    stub_funcs.ptr_gi_repository_prepend_library_path = try_find_sym(girepository, "gi_repository_prepend_library_path");
    stub_funcs.ptr_gi_repository_get_search_path = try_find_sym(girepository, "gi_repository_get_search_path");
    stub_funcs.ptr_gi_repository_get_library_path = try_find_sym(girepository, "gi_repository_get_library_path");
    stub_funcs.ptr_gi_repository_load_typelib = try_find_sym(girepository, "gi_repository_load_typelib");
    stub_funcs.ptr_gi_repository_is_registered = try_find_sym(girepository, "gi_repository_is_registered");
    stub_funcs.ptr_gi_repository_find_by_name = try_find_sym(girepository, "gi_repository_find_by_name");
    stub_funcs.ptr_gi_repository_enumerate_versions = try_find_sym(girepository, "gi_repository_enumerate_versions");
    stub_funcs.ptr_gi_repository_require = try_find_sym(girepository, "gi_repository_require");
    stub_funcs.ptr_gi_repository_require_private = try_find_sym(girepository, "gi_repository_require_private");
    stub_funcs.ptr_gi_repository_get_immediate_dependencies = try_find_sym(girepository, "gi_repository_get_immediate_dependencies");
    stub_funcs.ptr_gi_repository_get_dependencies = try_find_sym(girepository, "gi_repository_get_dependencies");
    stub_funcs.ptr_gi_repository_get_loaded_namespaces = try_find_sym(girepository, "gi_repository_get_loaded_namespaces");
    stub_funcs.ptr_gi_repository_find_by_gtype = try_find_sym(girepository, "gi_repository_find_by_gtype");
    stub_funcs.ptr_gi_repository_get_object_gtype_interfaces = try_find_sym(girepository, "gi_repository_get_object_gtype_interfaces");
    stub_funcs.ptr_gi_repository_get_n_infos = try_find_sym(girepository, "gi_repository_get_n_infos");
    stub_funcs.ptr_gi_repository_get_info = try_find_sym(girepository, "gi_repository_get_info");
    stub_funcs.ptr_gi_repository_find_by_error_domain = try_find_sym(girepository, "gi_repository_find_by_error_domain");
    stub_funcs.ptr_gi_repository_get_typelib_path = try_find_sym(girepository, "gi_repository_get_typelib_path");
    stub_funcs.ptr_gi_repository_get_shared_libraries = try_find_sym(girepository, "gi_repository_get_shared_libraries");
    stub_funcs.ptr_gi_repository_get_c_prefix = try_find_sym(girepository, "gi_repository_get_c_prefix");
    stub_funcs.ptr_gi_repository_get_version = try_find_sym(girepository, "gi_repository_get_version");
    stub_funcs.ptr_gi_repository_get_option_group = try_find_sym(girepository, "gi_repository_get_option_group");
    stub_funcs.ptr_gi_repository_dump = try_find_sym(girepository, "gi_repository_dump");
    stub_funcs.ptr_gi_repository_error_quark = try_find_sym(girepository, "gi_repository_error_quark");
    stub_funcs.ptr_gi_cclosure_marshal_generic = try_find_sym(girepository, "gi_cclosure_marshal_generic");
    // Header /usr/include/glib-2.0/girepository/girffi.h
    stub_funcs.ptr_gi_type_info_get_ffi_type = try_find_sym(girepository, "gi_type_info_get_ffi_type");
    stub_funcs.ptr_gi_type_info_extract_ffi_return_value = try_find_sym(girepository, "gi_type_info_extract_ffi_return_value");
    stub_funcs.ptr_gi_type_tag_extract_ffi_return_value = try_find_sym(girepository, "gi_type_tag_extract_ffi_return_value");
    stub_funcs.ptr_gi_function_info_prep_invoker = try_find_sym(girepository, "gi_function_info_prep_invoker");
    stub_funcs.ptr_gi_function_invoker_new_for_address = try_find_sym(girepository, "gi_function_invoker_new_for_address");
    stub_funcs.ptr_gi_function_invoker_clear = try_find_sym(girepository, "gi_function_invoker_clear");
    stub_funcs.ptr_gi_callable_info_create_closure = try_find_sym(girepository, "gi_callable_info_create_closure");
    stub_funcs.ptr_gi_callable_info_get_closure_native_address = try_find_sym(girepository, "gi_callable_info_get_closure_native_address");
    stub_funcs.ptr_gi_callable_info_destroy_closure = try_find_sym(girepository, "gi_callable_info_destroy_closure");
    stub_funcs.ptr_gi_type_tag_get_ffi_type = try_find_sym(girepository, "gi_type_tag_get_ffi_type");
}

void (g_mem_chunk_destroy)(GMemChunk *mem_chunk) { stub_funcs.ptr_g_mem_chunk_destroy(mem_chunk); }
gpointer (g_mem_chunk_alloc)(GMemChunk *mem_chunk) { return stub_funcs.ptr_g_mem_chunk_alloc(mem_chunk); }
gpointer (g_mem_chunk_alloc0)(GMemChunk *mem_chunk) { return stub_funcs.ptr_g_mem_chunk_alloc0(mem_chunk); }
void (g_mem_chunk_free)(GMemChunk *mem_chunk, gpointer mem) { stub_funcs.ptr_g_mem_chunk_free(mem_chunk, mem); }
void (g_mem_chunk_clean)(GMemChunk *mem_chunk) { stub_funcs.ptr_g_mem_chunk_clean(mem_chunk); }
void (g_mem_chunk_reset)(GMemChunk *mem_chunk) { stub_funcs.ptr_g_mem_chunk_reset(mem_chunk); }
void (g_mem_chunk_print)(GMemChunk *mem_chunk) { stub_funcs.ptr_g_mem_chunk_print(mem_chunk); }
void (g_mem_chunk_info)(void) { stub_funcs.ptr_g_mem_chunk_info(); }
void (g_blow_chunks)(void) { stub_funcs.ptr_g_blow_chunks(); }
GMemChunk * (g_mem_chunk_new)(const gchar *name, gint atom_size, gsize area_size, gint type) { return stub_funcs.ptr_g_mem_chunk_new(name, atom_size, area_size, type); }
void (g_cache_destroy)(GCache *cache) { stub_funcs.ptr_g_cache_destroy(cache); }
gpointer (g_cache_insert)(GCache *cache, gpointer key) { return stub_funcs.ptr_g_cache_insert(cache, key); }
void (g_cache_remove)(GCache *cache, gconstpointer value) { stub_funcs.ptr_g_cache_remove(cache, value); }
void (g_cache_key_foreach)(GCache *cache, GHFunc func, gpointer user_data) { stub_funcs.ptr_g_cache_key_foreach(cache, func, user_data); }
void (g_cache_value_foreach)(GCache *cache, GHFunc func, gpointer user_data) { stub_funcs.ptr_g_cache_value_foreach(cache, func, user_data); }
void (g_completion_add_items)(GCompletion* cmp, GList* items) { stub_funcs.ptr_g_completion_add_items(cmp, items); }
void (g_completion_remove_items)(GCompletion* cmp, GList* items) { stub_funcs.ptr_g_completion_remove_items(cmp, items); }
void (g_completion_clear_items)(GCompletion* cmp) { stub_funcs.ptr_g_completion_clear_items(cmp); }
GList* (g_completion_complete)(GCompletion* cmp, const gchar* prefix, gchar** new_prefix) { return stub_funcs.ptr_g_completion_complete(cmp, prefix, new_prefix); }
GList* (g_completion_complete_utf8)(GCompletion *cmp, const gchar* prefix, gchar** new_prefix) { return stub_funcs.ptr_g_completion_complete_utf8(cmp, prefix, new_prefix); }
void (g_completion_set_compare)(GCompletion *cmp, GCompletionStrncmpFunc strncmp_func) { stub_funcs.ptr_g_completion_set_compare(cmp, strncmp_func); }
void (g_completion_free)(GCompletion* cmp) { stub_funcs.ptr_g_completion_free(cmp); }
GCompletion* (g_completion_new)(GCompletionFunc func) { return stub_funcs.ptr_g_completion_new(func); }
void (g_relation_destroy)(GRelation *relation) { stub_funcs.ptr_g_relation_destroy(relation); }
void (g_relation_index)(GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func) { stub_funcs.ptr_g_relation_index(relation, field, hash_func, key_equal_func); }
// Unable to locate va_equiv for g_relation_insert
gint (g_relation_delete)(GRelation *relation, gconstpointer key, gint field) { return stub_funcs.ptr_g_relation_delete(relation, key, field); }
GTuples* (g_relation_select)(GRelation *relation, gconstpointer key, gint field) { return stub_funcs.ptr_g_relation_select(relation, key, field); }
gint (g_relation_count)(GRelation *relation, gconstpointer key, gint field) { return stub_funcs.ptr_g_relation_count(relation, key, field); }
// Unable to locate va_equiv for g_relation_exists
void (g_relation_print)(GRelation *relation) { stub_funcs.ptr_g_relation_print(relation); }
void (g_tuples_destroy)(GTuples *tuples) { stub_funcs.ptr_g_tuples_destroy(tuples); }
gpointer (g_tuples_index)(GTuples *tuples, gint index_, gint field) { return stub_funcs.ptr_g_tuples_index(tuples, index_, field); }
GRelation* (g_relation_new)(gint fields) { return stub_funcs.ptr_g_relation_new(fields); }
GThread* (g_thread_create)(GThreadFunc func, gpointer data, gboolean joinable, GError **error) { return stub_funcs.ptr_g_thread_create(func, data, joinable, error); }
GThread* (g_thread_create_full)(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error) { return stub_funcs.ptr_g_thread_create_full(func, data, stack_size, joinable, bound, priority, error); }
void (g_thread_set_priority)(GThread *thread, GThreadPriority priority) { stub_funcs.ptr_g_thread_set_priority(thread, priority); }
void (g_thread_foreach)(GFunc thread_func, gpointer user_data) { stub_funcs.ptr_g_thread_foreach(thread_func, user_data); }
GPrivate * (g_private_new)(GDestroyNotify notify) { return stub_funcs.ptr_g_private_new(notify); }
gboolean (g_once_init_enter_impl)(volatile gsize *location) { return stub_funcs.ptr_g_once_init_enter_impl(location); }
void (g_thread_init)(gpointer vtable) { stub_funcs.ptr_g_thread_init(vtable); }
void (g_thread_init_with_errorcheck_mutexes)(gpointer vtable) { stub_funcs.ptr_g_thread_init_with_errorcheck_mutexes(vtable); }
gboolean (g_thread_get_initialized)(void) { return stub_funcs.ptr_g_thread_get_initialized(); }
GMutex * (g_mutex_new)(void) { return stub_funcs.ptr_g_mutex_new(); }
void (g_mutex_free)(GMutex *mutex) { stub_funcs.ptr_g_mutex_free(mutex); }
GCond * (g_cond_new)(void) { return stub_funcs.ptr_g_cond_new(); }
void (g_cond_free)(GCond *cond) { stub_funcs.ptr_g_cond_free(cond); }
gboolean (g_cond_timed_wait)(GCond *cond, GMutex *mutex, GTimeVal *abs_time) { return stub_funcs.ptr_g_cond_timed_wait(cond, mutex, abs_time); }
GArray* (g_array_new_take)(gpointer data, gsize len, gboolean clear, gsize element_size) { return stub_funcs.ptr_g_array_new_take(data, len, clear, element_size); }
GArray* (g_array_new_take_zero_terminated)(gpointer data, gboolean clear, gsize element_size) { return stub_funcs.ptr_g_array_new_take_zero_terminated(data, clear, element_size); }
gpointer (g_array_steal)(GArray *array, gsize *len) { return stub_funcs.ptr_g_array_steal(array, len); }
GArray* (g_array_sized_new)(gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size) { return stub_funcs.ptr_g_array_sized_new(zero_terminated, clear_, element_size, reserved_size); }
GArray* (g_array_copy)(GArray *array) { return stub_funcs.ptr_g_array_copy(array); }
gchar* (g_array_free)(GArray *array, gboolean free_segment) { return stub_funcs.ptr_g_array_free(array, free_segment); }
GArray* (g_array_ref)(GArray *array) { return stub_funcs.ptr_g_array_ref(array); }
void (g_array_unref)(GArray *array) { stub_funcs.ptr_g_array_unref(array); }
guint (g_array_get_element_size)(GArray *array) { return stub_funcs.ptr_g_array_get_element_size(array); }
GArray* (g_array_append_vals)(GArray *array, gconstpointer data, guint len) { return stub_funcs.ptr_g_array_append_vals(array, data, len); }
GArray* (g_array_prepend_vals)(GArray *array, gconstpointer data, guint len) { return stub_funcs.ptr_g_array_prepend_vals(array, data, len); }
GArray* (g_array_insert_vals)(GArray *array, guint index_, gconstpointer data, guint len) { return stub_funcs.ptr_g_array_insert_vals(array, index_, data, len); }
GArray* (g_array_set_size)(GArray *array, guint length) { return stub_funcs.ptr_g_array_set_size(array, length); }
GArray* (g_array_remove_index)(GArray *array, guint index_) { return stub_funcs.ptr_g_array_remove_index(array, index_); }
GArray* (g_array_remove_index_fast)(GArray *array, guint index_) { return stub_funcs.ptr_g_array_remove_index_fast(array, index_); }
GArray* (g_array_remove_range)(GArray *array, guint index_, guint length) { return stub_funcs.ptr_g_array_remove_range(array, index_, length); }
void (g_array_sort)(GArray *array, GCompareFunc compare_func) { stub_funcs.ptr_g_array_sort(array, compare_func); }
void (g_array_sort_with_data)(GArray *array, GCompareDataFunc compare_func, gpointer user_data) { stub_funcs.ptr_g_array_sort_with_data(array, compare_func, user_data); }
gboolean (g_array_binary_search)(GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index) { return stub_funcs.ptr_g_array_binary_search(array, target, compare_func, out_match_index); }
void (g_array_set_clear_func)(GArray *array, GDestroyNotify clear_func) { stub_funcs.ptr_g_array_set_clear_func(array, clear_func); }
GPtrArray* (g_ptr_array_new)(void) { return stub_funcs.ptr_g_ptr_array_new(); }
GPtrArray* (g_ptr_array_new_with_free_func)(GDestroyNotify element_free_func) { return stub_funcs.ptr_g_ptr_array_new_with_free_func(element_free_func); }
GPtrArray* (g_ptr_array_new_take)(gpointer *data, gsize len, GDestroyNotify element_free_func) { return stub_funcs.ptr_g_ptr_array_new_take(data, len, element_free_func); }
GPtrArray* (g_ptr_array_new_from_array)(gpointer *data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func) { return stub_funcs.ptr_g_ptr_array_new_from_array(data, len, copy_func, copy_func_user_data, element_free_func); }
gpointer* (g_ptr_array_steal)(GPtrArray *array, gsize *len) { return stub_funcs.ptr_g_ptr_array_steal(array, len); }
GPtrArray* (g_ptr_array_copy)(GPtrArray *array, GCopyFunc func, gpointer user_data) { return stub_funcs.ptr_g_ptr_array_copy(array, func, user_data); }
GPtrArray* (g_ptr_array_sized_new)(guint reserved_size) { return stub_funcs.ptr_g_ptr_array_sized_new(reserved_size); }
GPtrArray* (g_ptr_array_new_full)(guint reserved_size, GDestroyNotify element_free_func) { return stub_funcs.ptr_g_ptr_array_new_full(reserved_size, element_free_func); }
GPtrArray* (g_ptr_array_new_null_terminated)(guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated) { return stub_funcs.ptr_g_ptr_array_new_null_terminated(reserved_size, element_free_func, null_terminated); }
GPtrArray* (g_ptr_array_new_take_null_terminated)(gpointer *data, GDestroyNotify element_free_func) { return stub_funcs.ptr_g_ptr_array_new_take_null_terminated(data, element_free_func); }
GPtrArray* (g_ptr_array_new_from_null_terminated_array)(gpointer *data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func) { return stub_funcs.ptr_g_ptr_array_new_from_null_terminated_array(data, copy_func, copy_func_user_data, element_free_func); }
gpointer* (g_ptr_array_free)(GPtrArray *array, gboolean free_seg) { return stub_funcs.ptr_g_ptr_array_free(array, free_seg); }
GPtrArray* (g_ptr_array_ref)(GPtrArray *array) { return stub_funcs.ptr_g_ptr_array_ref(array); }
void (g_ptr_array_unref)(GPtrArray *array) { stub_funcs.ptr_g_ptr_array_unref(array); }
void (g_ptr_array_set_free_func)(GPtrArray *array, GDestroyNotify element_free_func) { stub_funcs.ptr_g_ptr_array_set_free_func(array, element_free_func); }
void (g_ptr_array_set_size)(GPtrArray *array, gint length) { stub_funcs.ptr_g_ptr_array_set_size(array, length); }
gpointer (g_ptr_array_remove_index)(GPtrArray *array, guint index_) { return stub_funcs.ptr_g_ptr_array_remove_index(array, index_); }
gpointer (g_ptr_array_remove_index_fast)(GPtrArray *array, guint index_) { return stub_funcs.ptr_g_ptr_array_remove_index_fast(array, index_); }
gpointer (g_ptr_array_steal_index)(GPtrArray *array, guint index_) { return stub_funcs.ptr_g_ptr_array_steal_index(array, index_); }
gpointer (g_ptr_array_steal_index_fast)(GPtrArray *array, guint index_) { return stub_funcs.ptr_g_ptr_array_steal_index_fast(array, index_); }
gboolean (g_ptr_array_remove)(GPtrArray *array, gpointer data) { return stub_funcs.ptr_g_ptr_array_remove(array, data); }
gboolean (g_ptr_array_remove_fast)(GPtrArray *array, gpointer data) { return stub_funcs.ptr_g_ptr_array_remove_fast(array, data); }
GPtrArray* (g_ptr_array_remove_range)(GPtrArray *array, guint index_, guint length) { return stub_funcs.ptr_g_ptr_array_remove_range(array, index_, length); }
void (g_ptr_array_add)(GPtrArray *array, gpointer data) { stub_funcs.ptr_g_ptr_array_add(array, data); }
void (g_ptr_array_extend)(GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data) { stub_funcs.ptr_g_ptr_array_extend(array_to_extend, array, func, user_data); }
void (g_ptr_array_extend_and_steal)(GPtrArray *array_to_extend, GPtrArray *array) { stub_funcs.ptr_g_ptr_array_extend_and_steal(array_to_extend, array); }
void (g_ptr_array_insert)(GPtrArray *array, gint index_, gpointer data) { stub_funcs.ptr_g_ptr_array_insert(array, index_, data); }
void (g_ptr_array_sort)(GPtrArray *array, GCompareFunc compare_func) { stub_funcs.ptr_g_ptr_array_sort(array, compare_func); }
void (g_ptr_array_sort_with_data)(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data) { stub_funcs.ptr_g_ptr_array_sort_with_data(array, compare_func, user_data); }
void (g_ptr_array_sort_values)(GPtrArray *array, GCompareFunc compare_func) { stub_funcs.ptr_g_ptr_array_sort_values(array, compare_func); }
void (g_ptr_array_sort_values_with_data)(GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data) { stub_funcs.ptr_g_ptr_array_sort_values_with_data(array, compare_func, user_data); }
void (g_ptr_array_foreach)(GPtrArray *array, GFunc func, gpointer user_data) { stub_funcs.ptr_g_ptr_array_foreach(array, func, user_data); }
gboolean (g_ptr_array_find)(GPtrArray *haystack, gconstpointer needle, guint *index_) { return stub_funcs.ptr_g_ptr_array_find(haystack, needle, index_); }
gboolean (g_ptr_array_find_with_equal_func)(GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_) { return stub_funcs.ptr_g_ptr_array_find_with_equal_func(haystack, needle, equal_func, index_); }
gboolean (g_ptr_array_is_null_terminated)(GPtrArray *array) { return stub_funcs.ptr_g_ptr_array_is_null_terminated(array); }
GByteArray* (g_byte_array_new)(void) { return stub_funcs.ptr_g_byte_array_new(); }
GByteArray* (g_byte_array_new_take)(guint8 *data, gsize len) { return stub_funcs.ptr_g_byte_array_new_take(data, len); }
guint8* (g_byte_array_steal)(GByteArray *array, gsize *len) { return stub_funcs.ptr_g_byte_array_steal(array, len); }
GByteArray* (g_byte_array_sized_new)(guint reserved_size) { return stub_funcs.ptr_g_byte_array_sized_new(reserved_size); }
guint8* (g_byte_array_free)(GByteArray *array, gboolean free_segment) { return stub_funcs.ptr_g_byte_array_free(array, free_segment); }
GBytes* (g_byte_array_free_to_bytes)(GByteArray *array) { return stub_funcs.ptr_g_byte_array_free_to_bytes(array); }
GByteArray* (g_byte_array_ref)(GByteArray *array) { return stub_funcs.ptr_g_byte_array_ref(array); }
void (g_byte_array_unref)(GByteArray *array) { stub_funcs.ptr_g_byte_array_unref(array); }
GByteArray* (g_byte_array_append)(GByteArray *array, const guint8 *data, guint len) { return stub_funcs.ptr_g_byte_array_append(array, data, len); }
GByteArray* (g_byte_array_prepend)(GByteArray *array, const guint8 *data, guint len) { return stub_funcs.ptr_g_byte_array_prepend(array, data, len); }
GByteArray* (g_byte_array_set_size)(GByteArray *array, guint length) { return stub_funcs.ptr_g_byte_array_set_size(array, length); }
GByteArray* (g_byte_array_remove_index)(GByteArray *array, guint index_) { return stub_funcs.ptr_g_byte_array_remove_index(array, index_); }
GByteArray* (g_byte_array_remove_index_fast)(GByteArray *array, guint index_) { return stub_funcs.ptr_g_byte_array_remove_index_fast(array, index_); }
GByteArray* (g_byte_array_remove_range)(GByteArray *array, guint index_, guint length) { return stub_funcs.ptr_g_byte_array_remove_range(array, index_, length); }
void (g_byte_array_sort)(GByteArray *array, GCompareFunc compare_func) { stub_funcs.ptr_g_byte_array_sort(array, compare_func); }
void (g_byte_array_sort_with_data)(GByteArray *array, GCompareDataFunc compare_func, gpointer user_data) { stub_funcs.ptr_g_byte_array_sort_with_data(array, compare_func, user_data); }
GArray* (g_array_new)(gboolean zero_terminated, gboolean clear_, guint element_size) { return stub_funcs.ptr_g_array_new(zero_terminated, clear_, element_size); }
GAsyncQueue* (g_async_queue_new_full)(GDestroyNotify item_free_func) { return stub_funcs.ptr_g_async_queue_new_full(item_free_func); }
void (g_async_queue_lock)(GAsyncQueue *queue) { stub_funcs.ptr_g_async_queue_lock(queue); }
void (g_async_queue_unlock)(GAsyncQueue *queue) { stub_funcs.ptr_g_async_queue_unlock(queue); }
GAsyncQueue* (g_async_queue_ref)(GAsyncQueue *queue) { return stub_funcs.ptr_g_async_queue_ref(queue); }
void (g_async_queue_unref)(GAsyncQueue *queue) { stub_funcs.ptr_g_async_queue_unref(queue); }
void (g_async_queue_ref_unlocked)(GAsyncQueue *queue) { stub_funcs.ptr_g_async_queue_ref_unlocked(queue); }
void (g_async_queue_unref_and_unlock)(GAsyncQueue *queue) { stub_funcs.ptr_g_async_queue_unref_and_unlock(queue); }
void (g_async_queue_push)(GAsyncQueue *queue, gpointer data) { stub_funcs.ptr_g_async_queue_push(queue, data); }
void (g_async_queue_push_unlocked)(GAsyncQueue *queue, gpointer data) { stub_funcs.ptr_g_async_queue_push_unlocked(queue, data); }
void (g_async_queue_push_sorted)(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data) { stub_funcs.ptr_g_async_queue_push_sorted(queue, data, func, user_data); }
void (g_async_queue_push_sorted_unlocked)(GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data) { stub_funcs.ptr_g_async_queue_push_sorted_unlocked(queue, data, func, user_data); }
gpointer (g_async_queue_pop)(GAsyncQueue *queue) { return stub_funcs.ptr_g_async_queue_pop(queue); }
gpointer (g_async_queue_pop_unlocked)(GAsyncQueue *queue) { return stub_funcs.ptr_g_async_queue_pop_unlocked(queue); }
gpointer (g_async_queue_try_pop)(GAsyncQueue *queue) { return stub_funcs.ptr_g_async_queue_try_pop(queue); }
gpointer (g_async_queue_try_pop_unlocked)(GAsyncQueue *queue) { return stub_funcs.ptr_g_async_queue_try_pop_unlocked(queue); }
gpointer (g_async_queue_timeout_pop)(GAsyncQueue *queue, guint64 timeout) { return stub_funcs.ptr_g_async_queue_timeout_pop(queue, timeout); }
gpointer (g_async_queue_timeout_pop_unlocked)(GAsyncQueue *queue, guint64 timeout) { return stub_funcs.ptr_g_async_queue_timeout_pop_unlocked(queue, timeout); }
gint (g_async_queue_length)(GAsyncQueue *queue) { return stub_funcs.ptr_g_async_queue_length(queue); }
gint (g_async_queue_length_unlocked)(GAsyncQueue *queue) { return stub_funcs.ptr_g_async_queue_length_unlocked(queue); }
void (g_async_queue_sort)(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data) { stub_funcs.ptr_g_async_queue_sort(queue, func, user_data); }
void (g_async_queue_sort_unlocked)(GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data) { stub_funcs.ptr_g_async_queue_sort_unlocked(queue, func, user_data); }
gboolean (g_async_queue_remove)(GAsyncQueue *queue, gpointer item) { return stub_funcs.ptr_g_async_queue_remove(queue, item); }
gboolean (g_async_queue_remove_unlocked)(GAsyncQueue *queue, gpointer item) { return stub_funcs.ptr_g_async_queue_remove_unlocked(queue, item); }
void (g_async_queue_push_front)(GAsyncQueue *queue, gpointer item) { stub_funcs.ptr_g_async_queue_push_front(queue, item); }
void (g_async_queue_push_front_unlocked)(GAsyncQueue *queue, gpointer item) { stub_funcs.ptr_g_async_queue_push_front_unlocked(queue, item); }
gpointer (g_async_queue_timed_pop_unlocked)(GAsyncQueue *queue, GTimeVal *end_time) { return stub_funcs.ptr_g_async_queue_timed_pop_unlocked(queue, end_time); }
GAsyncQueue* (g_async_queue_new)(void) { return stub_funcs.ptr_g_async_queue_new(); }
void (g_atomic_int_set)(volatile gint *atomic, gint newval) { stub_funcs.ptr_g_atomic_int_set(atomic, newval); }
void (g_atomic_int_inc)(volatile gint *atomic) { stub_funcs.ptr_g_atomic_int_inc(atomic); }
gboolean (g_atomic_int_dec_and_test)(volatile gint *atomic) { return stub_funcs.ptr_g_atomic_int_dec_and_test(atomic); }
gboolean (g_atomic_int_compare_and_exchange)(volatile gint *atomic, gint oldval, gint newval) { return stub_funcs.ptr_g_atomic_int_compare_and_exchange(atomic, oldval, newval); }
gboolean (g_atomic_int_compare_and_exchange_full)(gint *atomic, gint oldval, gint newval, gint *preval) { return stub_funcs.ptr_g_atomic_int_compare_and_exchange_full(atomic, oldval, newval, preval); }
gint (g_atomic_int_exchange)(gint *atomic, gint newval) { return stub_funcs.ptr_g_atomic_int_exchange(atomic, newval); }
gint (g_atomic_int_add)(volatile gint *atomic, gint val) { return stub_funcs.ptr_g_atomic_int_add(atomic, val); }
guint (g_atomic_int_and)(volatile guint *atomic, guint val) { return stub_funcs.ptr_g_atomic_int_and(atomic, val); }
guint (g_atomic_int_or)(volatile guint *atomic, guint val) { return stub_funcs.ptr_g_atomic_int_or(atomic, val); }
guint (g_atomic_int_xor)(volatile guint *atomic, guint val) { return stub_funcs.ptr_g_atomic_int_xor(atomic, val); }
gpointer (g_atomic_pointer_get)(const volatile void *atomic) { return stub_funcs.ptr_g_atomic_pointer_get(atomic); }
void (g_atomic_pointer_set)(volatile void *atomic, gpointer newval) { stub_funcs.ptr_g_atomic_pointer_set(atomic, newval); }
gboolean (g_atomic_pointer_compare_and_exchange)(volatile void *atomic, gpointer oldval, gpointer newval) { return stub_funcs.ptr_g_atomic_pointer_compare_and_exchange(atomic, oldval, newval); }
gboolean (g_atomic_pointer_compare_and_exchange_full)(void *atomic, gpointer oldval, gpointer newval, void *preval) { return stub_funcs.ptr_g_atomic_pointer_compare_and_exchange_full(atomic, oldval, newval, preval); }
gpointer (g_atomic_pointer_exchange)(void *atomic, gpointer newval) { return stub_funcs.ptr_g_atomic_pointer_exchange(atomic, newval); }
gintptr (g_atomic_pointer_add)(volatile void *atomic, gssize val) { return stub_funcs.ptr_g_atomic_pointer_add(atomic, val); }
guintptr (g_atomic_pointer_and)(volatile void *atomic, gsize val) { return stub_funcs.ptr_g_atomic_pointer_and(atomic, val); }
guintptr (g_atomic_pointer_or)(volatile void *atomic, gsize val) { return stub_funcs.ptr_g_atomic_pointer_or(atomic, val); }
guintptr (g_atomic_pointer_xor)(volatile void *atomic, gsize val) { return stub_funcs.ptr_g_atomic_pointer_xor(atomic, val); }
gint (g_atomic_int_exchange_and_add)(volatile gint *atomic, gint val) { return stub_funcs.ptr_g_atomic_int_exchange_and_add(atomic, val); }
gint (g_atomic_int_get)(const volatile gint *atomic) { return stub_funcs.ptr_g_atomic_int_get(atomic); }
void (g_on_error_stack_trace)(const gchar *prg_name) { stub_funcs.ptr_g_on_error_stack_trace(prg_name); }
void (g_on_error_query)(const gchar *prg_name) { stub_funcs.ptr_g_on_error_query(prg_name); }
gsize (g_base64_encode_close)(gboolean break_lines, gchar *out, gint *state, gint *save) { return stub_funcs.ptr_g_base64_encode_close(break_lines, out, state, save); }
gchar* (g_base64_encode)(const guchar *data, gsize len) { return stub_funcs.ptr_g_base64_encode(data, len); }
gsize (g_base64_decode_step)(const gchar *in, gsize len, guchar *out, gint *state, guint *save) { return stub_funcs.ptr_g_base64_decode_step(in, len, out, state, save); }
guchar* (g_base64_decode)(const gchar *text, gsize *out_len) { return stub_funcs.ptr_g_base64_decode(text, out_len); }
guchar* (g_base64_decode_inplace)(gchar *text, gsize *out_len) { return stub_funcs.ptr_g_base64_decode_inplace(text, out_len); }
gsize (g_base64_encode_step)(const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save) { return stub_funcs.ptr_g_base64_encode_step(in, len, break_lines, out, state, save); }
gboolean (g_bit_trylock)(volatile gint *address, gint lock_bit) { return stub_funcs.ptr_g_bit_trylock(address, lock_bit); }
void (g_bit_unlock)(volatile gint *address, gint lock_bit) { stub_funcs.ptr_g_bit_unlock(address, lock_bit); }
void (g_pointer_bit_lock)(volatile void *address, gint lock_bit) { stub_funcs.ptr_g_pointer_bit_lock(address, lock_bit); }
void (g_pointer_bit_lock_and_get)(gpointer address, guint lock_bit, guintptr *out_ptr) { stub_funcs.ptr_g_pointer_bit_lock_and_get(address, lock_bit, out_ptr); }
gboolean (g_pointer_bit_trylock)(volatile void *address, gint lock_bit) { return stub_funcs.ptr_g_pointer_bit_trylock(address, lock_bit); }
void (g_pointer_bit_unlock)(volatile void *address, gint lock_bit) { stub_funcs.ptr_g_pointer_bit_unlock(address, lock_bit); }
gpointer (g_pointer_bit_lock_mask_ptr)(gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr) { return stub_funcs.ptr_g_pointer_bit_lock_mask_ptr(ptr, lock_bit, set, preserve_mask, preserve_ptr); }
void (g_pointer_bit_unlock_and_set)(void *address, guint lock_bit, gpointer ptr, guintptr preserve_mask) { stub_funcs.ptr_g_pointer_bit_unlock_and_set(address, lock_bit, ptr, preserve_mask); }
void (g_bit_lock)(volatile gint *address, gint lock_bit) { stub_funcs.ptr_g_bit_lock(address, lock_bit); }
GBookmarkFile* (g_bookmark_file_new)(void) { return stub_funcs.ptr_g_bookmark_file_new(); }
void (g_bookmark_file_free)(GBookmarkFile *bookmark) { stub_funcs.ptr_g_bookmark_file_free(bookmark); }
GBookmarkFile* (g_bookmark_file_copy)(GBookmarkFile *bookmark) { return stub_funcs.ptr_g_bookmark_file_copy(bookmark); }
gboolean (g_bookmark_file_load_from_file)(GBookmarkFile *bookmark, const gchar *filename, GError **error) { return stub_funcs.ptr_g_bookmark_file_load_from_file(bookmark, filename, error); }
gboolean (g_bookmark_file_load_from_data)(GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error) { return stub_funcs.ptr_g_bookmark_file_load_from_data(bookmark, data, length, error); }
gboolean (g_bookmark_file_load_from_data_dirs)(GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error) { return stub_funcs.ptr_g_bookmark_file_load_from_data_dirs(bookmark, file, full_path, error); }
gchar * (g_bookmark_file_to_data)(GBookmarkFile *bookmark, gsize *length, GError **error) { return stub_funcs.ptr_g_bookmark_file_to_data(bookmark, length, error); }
gboolean (g_bookmark_file_to_file)(GBookmarkFile *bookmark, const gchar *filename, GError **error) { return stub_funcs.ptr_g_bookmark_file_to_file(bookmark, filename, error); }
void (g_bookmark_file_set_title)(GBookmarkFile *bookmark, const gchar *uri, const gchar *title) { stub_funcs.ptr_g_bookmark_file_set_title(bookmark, uri, title); }
gchar * (g_bookmark_file_get_title)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_title(bookmark, uri, error); }
void (g_bookmark_file_set_description)(GBookmarkFile *bookmark, const gchar *uri, const gchar *description) { stub_funcs.ptr_g_bookmark_file_set_description(bookmark, uri, description); }
gchar * (g_bookmark_file_get_description)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_description(bookmark, uri, error); }
void (g_bookmark_file_set_mime_type)(GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type) { stub_funcs.ptr_g_bookmark_file_set_mime_type(bookmark, uri, mime_type); }
gchar * (g_bookmark_file_get_mime_type)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_mime_type(bookmark, uri, error); }
void (g_bookmark_file_set_groups)(GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length) { stub_funcs.ptr_g_bookmark_file_set_groups(bookmark, uri, groups, length); }
void (g_bookmark_file_add_group)(GBookmarkFile *bookmark, const gchar *uri, const gchar *group) { stub_funcs.ptr_g_bookmark_file_add_group(bookmark, uri, group); }
gboolean (g_bookmark_file_has_group)(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error) { return stub_funcs.ptr_g_bookmark_file_has_group(bookmark, uri, group, error); }
gchar ** (g_bookmark_file_get_groups)(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_groups(bookmark, uri, length, error); }
void (g_bookmark_file_add_application)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec) { stub_funcs.ptr_g_bookmark_file_add_application(bookmark, uri, name, exec); }
gboolean (g_bookmark_file_has_application)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error) { return stub_funcs.ptr_g_bookmark_file_has_application(bookmark, uri, name, error); }
gchar ** (g_bookmark_file_get_applications)(GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_applications(bookmark, uri, length, error); }
gboolean (g_bookmark_file_set_app_info)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error) { return stub_funcs.ptr_g_bookmark_file_set_app_info(bookmark, uri, name, exec, count, stamp, error); }
gboolean (g_bookmark_file_set_application_info)(GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error) { return stub_funcs.ptr_g_bookmark_file_set_application_info(bookmark, uri, name, exec, count, stamp, error); }
gboolean (g_bookmark_file_get_app_info)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_app_info(bookmark, uri, name, exec, count, stamp, error); }
gboolean (g_bookmark_file_get_application_info)(GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_application_info(bookmark, uri, name, exec, count, stamp, error); }
void (g_bookmark_file_set_is_private)(GBookmarkFile *bookmark, const gchar *uri, gboolean is_private) { stub_funcs.ptr_g_bookmark_file_set_is_private(bookmark, uri, is_private); }
gboolean (g_bookmark_file_get_is_private)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_is_private(bookmark, uri, error); }
void (g_bookmark_file_set_icon)(GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type) { stub_funcs.ptr_g_bookmark_file_set_icon(bookmark, uri, href, mime_type); }
gboolean (g_bookmark_file_get_icon)(GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_icon(bookmark, uri, href, mime_type, error); }
void (g_bookmark_file_set_added)(GBookmarkFile *bookmark, const gchar *uri, time_t added) { stub_funcs.ptr_g_bookmark_file_set_added(bookmark, uri, added); }
void (g_bookmark_file_set_added_date_time)(GBookmarkFile *bookmark, const char *uri, GDateTime *added) { stub_funcs.ptr_g_bookmark_file_set_added_date_time(bookmark, uri, added); }
time_t (g_bookmark_file_get_added)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_added(bookmark, uri, error); }
GDateTime* (g_bookmark_file_get_added_date_time)(GBookmarkFile *bookmark, const char *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_added_date_time(bookmark, uri, error); }
void (g_bookmark_file_set_modified)(GBookmarkFile *bookmark, const gchar *uri, time_t modified) { stub_funcs.ptr_g_bookmark_file_set_modified(bookmark, uri, modified); }
void (g_bookmark_file_set_modified_date_time)(GBookmarkFile *bookmark, const char *uri, GDateTime *modified) { stub_funcs.ptr_g_bookmark_file_set_modified_date_time(bookmark, uri, modified); }
time_t (g_bookmark_file_get_modified)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_modified(bookmark, uri, error); }
GDateTime* (g_bookmark_file_get_modified_date_time)(GBookmarkFile *bookmark, const char *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_modified_date_time(bookmark, uri, error); }
void (g_bookmark_file_set_visited)(GBookmarkFile *bookmark, const gchar *uri, time_t visited) { stub_funcs.ptr_g_bookmark_file_set_visited(bookmark, uri, visited); }
void (g_bookmark_file_set_visited_date_time)(GBookmarkFile *bookmark, const char *uri, GDateTime *visited) { stub_funcs.ptr_g_bookmark_file_set_visited_date_time(bookmark, uri, visited); }
time_t (g_bookmark_file_get_visited)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_visited(bookmark, uri, error); }
GDateTime* (g_bookmark_file_get_visited_date_time)(GBookmarkFile *bookmark, const char *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_get_visited_date_time(bookmark, uri, error); }
gboolean (g_bookmark_file_has_item)(GBookmarkFile *bookmark, const gchar *uri) { return stub_funcs.ptr_g_bookmark_file_has_item(bookmark, uri); }
gint (g_bookmark_file_get_size)(GBookmarkFile *bookmark) { return stub_funcs.ptr_g_bookmark_file_get_size(bookmark); }
gchar ** (g_bookmark_file_get_uris)(GBookmarkFile *bookmark, gsize *length) { return stub_funcs.ptr_g_bookmark_file_get_uris(bookmark, length); }
gboolean (g_bookmark_file_remove_group)(GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error) { return stub_funcs.ptr_g_bookmark_file_remove_group(bookmark, uri, group, error); }
gboolean (g_bookmark_file_remove_application)(GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error) { return stub_funcs.ptr_g_bookmark_file_remove_application(bookmark, uri, name, error); }
gboolean (g_bookmark_file_remove_item)(GBookmarkFile *bookmark, const gchar *uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_remove_item(bookmark, uri, error); }
gboolean (g_bookmark_file_move_item)(GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error) { return stub_funcs.ptr_g_bookmark_file_move_item(bookmark, old_uri, new_uri, error); }
GQuark (g_bookmark_file_error_quark)(void) { return stub_funcs.ptr_g_bookmark_file_error_quark(); }
GBytes * (g_bytes_new_take)(gpointer data, gsize size) { return stub_funcs.ptr_g_bytes_new_take(data, size); }
GBytes * (g_bytes_new_static)(gconstpointer data, gsize size) { return stub_funcs.ptr_g_bytes_new_static(data, size); }
GBytes * (g_bytes_new_with_free_func)(gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data) { return stub_funcs.ptr_g_bytes_new_with_free_func(data, size, free_func, user_data); }
GBytes * (g_bytes_new_from_bytes)(GBytes *bytes, gsize offset, gsize length) { return stub_funcs.ptr_g_bytes_new_from_bytes(bytes, offset, length); }
gconstpointer (g_bytes_get_data)(GBytes *bytes, gsize *size) { return stub_funcs.ptr_g_bytes_get_data(bytes, size); }
gsize (g_bytes_get_size)(GBytes *bytes) { return stub_funcs.ptr_g_bytes_get_size(bytes); }
GBytes * (g_bytes_ref)(GBytes *bytes) { return stub_funcs.ptr_g_bytes_ref(bytes); }
void (g_bytes_unref)(GBytes *bytes) { stub_funcs.ptr_g_bytes_unref(bytes); }
gpointer (g_bytes_unref_to_data)(GBytes *bytes, gsize *size) { return stub_funcs.ptr_g_bytes_unref_to_data(bytes, size); }
GByteArray * (g_bytes_unref_to_array)(GBytes *bytes) { return stub_funcs.ptr_g_bytes_unref_to_array(bytes); }
guint (g_bytes_hash)(gconstpointer bytes) { return stub_funcs.ptr_g_bytes_hash(bytes); }
gboolean (g_bytes_equal)(gconstpointer bytes1, gconstpointer bytes2) { return stub_funcs.ptr_g_bytes_equal(bytes1, bytes2); }
gint (g_bytes_compare)(gconstpointer bytes1, gconstpointer bytes2) { return stub_funcs.ptr_g_bytes_compare(bytes1, bytes2); }
gconstpointer (g_bytes_get_region)(GBytes *bytes, gsize element_size, gsize offset, gsize n_elements) { return stub_funcs.ptr_g_bytes_get_region(bytes, element_size, offset, n_elements); }
GBytes * (g_bytes_new)(gconstpointer data, gsize size) { return stub_funcs.ptr_g_bytes_new(data, size); }
gchar * (g_get_codeset)(void) { return stub_funcs.ptr_g_get_codeset(); }
gboolean (g_get_console_charset)(const char **charset) { return stub_funcs.ptr_g_get_console_charset(charset); }
const gchar * const * (g_get_language_names)(void) { return stub_funcs.ptr_g_get_language_names(); }
const gchar * const * (g_get_language_names_with_category)(const gchar *category_name) { return stub_funcs.ptr_g_get_language_names_with_category(category_name); }
gchar ** (g_get_locale_variants)(const gchar *locale) { return stub_funcs.ptr_g_get_locale_variants(locale); }
gboolean (g_get_charset)(const char **charset) { return stub_funcs.ptr_g_get_charset(charset); }
GChecksum * (g_checksum_new)(GChecksumType checksum_type) { return stub_funcs.ptr_g_checksum_new(checksum_type); }
void (g_checksum_reset)(GChecksum *checksum) { stub_funcs.ptr_g_checksum_reset(checksum); }
GChecksum * (g_checksum_copy)(const GChecksum *checksum) { return stub_funcs.ptr_g_checksum_copy(checksum); }
void (g_checksum_free)(GChecksum *checksum) { stub_funcs.ptr_g_checksum_free(checksum); }
void (g_checksum_update)(GChecksum *checksum, const guchar *data, gssize length) { stub_funcs.ptr_g_checksum_update(checksum, data, length); }
const gchar * (g_checksum_get_string)(GChecksum *checksum) { return stub_funcs.ptr_g_checksum_get_string(checksum); }
void (g_checksum_get_digest)(GChecksum *checksum, guint8 *buffer, gsize *digest_len) { stub_funcs.ptr_g_checksum_get_digest(checksum, buffer, digest_len); }
gchar* (g_compute_checksum_for_data)(GChecksumType checksum_type, const guchar *data, gsize length) { return stub_funcs.ptr_g_compute_checksum_for_data(checksum_type, data, length); }
gchar* (g_compute_checksum_for_string)(GChecksumType checksum_type, const gchar *str, gssize length) { return stub_funcs.ptr_g_compute_checksum_for_string(checksum_type, str, length); }
gchar* (g_compute_checksum_for_bytes)(GChecksumType checksum_type, GBytes *data) { return stub_funcs.ptr_g_compute_checksum_for_bytes(checksum_type, data); }
gssize (g_checksum_type_get_length)(GChecksumType checksum_type) { return stub_funcs.ptr_g_checksum_type_get_length(checksum_type); }
GIConv (g_iconv_open)(const gchar *to_codeset, const gchar *from_codeset) { return stub_funcs.ptr_g_iconv_open(to_codeset, from_codeset); }
gsize (g_iconv)(GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left) { return stub_funcs.ptr_g_iconv(converter, inbuf, inbytes_left, outbuf, outbytes_left); }
gint (g_iconv_close)(GIConv converter) { return stub_funcs.ptr_g_iconv_close(converter); }
gchar* (g_convert)(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_convert(str, len, to_codeset, from_codeset, bytes_read, bytes_written, error); }
gchar* (g_convert_with_iconv)(const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_convert_with_iconv(str, len, converter, bytes_read, bytes_written, error); }
gchar* (g_convert_with_fallback)(const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_convert_with_fallback(str, len, to_codeset, from_codeset, fallback, bytes_read, bytes_written, error); }
gchar* (g_locale_to_utf8)(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_locale_to_utf8(opsysstring, len, bytes_read, bytes_written, error); }
gchar* (g_locale_from_utf8)(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_locale_from_utf8(utf8string, len, bytes_read, bytes_written, error); }
gchar* (g_filename_to_utf8)(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_filename_to_utf8(opsysstring, len, bytes_read, bytes_written, error); }
gchar* (g_filename_from_utf8)(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_filename_from_utf8(utf8string, len, bytes_read, bytes_written, error); }
gchar* (g_filename_from_uri)(const gchar *uri, gchar **hostname, GError **error) { return stub_funcs.ptr_g_filename_from_uri(uri, hostname, error); }
gchar* (g_filename_to_uri)(const gchar *filename, const gchar *hostname, GError **error) { return stub_funcs.ptr_g_filename_to_uri(filename, hostname, error); }
gchar* (g_filename_display_name)(const gchar *filename) { return stub_funcs.ptr_g_filename_display_name(filename); }
gboolean (g_get_filename_charsets)(const gchar ***filename_charsets) { return stub_funcs.ptr_g_get_filename_charsets(filename_charsets); }
gchar* (g_filename_display_basename)(const gchar *filename) { return stub_funcs.ptr_g_filename_display_basename(filename); }
gchar** (g_uri_list_extract_uris)(const gchar *uri_list) { return stub_funcs.ptr_g_uri_list_extract_uris(uri_list); }
GQuark (g_convert_error_quark)(void) { return stub_funcs.ptr_g_convert_error_quark(); }
void (g_datalist_clear)(GData **datalist) { stub_funcs.ptr_g_datalist_clear(datalist); }
gpointer (g_datalist_id_get_data)(GData **datalist, GQuark key_id) { return stub_funcs.ptr_g_datalist_id_get_data(datalist, key_id); }
void (g_datalist_id_set_data_full)(GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func) { stub_funcs.ptr_g_datalist_id_set_data_full(datalist, key_id, data, destroy_func); }
void (g_datalist_id_remove_multiple)(GData **datalist, GQuark *keys, gsize n_keys) { stub_funcs.ptr_g_datalist_id_remove_multiple(datalist, keys, n_keys); }
gpointer (g_datalist_id_dup_data)(GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data) { return stub_funcs.ptr_g_datalist_id_dup_data(datalist, key_id, dup_func, user_data); }
gboolean (g_datalist_id_replace_data)(GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy) { return stub_funcs.ptr_g_datalist_id_replace_data(datalist, key_id, oldval, newval, destroy, old_destroy); }
gpointer (g_datalist_id_remove_no_notify)(GData **datalist, GQuark key_id) { return stub_funcs.ptr_g_datalist_id_remove_no_notify(datalist, key_id); }
void (g_datalist_foreach)(GData **datalist, GDataForeachFunc func, gpointer user_data) { stub_funcs.ptr_g_datalist_foreach(datalist, func, user_data); }
void (g_datalist_set_flags)(GData **datalist, guint flags) { stub_funcs.ptr_g_datalist_set_flags(datalist, flags); }
void (g_datalist_unset_flags)(GData **datalist, guint flags) { stub_funcs.ptr_g_datalist_unset_flags(datalist, flags); }
guint (g_datalist_get_flags)(GData **datalist) { return stub_funcs.ptr_g_datalist_get_flags(datalist); }
void (g_dataset_destroy)(gconstpointer dataset_location) { stub_funcs.ptr_g_dataset_destroy(dataset_location); }
gpointer (g_dataset_id_get_data)(gconstpointer dataset_location, GQuark key_id) { return stub_funcs.ptr_g_dataset_id_get_data(dataset_location, key_id); }
gpointer (g_datalist_get_data)(GData **datalist, const gchar *key) { return stub_funcs.ptr_g_datalist_get_data(datalist, key); }
void (g_dataset_id_set_data_full)(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func) { stub_funcs.ptr_g_dataset_id_set_data_full(dataset_location, key_id, data, destroy_func); }
gpointer (g_dataset_id_remove_no_notify)(gconstpointer dataset_location, GQuark key_id) { return stub_funcs.ptr_g_dataset_id_remove_no_notify(dataset_location, key_id); }
void (g_dataset_foreach)(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data) { stub_funcs.ptr_g_dataset_foreach(dataset_location, func, user_data); }
void (g_datalist_init)(GData **datalist) { stub_funcs.ptr_g_datalist_init(datalist); }
GDate* (g_date_new_dmy)(GDateDay day, GDateMonth month, GDateYear year) { return stub_funcs.ptr_g_date_new_dmy(day, month, year); }
GDate* (g_date_new_julian)(guint32 julian_day) { return stub_funcs.ptr_g_date_new_julian(julian_day); }
void (g_date_free)(GDate *date) { stub_funcs.ptr_g_date_free(date); }
GDate* (g_date_copy)(const GDate *date) { return stub_funcs.ptr_g_date_copy(date); }
gboolean (g_date_valid)(const GDate *date) { return stub_funcs.ptr_g_date_valid(date); }
gboolean (g_date_valid_day)(GDateDay day) { return stub_funcs.ptr_g_date_valid_day(day); }
gboolean (g_date_valid_month)(GDateMonth month) { return stub_funcs.ptr_g_date_valid_month(month); }
gboolean (g_date_valid_year)(GDateYear year) { return stub_funcs.ptr_g_date_valid_year(year); }
gboolean (g_date_valid_weekday)(GDateWeekday weekday) { return stub_funcs.ptr_g_date_valid_weekday(weekday); }
gboolean (g_date_valid_julian)(guint32 julian_date) { return stub_funcs.ptr_g_date_valid_julian(julian_date); }
gboolean (g_date_valid_dmy)(GDateDay day, GDateMonth month, GDateYear year) { return stub_funcs.ptr_g_date_valid_dmy(day, month, year); }
GDateWeekday (g_date_get_weekday)(const GDate *date) { return stub_funcs.ptr_g_date_get_weekday(date); }
GDateMonth (g_date_get_month)(const GDate *date) { return stub_funcs.ptr_g_date_get_month(date); }
GDateYear (g_date_get_year)(const GDate *date) { return stub_funcs.ptr_g_date_get_year(date); }
GDateDay (g_date_get_day)(const GDate *date) { return stub_funcs.ptr_g_date_get_day(date); }
guint32 (g_date_get_julian)(const GDate *date) { return stub_funcs.ptr_g_date_get_julian(date); }
guint (g_date_get_day_of_year)(const GDate *date) { return stub_funcs.ptr_g_date_get_day_of_year(date); }
guint (g_date_get_monday_week_of_year)(const GDate *date) { return stub_funcs.ptr_g_date_get_monday_week_of_year(date); }
guint (g_date_get_sunday_week_of_year)(const GDate *date) { return stub_funcs.ptr_g_date_get_sunday_week_of_year(date); }
guint (g_date_get_iso8601_week_of_year)(const GDate *date) { return stub_funcs.ptr_g_date_get_iso8601_week_of_year(date); }
void (g_date_clear)(GDate *date, guint n_dates) { stub_funcs.ptr_g_date_clear(date, n_dates); }
void (g_date_set_parse)(GDate *date, const gchar *str) { stub_funcs.ptr_g_date_set_parse(date, str); }
void (g_date_set_time_t)(GDate *date, time_t timet) { stub_funcs.ptr_g_date_set_time_t(date, timet); }
void (g_date_set_time)(GDate *date, GTime time_) { stub_funcs.ptr_g_date_set_time(date, time_); }
void (g_date_set_day)(GDate *date, GDateDay day) { stub_funcs.ptr_g_date_set_day(date, day); }
void (g_date_set_year)(GDate *date, GDateYear year) { stub_funcs.ptr_g_date_set_year(date, year); }
void (g_date_set_dmy)(GDate *date, GDateDay day, GDateMonth month, GDateYear y) { stub_funcs.ptr_g_date_set_dmy(date, day, month, y); }
void (g_date_set_julian)(GDate *date, guint32 julian_date) { stub_funcs.ptr_g_date_set_julian(date, julian_date); }
gboolean (g_date_is_first_of_month)(const GDate *date) { return stub_funcs.ptr_g_date_is_first_of_month(date); }
gboolean (g_date_is_last_of_month)(const GDate *date) { return stub_funcs.ptr_g_date_is_last_of_month(date); }
void (g_date_add_days)(GDate *date, guint n_days) { stub_funcs.ptr_g_date_add_days(date, n_days); }
void (g_date_subtract_days)(GDate *date, guint n_days) { stub_funcs.ptr_g_date_subtract_days(date, n_days); }
void (g_date_add_months)(GDate *date, guint n_months) { stub_funcs.ptr_g_date_add_months(date, n_months); }
void (g_date_subtract_months)(GDate *date, guint n_months) { stub_funcs.ptr_g_date_subtract_months(date, n_months); }
void (g_date_add_years)(GDate *date, guint n_years) { stub_funcs.ptr_g_date_add_years(date, n_years); }
void (g_date_subtract_years)(GDate *date, guint n_years) { stub_funcs.ptr_g_date_subtract_years(date, n_years); }
gboolean (g_date_is_leap_year)(GDateYear year) { return stub_funcs.ptr_g_date_is_leap_year(year); }
guint8 (g_date_get_days_in_month)(GDateMonth month, GDateYear year) { return stub_funcs.ptr_g_date_get_days_in_month(month, year); }
guint8 (g_date_get_monday_weeks_in_year)(GDateYear year) { return stub_funcs.ptr_g_date_get_monday_weeks_in_year(year); }
guint8 (g_date_get_sunday_weeks_in_year)(GDateYear year) { return stub_funcs.ptr_g_date_get_sunday_weeks_in_year(year); }
gint (g_date_days_between)(const GDate *date1, const GDate *date2) { return stub_funcs.ptr_g_date_days_between(date1, date2); }
gint (g_date_compare)(const GDate *lhs, const GDate *rhs) { return stub_funcs.ptr_g_date_compare(lhs, rhs); }
void (g_date_to_struct_tm)(const GDate *date, struct tm *tm) { stub_funcs.ptr_g_date_to_struct_tm(date, tm); }
void (g_date_clamp)(GDate *date, const GDate *min_date, const GDate *max_date) { stub_funcs.ptr_g_date_clamp(date, min_date, max_date); }
void (g_date_order)(GDate *date1, GDate *date2) { stub_funcs.ptr_g_date_order(date1, date2); }
gsize (g_date_strftime)(gchar *s, gsize slen, const gchar *format, const GDate *date) { return stub_funcs.ptr_g_date_strftime(s, slen, format, date); }
GDate* (g_date_new)(void) { return stub_funcs.ptr_g_date_new(); }
GDateTime * (g_date_time_ref)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_ref(datetime); }
GDateTime * (g_date_time_new_now)(GTimeZone *tz) { return stub_funcs.ptr_g_date_time_new_now(tz); }
GDateTime * (g_date_time_new_now_local)(void) { return stub_funcs.ptr_g_date_time_new_now_local(); }
GDateTime * (g_date_time_new_now_utc)(void) { return stub_funcs.ptr_g_date_time_new_now_utc(); }
GDateTime * (g_date_time_new_from_unix_local)(gint64 t) { return stub_funcs.ptr_g_date_time_new_from_unix_local(t); }
GDateTime * (g_date_time_new_from_unix_utc)(gint64 t) { return stub_funcs.ptr_g_date_time_new_from_unix_utc(t); }
GDateTime * (g_date_time_new_from_unix_local_usec)(gint64 usecs) { return stub_funcs.ptr_g_date_time_new_from_unix_local_usec(usecs); }
GDateTime * (g_date_time_new_from_unix_utc_usec)(gint64 usecs) { return stub_funcs.ptr_g_date_time_new_from_unix_utc_usec(usecs); }
GDateTime * (g_date_time_new_from_timeval_utc)(const GTimeVal *tv) { return stub_funcs.ptr_g_date_time_new_from_timeval_utc(tv); }
GDateTime * (g_date_time_new)(GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds) { return stub_funcs.ptr_g_date_time_new(tz, year, month, day, hour, minute, seconds); }
GDateTime * (g_date_time_new_local)(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds) { return stub_funcs.ptr_g_date_time_new_local(year, month, day, hour, minute, seconds); }
GDateTime * (g_date_time_new_utc)(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds) { return stub_funcs.ptr_g_date_time_new_utc(year, month, day, hour, minute, seconds); }
GDateTime * (g_date_time_add)(GDateTime *datetime, GTimeSpan timespan) { return stub_funcs.ptr_g_date_time_add(datetime, timespan); }
GDateTime * (g_date_time_add_years)(GDateTime *datetime, gint years) { return stub_funcs.ptr_g_date_time_add_years(datetime, years); }
GDateTime * (g_date_time_add_months)(GDateTime *datetime, gint months) { return stub_funcs.ptr_g_date_time_add_months(datetime, months); }
GDateTime * (g_date_time_add_weeks)(GDateTime *datetime, gint weeks) { return stub_funcs.ptr_g_date_time_add_weeks(datetime, weeks); }
GDateTime * (g_date_time_add_days)(GDateTime *datetime, gint days) { return stub_funcs.ptr_g_date_time_add_days(datetime, days); }
GDateTime * (g_date_time_add_hours)(GDateTime *datetime, gint hours) { return stub_funcs.ptr_g_date_time_add_hours(datetime, hours); }
GDateTime * (g_date_time_add_minutes)(GDateTime *datetime, gint minutes) { return stub_funcs.ptr_g_date_time_add_minutes(datetime, minutes); }
GDateTime * (g_date_time_add_seconds)(GDateTime *datetime, gdouble seconds) { return stub_funcs.ptr_g_date_time_add_seconds(datetime, seconds); }
GDateTime * (g_date_time_add_full)(GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds) { return stub_funcs.ptr_g_date_time_add_full(datetime, years, months, days, hours, minutes, seconds); }
gint (g_date_time_compare)(gconstpointer dt1, gconstpointer dt2) { return stub_funcs.ptr_g_date_time_compare(dt1, dt2); }
GTimeSpan (g_date_time_difference)(GDateTime *end, GDateTime *begin) { return stub_funcs.ptr_g_date_time_difference(end, begin); }
guint (g_date_time_hash)(gconstpointer datetime) { return stub_funcs.ptr_g_date_time_hash(datetime); }
gboolean (g_date_time_equal)(gconstpointer dt1, gconstpointer dt2) { return stub_funcs.ptr_g_date_time_equal(dt1, dt2); }
void (g_date_time_get_ymd)(GDateTime *datetime, gint *year, gint *month, gint *day) { stub_funcs.ptr_g_date_time_get_ymd(datetime, year, month, day); }
gint (g_date_time_get_year)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_year(datetime); }
gint (g_date_time_get_month)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_month(datetime); }
gint (g_date_time_get_day_of_month)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_day_of_month(datetime); }
gint (g_date_time_get_week_numbering_year)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_week_numbering_year(datetime); }
gint (g_date_time_get_week_of_year)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_week_of_year(datetime); }
gint (g_date_time_get_day_of_week)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_day_of_week(datetime); }
gint (g_date_time_get_day_of_year)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_day_of_year(datetime); }
gint (g_date_time_get_hour)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_hour(datetime); }
gint (g_date_time_get_minute)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_minute(datetime); }
gint (g_date_time_get_second)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_second(datetime); }
gint (g_date_time_get_microsecond)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_microsecond(datetime); }
gdouble (g_date_time_get_seconds)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_seconds(datetime); }
gint64 (g_date_time_to_unix)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_to_unix(datetime); }
gint64 (g_date_time_to_unix_usec)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_to_unix_usec(datetime); }
GTimeZone * (g_date_time_get_timezone)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_timezone(datetime); }
const gchar * (g_date_time_get_timezone_abbreviation)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_get_timezone_abbreviation(datetime); }
gboolean (g_date_time_is_daylight_savings)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_is_daylight_savings(datetime); }
GDateTime * (g_date_time_to_timezone)(GDateTime *datetime, GTimeZone *tz) { return stub_funcs.ptr_g_date_time_to_timezone(datetime, tz); }
GDateTime * (g_date_time_to_local)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_to_local(datetime); }
GDateTime * (g_date_time_to_utc)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_to_utc(datetime); }
gchar * (g_date_time_format)(GDateTime *datetime, const gchar *format) { return stub_funcs.ptr_g_date_time_format(datetime, format); }
gchar * (g_date_time_format_iso8601)(GDateTime *datetime) { return stub_funcs.ptr_g_date_time_format_iso8601(datetime); }
void (g_date_time_unref)(GDateTime *datetime) { stub_funcs.ptr_g_date_time_unref(datetime); }
const gchar * (g_dir_read_name)(GDir *dir) { return stub_funcs.ptr_g_dir_read_name(dir); }
void (g_dir_rewind)(GDir *dir) { stub_funcs.ptr_g_dir_rewind(dir); }
void (g_dir_close)(GDir *dir) { stub_funcs.ptr_g_dir_close(dir); }
GDir * (g_dir_ref)(GDir *dir) { return stub_funcs.ptr_g_dir_ref(dir); }
void (g_dir_unref)(GDir *dir) { stub_funcs.ptr_g_dir_unref(dir); }
GDir * (g_dir_open)(const gchar *path, guint flags, GError **error) { return stub_funcs.ptr_g_dir_open(path, flags, error); }
gboolean (g_setenv)(const gchar *variable, const gchar *value, gboolean overwrite) { return stub_funcs.ptr_g_setenv(variable, value, overwrite); }
void (g_unsetenv)(const gchar *variable) { stub_funcs.ptr_g_unsetenv(variable); }
gchar ** (g_listenv)(void) { return stub_funcs.ptr_g_listenv(); }
gchar ** (g_get_environ)(void) { return stub_funcs.ptr_g_get_environ(); }
const gchar * (g_environ_getenv)(gchar **envp, const gchar *variable) { return stub_funcs.ptr_g_environ_getenv(envp, variable); }
gchar ** (g_environ_setenv)(gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite) { return stub_funcs.ptr_g_environ_setenv(envp, variable, value, overwrite); }
gchar ** (g_environ_unsetenv)(gchar **envp, const gchar *variable) { return stub_funcs.ptr_g_environ_unsetenv(envp, variable); }
const gchar * (g_getenv)(const gchar *variable) { return stub_funcs.ptr_g_getenv(variable); }
GQuark (g_error_domain_register)(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear) { return stub_funcs.ptr_g_error_domain_register(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear); }
GError* (g_error_new)(GQuark domain, gint code, const gchar *format, ...) { GError* ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_error_new_valist(domain, code, format, vaargs); va_end(vaargs); return ret; }
GError* (g_error_new_literal)(GQuark domain, gint code, const gchar *message) { return stub_funcs.ptr_g_error_new_literal(domain, code, message); }
GError* (g_error_new_valist)(GQuark domain, gint code, const gchar *format, va_list args) { return stub_funcs.ptr_g_error_new_valist(domain, code, format, args); }
void (g_error_free)(GError *error) { stub_funcs.ptr_g_error_free(error); }
GError* (g_error_copy)(const GError *error) { return stub_funcs.ptr_g_error_copy(error); }
gboolean (g_error_matches)(const GError *error, GQuark domain, gint code) { return stub_funcs.ptr_g_error_matches(error, domain, code); }
// Unable to locate va_equiv for g_set_error
void (g_set_error_literal)(GError **err, GQuark domain, gint code, const gchar *message) { stub_funcs.ptr_g_set_error_literal(err, domain, code, message); }
void (g_propagate_error)(GError **dest, GError *src) { stub_funcs.ptr_g_propagate_error(dest, src); }
void (g_clear_error)(GError **err) { stub_funcs.ptr_g_clear_error(err); }
// Unable to locate va_equiv for g_prefix_error
void (g_prefix_error_literal)(GError **err, const gchar *prefix) { stub_funcs.ptr_g_prefix_error_literal(err, prefix); }
// Unable to locate va_equiv for g_propagate_prefixed_error
GQuark (g_error_domain_register_static)(const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear) { return stub_funcs.ptr_g_error_domain_register_static(error_type_name, error_type_private_size, error_type_init, error_type_copy, error_type_clear); }
GQuark (g_file_error_quark)(void) { return stub_funcs.ptr_g_file_error_quark(); }
GFileError (g_file_error_from_errno)(gint err_no) { return stub_funcs.ptr_g_file_error_from_errno(err_no); }
gboolean (g_file_test)(const gchar *filename, GFileTest test) { return stub_funcs.ptr_g_file_test(filename, test); }
gboolean (g_file_get_contents)(const gchar *filename, gchar **contents, gsize *length, GError **error) { return stub_funcs.ptr_g_file_get_contents(filename, contents, length, error); }
gboolean (g_file_set_contents)(const gchar *filename, const gchar *contents, gssize length, GError **error) { return stub_funcs.ptr_g_file_set_contents(filename, contents, length, error); }
gchar* (g_mkdtemp)(gchar *tmpl) { return stub_funcs.ptr_g_mkdtemp(tmpl); }
gchar* (g_mkdtemp_full)(gchar *tmpl, gint mode) { return stub_funcs.ptr_g_mkdtemp_full(tmpl, mode); }
gint (g_mkstemp)(gchar *tmpl) { return stub_funcs.ptr_g_mkstemp(tmpl); }
gint (g_mkstemp_full)(gchar *tmpl, gint flags, gint mode) { return stub_funcs.ptr_g_mkstemp_full(tmpl, flags, mode); }
gint (g_file_open_tmp)(const gchar *tmpl, gchar **name_used, GError **error) { return stub_funcs.ptr_g_file_open_tmp(tmpl, name_used, error); }
gchar* (g_dir_make_tmp)(const gchar *tmpl, GError **error) { return stub_funcs.ptr_g_dir_make_tmp(tmpl, error); }
// Found va_equiv for func g_build_path as func g_build_pathv with pattern g_build_path[_]*va*$, but err: va_list missing
gchar* (g_build_pathv)(const gchar *separator, gchar **args) { return stub_funcs.ptr_g_build_pathv(separator, args); }
gchar* (g_build_filename)(const gchar *first_element, ...) { gchar* ret; va_list vaargs; va_start(vaargs, first_element); ret = stub_funcs.ptr_g_build_filename_valist(first_element, &vaargs); va_end(vaargs); return ret; }
gchar* (g_build_filenamev)(gchar **args) { return stub_funcs.ptr_g_build_filenamev(args); }
gchar* (g_build_filename_valist)(const gchar *first_element, va_list *args) { return stub_funcs.ptr_g_build_filename_valist(first_element, args); }
gboolean (g_path_is_absolute)(const gchar *file_name) { return stub_funcs.ptr_g_path_is_absolute(file_name); }
const gchar* (g_path_skip_root)(const gchar *file_name) { return stub_funcs.ptr_g_path_skip_root(file_name); }
const gchar* (g_basename)(const gchar *file_name) { return stub_funcs.ptr_g_basename(file_name); }
gchar* (g_get_current_dir)(void) { return stub_funcs.ptr_g_get_current_dir(); }
gchar* (g_path_get_basename)(const gchar *file_name) { return stub_funcs.ptr_g_path_get_basename(file_name); }
gchar* (g_path_get_dirname)(const gchar *file_name) { return stub_funcs.ptr_g_path_get_dirname(file_name); }
gchar* (g_canonicalize_filename)(const gchar *filename, const gchar *relative_to) { return stub_funcs.ptr_g_canonicalize_filename(filename, relative_to); }
const gchar* (g_dgettext)(const gchar *domain, const gchar *msgid) { return stub_funcs.ptr_g_dgettext(domain, msgid); }
const gchar* (g_dcgettext)(const gchar *domain, const gchar *msgid, gint category) { return stub_funcs.ptr_g_dcgettext(domain, msgid, category); }
const gchar* (g_dngettext)(const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n) { return stub_funcs.ptr_g_dngettext(domain, msgid, msgid_plural, n); }
const gchar* (g_dpgettext)(const gchar *domain, const gchar *msgctxtid, gsize msgidoffset) { return stub_funcs.ptr_g_dpgettext(domain, msgctxtid, msgidoffset); }
const gchar* (g_dpgettext2)(const gchar *domain, const gchar *context, const gchar *msgid) { return stub_funcs.ptr_g_dpgettext2(domain, context, msgid); }
const gchar* (g_strip_context)(const gchar *msgid, const gchar *msgval) { return stub_funcs.ptr_g_strip_context(msgid, msgval); }
GHashTable* (g_hash_table_new_full)(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func) { return stub_funcs.ptr_g_hash_table_new_full(hash_func, key_equal_func, key_destroy_func, value_destroy_func); }
GHashTable* (g_hash_table_new_similar)(GHashTable *other_hash_table) { return stub_funcs.ptr_g_hash_table_new_similar(other_hash_table); }
void (g_hash_table_destroy)(GHashTable *hash_table) { stub_funcs.ptr_g_hash_table_destroy(hash_table); }
gboolean (g_hash_table_insert)(GHashTable *hash_table, gpointer key, gpointer value) { return stub_funcs.ptr_g_hash_table_insert(hash_table, key, value); }
gboolean (g_hash_table_replace)(GHashTable *hash_table, gpointer key, gpointer value) { return stub_funcs.ptr_g_hash_table_replace(hash_table, key, value); }
gboolean (g_hash_table_add)(GHashTable *hash_table, gpointer key) { return stub_funcs.ptr_g_hash_table_add(hash_table, key); }
gboolean (g_hash_table_remove)(GHashTable *hash_table, gconstpointer key) { return stub_funcs.ptr_g_hash_table_remove(hash_table, key); }
void (g_hash_table_remove_all)(GHashTable *hash_table) { stub_funcs.ptr_g_hash_table_remove_all(hash_table); }
gboolean (g_hash_table_steal)(GHashTable *hash_table, gconstpointer key) { return stub_funcs.ptr_g_hash_table_steal(hash_table, key); }
gboolean (g_hash_table_steal_extended)(GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value) { return stub_funcs.ptr_g_hash_table_steal_extended(hash_table, lookup_key, stolen_key, stolen_value); }
void (g_hash_table_steal_all)(GHashTable *hash_table) { stub_funcs.ptr_g_hash_table_steal_all(hash_table); }
GPtrArray * (g_hash_table_steal_all_keys)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_steal_all_keys(hash_table); }
GPtrArray * (g_hash_table_steal_all_values)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_steal_all_values(hash_table); }
gpointer (g_hash_table_lookup)(GHashTable *hash_table, gconstpointer key) { return stub_funcs.ptr_g_hash_table_lookup(hash_table, key); }
gboolean (g_hash_table_contains)(GHashTable *hash_table, gconstpointer key) { return stub_funcs.ptr_g_hash_table_contains(hash_table, key); }
gboolean (g_hash_table_lookup_extended)(GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value) { return stub_funcs.ptr_g_hash_table_lookup_extended(hash_table, lookup_key, orig_key, value); }
void (g_hash_table_foreach)(GHashTable *hash_table, GHFunc func, gpointer user_data) { stub_funcs.ptr_g_hash_table_foreach(hash_table, func, user_data); }
gpointer (g_hash_table_find)(GHashTable *hash_table, GHRFunc predicate, gpointer user_data) { return stub_funcs.ptr_g_hash_table_find(hash_table, predicate, user_data); }
guint (g_hash_table_foreach_remove)(GHashTable *hash_table, GHRFunc func, gpointer user_data) { return stub_funcs.ptr_g_hash_table_foreach_remove(hash_table, func, user_data); }
guint (g_hash_table_foreach_steal)(GHashTable *hash_table, GHRFunc func, gpointer user_data) { return stub_funcs.ptr_g_hash_table_foreach_steal(hash_table, func, user_data); }
guint (g_hash_table_size)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_size(hash_table); }
GList * (g_hash_table_get_keys)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_get_keys(hash_table); }
GList * (g_hash_table_get_values)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_get_values(hash_table); }
gpointer * (g_hash_table_get_keys_as_array)(GHashTable *hash_table, guint *length) { return stub_funcs.ptr_g_hash_table_get_keys_as_array(hash_table, length); }
GPtrArray * (g_hash_table_get_keys_as_ptr_array)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_get_keys_as_ptr_array(hash_table); }
GPtrArray * (g_hash_table_get_values_as_ptr_array)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_get_values_as_ptr_array(hash_table); }
void (g_hash_table_iter_init)(GHashTableIter *iter, GHashTable *hash_table) { stub_funcs.ptr_g_hash_table_iter_init(iter, hash_table); }
gboolean (g_hash_table_iter_next)(GHashTableIter *iter, gpointer *key, gpointer *value) { return stub_funcs.ptr_g_hash_table_iter_next(iter, key, value); }
GHashTable* (g_hash_table_iter_get_hash_table)(GHashTableIter *iter) { return stub_funcs.ptr_g_hash_table_iter_get_hash_table(iter); }
void (g_hash_table_iter_remove)(GHashTableIter *iter) { stub_funcs.ptr_g_hash_table_iter_remove(iter); }
void (g_hash_table_iter_replace)(GHashTableIter *iter, gpointer value) { stub_funcs.ptr_g_hash_table_iter_replace(iter, value); }
void (g_hash_table_iter_steal)(GHashTableIter *iter) { stub_funcs.ptr_g_hash_table_iter_steal(iter); }
GHashTable* (g_hash_table_ref)(GHashTable *hash_table) { return stub_funcs.ptr_g_hash_table_ref(hash_table); }
void (g_hash_table_unref)(GHashTable *hash_table) { stub_funcs.ptr_g_hash_table_unref(hash_table); }
gboolean (g_str_equal)(gconstpointer v1, gconstpointer v2) { return stub_funcs.ptr_g_str_equal(v1, v2); }
guint (g_str_hash)(gconstpointer v) { return stub_funcs.ptr_g_str_hash(v); }
gboolean (g_int_equal)(gconstpointer v1, gconstpointer v2) { return stub_funcs.ptr_g_int_equal(v1, v2); }
guint (g_int_hash)(gconstpointer v) { return stub_funcs.ptr_g_int_hash(v); }
gboolean (g_int64_equal)(gconstpointer v1, gconstpointer v2) { return stub_funcs.ptr_g_int64_equal(v1, v2); }
guint (g_int64_hash)(gconstpointer v) { return stub_funcs.ptr_g_int64_hash(v); }
gboolean (g_double_equal)(gconstpointer v1, gconstpointer v2) { return stub_funcs.ptr_g_double_equal(v1, v2); }
guint (g_double_hash)(gconstpointer v) { return stub_funcs.ptr_g_double_hash(v); }
guint (g_direct_hash)(gconstpointer v) { return stub_funcs.ptr_g_direct_hash(v); }
gboolean (g_direct_equal)(gconstpointer v1, gconstpointer v2) { return stub_funcs.ptr_g_direct_equal(v1, v2); }
GHashTable* (g_hash_table_new)(GHashFunc hash_func, GEqualFunc key_equal_func) { return stub_funcs.ptr_g_hash_table_new(hash_func, key_equal_func); }
GHmac * (g_hmac_copy)(const GHmac *hmac) { return stub_funcs.ptr_g_hmac_copy(hmac); }
GHmac * (g_hmac_ref)(GHmac *hmac) { return stub_funcs.ptr_g_hmac_ref(hmac); }
void (g_hmac_unref)(GHmac *hmac) { stub_funcs.ptr_g_hmac_unref(hmac); }
void (g_hmac_update)(GHmac *hmac, const guchar *data, gssize length) { stub_funcs.ptr_g_hmac_update(hmac, data, length); }
const gchar * (g_hmac_get_string)(GHmac *hmac) { return stub_funcs.ptr_g_hmac_get_string(hmac); }
void (g_hmac_get_digest)(GHmac *hmac, guint8 *buffer, gsize *digest_len) { stub_funcs.ptr_g_hmac_get_digest(hmac, buffer, digest_len); }
gchar* (g_compute_hmac_for_data)(GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length) { return stub_funcs.ptr_g_compute_hmac_for_data(digest_type, key, key_len, data, length); }
gchar* (g_compute_hmac_for_string)(GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length) { return stub_funcs.ptr_g_compute_hmac_for_string(digest_type, key, key_len, str, length); }
gchar* (g_compute_hmac_for_bytes)(GChecksumType digest_type, GBytes *key, GBytes *data) { return stub_funcs.ptr_g_compute_hmac_for_bytes(digest_type, key, data); }
GHmac * (g_hmac_new)(GChecksumType digest_type, const guchar *key, gsize key_len) { return stub_funcs.ptr_g_hmac_new(digest_type, key, key_len); }
void (g_hook_list_clear)(GHookList *hook_list) { stub_funcs.ptr_g_hook_list_clear(hook_list); }
GHook* (g_hook_alloc)(GHookList *hook_list) { return stub_funcs.ptr_g_hook_alloc(hook_list); }
void (g_hook_free)(GHookList *hook_list, GHook *hook) { stub_funcs.ptr_g_hook_free(hook_list, hook); }
GHook * (g_hook_ref)(GHookList *hook_list, GHook *hook) { return stub_funcs.ptr_g_hook_ref(hook_list, hook); }
void (g_hook_unref)(GHookList *hook_list, GHook *hook) { stub_funcs.ptr_g_hook_unref(hook_list, hook); }
gboolean (g_hook_destroy)(GHookList *hook_list, gulong hook_id) { return stub_funcs.ptr_g_hook_destroy(hook_list, hook_id); }
void (g_hook_destroy_link)(GHookList *hook_list, GHook *hook) { stub_funcs.ptr_g_hook_destroy_link(hook_list, hook); }
void (g_hook_prepend)(GHookList *hook_list, GHook *hook) { stub_funcs.ptr_g_hook_prepend(hook_list, hook); }
void (g_hook_insert_before)(GHookList *hook_list, GHook *sibling, GHook *hook) { stub_funcs.ptr_g_hook_insert_before(hook_list, sibling, hook); }
void (g_hook_insert_sorted)(GHookList *hook_list, GHook *hook, GHookCompareFunc func) { stub_funcs.ptr_g_hook_insert_sorted(hook_list, hook, func); }
GHook* (g_hook_get)(GHookList *hook_list, gulong hook_id) { return stub_funcs.ptr_g_hook_get(hook_list, hook_id); }
GHook* (g_hook_find)(GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data) { return stub_funcs.ptr_g_hook_find(hook_list, need_valids, func, data); }
GHook* (g_hook_find_data)(GHookList *hook_list, gboolean need_valids, gpointer data) { return stub_funcs.ptr_g_hook_find_data(hook_list, need_valids, data); }
GHook* (g_hook_find_func)(GHookList *hook_list, gboolean need_valids, gpointer func) { return stub_funcs.ptr_g_hook_find_func(hook_list, need_valids, func); }
GHook* (g_hook_find_func_data)(GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data) { return stub_funcs.ptr_g_hook_find_func_data(hook_list, need_valids, func, data); }
GHook* (g_hook_first_valid)(GHookList *hook_list, gboolean may_be_in_call) { return stub_funcs.ptr_g_hook_first_valid(hook_list, may_be_in_call); }
GHook* (g_hook_next_valid)(GHookList *hook_list, GHook *hook, gboolean may_be_in_call) { return stub_funcs.ptr_g_hook_next_valid(hook_list, hook, may_be_in_call); }
gint (g_hook_compare_ids)(GHook *new_hook, GHook *sibling) { return stub_funcs.ptr_g_hook_compare_ids(new_hook, sibling); }
void (g_hook_list_invoke)(GHookList *hook_list, gboolean may_recurse) { stub_funcs.ptr_g_hook_list_invoke(hook_list, may_recurse); }
void (g_hook_list_invoke_check)(GHookList *hook_list, gboolean may_recurse) { stub_funcs.ptr_g_hook_list_invoke_check(hook_list, may_recurse); }
void (g_hook_list_marshal)(GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data) { stub_funcs.ptr_g_hook_list_marshal(hook_list, may_recurse, marshaller, marshal_data); }
void (g_hook_list_marshal_check)(GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data) { stub_funcs.ptr_g_hook_list_marshal_check(hook_list, may_recurse, marshaller, marshal_data); }
void (g_hook_list_init)(GHookList *hook_list, guint hook_size) { stub_funcs.ptr_g_hook_list_init(hook_list, hook_size); }
gboolean (g_hostname_is_ascii_encoded)(const gchar *hostname) { return stub_funcs.ptr_g_hostname_is_ascii_encoded(hostname); }
gboolean (g_hostname_is_ip_address)(const gchar *hostname) { return stub_funcs.ptr_g_hostname_is_ip_address(hostname); }
gchar* (g_hostname_to_ascii)(const gchar *hostname) { return stub_funcs.ptr_g_hostname_to_ascii(hostname); }
gchar* (g_hostname_to_unicode)(const gchar *hostname) { return stub_funcs.ptr_g_hostname_to_unicode(hostname); }
gboolean (g_hostname_is_non_ascii)(const gchar *hostname) { return stub_funcs.ptr_g_hostname_is_non_ascii(hostname); }
GIOChannel* (g_io_channel_ref)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_ref(channel); }
void (g_io_channel_unref)(GIOChannel *channel) { stub_funcs.ptr_g_io_channel_unref(channel); }
GIOError (g_io_channel_read)(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read) { return stub_funcs.ptr_g_io_channel_read(channel, buf, count, bytes_read); }
GIOError (g_io_channel_write)(GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written) { return stub_funcs.ptr_g_io_channel_write(channel, buf, count, bytes_written); }
GIOError (g_io_channel_seek)(GIOChannel *channel, gint64 offset, GSeekType type) { return stub_funcs.ptr_g_io_channel_seek(channel, offset, type); }
void (g_io_channel_close)(GIOChannel *channel) { stub_funcs.ptr_g_io_channel_close(channel); }
GIOStatus (g_io_channel_shutdown)(GIOChannel *channel, gboolean flush, GError **err) { return stub_funcs.ptr_g_io_channel_shutdown(channel, flush, err); }
guint (g_io_add_watch_full)(GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify) { return stub_funcs.ptr_g_io_add_watch_full(channel, priority, condition, func, user_data, notify); }
GSource * (g_io_create_watch)(GIOChannel *channel, GIOCondition condition) { return stub_funcs.ptr_g_io_create_watch(channel, condition); }
guint (g_io_add_watch)(GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data) { return stub_funcs.ptr_g_io_add_watch(channel, condition, func, user_data); }
void (g_io_channel_set_buffer_size)(GIOChannel *channel, gsize size) { stub_funcs.ptr_g_io_channel_set_buffer_size(channel, size); }
gsize (g_io_channel_get_buffer_size)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_get_buffer_size(channel); }
GIOCondition (g_io_channel_get_buffer_condition)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_get_buffer_condition(channel); }
GIOStatus (g_io_channel_set_flags)(GIOChannel *channel, GIOFlags flags, GError **error) { return stub_funcs.ptr_g_io_channel_set_flags(channel, flags, error); }
GIOFlags (g_io_channel_get_flags)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_get_flags(channel); }
void (g_io_channel_set_line_term)(GIOChannel *channel, const gchar *line_term, gint length) { stub_funcs.ptr_g_io_channel_set_line_term(channel, line_term, length); }
const gchar * (g_io_channel_get_line_term)(GIOChannel *channel, gint *length) { return stub_funcs.ptr_g_io_channel_get_line_term(channel, length); }
void (g_io_channel_set_buffered)(GIOChannel *channel, gboolean buffered) { stub_funcs.ptr_g_io_channel_set_buffered(channel, buffered); }
gboolean (g_io_channel_get_buffered)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_get_buffered(channel); }
GIOStatus (g_io_channel_set_encoding)(GIOChannel *channel, const gchar *encoding, GError **error) { return stub_funcs.ptr_g_io_channel_set_encoding(channel, encoding, error); }
const gchar * (g_io_channel_get_encoding)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_get_encoding(channel); }
void (g_io_channel_set_close_on_unref)(GIOChannel *channel, gboolean do_close) { stub_funcs.ptr_g_io_channel_set_close_on_unref(channel, do_close); }
gboolean (g_io_channel_get_close_on_unref)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_get_close_on_unref(channel); }
GIOStatus (g_io_channel_flush)(GIOChannel *channel, GError **error) { return stub_funcs.ptr_g_io_channel_flush(channel, error); }
GIOStatus (g_io_channel_read_line)(GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error) { return stub_funcs.ptr_g_io_channel_read_line(channel, str_return, length, terminator_pos, error); }
GIOStatus (g_io_channel_read_line_string)(GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error) { return stub_funcs.ptr_g_io_channel_read_line_string(channel, buffer, terminator_pos, error); }
GIOStatus (g_io_channel_read_to_end)(GIOChannel *channel, gchar **str_return, gsize *length, GError **error) { return stub_funcs.ptr_g_io_channel_read_to_end(channel, str_return, length, error); }
GIOStatus (g_io_channel_read_chars)(GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error) { return stub_funcs.ptr_g_io_channel_read_chars(channel, buf, count, bytes_read, error); }
GIOStatus (g_io_channel_read_unichar)(GIOChannel *channel, gunichar *thechar, GError **error) { return stub_funcs.ptr_g_io_channel_read_unichar(channel, thechar, error); }
GIOStatus (g_io_channel_write_chars)(GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_io_channel_write_chars(channel, buf, count, bytes_written, error); }
GIOStatus (g_io_channel_write_unichar)(GIOChannel *channel, gunichar thechar, GError **error) { return stub_funcs.ptr_g_io_channel_write_unichar(channel, thechar, error); }
GIOStatus (g_io_channel_seek_position)(GIOChannel *channel, gint64 offset, GSeekType type, GError **error) { return stub_funcs.ptr_g_io_channel_seek_position(channel, offset, type, error); }
GIOChannel* (g_io_channel_new_file)(const gchar *filename, const gchar *mode, GError **error) { return stub_funcs.ptr_g_io_channel_new_file(filename, mode, error); }
GQuark (g_io_channel_error_quark)(void) { return stub_funcs.ptr_g_io_channel_error_quark(); }
GIOChannelError (g_io_channel_error_from_errno)(gint en) { return stub_funcs.ptr_g_io_channel_error_from_errno(en); }
GIOChannel* (g_io_channel_unix_new)(int fd) { return stub_funcs.ptr_g_io_channel_unix_new(fd); }
gint (g_io_channel_unix_get_fd)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_unix_get_fd(channel); }
void (g_io_channel_win32_make_pollfd)(GIOChannel *channel, GIOCondition condition, GPollFD *fd) { stub_funcs.ptr_g_io_channel_win32_make_pollfd(channel, condition, fd); }
gint (g_io_channel_win32_poll)(GPollFD *fds, gint n_fds, gint timeout_) { return stub_funcs.ptr_g_io_channel_win32_poll(fds, n_fds, timeout_); }
GIOChannel* (g_io_channel_win32_new_messages)(gsize hwnd) { return stub_funcs.ptr_g_io_channel_win32_new_messages(hwnd); }
GIOChannel* (g_io_channel_win32_new_fd)(gint fd) { return stub_funcs.ptr_g_io_channel_win32_new_fd(fd); }
gint (g_io_channel_win32_get_fd)(GIOChannel *channel) { return stub_funcs.ptr_g_io_channel_win32_get_fd(channel); }
GIOChannel* (g_io_channel_win32_new_socket)(gint socket) { return stub_funcs.ptr_g_io_channel_win32_new_socket(socket); }
GIOChannel* (g_io_channel_win32_new_stream_socket)(gint socket) { return stub_funcs.ptr_g_io_channel_win32_new_stream_socket(socket); }
void (g_io_channel_win32_set_debug)(GIOChannel *channel, gboolean flag) { stub_funcs.ptr_g_io_channel_win32_set_debug(channel, flag); }
void (g_io_channel_init)(GIOChannel *channel) { stub_funcs.ptr_g_io_channel_init(channel); }
GKeyFile* (g_key_file_new)(void) { return stub_funcs.ptr_g_key_file_new(); }
GKeyFile* (g_key_file_ref)(GKeyFile *key_file) { return stub_funcs.ptr_g_key_file_ref(key_file); }
void (g_key_file_unref)(GKeyFile *key_file) { stub_funcs.ptr_g_key_file_unref(key_file); }
void (g_key_file_free)(GKeyFile *key_file) { stub_funcs.ptr_g_key_file_free(key_file); }
void (g_key_file_set_list_separator)(GKeyFile *key_file, gchar separator) { stub_funcs.ptr_g_key_file_set_list_separator(key_file, separator); }
gboolean (g_key_file_load_from_file)(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error) { return stub_funcs.ptr_g_key_file_load_from_file(key_file, file, flags, error); }
gboolean (g_key_file_load_from_data)(GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error) { return stub_funcs.ptr_g_key_file_load_from_data(key_file, data, length, flags, error); }
gboolean (g_key_file_load_from_bytes)(GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error) { return stub_funcs.ptr_g_key_file_load_from_bytes(key_file, bytes, flags, error); }
gboolean (g_key_file_load_from_dirs)(GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error) { return stub_funcs.ptr_g_key_file_load_from_dirs(key_file, file, search_dirs, full_path, flags, error); }
gboolean (g_key_file_load_from_data_dirs)(GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error) { return stub_funcs.ptr_g_key_file_load_from_data_dirs(key_file, file, full_path, flags, error); }
gchar* (g_key_file_to_data)(GKeyFile *key_file, gsize *length, GError **error) { return stub_funcs.ptr_g_key_file_to_data(key_file, length, error); }
gboolean (g_key_file_save_to_file)(GKeyFile *key_file, const gchar *filename, GError **error) { return stub_funcs.ptr_g_key_file_save_to_file(key_file, filename, error); }
gchar* (g_key_file_get_start_group)(GKeyFile *key_file) { return stub_funcs.ptr_g_key_file_get_start_group(key_file); }
gchar** (g_key_file_get_groups)(GKeyFile *key_file, gsize *length) { return stub_funcs.ptr_g_key_file_get_groups(key_file, length); }
gchar** (g_key_file_get_keys)(GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error) { return stub_funcs.ptr_g_key_file_get_keys(key_file, group_name, length, error); }
gboolean (g_key_file_has_group)(GKeyFile *key_file, const gchar *group_name) { return stub_funcs.ptr_g_key_file_has_group(key_file, group_name); }
gboolean (g_key_file_has_key)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_has_key(key_file, group_name, key, error); }
gchar* (g_key_file_get_value)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_value(key_file, group_name, key, error); }
void (g_key_file_set_value)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value) { stub_funcs.ptr_g_key_file_set_value(key_file, group_name, key, value); }
gchar* (g_key_file_get_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_string(key_file, group_name, key, error); }
void (g_key_file_set_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string) { stub_funcs.ptr_g_key_file_set_string(key_file, group_name, key, string); }
gchar* (g_key_file_get_locale_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error) { return stub_funcs.ptr_g_key_file_get_locale_string(key_file, group_name, key, locale, error); }
gchar* (g_key_file_get_locale_for_key)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale) { return stub_funcs.ptr_g_key_file_get_locale_for_key(key_file, group_name, key, locale); }
void (g_key_file_set_locale_string)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string) { stub_funcs.ptr_g_key_file_set_locale_string(key_file, group_name, key, locale, string); }
gboolean (g_key_file_get_boolean)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_boolean(key_file, group_name, key, error); }
void (g_key_file_set_boolean)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value) { stub_funcs.ptr_g_key_file_set_boolean(key_file, group_name, key, value); }
gint (g_key_file_get_integer)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_integer(key_file, group_name, key, error); }
void (g_key_file_set_integer)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value) { stub_funcs.ptr_g_key_file_set_integer(key_file, group_name, key, value); }
gint64 (g_key_file_get_int64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_int64(key_file, group_name, key, error); }
void (g_key_file_set_int64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value) { stub_funcs.ptr_g_key_file_set_int64(key_file, group_name, key, value); }
guint64 (g_key_file_get_uint64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_uint64(key_file, group_name, key, error); }
void (g_key_file_set_uint64)(GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value) { stub_funcs.ptr_g_key_file_set_uint64(key_file, group_name, key, value); }
gdouble (g_key_file_get_double)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_double(key_file, group_name, key, error); }
void (g_key_file_set_double)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value) { stub_funcs.ptr_g_key_file_set_double(key_file, group_name, key, value); }
gchar** (g_key_file_get_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) { return stub_funcs.ptr_g_key_file_get_string_list(key_file, group_name, key, length, error); }
void (g_key_file_set_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar * const list[], gsize length) { stub_funcs.ptr_g_key_file_set_string_list(key_file, group_name, key, list, length); }
gchar** (g_key_file_get_locale_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error) { return stub_funcs.ptr_g_key_file_get_locale_string_list(key_file, group_name, key, locale, length, error); }
void (g_key_file_set_locale_string_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar * const list[], gsize length) { stub_funcs.ptr_g_key_file_set_locale_string_list(key_file, group_name, key, locale, list, length); }
gboolean* (g_key_file_get_boolean_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) { return stub_funcs.ptr_g_key_file_get_boolean_list(key_file, group_name, key, length, error); }
void (g_key_file_set_boolean_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length) { stub_funcs.ptr_g_key_file_set_boolean_list(key_file, group_name, key, list, length); }
gint* (g_key_file_get_integer_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) { return stub_funcs.ptr_g_key_file_get_integer_list(key_file, group_name, key, length, error); }
void (g_key_file_set_double_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length) { stub_funcs.ptr_g_key_file_set_double_list(key_file, group_name, key, list, length); }
gdouble* (g_key_file_get_double_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) { return stub_funcs.ptr_g_key_file_get_double_list(key_file, group_name, key, length, error); }
void (g_key_file_set_integer_list)(GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length) { stub_funcs.ptr_g_key_file_set_integer_list(key_file, group_name, key, list, length); }
gboolean (g_key_file_set_comment)(GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error) { return stub_funcs.ptr_g_key_file_set_comment(key_file, group_name, key, comment, error); }
gchar* (g_key_file_get_comment)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_get_comment(key_file, group_name, key, error); }
gboolean (g_key_file_remove_comment)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_remove_comment(key_file, group_name, key, error); }
gboolean (g_key_file_remove_key)(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) { return stub_funcs.ptr_g_key_file_remove_key(key_file, group_name, key, error); }
gboolean (g_key_file_remove_group)(GKeyFile *key_file, const gchar *group_name, GError **error) { return stub_funcs.ptr_g_key_file_remove_group(key_file, group_name, error); }
GQuark (g_key_file_error_quark)(void) { return stub_funcs.ptr_g_key_file_error_quark(); }
void (g_list_free)(GList *list) { stub_funcs.ptr_g_list_free(list); }
void (g_list_free_1)(GList *list) { stub_funcs.ptr_g_list_free_1(list); }
void (g_list_free_full)(GList *list, GDestroyNotify free_func) { stub_funcs.ptr_g_list_free_full(list, free_func); }
GList* (g_list_append)(GList *list, gpointer data) { return stub_funcs.ptr_g_list_append(list, data); }
GList* (g_list_prepend)(GList *list, gpointer data) { return stub_funcs.ptr_g_list_prepend(list, data); }
GList* (g_list_insert)(GList *list, gpointer data, gint position) { return stub_funcs.ptr_g_list_insert(list, data, position); }
GList* (g_list_insert_sorted)(GList *list, gpointer data, GCompareFunc func) { return stub_funcs.ptr_g_list_insert_sorted(list, data, func); }
GList* (g_list_insert_sorted_with_data)(GList *list, gpointer data, GCompareDataFunc func, gpointer user_data) { return stub_funcs.ptr_g_list_insert_sorted_with_data(list, data, func, user_data); }
GList* (g_list_insert_before)(GList *list, GList *sibling, gpointer data) { return stub_funcs.ptr_g_list_insert_before(list, sibling, data); }
GList* (g_list_insert_before_link)(GList *list, GList *sibling, GList *link_) { return stub_funcs.ptr_g_list_insert_before_link(list, sibling, link_); }
GList* (g_list_concat)(GList *list1, GList *list2) { return stub_funcs.ptr_g_list_concat(list1, list2); }
GList* (g_list_remove)(GList *list, gconstpointer data) { return stub_funcs.ptr_g_list_remove(list, data); }
GList* (g_list_remove_all)(GList *list, gconstpointer data) { return stub_funcs.ptr_g_list_remove_all(list, data); }
GList* (g_list_remove_link)(GList *list, GList *llink) { return stub_funcs.ptr_g_list_remove_link(list, llink); }
GList* (g_list_delete_link)(GList *list, GList *link_) { return stub_funcs.ptr_g_list_delete_link(list, link_); }
GList* (g_list_reverse)(GList *list) { return stub_funcs.ptr_g_list_reverse(list); }
GList* (g_list_copy)(GList *list) { return stub_funcs.ptr_g_list_copy(list); }
GList* (g_list_copy_deep)(GList *list, GCopyFunc func, gpointer user_data) { return stub_funcs.ptr_g_list_copy_deep(list, func, user_data); }
GList* (g_list_nth)(GList *list, guint n) { return stub_funcs.ptr_g_list_nth(list, n); }
GList* (g_list_nth_prev)(GList *list, guint n) { return stub_funcs.ptr_g_list_nth_prev(list, n); }
GList* (g_list_find)(GList *list, gconstpointer data) { return stub_funcs.ptr_g_list_find(list, data); }
GList* (g_list_find_custom)(GList *list, gconstpointer data, GCompareFunc func) { return stub_funcs.ptr_g_list_find_custom(list, data, func); }
gint (g_list_position)(GList *list, GList *llink) { return stub_funcs.ptr_g_list_position(list, llink); }
gint (g_list_index)(GList *list, gconstpointer data) { return stub_funcs.ptr_g_list_index(list, data); }
GList* (g_list_last)(GList *list) { return stub_funcs.ptr_g_list_last(list); }
GList* (g_list_first)(GList *list) { return stub_funcs.ptr_g_list_first(list); }
guint (g_list_length)(GList *list) { return stub_funcs.ptr_g_list_length(list); }
void (g_list_foreach)(GList *list, GFunc func, gpointer user_data) { stub_funcs.ptr_g_list_foreach(list, func, user_data); }
GList* (g_list_sort)(GList *list, GCompareFunc compare_func) { return stub_funcs.ptr_g_list_sort(list, compare_func); }
GList* (g_list_sort_with_data)(GList *list, GCompareDataFunc compare_func, gpointer user_data) { return stub_funcs.ptr_g_list_sort_with_data(list, compare_func, user_data); }
gpointer (g_list_nth_data)(GList *list, guint n) { return stub_funcs.ptr_g_list_nth_data(list, n); }
void (g_clear_list)(GList **list_ptr, GDestroyNotify destroy) { stub_funcs.ptr_g_clear_list(list_ptr, destroy); }
GList* (g_list_alloc)(void) { return stub_funcs.ptr_g_list_alloc(); }
void (g_main_context_unref)(GMainContext *context) { stub_funcs.ptr_g_main_context_unref(context); }
GMainContext* (g_main_context_default)(void) { return stub_funcs.ptr_g_main_context_default(); }
gboolean (g_main_context_iteration)(GMainContext *context, gboolean may_block) { return stub_funcs.ptr_g_main_context_iteration(context, may_block); }
gboolean (g_main_context_pending)(GMainContext *context) { return stub_funcs.ptr_g_main_context_pending(context); }
GSource* (g_main_context_find_source_by_id)(GMainContext *context, guint source_id) { return stub_funcs.ptr_g_main_context_find_source_by_id(context, source_id); }
GSource* (g_main_context_find_source_by_user_data)(GMainContext *context, gpointer user_data) { return stub_funcs.ptr_g_main_context_find_source_by_user_data(context, user_data); }
GSource* (g_main_context_find_source_by_funcs_user_data)(GMainContext *context, GSourceFuncs *funcs, gpointer user_data) { return stub_funcs.ptr_g_main_context_find_source_by_funcs_user_data(context, funcs, user_data); }
void (g_main_context_wakeup)(GMainContext *context) { stub_funcs.ptr_g_main_context_wakeup(context); }
gboolean (g_main_context_acquire)(GMainContext *context) { return stub_funcs.ptr_g_main_context_acquire(context); }
void (g_main_context_release)(GMainContext *context) { stub_funcs.ptr_g_main_context_release(context); }
gboolean (g_main_context_is_owner)(GMainContext *context) { return stub_funcs.ptr_g_main_context_is_owner(context); }
gboolean (g_main_context_wait)(GMainContext *context, GCond *cond, GMutex *mutex) { return stub_funcs.ptr_g_main_context_wait(context, cond, mutex); }
gboolean (g_main_context_prepare)(GMainContext *context, gint *priority) { return stub_funcs.ptr_g_main_context_prepare(context, priority); }
gint (g_main_context_query)(GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds) { return stub_funcs.ptr_g_main_context_query(context, max_priority, timeout_, fds, n_fds); }
gboolean (g_main_context_check)(GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds) { return stub_funcs.ptr_g_main_context_check(context, max_priority, fds, n_fds); }
void (g_main_context_dispatch)(GMainContext *context) { stub_funcs.ptr_g_main_context_dispatch(context); }
void (g_main_context_set_poll_func)(GMainContext *context, GPollFunc func) { stub_funcs.ptr_g_main_context_set_poll_func(context, func); }
GPollFunc (g_main_context_get_poll_func)(GMainContext *context) { return stub_funcs.ptr_g_main_context_get_poll_func(context); }
void (g_main_context_add_poll)(GMainContext *context, GPollFD *fd, gint priority) { stub_funcs.ptr_g_main_context_add_poll(context, fd, priority); }
void (g_main_context_remove_poll)(GMainContext *context, GPollFD *fd) { stub_funcs.ptr_g_main_context_remove_poll(context, fd); }
gint (g_main_depth)(void) { return stub_funcs.ptr_g_main_depth(); }
GSource* (g_main_current_source)(void) { return stub_funcs.ptr_g_main_current_source(); }
void (g_main_context_push_thread_default)(GMainContext *context) { stub_funcs.ptr_g_main_context_push_thread_default(context); }
void (g_main_context_pop_thread_default)(GMainContext *context) { stub_funcs.ptr_g_main_context_pop_thread_default(context); }
GMainContext* (g_main_context_get_thread_default)(void) { return stub_funcs.ptr_g_main_context_get_thread_default(); }
GMainContext* (g_main_context_ref_thread_default)(void) { return stub_funcs.ptr_g_main_context_ref_thread_default(); }
void (g_main_loop_run)(GMainLoop *loop) { stub_funcs.ptr_g_main_loop_run(loop); }
void (g_main_loop_quit)(GMainLoop *loop) { stub_funcs.ptr_g_main_loop_quit(loop); }
GMainLoop* (g_main_loop_ref)(GMainLoop *loop) { return stub_funcs.ptr_g_main_loop_ref(loop); }
void (g_main_loop_unref)(GMainLoop *loop) { stub_funcs.ptr_g_main_loop_unref(loop); }
gboolean (g_main_loop_is_running)(GMainLoop *loop) { return stub_funcs.ptr_g_main_loop_is_running(loop); }
GMainContext* (g_main_loop_get_context)(GMainLoop *loop) { return stub_funcs.ptr_g_main_loop_get_context(loop); }
GSource* (g_source_new)(GSourceFuncs *source_funcs, guint struct_size) { return stub_funcs.ptr_g_source_new(source_funcs, struct_size); }
void (g_source_unref)(GSource *source) { stub_funcs.ptr_g_source_unref(source); }
guint (g_source_attach)(GSource *source, GMainContext *context) { return stub_funcs.ptr_g_source_attach(source, context); }
void (g_source_destroy)(GSource *source) { stub_funcs.ptr_g_source_destroy(source); }
void (g_source_set_priority)(GSource *source, gint priority) { stub_funcs.ptr_g_source_set_priority(source, priority); }
gint (g_source_get_priority)(GSource *source) { return stub_funcs.ptr_g_source_get_priority(source); }
void (g_source_set_can_recurse)(GSource *source, gboolean can_recurse) { stub_funcs.ptr_g_source_set_can_recurse(source, can_recurse); }
gboolean (g_source_get_can_recurse)(GSource *source) { return stub_funcs.ptr_g_source_get_can_recurse(source); }
guint (g_source_get_id)(GSource *source) { return stub_funcs.ptr_g_source_get_id(source); }
GMainContext* (g_source_get_context)(GSource *source) { return stub_funcs.ptr_g_source_get_context(source); }
void (g_source_set_callback)(GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify) { stub_funcs.ptr_g_source_set_callback(source, func, data, notify); }
void (g_source_set_funcs)(GSource *source, GSourceFuncs *funcs) { stub_funcs.ptr_g_source_set_funcs(source, funcs); }
gboolean (g_source_is_destroyed)(GSource *source) { return stub_funcs.ptr_g_source_is_destroyed(source); }
void (g_source_set_name)(GSource *source, const char *name) { stub_funcs.ptr_g_source_set_name(source, name); }
void (g_source_set_static_name)(GSource *source, const char *name) { stub_funcs.ptr_g_source_set_static_name(source, name); }
const char * (g_source_get_name)(GSource *source) { return stub_funcs.ptr_g_source_get_name(source); }
void (g_source_set_name_by_id)(guint tag, const char *name) { stub_funcs.ptr_g_source_set_name_by_id(tag, name); }
void (g_source_set_ready_time)(GSource *source, gint64 ready_time) { stub_funcs.ptr_g_source_set_ready_time(source, ready_time); }
gint64 (g_source_get_ready_time)(GSource *source) { return stub_funcs.ptr_g_source_get_ready_time(source); }
gpointer (g_source_add_unix_fd)(GSource *source, gint fd, GIOCondition events) { return stub_funcs.ptr_g_source_add_unix_fd(source, fd, events); }
void (g_source_modify_unix_fd)(GSource *source, gpointer tag, GIOCondition new_events) { stub_funcs.ptr_g_source_modify_unix_fd(source, tag, new_events); }
void (g_source_remove_unix_fd)(GSource *source, gpointer tag) { stub_funcs.ptr_g_source_remove_unix_fd(source, tag); }
GIOCondition (g_source_query_unix_fd)(GSource *source, gpointer tag) { return stub_funcs.ptr_g_source_query_unix_fd(source, tag); }
void (g_source_set_callback_indirect)(GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs) { stub_funcs.ptr_g_source_set_callback_indirect(source, callback_data, callback_funcs); }
void (g_source_add_poll)(GSource *source, GPollFD *fd) { stub_funcs.ptr_g_source_add_poll(source, fd); }
void (g_source_remove_poll)(GSource *source, GPollFD *fd) { stub_funcs.ptr_g_source_remove_poll(source, fd); }
void (g_source_add_child_source)(GSource *source, GSource *child_source) { stub_funcs.ptr_g_source_add_child_source(source, child_source); }
void (g_source_remove_child_source)(GSource *source, GSource *child_source) { stub_funcs.ptr_g_source_remove_child_source(source, child_source); }
GSource* (g_idle_source_new)(void) { return stub_funcs.ptr_g_idle_source_new(); }
GSource* (g_child_watch_source_new)(GPid pid) { return stub_funcs.ptr_g_child_watch_source_new(pid); }
GSource* (g_timeout_source_new)(guint interval) { return stub_funcs.ptr_g_timeout_source_new(interval); }
GSource* (g_timeout_source_new_seconds)(guint interval) { return stub_funcs.ptr_g_timeout_source_new_seconds(interval); }
gint64 (g_get_real_time)(void) { return stub_funcs.ptr_g_get_real_time(); }
gboolean (g_source_remove)(guint tag) { return stub_funcs.ptr_g_source_remove(tag); }
gboolean (g_source_remove_by_user_data)(gpointer user_data) { return stub_funcs.ptr_g_source_remove_by_user_data(user_data); }
gboolean (g_source_remove_by_funcs_user_data)(GSourceFuncs *funcs, gpointer user_data) { return stub_funcs.ptr_g_source_remove_by_funcs_user_data(funcs, user_data); }
void (g_clear_handle_id)(guint *tag_ptr, GClearHandleFunc clear_func) { stub_funcs.ptr_g_clear_handle_id(tag_ptr, clear_func); }
guint (g_timeout_add_full)(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify) { return stub_funcs.ptr_g_timeout_add_full(priority, interval, function, data, notify); }
guint (g_timeout_add)(guint interval, GSourceFunc function, gpointer data) { return stub_funcs.ptr_g_timeout_add(interval, function, data); }
guint (g_timeout_add_once)(guint interval, GSourceOnceFunc function, gpointer data) { return stub_funcs.ptr_g_timeout_add_once(interval, function, data); }
guint (g_timeout_add_seconds_full)(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify) { return stub_funcs.ptr_g_timeout_add_seconds_full(priority, interval, function, data, notify); }
guint (g_timeout_add_seconds)(guint interval, GSourceFunc function, gpointer data) { return stub_funcs.ptr_g_timeout_add_seconds(interval, function, data); }
guint (g_timeout_add_seconds_once)(guint interval, GSourceOnceFunc function, gpointer data) { return stub_funcs.ptr_g_timeout_add_seconds_once(interval, function, data); }
guint (g_child_watch_add_full)(gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify) { return stub_funcs.ptr_g_child_watch_add_full(priority, pid, function, data, notify); }
guint (g_child_watch_add)(GPid pid, GChildWatchFunc function, gpointer data) { return stub_funcs.ptr_g_child_watch_add(pid, function, data); }
guint (g_idle_add)(GSourceFunc function, gpointer data) { return stub_funcs.ptr_g_idle_add(function, data); }
guint (g_idle_add_full)(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify) { return stub_funcs.ptr_g_idle_add_full(priority, function, data, notify); }
guint (g_idle_add_once)(GSourceOnceFunc function, gpointer data) { return stub_funcs.ptr_g_idle_add_once(function, data); }
gboolean (g_idle_remove_by_data)(gpointer data) { return stub_funcs.ptr_g_idle_remove_by_data(data); }
void (g_main_context_invoke_full)(GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify) { stub_funcs.ptr_g_main_context_invoke_full(context, priority, function, data, notify); }
void (g_main_context_invoke)(GMainContext *context, GSourceFunc function, gpointer data) { stub_funcs.ptr_g_main_context_invoke(context, function, data); }
GMainContext* (g_main_context_new)(void) { return stub_funcs.ptr_g_main_context_new(); }
GMappedFile* (g_mapped_file_new_from_fd)(gint fd, gboolean writable, GError **error) { return stub_funcs.ptr_g_mapped_file_new_from_fd(fd, writable, error); }
gsize (g_mapped_file_get_length)(GMappedFile *file) { return stub_funcs.ptr_g_mapped_file_get_length(file); }
gchar* (g_mapped_file_get_contents)(GMappedFile *file) { return stub_funcs.ptr_g_mapped_file_get_contents(file); }
GBytes * (g_mapped_file_get_bytes)(GMappedFile *file) { return stub_funcs.ptr_g_mapped_file_get_bytes(file); }
GMappedFile* (g_mapped_file_ref)(GMappedFile *file) { return stub_funcs.ptr_g_mapped_file_ref(file); }
void (g_mapped_file_unref)(GMappedFile *file) { stub_funcs.ptr_g_mapped_file_unref(file); }
void (g_mapped_file_free)(GMappedFile *file) { stub_funcs.ptr_g_mapped_file_free(file); }
GMappedFile* (g_mapped_file_new)(const gchar *filename, gboolean writable, GError **error) { return stub_funcs.ptr_g_mapped_file_new(filename, writable, error); }
GMarkupParseContext* (g_markup_parse_context_new)(const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify) { return stub_funcs.ptr_g_markup_parse_context_new(parser, flags, user_data, user_data_dnotify); }
GMarkupParseContext* (g_markup_parse_context_ref)(GMarkupParseContext *context) { return stub_funcs.ptr_g_markup_parse_context_ref(context); }
void (g_markup_parse_context_unref)(GMarkupParseContext *context) { stub_funcs.ptr_g_markup_parse_context_unref(context); }
void (g_markup_parse_context_free)(GMarkupParseContext *context) { stub_funcs.ptr_g_markup_parse_context_free(context); }
gboolean (g_markup_parse_context_parse)(GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error) { return stub_funcs.ptr_g_markup_parse_context_parse(context, text, text_len, error); }
void (g_markup_parse_context_push)(GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data) { stub_funcs.ptr_g_markup_parse_context_push(context, parser, user_data); }
gpointer (g_markup_parse_context_pop)(GMarkupParseContext *context) { return stub_funcs.ptr_g_markup_parse_context_pop(context); }
gboolean (g_markup_parse_context_end_parse)(GMarkupParseContext *context, GError **error) { return stub_funcs.ptr_g_markup_parse_context_end_parse(context, error); }
const gchar * (g_markup_parse_context_get_element)(GMarkupParseContext *context) { return stub_funcs.ptr_g_markup_parse_context_get_element(context); }
const GSList * (g_markup_parse_context_get_element_stack)(GMarkupParseContext *context) { return stub_funcs.ptr_g_markup_parse_context_get_element_stack(context); }
void (g_markup_parse_context_get_position)(GMarkupParseContext *context, gint *line_number, gint *char_number) { stub_funcs.ptr_g_markup_parse_context_get_position(context, line_number, char_number); }
gpointer (g_markup_parse_context_get_user_data)(GMarkupParseContext *context) { return stub_funcs.ptr_g_markup_parse_context_get_user_data(context); }
gchar* (g_markup_escape_text)(const gchar *text, gssize length) { return stub_funcs.ptr_g_markup_escape_text(text, length); }
gchar* (g_markup_printf_escaped)(const char *format, ...) { gchar* ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_markup_vprintf_escaped(format, vaargs); va_end(vaargs); return ret; }
gchar* (g_markup_vprintf_escaped)(const char *format, va_list args) { return stub_funcs.ptr_g_markup_vprintf_escaped(format, args); }
// Unable to locate va_equiv for g_markup_collect_attributes
GQuark (g_markup_error_quark)(void) { return stub_funcs.ptr_g_markup_error_quark(); }
void (g_free_sized)(gpointer mem, size_t size) { stub_funcs.ptr_g_free_sized(mem, size); }
void (g_clear_pointer)(gpointer *pp, GDestroyNotify destroy) { stub_funcs.ptr_g_clear_pointer(pp, destroy); }
gpointer (g_malloc)(gsize n_bytes) { return stub_funcs.ptr_g_malloc(n_bytes); }
gpointer (g_malloc0)(gsize n_bytes) { return stub_funcs.ptr_g_malloc0(n_bytes); }
gpointer (g_realloc)(gpointer mem, gsize n_bytes) { return stub_funcs.ptr_g_realloc(mem, n_bytes); }
gpointer (g_try_malloc)(gsize n_bytes) { return stub_funcs.ptr_g_try_malloc(n_bytes); }
gpointer (g_try_malloc0)(gsize n_bytes) { return stub_funcs.ptr_g_try_malloc0(n_bytes); }
gpointer (g_try_realloc)(gpointer mem, gsize n_bytes) { return stub_funcs.ptr_g_try_realloc(mem, n_bytes); }
gpointer (g_malloc_n)(gsize n_blocks, gsize n_block_bytes) { return stub_funcs.ptr_g_malloc_n(n_blocks, n_block_bytes); }
gpointer (g_malloc0_n)(gsize n_blocks, gsize n_block_bytes) { return stub_funcs.ptr_g_malloc0_n(n_blocks, n_block_bytes); }
gpointer (g_realloc_n)(gpointer mem, gsize n_blocks, gsize n_block_bytes) { return stub_funcs.ptr_g_realloc_n(mem, n_blocks, n_block_bytes); }
gpointer (g_try_malloc_n)(gsize n_blocks, gsize n_block_bytes) { return stub_funcs.ptr_g_try_malloc_n(n_blocks, n_block_bytes); }
gpointer (g_try_malloc0_n)(gsize n_blocks, gsize n_block_bytes) { return stub_funcs.ptr_g_try_malloc0_n(n_blocks, n_block_bytes); }
gpointer (g_try_realloc_n)(gpointer mem, gsize n_blocks, gsize n_block_bytes) { return stub_funcs.ptr_g_try_realloc_n(mem, n_blocks, n_block_bytes); }
gpointer (g_aligned_alloc)(gsize n_blocks, gsize n_block_bytes, gsize alignment) { return stub_funcs.ptr_g_aligned_alloc(n_blocks, n_block_bytes, alignment); }
gpointer (g_aligned_alloc0)(gsize n_blocks, gsize n_block_bytes, gsize alignment) { return stub_funcs.ptr_g_aligned_alloc0(n_blocks, n_block_bytes, alignment); }
void (g_aligned_free)(gpointer mem) { stub_funcs.ptr_g_aligned_free(mem); }
void (g_aligned_free_sized)(gpointer mem, size_t alignment, size_t size) { stub_funcs.ptr_g_aligned_free_sized(mem, alignment, size); }
void (g_mem_set_vtable)(GMemVTable *vtable) { stub_funcs.ptr_g_mem_set_vtable(vtable); }
gboolean (g_mem_is_system_malloc)(void) { return stub_funcs.ptr_g_mem_is_system_malloc(); }
void (g_mem_profile)(void) { stub_funcs.ptr_g_mem_profile(); }
void (g_free)(gpointer mem) { stub_funcs.ptr_g_free(mem); }
guint (g_log_set_handler)(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data) { return stub_funcs.ptr_g_log_set_handler(log_domain, log_levels, log_func, user_data); }
guint (g_log_set_handler_full)(const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy) { return stub_funcs.ptr_g_log_set_handler_full(log_domain, log_levels, log_func, user_data, destroy); }
void (g_log_default_handler)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data) { stub_funcs.ptr_g_log_default_handler(log_domain, log_level, message, unused_data); }
GLogFunc (g_log_set_default_handler)(GLogFunc log_func, gpointer user_data) { return stub_funcs.ptr_g_log_set_default_handler(log_func, user_data); }
void (g_log)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, ...) { va_list vaargs; va_start(vaargs, format); stub_funcs.ptr_g_logv(log_domain, log_level, format, vaargs); va_end(vaargs); }
void (g_logv)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args) { stub_funcs.ptr_g_logv(log_domain, log_level, format, args); }
GLogLevelFlags (g_log_set_fatal_mask)(const gchar *log_domain, GLogLevelFlags fatal_mask) { return stub_funcs.ptr_g_log_set_fatal_mask(log_domain, fatal_mask); }
GLogLevelFlags (g_log_set_always_fatal)(GLogLevelFlags fatal_mask) { return stub_funcs.ptr_g_log_set_always_fatal(fatal_mask); }
// Unable to locate va_equiv for g_log_structured
void (g_log_structured_array)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields) { stub_funcs.ptr_g_log_structured_array(log_level, fields, n_fields); }
void (g_log_variant)(const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields) { stub_funcs.ptr_g_log_variant(log_domain, log_level, fields); }
void (g_log_set_writer_func)(GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free) { stub_funcs.ptr_g_log_set_writer_func(func, user_data, user_data_free); }
gboolean (g_log_writer_supports_color)(gint output_fd) { return stub_funcs.ptr_g_log_writer_supports_color(output_fd); }
gboolean (g_log_writer_is_journald)(gint output_fd) { return stub_funcs.ptr_g_log_writer_is_journald(output_fd); }
gchar* (g_log_writer_format_fields)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color) { return stub_funcs.ptr_g_log_writer_format_fields(log_level, fields, n_fields, use_color); }
GLogWriterOutput (g_log_writer_syslog)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data) { return stub_funcs.ptr_g_log_writer_syslog(log_level, fields, n_fields, user_data); }
GLogWriterOutput (g_log_writer_journald)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data) { return stub_funcs.ptr_g_log_writer_journald(log_level, fields, n_fields, user_data); }
GLogWriterOutput (g_log_writer_standard_streams)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data) { return stub_funcs.ptr_g_log_writer_standard_streams(log_level, fields, n_fields, user_data); }
GLogWriterOutput (g_log_writer_default)(GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data) { return stub_funcs.ptr_g_log_writer_default(log_level, fields, n_fields, user_data); }
void (g_log_writer_default_set_use_stderr)(gboolean use_stderr) { stub_funcs.ptr_g_log_writer_default_set_use_stderr(use_stderr); }
gboolean (g_log_writer_default_would_drop)(GLogLevelFlags log_level, const char *log_domain) { return stub_funcs.ptr_g_log_writer_default_would_drop(log_level, log_domain); }
void (g_log_writer_default_set_debug_domains)(const gchar * const *domains) { stub_funcs.ptr_g_log_writer_default_set_debug_domains(domains); }
gboolean (g_log_get_debug_enabled)(void) { return stub_funcs.ptr_g_log_get_debug_enabled(); }
void (g_log_set_debug_enabled)(gboolean enabled) { stub_funcs.ptr_g_log_set_debug_enabled(enabled); }
void (_g_log_fallback_handler)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data) { stub_funcs.ptr__g_log_fallback_handler(log_domain, log_level, message, unused_data); }
void (g_return_if_fail_warning)(const char *log_domain, const char *pretty_function, const char *expression) { stub_funcs.ptr_g_return_if_fail_warning(log_domain, pretty_function, expression); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_warn_message)(const char *domain, const char *file, int line, const char *func, const char *warnexpr) { stub_funcs.ptr_g_warn_message(domain, file, line, func, warnexpr); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_assert_warning)(const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression) { stub_funcs.ptr_g_assert_warning(log_domain, file, line, pretty_function, expression); __builtin_unreachable(); /* oops rayo cosmico */  }
// Unable to locate va_equiv for g_log_structured_standard
// Unable to locate va_equiv for g_error
// Unable to locate va_equiv for g_critical
// Unable to locate va_equiv for g_print
GPrintFunc (g_set_print_handler)(GPrintFunc func) { return stub_funcs.ptr_g_set_print_handler(func); }
// Unable to locate va_equiv for g_printerr
GPrintFunc (g_set_printerr_handler)(GPrintFunc func) { return stub_funcs.ptr_g_set_printerr_handler(func); }
gsize (g_printf_string_upper_bound)(const gchar* format, va_list args) { return stub_funcs.ptr_g_printf_string_upper_bound(format, args); }
void (g_node_destroy)(GNode *root) { stub_funcs.ptr_g_node_destroy(root); }
void (g_node_unlink)(GNode *node) { stub_funcs.ptr_g_node_unlink(node); }
GNode* (g_node_copy_deep)(GNode *node, GCopyFunc copy_func, gpointer data) { return stub_funcs.ptr_g_node_copy_deep(node, copy_func, data); }
GNode* (g_node_copy)(GNode *node) { return stub_funcs.ptr_g_node_copy(node); }
GNode* (g_node_insert)(GNode *parent, gint position, GNode *node) { return stub_funcs.ptr_g_node_insert(parent, position, node); }
GNode* (g_node_insert_before)(GNode *parent, GNode *sibling, GNode *node) { return stub_funcs.ptr_g_node_insert_before(parent, sibling, node); }
GNode* (g_node_insert_after)(GNode *parent, GNode *sibling, GNode *node) { return stub_funcs.ptr_g_node_insert_after(parent, sibling, node); }
GNode* (g_node_prepend)(GNode *parent, GNode *node) { return stub_funcs.ptr_g_node_prepend(parent, node); }
guint (g_node_n_nodes)(GNode *root, GTraverseFlags flags) { return stub_funcs.ptr_g_node_n_nodes(root, flags); }
GNode* (g_node_get_root)(GNode *node) { return stub_funcs.ptr_g_node_get_root(node); }
gboolean (g_node_is_ancestor)(GNode *node, GNode *descendant) { return stub_funcs.ptr_g_node_is_ancestor(node, descendant); }
guint (g_node_depth)(GNode *node) { return stub_funcs.ptr_g_node_depth(node); }
GNode* (g_node_find)(GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data) { return stub_funcs.ptr_g_node_find(root, order, flags, data); }
void (g_node_traverse)(GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data) { stub_funcs.ptr_g_node_traverse(root, order, flags, max_depth, func, data); }
guint (g_node_max_height)(GNode *root) { return stub_funcs.ptr_g_node_max_height(root); }
void (g_node_children_foreach)(GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data) { stub_funcs.ptr_g_node_children_foreach(node, flags, func, data); }
void (g_node_reverse_children)(GNode *node) { stub_funcs.ptr_g_node_reverse_children(node); }
guint (g_node_n_children)(GNode *node) { return stub_funcs.ptr_g_node_n_children(node); }
GNode* (g_node_nth_child)(GNode *node, guint n) { return stub_funcs.ptr_g_node_nth_child(node, n); }
GNode* (g_node_last_child)(GNode *node) { return stub_funcs.ptr_g_node_last_child(node); }
GNode* (g_node_find_child)(GNode *node, GTraverseFlags flags, gpointer data) { return stub_funcs.ptr_g_node_find_child(node, flags, data); }
gint (g_node_child_position)(GNode *node, GNode *child) { return stub_funcs.ptr_g_node_child_position(node, child); }
gint (g_node_child_index)(GNode *node, gpointer data) { return stub_funcs.ptr_g_node_child_index(node, data); }
GNode* (g_node_first_sibling)(GNode *node) { return stub_funcs.ptr_g_node_first_sibling(node); }
GNode* (g_node_last_sibling)(GNode *node) { return stub_funcs.ptr_g_node_last_sibling(node); }
GNode* (g_node_new)(gpointer data) { return stub_funcs.ptr_g_node_new(data); }
GOptionContext* (g_option_context_new)(const gchar *parameter_string) { return stub_funcs.ptr_g_option_context_new(parameter_string); }
void (g_option_context_set_summary)(GOptionContext *context, const gchar *summary) { stub_funcs.ptr_g_option_context_set_summary(context, summary); }
const gchar * (g_option_context_get_summary)(GOptionContext *context) { return stub_funcs.ptr_g_option_context_get_summary(context); }
void (g_option_context_set_description)(GOptionContext *context, const gchar *description) { stub_funcs.ptr_g_option_context_set_description(context, description); }
const gchar * (g_option_context_get_description)(GOptionContext *context) { return stub_funcs.ptr_g_option_context_get_description(context); }
void (g_option_context_free)(GOptionContext *context) { stub_funcs.ptr_g_option_context_free(context); }
void (g_option_context_set_help_enabled)(GOptionContext *context, gboolean help_enabled) { stub_funcs.ptr_g_option_context_set_help_enabled(context, help_enabled); }
gboolean (g_option_context_get_help_enabled)(GOptionContext *context) { return stub_funcs.ptr_g_option_context_get_help_enabled(context); }
void (g_option_context_set_ignore_unknown_options)(GOptionContext *context, gboolean ignore_unknown) { stub_funcs.ptr_g_option_context_set_ignore_unknown_options(context, ignore_unknown); }
gboolean (g_option_context_get_ignore_unknown_options)(GOptionContext *context) { return stub_funcs.ptr_g_option_context_get_ignore_unknown_options(context); }
void (g_option_context_set_strict_posix)(GOptionContext *context, gboolean strict_posix) { stub_funcs.ptr_g_option_context_set_strict_posix(context, strict_posix); }
gboolean (g_option_context_get_strict_posix)(GOptionContext *context) { return stub_funcs.ptr_g_option_context_get_strict_posix(context); }
void (g_option_context_add_main_entries)(GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain) { stub_funcs.ptr_g_option_context_add_main_entries(context, entries, translation_domain); }
gboolean (g_option_context_parse)(GOptionContext *context, gint *argc, gchar ***argv, GError **error) { return stub_funcs.ptr_g_option_context_parse(context, argc, argv, error); }
gboolean (g_option_context_parse_strv)(GOptionContext *context, gchar ***arguments, GError **error) { return stub_funcs.ptr_g_option_context_parse_strv(context, arguments, error); }
void (g_option_context_set_translate_func)(GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify) { stub_funcs.ptr_g_option_context_set_translate_func(context, func, data, destroy_notify); }
void (g_option_context_set_translation_domain)(GOptionContext *context, const gchar *domain) { stub_funcs.ptr_g_option_context_set_translation_domain(context, domain); }
void (g_option_context_add_group)(GOptionContext *context, GOptionGroup *group) { stub_funcs.ptr_g_option_context_add_group(context, group); }
void (g_option_context_set_main_group)(GOptionContext *context, GOptionGroup *group) { stub_funcs.ptr_g_option_context_set_main_group(context, group); }
GOptionGroup* (g_option_context_get_main_group)(GOptionContext *context) { return stub_funcs.ptr_g_option_context_get_main_group(context); }
gchar* (g_option_context_get_help)(GOptionContext *context, gboolean main_help, GOptionGroup *group) { return stub_funcs.ptr_g_option_context_get_help(context, main_help, group); }
GOptionGroup* (g_option_group_new)(const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy) { return stub_funcs.ptr_g_option_group_new(name, description, help_description, user_data, destroy); }
void (g_option_group_set_parse_hooks)(GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func) { stub_funcs.ptr_g_option_group_set_parse_hooks(group, pre_parse_func, post_parse_func); }
void (g_option_group_set_error_hook)(GOptionGroup *group, GOptionErrorFunc error_func) { stub_funcs.ptr_g_option_group_set_error_hook(group, error_func); }
void (g_option_group_free)(GOptionGroup *group) { stub_funcs.ptr_g_option_group_free(group); }
GOptionGroup* (g_option_group_ref)(GOptionGroup *group) { return stub_funcs.ptr_g_option_group_ref(group); }
void (g_option_group_unref)(GOptionGroup *group) { stub_funcs.ptr_g_option_group_unref(group); }
void (g_option_group_add_entries)(GOptionGroup *group, const GOptionEntry *entries) { stub_funcs.ptr_g_option_group_add_entries(group, entries); }
void (g_option_group_set_translate_func)(GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify) { stub_funcs.ptr_g_option_group_set_translate_func(group, func, data, destroy_notify); }
void (g_option_group_set_translation_domain)(GOptionGroup *group, const gchar *domain) { stub_funcs.ptr_g_option_group_set_translation_domain(group, domain); }
GQuark (g_option_error_quark)(void) { return stub_funcs.ptr_g_option_error_quark(); }
GPathBuf * (g_path_buf_new_from_path)(const char *path) { return stub_funcs.ptr_g_path_buf_new_from_path(path); }
GPathBuf * (g_path_buf_init)(GPathBuf *buf) { return stub_funcs.ptr_g_path_buf_init(buf); }
GPathBuf * (g_path_buf_init_from_path)(GPathBuf *buf, const char *path) { return stub_funcs.ptr_g_path_buf_init_from_path(buf, path); }
void (g_path_buf_clear)(GPathBuf *buf) { stub_funcs.ptr_g_path_buf_clear(buf); }
char * (g_path_buf_clear_to_path)(GPathBuf *buf) { return stub_funcs.ptr_g_path_buf_clear_to_path(buf); }
void (g_path_buf_free)(GPathBuf *buf) { stub_funcs.ptr_g_path_buf_free(buf); }
char * (g_path_buf_free_to_path)(GPathBuf *buf) { return stub_funcs.ptr_g_path_buf_free_to_path(buf); }
GPathBuf * (g_path_buf_copy)(GPathBuf *buf) { return stub_funcs.ptr_g_path_buf_copy(buf); }
GPathBuf * (g_path_buf_push)(GPathBuf *buf, const char *path) { return stub_funcs.ptr_g_path_buf_push(buf, path); }
gboolean (g_path_buf_pop)(GPathBuf *buf) { return stub_funcs.ptr_g_path_buf_pop(buf); }
gboolean (g_path_buf_set_filename)(GPathBuf *buf, const char *file_name) { return stub_funcs.ptr_g_path_buf_set_filename(buf, file_name); }
gboolean (g_path_buf_set_extension)(GPathBuf *buf, const char *extension) { return stub_funcs.ptr_g_path_buf_set_extension(buf, extension); }
char * (g_path_buf_to_path)(GPathBuf *buf) { return stub_funcs.ptr_g_path_buf_to_path(buf); }
gboolean (g_path_buf_equal)(gconstpointer v1, gconstpointer v2) { return stub_funcs.ptr_g_path_buf_equal(v1, v2); }
GPathBuf * (g_path_buf_new)(void) { return stub_funcs.ptr_g_path_buf_new(); }
void (g_pattern_spec_free)(GPatternSpec *pspec) { stub_funcs.ptr_g_pattern_spec_free(pspec); }
GPatternSpec* (g_pattern_spec_copy)(GPatternSpec *pspec) { return stub_funcs.ptr_g_pattern_spec_copy(pspec); }
gboolean (g_pattern_spec_equal)(GPatternSpec *pspec1, GPatternSpec *pspec2) { return stub_funcs.ptr_g_pattern_spec_equal(pspec1, pspec2); }
gboolean (g_pattern_spec_match)(GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed) { return stub_funcs.ptr_g_pattern_spec_match(pspec, string_length, string, string_reversed); }
gboolean (g_pattern_spec_match_string)(GPatternSpec *pspec, const gchar *string) { return stub_funcs.ptr_g_pattern_spec_match_string(pspec, string); }
gboolean (g_pattern_match)(GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed) { return stub_funcs.ptr_g_pattern_match(pspec, string_length, string, string_reversed); }
gboolean (g_pattern_match_string)(GPatternSpec *pspec, const gchar *string) { return stub_funcs.ptr_g_pattern_match_string(pspec, string); }
gboolean (g_pattern_match_simple)(const gchar *pattern, const gchar *string) { return stub_funcs.ptr_g_pattern_match_simple(pattern, string); }
GPatternSpec* (g_pattern_spec_new)(const gchar *pattern) { return stub_funcs.ptr_g_pattern_spec_new(pattern); }
gint (g_poll)(GPollFD *fds, guint nfds, gint timeout) { return stub_funcs.ptr_g_poll(fds, nfds, timeout); }
guint (g_spaced_primes_closest)(guint num) { return stub_funcs.ptr_g_spaced_primes_closest(num); }
gint (g_fprintf)(FILE *file, gchar const *format, ...) { gint ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_vfprintf(file, format, vaargs); va_end(vaargs); return ret; }
gint (g_sprintf)(gchar *string, gchar const *format, ...) { gint ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_vsprintf(string, format, vaargs); va_end(vaargs); return ret; }
gint (g_vprintf)(gchar const *format, va_list args) { return stub_funcs.ptr_g_vprintf(format, args); }
gint (g_vfprintf)(FILE *file, gchar const *format, va_list args) { return stub_funcs.ptr_g_vfprintf(file, format, args); }
gint (g_vsprintf)(gchar *string, gchar const *format, va_list args) { return stub_funcs.ptr_g_vsprintf(string, format, args); }
gint (g_vasprintf)(gchar **string, gchar const *format, va_list args) { return stub_funcs.ptr_g_vasprintf(string, format, args); }
gint (g_printf)(gchar const *format, ...) { gint ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_vprintf(format, vaargs); va_end(vaargs); return ret; }
void (g_qsort_with_data)(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data) { stub_funcs.ptr_g_qsort_with_data(pbase, total_elems, size, compare_func, user_data); }
GQuark (g_quark_from_static_string)(const gchar *string) { return stub_funcs.ptr_g_quark_from_static_string(string); }
GQuark (g_quark_from_string)(const gchar *string) { return stub_funcs.ptr_g_quark_from_string(string); }
const gchar * (g_quark_to_string)(GQuark quark) { return stub_funcs.ptr_g_quark_to_string(quark); }
const gchar * (g_intern_string)(const gchar *string) { return stub_funcs.ptr_g_intern_string(string); }
const gchar * (g_intern_static_string)(const gchar *string) { return stub_funcs.ptr_g_intern_static_string(string); }
GQuark (g_quark_try_string)(const gchar *string) { return stub_funcs.ptr_g_quark_try_string(string); }
void (g_queue_free)(GQueue *queue) { stub_funcs.ptr_g_queue_free(queue); }
void (g_queue_free_full)(GQueue *queue, GDestroyNotify free_func) { stub_funcs.ptr_g_queue_free_full(queue, free_func); }
void (g_queue_init)(GQueue *queue) { stub_funcs.ptr_g_queue_init(queue); }
void (g_queue_clear)(GQueue *queue) { stub_funcs.ptr_g_queue_clear(queue); }
gboolean (g_queue_is_empty)(GQueue *queue) { return stub_funcs.ptr_g_queue_is_empty(queue); }
void (g_queue_clear_full)(GQueue *queue, GDestroyNotify free_func) { stub_funcs.ptr_g_queue_clear_full(queue, free_func); }
guint (g_queue_get_length)(GQueue *queue) { return stub_funcs.ptr_g_queue_get_length(queue); }
void (g_queue_reverse)(GQueue *queue) { stub_funcs.ptr_g_queue_reverse(queue); }
GQueue * (g_queue_copy)(GQueue *queue) { return stub_funcs.ptr_g_queue_copy(queue); }
void (g_queue_foreach)(GQueue *queue, GFunc func, gpointer user_data) { stub_funcs.ptr_g_queue_foreach(queue, func, user_data); }
GList * (g_queue_find)(GQueue *queue, gconstpointer data) { return stub_funcs.ptr_g_queue_find(queue, data); }
GList * (g_queue_find_custom)(GQueue *queue, gconstpointer data, GCompareFunc func) { return stub_funcs.ptr_g_queue_find_custom(queue, data, func); }
void (g_queue_sort)(GQueue *queue, GCompareDataFunc compare_func, gpointer user_data) { stub_funcs.ptr_g_queue_sort(queue, compare_func, user_data); }
void (g_queue_push_head)(GQueue *queue, gpointer data) { stub_funcs.ptr_g_queue_push_head(queue, data); }
void (g_queue_push_tail)(GQueue *queue, gpointer data) { stub_funcs.ptr_g_queue_push_tail(queue, data); }
void (g_queue_push_nth)(GQueue *queue, gpointer data, gint n) { stub_funcs.ptr_g_queue_push_nth(queue, data, n); }
gpointer (g_queue_pop_head)(GQueue *queue) { return stub_funcs.ptr_g_queue_pop_head(queue); }
gpointer (g_queue_pop_tail)(GQueue *queue) { return stub_funcs.ptr_g_queue_pop_tail(queue); }
gpointer (g_queue_pop_nth)(GQueue *queue, guint n) { return stub_funcs.ptr_g_queue_pop_nth(queue, n); }
gpointer (g_queue_peek_head)(GQueue *queue) { return stub_funcs.ptr_g_queue_peek_head(queue); }
gpointer (g_queue_peek_tail)(GQueue *queue) { return stub_funcs.ptr_g_queue_peek_tail(queue); }
gpointer (g_queue_peek_nth)(GQueue *queue, guint n) { return stub_funcs.ptr_g_queue_peek_nth(queue, n); }
gint (g_queue_index)(GQueue *queue, gconstpointer data) { return stub_funcs.ptr_g_queue_index(queue, data); }
gboolean (g_queue_remove)(GQueue *queue, gconstpointer data) { return stub_funcs.ptr_g_queue_remove(queue, data); }
guint (g_queue_remove_all)(GQueue *queue, gconstpointer data) { return stub_funcs.ptr_g_queue_remove_all(queue, data); }
void (g_queue_insert_before)(GQueue *queue, GList *sibling, gpointer data) { stub_funcs.ptr_g_queue_insert_before(queue, sibling, data); }
void (g_queue_insert_before_link)(GQueue *queue, GList *sibling, GList *link_) { stub_funcs.ptr_g_queue_insert_before_link(queue, sibling, link_); }
void (g_queue_insert_after)(GQueue *queue, GList *sibling, gpointer data) { stub_funcs.ptr_g_queue_insert_after(queue, sibling, data); }
void (g_queue_insert_after_link)(GQueue *queue, GList *sibling, GList *link_) { stub_funcs.ptr_g_queue_insert_after_link(queue, sibling, link_); }
void (g_queue_insert_sorted)(GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data) { stub_funcs.ptr_g_queue_insert_sorted(queue, data, func, user_data); }
void (g_queue_push_head_link)(GQueue *queue, GList *link_) { stub_funcs.ptr_g_queue_push_head_link(queue, link_); }
void (g_queue_push_tail_link)(GQueue *queue, GList *link_) { stub_funcs.ptr_g_queue_push_tail_link(queue, link_); }
void (g_queue_push_nth_link)(GQueue *queue, gint n, GList *link_) { stub_funcs.ptr_g_queue_push_nth_link(queue, n, link_); }
GList* (g_queue_pop_head_link)(GQueue *queue) { return stub_funcs.ptr_g_queue_pop_head_link(queue); }
GList* (g_queue_pop_tail_link)(GQueue *queue) { return stub_funcs.ptr_g_queue_pop_tail_link(queue); }
GList* (g_queue_pop_nth_link)(GQueue *queue, guint n) { return stub_funcs.ptr_g_queue_pop_nth_link(queue, n); }
GList* (g_queue_peek_head_link)(GQueue *queue) { return stub_funcs.ptr_g_queue_peek_head_link(queue); }
GList* (g_queue_peek_tail_link)(GQueue *queue) { return stub_funcs.ptr_g_queue_peek_tail_link(queue); }
GList* (g_queue_peek_nth_link)(GQueue *queue, guint n) { return stub_funcs.ptr_g_queue_peek_nth_link(queue, n); }
gint (g_queue_link_index)(GQueue *queue, GList *link_) { return stub_funcs.ptr_g_queue_link_index(queue, link_); }
void (g_queue_unlink)(GQueue *queue, GList *link_) { stub_funcs.ptr_g_queue_unlink(queue, link_); }
void (g_queue_delete_link)(GQueue *queue, GList *link_) { stub_funcs.ptr_g_queue_delete_link(queue, link_); }
GQueue* (g_queue_new)(void) { return stub_funcs.ptr_g_queue_new(); }
GRand* (g_rand_new_with_seed_array)(const guint32 *seed, guint seed_length) { return stub_funcs.ptr_g_rand_new_with_seed_array(seed, seed_length); }
GRand* (g_rand_new)(void) { return stub_funcs.ptr_g_rand_new(); }
void (g_rand_free)(GRand *rand_) { stub_funcs.ptr_g_rand_free(rand_); }
GRand* (g_rand_copy)(GRand *rand_) { return stub_funcs.ptr_g_rand_copy(rand_); }
void (g_rand_set_seed)(GRand *rand_, guint32 seed) { stub_funcs.ptr_g_rand_set_seed(rand_, seed); }
void (g_rand_set_seed_array)(GRand *rand_, const guint32 *seed, guint seed_length) { stub_funcs.ptr_g_rand_set_seed_array(rand_, seed, seed_length); }
guint32 (g_rand_int)(GRand *rand_) { return stub_funcs.ptr_g_rand_int(rand_); }
gint32 (g_rand_int_range)(GRand *rand_, gint32 begin, gint32 end) { return stub_funcs.ptr_g_rand_int_range(rand_, begin, end); }
gdouble (g_rand_double)(GRand *rand_) { return stub_funcs.ptr_g_rand_double(rand_); }
gdouble (g_rand_double_range)(GRand *rand_, gdouble begin, gdouble end) { return stub_funcs.ptr_g_rand_double_range(rand_, begin, end); }
void (g_random_set_seed)(guint32 seed) { stub_funcs.ptr_g_random_set_seed(seed); }
guint32 (g_random_int)(void) { return stub_funcs.ptr_g_random_int(); }
gint32 (g_random_int_range)(gint32 begin, gint32 end) { return stub_funcs.ptr_g_random_int_range(begin, end); }
gdouble (g_random_double)(void) { return stub_funcs.ptr_g_random_double(); }
gdouble (g_random_double_range)(gdouble begin, gdouble end) { return stub_funcs.ptr_g_random_double_range(begin, end); }
GRand* (g_rand_new_with_seed)(guint32 seed) { return stub_funcs.ptr_g_rand_new_with_seed(seed); }
gpointer (g_rc_box_alloc0)(gsize block_size) { return stub_funcs.ptr_g_rc_box_alloc0(block_size); }
gpointer (g_rc_box_dup)(gsize block_size, gconstpointer mem_block) { return stub_funcs.ptr_g_rc_box_dup(block_size, mem_block); }
gpointer (g_rc_box_acquire)(gpointer mem_block) { return stub_funcs.ptr_g_rc_box_acquire(mem_block); }
void (g_rc_box_release)(gpointer mem_block) { stub_funcs.ptr_g_rc_box_release(mem_block); }
void (g_rc_box_release_full)(gpointer mem_block, GDestroyNotify clear_func) { stub_funcs.ptr_g_rc_box_release_full(mem_block, clear_func); }
gsize (g_rc_box_get_size)(gpointer mem_block) { return stub_funcs.ptr_g_rc_box_get_size(mem_block); }
gpointer (g_atomic_rc_box_alloc)(gsize block_size) { return stub_funcs.ptr_g_atomic_rc_box_alloc(block_size); }
gpointer (g_atomic_rc_box_alloc0)(gsize block_size) { return stub_funcs.ptr_g_atomic_rc_box_alloc0(block_size); }
gpointer (g_atomic_rc_box_dup)(gsize block_size, gconstpointer mem_block) { return stub_funcs.ptr_g_atomic_rc_box_dup(block_size, mem_block); }
gpointer (g_atomic_rc_box_acquire)(gpointer mem_block) { return stub_funcs.ptr_g_atomic_rc_box_acquire(mem_block); }
void (g_atomic_rc_box_release)(gpointer mem_block) { stub_funcs.ptr_g_atomic_rc_box_release(mem_block); }
void (g_atomic_rc_box_release_full)(gpointer mem_block, GDestroyNotify clear_func) { stub_funcs.ptr_g_atomic_rc_box_release_full(mem_block, clear_func); }
gsize (g_atomic_rc_box_get_size)(gpointer mem_block) { return stub_funcs.ptr_g_atomic_rc_box_get_size(mem_block); }
gpointer (g_rc_box_alloc)(gsize block_size) { return stub_funcs.ptr_g_rc_box_alloc(block_size); }
void (g_ref_count_inc)(grefcount *rc) { stub_funcs.ptr_g_ref_count_inc(rc); }
gboolean (g_ref_count_dec)(grefcount *rc) { return stub_funcs.ptr_g_ref_count_dec(rc); }
gboolean (g_ref_count_compare)(grefcount *rc, gint val) { return stub_funcs.ptr_g_ref_count_compare(rc, val); }
void (g_atomic_ref_count_init)(gatomicrefcount *arc) { stub_funcs.ptr_g_atomic_ref_count_init(arc); }
void (g_atomic_ref_count_inc)(gatomicrefcount *arc) { stub_funcs.ptr_g_atomic_ref_count_inc(arc); }
gboolean (g_atomic_ref_count_dec)(gatomicrefcount *arc) { return stub_funcs.ptr_g_atomic_ref_count_dec(arc); }
gboolean (g_atomic_ref_count_compare)(gatomicrefcount *arc, gint val) { return stub_funcs.ptr_g_atomic_ref_count_compare(arc, val); }
void (g_ref_count_init)(grefcount *rc) { stub_funcs.ptr_g_ref_count_init(rc); }
char * (g_ref_string_new_len)(const char *str, gssize len) { return stub_funcs.ptr_g_ref_string_new_len(str, len); }
char * (g_ref_string_new_intern)(const char *str) { return stub_funcs.ptr_g_ref_string_new_intern(str); }
char * (g_ref_string_acquire)(char *str) { return stub_funcs.ptr_g_ref_string_acquire(str); }
void (g_ref_string_release)(char *str) { stub_funcs.ptr_g_ref_string_release(str); }
gsize (g_ref_string_length)(char *str) { return stub_funcs.ptr_g_ref_string_length(str); }
char * (g_ref_string_new)(const char *str) { return stub_funcs.ptr_g_ref_string_new(str); }
GRegex* (g_regex_new)(const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error) { return stub_funcs.ptr_g_regex_new(pattern, compile_options, match_options, error); }
GRegex* (g_regex_ref)(GRegex *regex) { return stub_funcs.ptr_g_regex_ref(regex); }
void (g_regex_unref)(GRegex *regex) { stub_funcs.ptr_g_regex_unref(regex); }
const gchar* (g_regex_get_pattern)(const GRegex *regex) { return stub_funcs.ptr_g_regex_get_pattern(regex); }
gint (g_regex_get_max_backref)(const GRegex *regex) { return stub_funcs.ptr_g_regex_get_max_backref(regex); }
gint (g_regex_get_capture_count)(const GRegex *regex) { return stub_funcs.ptr_g_regex_get_capture_count(regex); }
gboolean (g_regex_get_has_cr_or_lf)(const GRegex *regex) { return stub_funcs.ptr_g_regex_get_has_cr_or_lf(regex); }
gint (g_regex_get_max_lookbehind)(const GRegex *regex) { return stub_funcs.ptr_g_regex_get_max_lookbehind(regex); }
gint (g_regex_get_string_number)(const GRegex *regex, const gchar *name) { return stub_funcs.ptr_g_regex_get_string_number(regex, name); }
gchar* (g_regex_escape_string)(const gchar *string, gint length) { return stub_funcs.ptr_g_regex_escape_string(string, length); }
gchar* (g_regex_escape_nul)(const gchar *string, gint length) { return stub_funcs.ptr_g_regex_escape_nul(string, length); }
GRegexCompileFlags (g_regex_get_compile_flags)(const GRegex *regex) { return stub_funcs.ptr_g_regex_get_compile_flags(regex); }
GRegexMatchFlags (g_regex_get_match_flags)(const GRegex *regex) { return stub_funcs.ptr_g_regex_get_match_flags(regex); }
gboolean (g_regex_match_simple)(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options) { return stub_funcs.ptr_g_regex_match_simple(pattern, string, compile_options, match_options); }
gboolean (g_regex_match)(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info) { return stub_funcs.ptr_g_regex_match(regex, string, match_options, match_info); }
gboolean (g_regex_match_full)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error) { return stub_funcs.ptr_g_regex_match_full(regex, string, string_len, start_position, match_options, match_info, error); }
gboolean (g_regex_match_all)(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info) { return stub_funcs.ptr_g_regex_match_all(regex, string, match_options, match_info); }
gboolean (g_regex_match_all_full)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error) { return stub_funcs.ptr_g_regex_match_all_full(regex, string, string_len, start_position, match_options, match_info, error); }
gchar** (g_regex_split_simple)(const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options) { return stub_funcs.ptr_g_regex_split_simple(pattern, string, compile_options, match_options); }
gchar** (g_regex_split)(const GRegex *regex, const gchar *string, GRegexMatchFlags match_options) { return stub_funcs.ptr_g_regex_split(regex, string, match_options); }
gchar** (g_regex_split_full)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error) { return stub_funcs.ptr_g_regex_split_full(regex, string, string_len, start_position, match_options, max_tokens, error); }
gchar* (g_regex_replace)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error) { return stub_funcs.ptr_g_regex_replace(regex, string, string_len, start_position, replacement, match_options, error); }
gchar* (g_regex_replace_literal)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error) { return stub_funcs.ptr_g_regex_replace_literal(regex, string, string_len, start_position, replacement, match_options, error); }
gchar* (g_regex_replace_eval)(const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error) { return stub_funcs.ptr_g_regex_replace_eval(regex, string, string_len, start_position, match_options, eval, user_data, error); }
gboolean (g_regex_check_replacement)(const gchar *replacement, gboolean *has_references, GError **error) { return stub_funcs.ptr_g_regex_check_replacement(replacement, has_references, error); }
GRegex* (g_match_info_get_regex)(const GMatchInfo *match_info) { return stub_funcs.ptr_g_match_info_get_regex(match_info); }
const gchar* (g_match_info_get_string)(const GMatchInfo *match_info) { return stub_funcs.ptr_g_match_info_get_string(match_info); }
GMatchInfo* (g_match_info_ref)(GMatchInfo *match_info) { return stub_funcs.ptr_g_match_info_ref(match_info); }
void (g_match_info_unref)(GMatchInfo *match_info) { stub_funcs.ptr_g_match_info_unref(match_info); }
void (g_match_info_free)(GMatchInfo *match_info) { stub_funcs.ptr_g_match_info_free(match_info); }
gboolean (g_match_info_next)(GMatchInfo *match_info, GError **error) { return stub_funcs.ptr_g_match_info_next(match_info, error); }
gboolean (g_match_info_matches)(const GMatchInfo *match_info) { return stub_funcs.ptr_g_match_info_matches(match_info); }
gint (g_match_info_get_match_count)(const GMatchInfo *match_info) { return stub_funcs.ptr_g_match_info_get_match_count(match_info); }
gboolean (g_match_info_is_partial_match)(const GMatchInfo *match_info) { return stub_funcs.ptr_g_match_info_is_partial_match(match_info); }
gchar* (g_match_info_expand_references)(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error) { return stub_funcs.ptr_g_match_info_expand_references(match_info, string_to_expand, error); }
gchar* (g_match_info_fetch)(const GMatchInfo *match_info, gint match_num) { return stub_funcs.ptr_g_match_info_fetch(match_info, match_num); }
gboolean (g_match_info_fetch_pos)(const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos) { return stub_funcs.ptr_g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos); }
gchar* (g_match_info_fetch_named)(const GMatchInfo *match_info, const gchar *name) { return stub_funcs.ptr_g_match_info_fetch_named(match_info, name); }
gboolean (g_match_info_fetch_named_pos)(const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos) { return stub_funcs.ptr_g_match_info_fetch_named_pos(match_info, name, start_pos, end_pos); }
gchar** (g_match_info_fetch_all)(const GMatchInfo *match_info) { return stub_funcs.ptr_g_match_info_fetch_all(match_info); }
GQuark (g_regex_error_quark)(void) { return stub_funcs.ptr_g_regex_error_quark(); }
void (g_scanner_destroy)(GScanner *scanner) { stub_funcs.ptr_g_scanner_destroy(scanner); }
void (g_scanner_input_file)(GScanner *scanner, gint input_fd) { stub_funcs.ptr_g_scanner_input_file(scanner, input_fd); }
void (g_scanner_sync_file_offset)(GScanner *scanner) { stub_funcs.ptr_g_scanner_sync_file_offset(scanner); }
void (g_scanner_input_text)(GScanner *scanner, const gchar *text, guint text_len) { stub_funcs.ptr_g_scanner_input_text(scanner, text, text_len); }
GTokenType (g_scanner_get_next_token)(GScanner *scanner) { return stub_funcs.ptr_g_scanner_get_next_token(scanner); }
GTokenType (g_scanner_peek_next_token)(GScanner *scanner) { return stub_funcs.ptr_g_scanner_peek_next_token(scanner); }
GTokenType (g_scanner_cur_token)(GScanner *scanner) { return stub_funcs.ptr_g_scanner_cur_token(scanner); }
GTokenValue (g_scanner_cur_value)(GScanner *scanner) { return stub_funcs.ptr_g_scanner_cur_value(scanner); }
guint (g_scanner_cur_line)(GScanner *scanner) { return stub_funcs.ptr_g_scanner_cur_line(scanner); }
guint (g_scanner_cur_position)(GScanner *scanner) { return stub_funcs.ptr_g_scanner_cur_position(scanner); }
gboolean (g_scanner_eof)(GScanner *scanner) { return stub_funcs.ptr_g_scanner_eof(scanner); }
guint (g_scanner_set_scope)(GScanner *scanner, guint scope_id) { return stub_funcs.ptr_g_scanner_set_scope(scanner, scope_id); }
void (g_scanner_scope_add_symbol)(GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value) { stub_funcs.ptr_g_scanner_scope_add_symbol(scanner, scope_id, symbol, value); }
void (g_scanner_scope_remove_symbol)(GScanner *scanner, guint scope_id, const gchar *symbol) { stub_funcs.ptr_g_scanner_scope_remove_symbol(scanner, scope_id, symbol); }
gpointer (g_scanner_scope_lookup_symbol)(GScanner *scanner, guint scope_id, const gchar *symbol) { return stub_funcs.ptr_g_scanner_scope_lookup_symbol(scanner, scope_id, symbol); }
void (g_scanner_scope_foreach_symbol)(GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data) { stub_funcs.ptr_g_scanner_scope_foreach_symbol(scanner, scope_id, func, user_data); }
gpointer (g_scanner_lookup_symbol)(GScanner *scanner, const gchar *symbol) { return stub_funcs.ptr_g_scanner_lookup_symbol(scanner, symbol); }
void (g_scanner_unexp_token)(GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error) { stub_funcs.ptr_g_scanner_unexp_token(scanner, expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error); }
// Unable to locate va_equiv for g_scanner_error
// Unable to locate va_equiv for g_scanner_warn
GScanner* (g_scanner_new)(const GScannerConfig *config_templ) { return stub_funcs.ptr_g_scanner_new(config_templ); }
void (g_sequence_free)(GSequence *seq) { stub_funcs.ptr_g_sequence_free(seq); }
gint (g_sequence_get_length)(GSequence *seq) { return stub_funcs.ptr_g_sequence_get_length(seq); }
void (g_sequence_foreach)(GSequence *seq, GFunc func, gpointer user_data) { stub_funcs.ptr_g_sequence_foreach(seq, func, user_data); }
void (g_sequence_foreach_range)(GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data) { stub_funcs.ptr_g_sequence_foreach_range(begin, end, func, user_data); }
void (g_sequence_sort)(GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data) { stub_funcs.ptr_g_sequence_sort(seq, cmp_func, cmp_data); }
void (g_sequence_sort_iter)(GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data) { stub_funcs.ptr_g_sequence_sort_iter(seq, cmp_func, cmp_data); }
gboolean (g_sequence_is_empty)(GSequence *seq) { return stub_funcs.ptr_g_sequence_is_empty(seq); }
GSequenceIter* (g_sequence_get_begin_iter)(GSequence *seq) { return stub_funcs.ptr_g_sequence_get_begin_iter(seq); }
GSequenceIter* (g_sequence_get_end_iter)(GSequence *seq) { return stub_funcs.ptr_g_sequence_get_end_iter(seq); }
GSequenceIter* (g_sequence_get_iter_at_pos)(GSequence *seq, gint pos) { return stub_funcs.ptr_g_sequence_get_iter_at_pos(seq, pos); }
GSequenceIter* (g_sequence_append)(GSequence *seq, gpointer data) { return stub_funcs.ptr_g_sequence_append(seq, data); }
GSequenceIter* (g_sequence_prepend)(GSequence *seq, gpointer data) { return stub_funcs.ptr_g_sequence_prepend(seq, data); }
GSequenceIter* (g_sequence_insert_before)(GSequenceIter *iter, gpointer data) { return stub_funcs.ptr_g_sequence_insert_before(iter, data); }
void (g_sequence_move)(GSequenceIter *src, GSequenceIter *dest) { stub_funcs.ptr_g_sequence_move(src, dest); }
void (g_sequence_swap)(GSequenceIter *a, GSequenceIter *b) { stub_funcs.ptr_g_sequence_swap(a, b); }
GSequenceIter* (g_sequence_insert_sorted)(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data) { return stub_funcs.ptr_g_sequence_insert_sorted(seq, data, cmp_func, cmp_data); }
GSequenceIter* (g_sequence_insert_sorted_iter)(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data) { return stub_funcs.ptr_g_sequence_insert_sorted_iter(seq, data, iter_cmp, cmp_data); }
void (g_sequence_sort_changed)(GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data) { stub_funcs.ptr_g_sequence_sort_changed(iter, cmp_func, cmp_data); }
void (g_sequence_sort_changed_iter)(GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data) { stub_funcs.ptr_g_sequence_sort_changed_iter(iter, iter_cmp, cmp_data); }
void (g_sequence_remove)(GSequenceIter *iter) { stub_funcs.ptr_g_sequence_remove(iter); }
void (g_sequence_remove_range)(GSequenceIter *begin, GSequenceIter *end) { stub_funcs.ptr_g_sequence_remove_range(begin, end); }
void (g_sequence_move_range)(GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end) { stub_funcs.ptr_g_sequence_move_range(dest, begin, end); }
GSequenceIter* (g_sequence_search)(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data) { return stub_funcs.ptr_g_sequence_search(seq, data, cmp_func, cmp_data); }
GSequenceIter* (g_sequence_search_iter)(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data) { return stub_funcs.ptr_g_sequence_search_iter(seq, data, iter_cmp, cmp_data); }
GSequenceIter* (g_sequence_lookup)(GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data) { return stub_funcs.ptr_g_sequence_lookup(seq, data, cmp_func, cmp_data); }
GSequenceIter* (g_sequence_lookup_iter)(GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data) { return stub_funcs.ptr_g_sequence_lookup_iter(seq, data, iter_cmp, cmp_data); }
gpointer (g_sequence_get)(GSequenceIter *iter) { return stub_funcs.ptr_g_sequence_get(iter); }
void (g_sequence_set)(GSequenceIter *iter, gpointer data) { stub_funcs.ptr_g_sequence_set(iter, data); }
gboolean (g_sequence_iter_is_begin)(GSequenceIter *iter) { return stub_funcs.ptr_g_sequence_iter_is_begin(iter); }
gboolean (g_sequence_iter_is_end)(GSequenceIter *iter) { return stub_funcs.ptr_g_sequence_iter_is_end(iter); }
GSequenceIter* (g_sequence_iter_next)(GSequenceIter *iter) { return stub_funcs.ptr_g_sequence_iter_next(iter); }
GSequenceIter* (g_sequence_iter_prev)(GSequenceIter *iter) { return stub_funcs.ptr_g_sequence_iter_prev(iter); }
gint (g_sequence_iter_get_position)(GSequenceIter *iter) { return stub_funcs.ptr_g_sequence_iter_get_position(iter); }
GSequenceIter* (g_sequence_iter_move)(GSequenceIter *iter, gint delta) { return stub_funcs.ptr_g_sequence_iter_move(iter, delta); }
GSequence * (g_sequence_iter_get_sequence)(GSequenceIter *iter) { return stub_funcs.ptr_g_sequence_iter_get_sequence(iter); }
gint (g_sequence_iter_compare)(GSequenceIter *a, GSequenceIter *b) { return stub_funcs.ptr_g_sequence_iter_compare(a, b); }
GSequenceIter* (g_sequence_range_get_midpoint)(GSequenceIter *begin, GSequenceIter *end) { return stub_funcs.ptr_g_sequence_range_get_midpoint(begin, end); }
GSequence * (g_sequence_new)(GDestroyNotify data_destroy) { return stub_funcs.ptr_g_sequence_new(data_destroy); }
gchar* (g_shell_quote)(const gchar *unquoted_string) { return stub_funcs.ptr_g_shell_quote(unquoted_string); }
gchar* (g_shell_unquote)(const gchar *quoted_string, GError **error) { return stub_funcs.ptr_g_shell_unquote(quoted_string, error); }
gboolean (g_shell_parse_argv)(const gchar *command_line, gint *argcp, gchar ***argvp, GError **error) { return stub_funcs.ptr_g_shell_parse_argv(command_line, argcp, argvp, error); }
GQuark (g_shell_error_quark)(void) { return stub_funcs.ptr_g_shell_error_quark(); }
gpointer (g_slice_alloc0)(gsize block_size) { return stub_funcs.ptr_g_slice_alloc0(block_size); }
gpointer (g_slice_copy)(gsize block_size, gconstpointer mem_block) { return stub_funcs.ptr_g_slice_copy(block_size, mem_block); }
void (g_slice_free1)(gsize block_size, gpointer mem_block) { stub_funcs.ptr_g_slice_free1(block_size, mem_block); }
void (g_slice_free_chain_with_offset)(gsize block_size, gpointer mem_chain, gsize next_offset) { stub_funcs.ptr_g_slice_free_chain_with_offset(block_size, mem_chain, next_offset); }
void (g_slice_set_config)(GSliceConfig ckey, gint64 value) { stub_funcs.ptr_g_slice_set_config(ckey, value); }
gint64 (g_slice_get_config)(GSliceConfig ckey) { return stub_funcs.ptr_g_slice_get_config(ckey); }
void (g_slice_debug_tree_statistics)(void) { stub_funcs.ptr_g_slice_debug_tree_statistics(); }
gpointer (g_slice_alloc)(gsize block_size) { return stub_funcs.ptr_g_slice_alloc(block_size); }
void (g_slist_free)(GSList *list) { stub_funcs.ptr_g_slist_free(list); }
void (g_slist_free_1)(GSList *list) { stub_funcs.ptr_g_slist_free_1(list); }
void (g_slist_free_full)(GSList *list, GDestroyNotify free_func) { stub_funcs.ptr_g_slist_free_full(list, free_func); }
GSList* (g_slist_append)(GSList *list, gpointer data) { return stub_funcs.ptr_g_slist_append(list, data); }
GSList* (g_slist_prepend)(GSList *list, gpointer data) { return stub_funcs.ptr_g_slist_prepend(list, data); }
GSList* (g_slist_insert)(GSList *list, gpointer data, gint position) { return stub_funcs.ptr_g_slist_insert(list, data, position); }
GSList* (g_slist_insert_sorted)(GSList *list, gpointer data, GCompareFunc func) { return stub_funcs.ptr_g_slist_insert_sorted(list, data, func); }
GSList* (g_slist_insert_sorted_with_data)(GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data) { return stub_funcs.ptr_g_slist_insert_sorted_with_data(list, data, func, user_data); }
GSList* (g_slist_insert_before)(GSList *slist, GSList *sibling, gpointer data) { return stub_funcs.ptr_g_slist_insert_before(slist, sibling, data); }
GSList* (g_slist_concat)(GSList *list1, GSList *list2) { return stub_funcs.ptr_g_slist_concat(list1, list2); }
GSList* (g_slist_remove)(GSList *list, gconstpointer data) { return stub_funcs.ptr_g_slist_remove(list, data); }
GSList* (g_slist_remove_all)(GSList *list, gconstpointer data) { return stub_funcs.ptr_g_slist_remove_all(list, data); }
GSList* (g_slist_remove_link)(GSList *list, GSList *link_) { return stub_funcs.ptr_g_slist_remove_link(list, link_); }
GSList* (g_slist_delete_link)(GSList *list, GSList *link_) { return stub_funcs.ptr_g_slist_delete_link(list, link_); }
GSList* (g_slist_reverse)(GSList *list) { return stub_funcs.ptr_g_slist_reverse(list); }
GSList* (g_slist_copy)(GSList *list) { return stub_funcs.ptr_g_slist_copy(list); }
GSList* (g_slist_copy_deep)(GSList *list, GCopyFunc func, gpointer user_data) { return stub_funcs.ptr_g_slist_copy_deep(list, func, user_data); }
GSList* (g_slist_nth)(GSList *list, guint n) { return stub_funcs.ptr_g_slist_nth(list, n); }
GSList* (g_slist_find)(GSList *list, gconstpointer data) { return stub_funcs.ptr_g_slist_find(list, data); }
GSList* (g_slist_find_custom)(GSList *list, gconstpointer data, GCompareFunc func) { return stub_funcs.ptr_g_slist_find_custom(list, data, func); }
gint (g_slist_position)(GSList *list, GSList *llink) { return stub_funcs.ptr_g_slist_position(list, llink); }
gint (g_slist_index)(GSList *list, gconstpointer data) { return stub_funcs.ptr_g_slist_index(list, data); }
GSList* (g_slist_last)(GSList *list) { return stub_funcs.ptr_g_slist_last(list); }
guint (g_slist_length)(GSList *list) { return stub_funcs.ptr_g_slist_length(list); }
void (g_slist_foreach)(GSList *list, GFunc func, gpointer user_data) { stub_funcs.ptr_g_slist_foreach(list, func, user_data); }
GSList* (g_slist_sort)(GSList *list, GCompareFunc compare_func) { return stub_funcs.ptr_g_slist_sort(list, compare_func); }
GSList* (g_slist_sort_with_data)(GSList *list, GCompareDataFunc compare_func, gpointer user_data) { return stub_funcs.ptr_g_slist_sort_with_data(list, compare_func, user_data); }
gpointer (g_slist_nth_data)(GSList *list, guint n) { return stub_funcs.ptr_g_slist_nth_data(list, n); }
void (g_clear_slist)(GSList **slist_ptr, GDestroyNotify destroy) { stub_funcs.ptr_g_clear_slist(slist_ptr, destroy); }
GSList* (g_slist_alloc)(void) { return stub_funcs.ptr_g_slist_alloc(); }
GQuark (g_spawn_exit_error_quark)(void) { return stub_funcs.ptr_g_spawn_exit_error_quark(); }
gboolean (g_spawn_async)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error) { return stub_funcs.ptr_g_spawn_async(working_directory, argv, envp, flags, child_setup, user_data, child_pid, error); }
gboolean (g_spawn_async_with_pipes)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error) { return stub_funcs.ptr_g_spawn_async_with_pipes(working_directory, argv, envp, flags, child_setup, user_data, child_pid, standard_input, standard_output, standard_error, error); }
gboolean (g_spawn_async_with_pipes_and_fds)(const gchar *working_directory, const gchar * const *argv, const gchar * const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error) { return stub_funcs.ptr_g_spawn_async_with_pipes_and_fds(working_directory, argv, envp, flags, child_setup, user_data, stdin_fd, stdout_fd, stderr_fd, source_fds, target_fds, n_fds, child_pid_out, stdin_pipe_out, stdout_pipe_out, stderr_pipe_out, error); }
gboolean (g_spawn_async_with_fds)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error) { return stub_funcs.ptr_g_spawn_async_with_fds(working_directory, argv, envp, flags, child_setup, user_data, child_pid, stdin_fd, stdout_fd, stderr_fd, error); }
gboolean (g_spawn_sync)(const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error) { return stub_funcs.ptr_g_spawn_sync(working_directory, argv, envp, flags, child_setup, user_data, standard_output, standard_error, wait_status, error); }
gboolean (g_spawn_command_line_sync)(const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error) { return stub_funcs.ptr_g_spawn_command_line_sync(command_line, standard_output, standard_error, wait_status, error); }
gboolean (g_spawn_command_line_async)(const gchar *command_line, GError **error) { return stub_funcs.ptr_g_spawn_command_line_async(command_line, error); }
gboolean (g_spawn_check_wait_status)(gint wait_status, GError **error) { return stub_funcs.ptr_g_spawn_check_wait_status(wait_status, error); }
gboolean (g_spawn_check_exit_status)(gint wait_status, GError **error) { return stub_funcs.ptr_g_spawn_check_exit_status(wait_status, error); }
void (g_spawn_close_pid)(GPid pid) { stub_funcs.ptr_g_spawn_close_pid(pid); }
GQuark (g_spawn_error_quark)(void) { return stub_funcs.ptr_g_spawn_error_quark(); }
int (g_chdir)(const gchar *path) { return stub_funcs.ptr_g_chdir(path); }
int (g_unlink)(const gchar *filename) { return stub_funcs.ptr_g_unlink(filename); }
int (g_rmdir)(const gchar *filename) { return stub_funcs.ptr_g_rmdir(filename); }
int (g_access)(const gchar *filename, int mode) { return stub_funcs.ptr_g_access(filename, mode); }
gboolean (g_close)(gint fd, GError **error) { return stub_funcs.ptr_g_close(fd, error); }
gchar (g_ascii_tolower)(gchar c) { return stub_funcs.ptr_g_ascii_tolower(c); }
gchar (g_ascii_toupper)(gchar c) { return stub_funcs.ptr_g_ascii_toupper(c); }
gint (g_ascii_digit_value)(gchar c) { return stub_funcs.ptr_g_ascii_digit_value(c); }
gint (g_ascii_xdigit_value)(gchar c) { return stub_funcs.ptr_g_ascii_xdigit_value(c); }
gchar* (g_strdelimit)(gchar *string, const gchar *delimiters, gchar new_delimiter) { return stub_funcs.ptr_g_strdelimit(string, delimiters, new_delimiter); }
gchar* (g_strcanon)(gchar *string, const gchar *valid_chars, gchar substitutor) { return stub_funcs.ptr_g_strcanon(string, valid_chars, substitutor); }
const gchar * (g_strerror)(gint errnum) { return stub_funcs.ptr_g_strerror(errnum); }
const gchar * (g_strsignal)(gint signum) { return stub_funcs.ptr_g_strsignal(signum); }
gchar * (g_strreverse)(gchar *string) { return stub_funcs.ptr_g_strreverse(string); }
gsize (g_strlcpy)(gchar *dest, const gchar *src, gsize dest_size) { return stub_funcs.ptr_g_strlcpy(dest, src, dest_size); }
gsize (g_strlcat)(gchar *dest, const gchar *src, gsize dest_size) { return stub_funcs.ptr_g_strlcat(dest, src, dest_size); }
gchar * (g_strstr_len)(const gchar *haystack, gssize haystack_len, const gchar *needle) { return stub_funcs.ptr_g_strstr_len(haystack, haystack_len, needle); }
gchar * (g_strrstr)(const gchar *haystack, const gchar *needle) { return stub_funcs.ptr_g_strrstr(haystack, needle); }
gchar * (g_strrstr_len)(const gchar *haystack, gssize haystack_len, const gchar *needle) { return stub_funcs.ptr_g_strrstr_len(haystack, haystack_len, needle); }
gboolean (g_str_has_suffix)(const gchar *str, const gchar *suffix) { return stub_funcs.ptr_g_str_has_suffix(str, suffix); }
gboolean (g_str_has_prefix)(const gchar *str, const gchar *prefix) { return stub_funcs.ptr_g_str_has_prefix(str, prefix); }
gdouble (g_strtod)(const gchar *nptr, gchar **endptr) { return stub_funcs.ptr_g_strtod(nptr, endptr); }
gdouble (g_ascii_strtod)(const gchar *nptr, gchar **endptr) { return stub_funcs.ptr_g_ascii_strtod(nptr, endptr); }
guint64 (g_ascii_strtoull)(const gchar *nptr, gchar **endptr, guint base) { return stub_funcs.ptr_g_ascii_strtoull(nptr, endptr, base); }
gint64 (g_ascii_strtoll)(const gchar *nptr, gchar **endptr, guint base) { return stub_funcs.ptr_g_ascii_strtoll(nptr, endptr, base); }
gchar * (g_ascii_dtostr)(gchar *buffer, gint buf_len, gdouble d) { return stub_funcs.ptr_g_ascii_dtostr(buffer, buf_len, d); }
gchar * (g_ascii_formatd)(gchar *buffer, gint buf_len, const gchar *format, gdouble d) { return stub_funcs.ptr_g_ascii_formatd(buffer, buf_len, format, d); }
gchar* (g_strchug)(gchar *string) { return stub_funcs.ptr_g_strchug(string); }
gchar* (g_strchomp)(gchar *string) { return stub_funcs.ptr_g_strchomp(string); }
gint (g_ascii_strcasecmp)(const gchar *s1, const gchar *s2) { return stub_funcs.ptr_g_ascii_strcasecmp(s1, s2); }
gint (g_ascii_strncasecmp)(const gchar *s1, const gchar *s2, gsize n) { return stub_funcs.ptr_g_ascii_strncasecmp(s1, s2, n); }
gchar* (g_ascii_strdown)(const gchar *str, gssize len) { return stub_funcs.ptr_g_ascii_strdown(str, len); }
gchar* (g_ascii_strup)(const gchar *str, gssize len) { return stub_funcs.ptr_g_ascii_strup(str, len); }
gboolean (g_str_is_ascii)(const gchar *str) { return stub_funcs.ptr_g_str_is_ascii(str); }
gint (g_strcasecmp)(const gchar *s1, const gchar *s2) { return stub_funcs.ptr_g_strcasecmp(s1, s2); }
gint (g_strncasecmp)(const gchar *s1, const gchar *s2, guint n) { return stub_funcs.ptr_g_strncasecmp(s1, s2, n); }
gchar* (g_strdown)(gchar *string) { return stub_funcs.ptr_g_strdown(string); }
gchar* (g_strup)(gchar *string) { return stub_funcs.ptr_g_strup(string); }
gchar* (g_strdup)(const gchar *str) { return stub_funcs.ptr_g_strdup(str); }
gchar* (g_strdup_printf)(const gchar *format, ...) { gchar* ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_strdup_vprintf(format, vaargs); va_end(vaargs); return ret; }
gchar* (g_strdup_vprintf)(const gchar *format, va_list args) { return stub_funcs.ptr_g_strdup_vprintf(format, args); }
gchar* (g_strndup)(const gchar *str, gsize n) { return stub_funcs.ptr_g_strndup(str, n); }
gchar* (g_strnfill)(gsize length, gchar fill_char) { return stub_funcs.ptr_g_strnfill(length, fill_char); }
// Unable to locate va_equiv for g_strconcat
// Found va_equiv for func g_strjoin as func g_strjoinv with pattern g_strjoin[_]*va*$, but err: va_list missing
gchar* (g_strcompress)(const gchar *source) { return stub_funcs.ptr_g_strcompress(source); }
gchar* (g_strescape)(const gchar *source, const gchar *exceptions) { return stub_funcs.ptr_g_strescape(source, exceptions); }
gpointer (g_memdup)(gconstpointer mem, guint byte_size) { return stub_funcs.ptr_g_memdup(mem, byte_size); }
gpointer (g_memdup2)(gconstpointer mem, gsize byte_size) { return stub_funcs.ptr_g_memdup2(mem, byte_size); }
gchar** (g_strsplit)(const gchar *string, const gchar *delimiter, gint max_tokens) { return stub_funcs.ptr_g_strsplit(string, delimiter, max_tokens); }
gchar ** (g_strsplit_set)(const gchar *string, const gchar *delimiters, gint max_tokens) { return stub_funcs.ptr_g_strsplit_set(string, delimiters, max_tokens); }
gchar* (g_strjoinv)(const gchar *separator, gchar **str_array) { return stub_funcs.ptr_g_strjoinv(separator, str_array); }
void (g_strfreev)(gchar **str_array) { stub_funcs.ptr_g_strfreev(str_array); }
gchar** (g_strdupv)(gchar **str_array) { return stub_funcs.ptr_g_strdupv(str_array); }
guint (g_strv_length)(gchar **str_array) { return stub_funcs.ptr_g_strv_length(str_array); }
gchar* (g_stpcpy)(gchar *dest, const char *src) { return stub_funcs.ptr_g_stpcpy(dest, src); }
gchar * (g_str_to_ascii)(const gchar *str, const gchar *from_locale) { return stub_funcs.ptr_g_str_to_ascii(str, from_locale); }
gchar ** (g_str_tokenize_and_fold)(const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates) { return stub_funcs.ptr_g_str_tokenize_and_fold(string, translit_locale, ascii_alternates); }
gboolean (g_str_match_string)(const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates) { return stub_funcs.ptr_g_str_match_string(search_term, potential_hit, accept_alternates); }
gboolean (g_strv_contains)(const gchar * const *strv, const gchar *str) { return stub_funcs.ptr_g_strv_contains(strv, str); }
gboolean (g_strv_equal)(const gchar * const *strv1, const gchar * const *strv2) { return stub_funcs.ptr_g_strv_equal(strv1, strv2); }
GQuark (g_number_parser_error_quark)(void) { return stub_funcs.ptr_g_number_parser_error_quark(); }
gboolean (g_ascii_string_to_signed)(const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error) { return stub_funcs.ptr_g_ascii_string_to_signed(str, base, min, max, out_num, error); }
gboolean (g_ascii_string_to_unsigned)(const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error) { return stub_funcs.ptr_g_ascii_string_to_unsigned(str, base, min, max, out_num, error); }
GString* (g_string_new_take)(gchar *init) { return stub_funcs.ptr_g_string_new_take(init); }
GString* (g_string_new_len)(const gchar *init, gssize len) { return stub_funcs.ptr_g_string_new_len(init, len); }
GString* (g_string_sized_new)(gsize dfl_size) { return stub_funcs.ptr_g_string_sized_new(dfl_size); }
gchar* (g_string_free)(GString *string, gboolean free_segment) { return stub_funcs.ptr_g_string_free(string, free_segment); }
gchar* (g_string_free_and_steal)(GString *string) { return stub_funcs.ptr_g_string_free_and_steal(string); }
GBytes* (g_string_free_to_bytes)(GString *string) { return stub_funcs.ptr_g_string_free_to_bytes(string); }
gboolean (g_string_equal)(const GString *v, const GString *v2) { return stub_funcs.ptr_g_string_equal(v, v2); }
guint (g_string_hash)(const GString *str) { return stub_funcs.ptr_g_string_hash(str); }
GString* (g_string_assign)(GString *string, const gchar *rval) { return stub_funcs.ptr_g_string_assign(string, rval); }
GString* (g_string_truncate)(GString *string, gsize len) { return stub_funcs.ptr_g_string_truncate(string, len); }
GString* (g_string_set_size)(GString *string, gsize len) { return stub_funcs.ptr_g_string_set_size(string, len); }
GString* (g_string_insert_len)(GString *string, gssize pos, const gchar *val, gssize len) { return stub_funcs.ptr_g_string_insert_len(string, pos, val, len); }
GString* (g_string_append)(GString *string, const gchar *val) { return stub_funcs.ptr_g_string_append(string, val); }
GString* (g_string_append_len)(GString *string, const gchar *val, gssize len) { return stub_funcs.ptr_g_string_append_len(string, val, len); }
GString* (g_string_append_c)(GString *string, gchar c) { return stub_funcs.ptr_g_string_append_c(string, c); }
GString* (g_string_append_unichar)(GString *string, gunichar wc) { return stub_funcs.ptr_g_string_append_unichar(string, wc); }
GString* (g_string_prepend)(GString *string, const gchar *val) { return stub_funcs.ptr_g_string_prepend(string, val); }
GString* (g_string_prepend_c)(GString *string, gchar c) { return stub_funcs.ptr_g_string_prepend_c(string, c); }
GString* (g_string_prepend_unichar)(GString *string, gunichar wc) { return stub_funcs.ptr_g_string_prepend_unichar(string, wc); }
GString* (g_string_prepend_len)(GString *string, const gchar *val, gssize len) { return stub_funcs.ptr_g_string_prepend_len(string, val, len); }
GString* (g_string_insert)(GString *string, gssize pos, const gchar *val) { return stub_funcs.ptr_g_string_insert(string, pos, val); }
GString* (g_string_insert_c)(GString *string, gssize pos, gchar c) { return stub_funcs.ptr_g_string_insert_c(string, pos, c); }
GString* (g_string_insert_unichar)(GString *string, gssize pos, gunichar wc) { return stub_funcs.ptr_g_string_insert_unichar(string, pos, wc); }
GString* (g_string_overwrite)(GString *string, gsize pos, const gchar *val) { return stub_funcs.ptr_g_string_overwrite(string, pos, val); }
GString* (g_string_overwrite_len)(GString *string, gsize pos, const gchar *val, gssize len) { return stub_funcs.ptr_g_string_overwrite_len(string, pos, val, len); }
GString* (g_string_erase)(GString *string, gssize pos, gssize len) { return stub_funcs.ptr_g_string_erase(string, pos, len); }
guint (g_string_replace)(GString *string, const gchar *find, const gchar *replace, guint limit) { return stub_funcs.ptr_g_string_replace(string, find, replace, limit); }
GString* (g_string_ascii_down)(GString *string) { return stub_funcs.ptr_g_string_ascii_down(string); }
GString* (g_string_ascii_up)(GString *string) { return stub_funcs.ptr_g_string_ascii_up(string); }
void (g_string_vprintf)(GString *string, const gchar *format, va_list args) { stub_funcs.ptr_g_string_vprintf(string, format, args); }
void (g_string_printf)(GString *string, const gchar *format, ...) { va_list vaargs; va_start(vaargs, format); stub_funcs.ptr_g_string_vprintf(string, format, vaargs); va_end(vaargs); }
void (g_string_append_vprintf)(GString *string, const gchar *format, va_list args) { stub_funcs.ptr_g_string_append_vprintf(string, format, args); }
void (g_string_append_printf)(GString *string, const gchar *format, ...) { va_list vaargs; va_start(vaargs, format); stub_funcs.ptr_g_string_append_vprintf(string, format, vaargs); va_end(vaargs); }
GString* (g_string_append_uri_escaped)(GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8) { return stub_funcs.ptr_g_string_append_uri_escaped(string, unescaped, reserved_chars_allowed, allow_utf8); }
GString* (g_string_down)(GString *string) { return stub_funcs.ptr_g_string_down(string); }
GString* (g_string_up)(GString *string) { return stub_funcs.ptr_g_string_up(string); }
GString* (g_string_new)(const gchar *init) { return stub_funcs.ptr_g_string_new(init); }
void (g_string_chunk_free)(GStringChunk *chunk) { stub_funcs.ptr_g_string_chunk_free(chunk); }
void (g_string_chunk_clear)(GStringChunk *chunk) { stub_funcs.ptr_g_string_chunk_clear(chunk); }
gchar* (g_string_chunk_insert)(GStringChunk *chunk, const gchar *string) { return stub_funcs.ptr_g_string_chunk_insert(chunk, string); }
gchar* (g_string_chunk_insert_len)(GStringChunk *chunk, const gchar *string, gssize len) { return stub_funcs.ptr_g_string_chunk_insert_len(chunk, string, len); }
gchar* (g_string_chunk_insert_const)(GStringChunk *chunk, const gchar *string) { return stub_funcs.ptr_g_string_chunk_insert_const(chunk, string); }
GStringChunk* (g_string_chunk_new)(gsize size) { return stub_funcs.ptr_g_string_chunk_new(size); }
void (g_strv_builder_unref)(GStrvBuilder *builder) { stub_funcs.ptr_g_strv_builder_unref(builder); }
GStrvBuilder* (g_strv_builder_ref)(GStrvBuilder *builder) { return stub_funcs.ptr_g_strv_builder_ref(builder); }
void (g_strv_builder_add)(GStrvBuilder *builder, const char *value) { stub_funcs.ptr_g_strv_builder_add(builder, value); }
void (g_strv_builder_addv)(GStrvBuilder *builder, const char **value) { stub_funcs.ptr_g_strv_builder_addv(builder, value); }
// Unable to locate va_equiv for g_strv_builder_add_many
void (g_strv_builder_take)(GStrvBuilder *builder, char *value) { stub_funcs.ptr_g_strv_builder_take(builder, value); }
GStrv (g_strv_builder_end)(GStrvBuilder *builder) { return stub_funcs.ptr_g_strv_builder_end(builder); }
GStrvBuilder* (g_strv_builder_new)(void) { return stub_funcs.ptr_g_strv_builder_new(); }
// Unable to locate va_equiv for g_test_minimized_result
// Unable to locate va_equiv for g_test_maximized_result
// Unable to locate va_equiv for g_test_init
gboolean (g_test_subprocess)(void) { return stub_funcs.ptr_g_test_subprocess(); }
int (g_test_run)(void) { return stub_funcs.ptr_g_test_run(); }
void (g_test_add_func)(const char *testpath, GTestFunc test_func) { stub_funcs.ptr_g_test_add_func(testpath, test_func); }
void (g_test_add_data_func)(const char *testpath, gconstpointer test_data, GTestDataFunc test_func) { stub_funcs.ptr_g_test_add_data_func(testpath, test_data, test_func); }
void (g_test_add_data_func_full)(const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func) { stub_funcs.ptr_g_test_add_data_func_full(testpath, test_data, test_func, data_free_func); }
const char * (g_test_get_path)(void) { return stub_funcs.ptr_g_test_get_path(); }
void (g_test_fail)(void) { stub_funcs.ptr_g_test_fail(); }
// Unable to locate va_equiv for g_test_fail_printf
void (g_test_incomplete)(const gchar *msg) { stub_funcs.ptr_g_test_incomplete(msg); }
// Unable to locate va_equiv for g_test_incomplete_printf
void (g_test_skip)(const gchar *msg) { stub_funcs.ptr_g_test_skip(msg); }
// Unable to locate va_equiv for g_test_skip_printf
gboolean (g_test_failed)(void) { return stub_funcs.ptr_g_test_failed(); }
void (g_test_set_nonfatal_assertions)(void) { stub_funcs.ptr_g_test_set_nonfatal_assertions(); }
void (g_test_disable_crash_reporting)(void) { stub_funcs.ptr_g_test_disable_crash_reporting(); }
// Unable to locate va_equiv for g_test_message
void (g_test_bug_base)(const char *uri_pattern) { stub_funcs.ptr_g_test_bug_base(uri_pattern); }
void (g_test_bug)(const char *bug_uri_snippet) { stub_funcs.ptr_g_test_bug(bug_uri_snippet); }
void (g_test_summary)(const char *summary) { stub_funcs.ptr_g_test_summary(summary); }
void (g_test_timer_start)(void) { stub_funcs.ptr_g_test_timer_start(); }
double (g_test_timer_elapsed)(void) { return stub_funcs.ptr_g_test_timer_elapsed(); }
double (g_test_timer_last)(void) { return stub_funcs.ptr_g_test_timer_last(); }
void (g_test_queue_free)(gpointer gfree_pointer) { stub_funcs.ptr_g_test_queue_free(gfree_pointer); }
void (g_test_queue_destroy)(GDestroyNotify destroy_func, gpointer destroy_data) { stub_funcs.ptr_g_test_queue_destroy(destroy_func, destroy_data); }
void (g_test_trap_subprocess_with_envp)(const char *test_path, const char * const *envp, guint64 usec_timeout, GTestSubprocessFlags test_flags) { stub_funcs.ptr_g_test_trap_subprocess_with_envp(test_path, envp, usec_timeout, test_flags); }
gboolean (g_test_trap_has_passed)(void) { return stub_funcs.ptr_g_test_trap_has_passed(); }
gboolean (g_test_trap_reached_timeout)(void) { return stub_funcs.ptr_g_test_trap_reached_timeout(); }
gint32 (g_test_rand_int)(void) { return stub_funcs.ptr_g_test_rand_int(); }
gint32 (g_test_rand_int_range)(gint32 begin, gint32 end) { return stub_funcs.ptr_g_test_rand_int_range(begin, end); }
double (g_test_rand_double)(void) { return stub_funcs.ptr_g_test_rand_double(); }
double (g_test_rand_double_range)(double range_start, double range_end) { return stub_funcs.ptr_g_test_rand_double_range(range_start, range_end); }
GTestCase* (g_test_create_case)(const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown) { return stub_funcs.ptr_g_test_create_case(test_name, data_size, test_data, data_setup, data_test, data_teardown); }
GTestSuite* (g_test_create_suite)(const char *suite_name) { return stub_funcs.ptr_g_test_create_suite(suite_name); }
GTestSuite* (g_test_get_root)(void) { return stub_funcs.ptr_g_test_get_root(); }
void (g_test_suite_add)(GTestSuite *suite, GTestCase *test_case) { stub_funcs.ptr_g_test_suite_add(suite, test_case); }
void (g_test_suite_add_suite)(GTestSuite *suite, GTestSuite *nestedsuite) { stub_funcs.ptr_g_test_suite_add_suite(suite, nestedsuite); }
int (g_test_run_suite)(GTestSuite *suite) { return stub_funcs.ptr_g_test_run_suite(suite); }
void (g_test_case_free)(GTestCase *test_case) { stub_funcs.ptr_g_test_case_free(test_case); }
void (g_test_suite_free)(GTestSuite *suite) { stub_funcs.ptr_g_test_suite_free(suite); }
void (g_test_trap_assertions)(const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern) { stub_funcs.ptr_g_test_trap_assertions(domain, file, line, func, assertion_flags, pattern); }
void (g_assertion_message)(const char *domain, const char *file, int line, const char *func, const char *message) { stub_funcs.ptr_g_assertion_message(domain, file, line, func, message); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_assertion_message_expr)(const char *domain, const char *file, int line, const char *func, const char *expr) { stub_funcs.ptr_g_assertion_message_expr(domain, file, line, func, expr); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_assertion_message_cmpstr)(const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2) { stub_funcs.ptr_g_assertion_message_cmpstr(domain, file, line, func, expr, arg1, cmp, arg2); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_assertion_message_cmpstrv)(const char *domain, const char *file, int line, const char *func, const char *expr, const char * const *arg1, const char * const *arg2, gsize first_wrong_idx) { stub_funcs.ptr_g_assertion_message_cmpstrv(domain, file, line, func, expr, arg1, arg2, first_wrong_idx); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_assertion_message_cmpint)(const char *domain, const char *file, int line, const char *func, const char *expr, guint64 arg1, const char *cmp, guint64 arg2, char numtype) { stub_funcs.ptr_g_assertion_message_cmpint(domain, file, line, func, expr, arg1, cmp, arg2, numtype); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_assertion_message_cmpnum)(const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype) { stub_funcs.ptr_g_assertion_message_cmpnum(domain, file, line, func, expr, arg1, cmp, arg2, numtype); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_assertion_message_error)(const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code) { stub_funcs.ptr_g_assertion_message_error(domain, file, line, func, expr, error, error_domain, error_code); __builtin_unreachable(); /* oops rayo cosmico */  }
void (g_test_add_vtable)(const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown) { stub_funcs.ptr_g_test_add_vtable(testpath, data_size, test_data, data_setup, data_test, data_teardown); }
const char* (g_test_log_type_name)(GTestLogType log_type) { return stub_funcs.ptr_g_test_log_type_name(log_type); }
GTestLogBuffer* (g_test_log_buffer_new)(void) { return stub_funcs.ptr_g_test_log_buffer_new(); }
void (g_test_log_buffer_free)(GTestLogBuffer *tbuffer) { stub_funcs.ptr_g_test_log_buffer_free(tbuffer); }
void (g_test_log_buffer_push)(GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes) { stub_funcs.ptr_g_test_log_buffer_push(tbuffer, n_bytes, bytes); }
GTestLogMsg* (g_test_log_buffer_pop)(GTestLogBuffer *tbuffer) { return stub_funcs.ptr_g_test_log_buffer_pop(tbuffer); }
void (g_test_log_msg_free)(GTestLogMsg *tmsg) { stub_funcs.ptr_g_test_log_msg_free(tmsg); }
void (g_test_log_set_fatal_handler)(GTestLogFatalFunc log_func, gpointer user_data) { stub_funcs.ptr_g_test_log_set_fatal_handler(log_func, user_data); }
void (g_test_expect_message)(const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern) { stub_funcs.ptr_g_test_expect_message(log_domain, log_level, pattern); }
void (g_test_assert_expected_messages_internal)(const char *domain, const char *file, int line, const char *func) { stub_funcs.ptr_g_test_assert_expected_messages_internal(domain, file, line, func); }
// Unable to locate va_equiv for g_test_build_filename
const gchar* (g_test_get_dir)(GTestFileType file_type) { return stub_funcs.ptr_g_test_get_dir(file_type); }
// Unable to locate va_equiv for g_test_get_filename
int (g_strcmp0)(const char *str1, const char *str2) { return stub_funcs.ptr_g_strcmp0(str1, str2); }
GThread * (g_thread_ref)(GThread *thread) { return stub_funcs.ptr_g_thread_ref(thread); }
void (g_thread_unref)(GThread *thread) { stub_funcs.ptr_g_thread_unref(thread); }
GThread * (g_thread_new)(const gchar *name, GThreadFunc func, gpointer data) { return stub_funcs.ptr_g_thread_new(name, func, data); }
GThread * (g_thread_try_new)(const gchar *name, GThreadFunc func, gpointer data, GError **error) { return stub_funcs.ptr_g_thread_try_new(name, func, data, error); }
GThread * (g_thread_self)(void) { return stub_funcs.ptr_g_thread_self(); }
void (g_thread_exit)(gpointer retval) { stub_funcs.ptr_g_thread_exit(retval); __builtin_unreachable(); /* oops rayo cosmico */  }
gpointer (g_thread_join)(GThread *thread) { return stub_funcs.ptr_g_thread_join(thread); }
void (g_thread_yield)(void) { stub_funcs.ptr_g_thread_yield(); }
void (g_mutex_init)(GMutex *mutex) { stub_funcs.ptr_g_mutex_init(mutex); }
void (g_mutex_clear)(GMutex *mutex) { stub_funcs.ptr_g_mutex_clear(mutex); }
void (g_mutex_lock)(GMutex *mutex) { stub_funcs.ptr_g_mutex_lock(mutex); }
gboolean (g_mutex_trylock)(GMutex *mutex) { return stub_funcs.ptr_g_mutex_trylock(mutex); }
void (g_mutex_unlock)(GMutex *mutex) { stub_funcs.ptr_g_mutex_unlock(mutex); }
void (g_rw_lock_init)(GRWLock *rw_lock) { stub_funcs.ptr_g_rw_lock_init(rw_lock); }
void (g_rw_lock_clear)(GRWLock *rw_lock) { stub_funcs.ptr_g_rw_lock_clear(rw_lock); }
void (g_rw_lock_writer_lock)(GRWLock *rw_lock) { stub_funcs.ptr_g_rw_lock_writer_lock(rw_lock); }
gboolean (g_rw_lock_writer_trylock)(GRWLock *rw_lock) { return stub_funcs.ptr_g_rw_lock_writer_trylock(rw_lock); }
void (g_rw_lock_writer_unlock)(GRWLock *rw_lock) { stub_funcs.ptr_g_rw_lock_writer_unlock(rw_lock); }
void (g_rw_lock_reader_lock)(GRWLock *rw_lock) { stub_funcs.ptr_g_rw_lock_reader_lock(rw_lock); }
gboolean (g_rw_lock_reader_trylock)(GRWLock *rw_lock) { return stub_funcs.ptr_g_rw_lock_reader_trylock(rw_lock); }
void (g_rw_lock_reader_unlock)(GRWLock *rw_lock) { stub_funcs.ptr_g_rw_lock_reader_unlock(rw_lock); }
void (g_rec_mutex_init)(GRecMutex *rec_mutex) { stub_funcs.ptr_g_rec_mutex_init(rec_mutex); }
void (g_rec_mutex_clear)(GRecMutex *rec_mutex) { stub_funcs.ptr_g_rec_mutex_clear(rec_mutex); }
void (g_rec_mutex_lock)(GRecMutex *rec_mutex) { stub_funcs.ptr_g_rec_mutex_lock(rec_mutex); }
gboolean (g_rec_mutex_trylock)(GRecMutex *rec_mutex) { return stub_funcs.ptr_g_rec_mutex_trylock(rec_mutex); }
void (g_rec_mutex_unlock)(GRecMutex *rec_mutex) { stub_funcs.ptr_g_rec_mutex_unlock(rec_mutex); }
void (g_cond_init)(GCond *cond) { stub_funcs.ptr_g_cond_init(cond); }
void (g_cond_clear)(GCond *cond) { stub_funcs.ptr_g_cond_clear(cond); }
void (g_cond_wait)(GCond *cond, GMutex *mutex) { stub_funcs.ptr_g_cond_wait(cond, mutex); }
void (g_cond_signal)(GCond *cond) { stub_funcs.ptr_g_cond_signal(cond); }
void (g_cond_broadcast)(GCond *cond) { stub_funcs.ptr_g_cond_broadcast(cond); }
gboolean (g_cond_wait_until)(GCond *cond, GMutex *mutex, gint64 end_time) { return stub_funcs.ptr_g_cond_wait_until(cond, mutex, end_time); }
gpointer (g_private_get)(GPrivate *key) { return stub_funcs.ptr_g_private_get(key); }
void (g_private_set)(GPrivate *key, gpointer value) { stub_funcs.ptr_g_private_set(key, value); }
void (g_private_replace)(GPrivate *key, gpointer value) { stub_funcs.ptr_g_private_replace(key, value); }
gpointer (g_once_impl)(GOnce *once, GThreadFunc func, gpointer arg) { return stub_funcs.ptr_g_once_impl(once, func, arg); }
gboolean (g_once_init_enter)(volatile void *location) { return stub_funcs.ptr_g_once_init_enter(location); }
void (g_once_init_leave)(volatile void *location, gsize result) { stub_funcs.ptr_g_once_init_leave(location, result); }
gboolean (g_once_init_enter_pointer)(void *location) { return stub_funcs.ptr_g_once_init_enter_pointer(location); }
void (g_once_init_leave_pointer)(void *location, gpointer result) { stub_funcs.ptr_g_once_init_leave_pointer(location, result); }
guint (g_get_num_processors)(void) { return stub_funcs.ptr_g_get_num_processors(); }
GQuark (g_thread_error_quark)(void) { return stub_funcs.ptr_g_thread_error_quark(); }
GThreadPool * (g_thread_pool_new_full)(GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error) { return stub_funcs.ptr_g_thread_pool_new_full(func, user_data, item_free_func, max_threads, exclusive, error); }
void (g_thread_pool_free)(GThreadPool *pool, gboolean immediate, gboolean wait_) { stub_funcs.ptr_g_thread_pool_free(pool, immediate, wait_); }
gboolean (g_thread_pool_push)(GThreadPool *pool, gpointer data, GError **error) { return stub_funcs.ptr_g_thread_pool_push(pool, data, error); }
guint (g_thread_pool_unprocessed)(GThreadPool *pool) { return stub_funcs.ptr_g_thread_pool_unprocessed(pool); }
void (g_thread_pool_set_sort_function)(GThreadPool *pool, GCompareDataFunc func, gpointer user_data) { stub_funcs.ptr_g_thread_pool_set_sort_function(pool, func, user_data); }
gboolean (g_thread_pool_move_to_front)(GThreadPool *pool, gpointer data) { return stub_funcs.ptr_g_thread_pool_move_to_front(pool, data); }
gboolean (g_thread_pool_set_max_threads)(GThreadPool *pool, gint max_threads, GError **error) { return stub_funcs.ptr_g_thread_pool_set_max_threads(pool, max_threads, error); }
gint (g_thread_pool_get_max_threads)(GThreadPool *pool) { return stub_funcs.ptr_g_thread_pool_get_max_threads(pool); }
guint (g_thread_pool_get_num_threads)(GThreadPool *pool) { return stub_funcs.ptr_g_thread_pool_get_num_threads(pool); }
void (g_thread_pool_set_max_unused_threads)(gint max_threads) { stub_funcs.ptr_g_thread_pool_set_max_unused_threads(max_threads); }
gint (g_thread_pool_get_max_unused_threads)(void) { return stub_funcs.ptr_g_thread_pool_get_max_unused_threads(); }
guint (g_thread_pool_get_num_unused_threads)(void) { return stub_funcs.ptr_g_thread_pool_get_num_unused_threads(); }
void (g_thread_pool_stop_unused_threads)(void) { stub_funcs.ptr_g_thread_pool_stop_unused_threads(); }
void (g_thread_pool_set_max_idle_time)(guint interval) { stub_funcs.ptr_g_thread_pool_set_max_idle_time(interval); }
guint (g_thread_pool_get_max_idle_time)(void) { return stub_funcs.ptr_g_thread_pool_get_max_idle_time(); }
GThreadPool * (g_thread_pool_new)(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error) { return stub_funcs.ptr_g_thread_pool_new(func, user_data, max_threads, exclusive, error); }
void (g_timer_destroy)(GTimer *timer) { stub_funcs.ptr_g_timer_destroy(timer); }
void (g_timer_start)(GTimer *timer) { stub_funcs.ptr_g_timer_start(timer); }
void (g_timer_stop)(GTimer *timer) { stub_funcs.ptr_g_timer_stop(timer); }
void (g_timer_reset)(GTimer *timer) { stub_funcs.ptr_g_timer_reset(timer); }
void (g_timer_continue)(GTimer *timer) { stub_funcs.ptr_g_timer_continue(timer); }
gdouble (g_timer_elapsed)(GTimer *timer, gulong *microseconds) { return stub_funcs.ptr_g_timer_elapsed(timer, microseconds); }
gboolean (g_timer_is_active)(GTimer *timer) { return stub_funcs.ptr_g_timer_is_active(timer); }
void (g_usleep)(gulong microseconds) { stub_funcs.ptr_g_usleep(microseconds); }
gboolean (g_time_val_from_iso8601)(const gchar *iso_date, GTimeVal *time_) { return stub_funcs.ptr_g_time_val_from_iso8601(iso_date, time_); }
gchar* (g_time_val_to_iso8601)(GTimeVal *time_) { return stub_funcs.ptr_g_time_val_to_iso8601(time_); }
GTimer* (g_timer_new)(void) { return stub_funcs.ptr_g_timer_new(); }
GTimeZone * (g_time_zone_new_identifier)(const gchar *identifier) { return stub_funcs.ptr_g_time_zone_new_identifier(identifier); }
GTimeZone * (g_time_zone_new_utc)(void) { return stub_funcs.ptr_g_time_zone_new_utc(); }
GTimeZone * (g_time_zone_new_local)(void) { return stub_funcs.ptr_g_time_zone_new_local(); }
GTimeZone * (g_time_zone_new_offset)(gint32 seconds) { return stub_funcs.ptr_g_time_zone_new_offset(seconds); }
GTimeZone * (g_time_zone_ref)(GTimeZone *tz) { return stub_funcs.ptr_g_time_zone_ref(tz); }
void (g_time_zone_unref)(GTimeZone *tz) { stub_funcs.ptr_g_time_zone_unref(tz); }
gint (g_time_zone_find_interval)(GTimeZone *tz, GTimeType type, gint64 time_) { return stub_funcs.ptr_g_time_zone_find_interval(tz, type, time_); }
gint (g_time_zone_adjust_time)(GTimeZone *tz, GTimeType type, gint64 *time_) { return stub_funcs.ptr_g_time_zone_adjust_time(tz, type, time_); }
const gchar * (g_time_zone_get_abbreviation)(GTimeZone *tz, gint interval) { return stub_funcs.ptr_g_time_zone_get_abbreviation(tz, interval); }
gint32 (g_time_zone_get_offset)(GTimeZone *tz, gint interval) { return stub_funcs.ptr_g_time_zone_get_offset(tz, interval); }
gboolean (g_time_zone_is_dst)(GTimeZone *tz, gint interval) { return stub_funcs.ptr_g_time_zone_is_dst(tz, interval); }
const gchar * (g_time_zone_get_identifier)(GTimeZone *tz) { return stub_funcs.ptr_g_time_zone_get_identifier(tz); }
GTimeZone * (g_time_zone_new)(const gchar *identifier) { return stub_funcs.ptr_g_time_zone_new(identifier); }
gpointer (g_trash_stack_pop)(GTrashStack **stack_p) { return stub_funcs.ptr_g_trash_stack_pop(stack_p); }
gpointer (g_trash_stack_peek)(GTrashStack **stack_p) { return stub_funcs.ptr_g_trash_stack_peek(stack_p); }
guint (g_trash_stack_height)(GTrashStack **stack_p) { return stub_funcs.ptr_g_trash_stack_height(stack_p); }
GTree* (g_tree_new_with_data)(GCompareDataFunc key_compare_func, gpointer key_compare_data) { return stub_funcs.ptr_g_tree_new_with_data(key_compare_func, key_compare_data); }
GTree* (g_tree_new_full)(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func) { return stub_funcs.ptr_g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func, value_destroy_func); }
GTreeNode* (g_tree_node_first)(GTree *tree) { return stub_funcs.ptr_g_tree_node_first(tree); }
GTreeNode* (g_tree_node_last)(GTree *tree) { return stub_funcs.ptr_g_tree_node_last(tree); }
GTreeNode* (g_tree_node_previous)(GTreeNode *node) { return stub_funcs.ptr_g_tree_node_previous(node); }
GTreeNode* (g_tree_node_next)(GTreeNode *node) { return stub_funcs.ptr_g_tree_node_next(node); }
GTree* (g_tree_ref)(GTree *tree) { return stub_funcs.ptr_g_tree_ref(tree); }
void (g_tree_unref)(GTree *tree) { stub_funcs.ptr_g_tree_unref(tree); }
void (g_tree_destroy)(GTree *tree) { stub_funcs.ptr_g_tree_destroy(tree); }
GTreeNode* (g_tree_insert_node)(GTree *tree, gpointer key, gpointer value) { return stub_funcs.ptr_g_tree_insert_node(tree, key, value); }
void (g_tree_insert)(GTree *tree, gpointer key, gpointer value) { stub_funcs.ptr_g_tree_insert(tree, key, value); }
GTreeNode* (g_tree_replace_node)(GTree *tree, gpointer key, gpointer value) { return stub_funcs.ptr_g_tree_replace_node(tree, key, value); }
void (g_tree_replace)(GTree *tree, gpointer key, gpointer value) { stub_funcs.ptr_g_tree_replace(tree, key, value); }
gboolean (g_tree_remove)(GTree *tree, gconstpointer key) { return stub_funcs.ptr_g_tree_remove(tree, key); }
void (g_tree_remove_all)(GTree *tree) { stub_funcs.ptr_g_tree_remove_all(tree); }
gboolean (g_tree_steal)(GTree *tree, gconstpointer key) { return stub_funcs.ptr_g_tree_steal(tree, key); }
gpointer (g_tree_node_key)(GTreeNode *node) { return stub_funcs.ptr_g_tree_node_key(node); }
gpointer (g_tree_node_value)(GTreeNode *node) { return stub_funcs.ptr_g_tree_node_value(node); }
GTreeNode* (g_tree_lookup_node)(GTree *tree, gconstpointer key) { return stub_funcs.ptr_g_tree_lookup_node(tree, key); }
gpointer (g_tree_lookup)(GTree *tree, gconstpointer key) { return stub_funcs.ptr_g_tree_lookup(tree, key); }
gboolean (g_tree_lookup_extended)(GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value) { return stub_funcs.ptr_g_tree_lookup_extended(tree, lookup_key, orig_key, value); }
void (g_tree_foreach)(GTree *tree, GTraverseFunc func, gpointer user_data) { stub_funcs.ptr_g_tree_foreach(tree, func, user_data); }
void (g_tree_foreach_node)(GTree *tree, GTraverseNodeFunc func, gpointer user_data) { stub_funcs.ptr_g_tree_foreach_node(tree, func, user_data); }
void (g_tree_traverse)(GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data) { stub_funcs.ptr_g_tree_traverse(tree, traverse_func, traverse_type, user_data); }
GTreeNode* (g_tree_search_node)(GTree *tree, GCompareFunc search_func, gconstpointer user_data) { return stub_funcs.ptr_g_tree_search_node(tree, search_func, user_data); }
gpointer (g_tree_search)(GTree *tree, GCompareFunc search_func, gconstpointer user_data) { return stub_funcs.ptr_g_tree_search(tree, search_func, user_data); }
GTreeNode* (g_tree_lower_bound)(GTree *tree, gconstpointer key) { return stub_funcs.ptr_g_tree_lower_bound(tree, key); }
GTreeNode* (g_tree_upper_bound)(GTree *tree, gconstpointer key) { return stub_funcs.ptr_g_tree_upper_bound(tree, key); }
gint (g_tree_height)(GTree *tree) { return stub_funcs.ptr_g_tree_height(tree); }
gint (g_tree_nnodes)(GTree *tree) { return stub_funcs.ptr_g_tree_nnodes(tree); }
void (g_tree_dump)(GTree *tree) { stub_funcs.ptr_g_tree_dump(tree); }
GTree* (g_tree_new)(GCompareFunc key_compare_func) { return stub_funcs.ptr_g_tree_new(key_compare_func); }
GUnicodeScript (g_unicode_script_from_iso15924)(guint32 iso15924) { return stub_funcs.ptr_g_unicode_script_from_iso15924(iso15924); }
gboolean (g_unichar_isalnum)(gunichar c) { return stub_funcs.ptr_g_unichar_isalnum(c); }
gboolean (g_unichar_isalpha)(gunichar c) { return stub_funcs.ptr_g_unichar_isalpha(c); }
gboolean (g_unichar_iscntrl)(gunichar c) { return stub_funcs.ptr_g_unichar_iscntrl(c); }
gboolean (g_unichar_isdigit)(gunichar c) { return stub_funcs.ptr_g_unichar_isdigit(c); }
gboolean (g_unichar_isgraph)(gunichar c) { return stub_funcs.ptr_g_unichar_isgraph(c); }
gboolean (g_unichar_islower)(gunichar c) { return stub_funcs.ptr_g_unichar_islower(c); }
gboolean (g_unichar_isprint)(gunichar c) { return stub_funcs.ptr_g_unichar_isprint(c); }
gboolean (g_unichar_ispunct)(gunichar c) { return stub_funcs.ptr_g_unichar_ispunct(c); }
gboolean (g_unichar_isspace)(gunichar c) { return stub_funcs.ptr_g_unichar_isspace(c); }
gboolean (g_unichar_isupper)(gunichar c) { return stub_funcs.ptr_g_unichar_isupper(c); }
gboolean (g_unichar_isxdigit)(gunichar c) { return stub_funcs.ptr_g_unichar_isxdigit(c); }
gboolean (g_unichar_istitle)(gunichar c) { return stub_funcs.ptr_g_unichar_istitle(c); }
gboolean (g_unichar_isdefined)(gunichar c) { return stub_funcs.ptr_g_unichar_isdefined(c); }
gboolean (g_unichar_iswide)(gunichar c) { return stub_funcs.ptr_g_unichar_iswide(c); }
gboolean (g_unichar_iswide_cjk)(gunichar c) { return stub_funcs.ptr_g_unichar_iswide_cjk(c); }
gboolean (g_unichar_iszerowidth)(gunichar c) { return stub_funcs.ptr_g_unichar_iszerowidth(c); }
gboolean (g_unichar_ismark)(gunichar c) { return stub_funcs.ptr_g_unichar_ismark(c); }
gunichar (g_unichar_toupper)(gunichar c) { return stub_funcs.ptr_g_unichar_toupper(c); }
gunichar (g_unichar_tolower)(gunichar c) { return stub_funcs.ptr_g_unichar_tolower(c); }
gunichar (g_unichar_totitle)(gunichar c) { return stub_funcs.ptr_g_unichar_totitle(c); }
gint (g_unichar_digit_value)(gunichar c) { return stub_funcs.ptr_g_unichar_digit_value(c); }
gint (g_unichar_xdigit_value)(gunichar c) { return stub_funcs.ptr_g_unichar_xdigit_value(c); }
GUnicodeType (g_unichar_type)(gunichar c) { return stub_funcs.ptr_g_unichar_type(c); }
GUnicodeBreakType (g_unichar_break_type)(gunichar c) { return stub_funcs.ptr_g_unichar_break_type(c); }
gint (g_unichar_combining_class)(gunichar uc) { return stub_funcs.ptr_g_unichar_combining_class(uc); }
gboolean (g_unichar_get_mirror_char)(gunichar ch, gunichar *mirrored_ch) { return stub_funcs.ptr_g_unichar_get_mirror_char(ch, mirrored_ch); }
GUnicodeScript (g_unichar_get_script)(gunichar ch) { return stub_funcs.ptr_g_unichar_get_script(ch); }
gboolean (g_unichar_validate)(gunichar ch) { return stub_funcs.ptr_g_unichar_validate(ch); }
gboolean (g_unichar_compose)(gunichar a, gunichar b, gunichar *ch) { return stub_funcs.ptr_g_unichar_compose(a, b, ch); }
gboolean (g_unichar_decompose)(gunichar ch, gunichar *a, gunichar *b) { return stub_funcs.ptr_g_unichar_decompose(ch, a, b); }
gsize (g_unichar_fully_decompose)(gunichar ch, gboolean compat, gunichar *result, gsize result_len) { return stub_funcs.ptr_g_unichar_fully_decompose(ch, compat, result, result_len); }
void (g_unicode_canonical_ordering)(gunichar *string, gsize len) { stub_funcs.ptr_g_unicode_canonical_ordering(string, len); }
gunichar* (g_unicode_canonical_decomposition)(gunichar ch, gsize *result_len) { return stub_funcs.ptr_g_unicode_canonical_decomposition(ch, result_len); }
gunichar (g_utf8_get_char)(const gchar *p) { return stub_funcs.ptr_g_utf8_get_char(p); }
gunichar (g_utf8_get_char_validated)(const gchar *p, gssize max_len) { return stub_funcs.ptr_g_utf8_get_char_validated(p, max_len); }
gchar* (g_utf8_offset_to_pointer)(const gchar *str, glong offset) { return stub_funcs.ptr_g_utf8_offset_to_pointer(str, offset); }
glong (g_utf8_pointer_to_offset)(const gchar *str, const gchar *pos) { return stub_funcs.ptr_g_utf8_pointer_to_offset(str, pos); }
gchar* (g_utf8_prev_char)(const gchar *p) { return stub_funcs.ptr_g_utf8_prev_char(p); }
gchar* (g_utf8_find_next_char)(const gchar *p, const gchar *end) { return stub_funcs.ptr_g_utf8_find_next_char(p, end); }
gchar* (g_utf8_find_prev_char)(const gchar *str, const gchar *p) { return stub_funcs.ptr_g_utf8_find_prev_char(str, p); }
glong (g_utf8_strlen)(const gchar *p, gssize max) { return stub_funcs.ptr_g_utf8_strlen(p, max); }
gchar* (g_utf8_substring)(const gchar *str, glong start_pos, glong end_pos) { return stub_funcs.ptr_g_utf8_substring(str, start_pos, end_pos); }
gchar* (g_utf8_strncpy)(gchar *dest, const gchar *src, gsize n) { return stub_funcs.ptr_g_utf8_strncpy(dest, src, n); }
gchar* (g_utf8_truncate_middle)(const gchar *string, gsize truncate_length) { return stub_funcs.ptr_g_utf8_truncate_middle(string, truncate_length); }
gchar* (g_utf8_strchr)(const gchar *p, gssize len, gunichar c) { return stub_funcs.ptr_g_utf8_strchr(p, len, c); }
gchar* (g_utf8_strrchr)(const gchar *p, gssize len, gunichar c) { return stub_funcs.ptr_g_utf8_strrchr(p, len, c); }
gchar* (g_utf8_strreverse)(const gchar *str, gssize len) { return stub_funcs.ptr_g_utf8_strreverse(str, len); }
gunichar2* (g_utf8_to_utf16)(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) { return stub_funcs.ptr_g_utf8_to_utf16(str, len, items_read, items_written, error); }
gunichar * (g_utf8_to_ucs4)(const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) { return stub_funcs.ptr_g_utf8_to_ucs4(str, len, items_read, items_written, error); }
gunichar * (g_utf8_to_ucs4_fast)(const gchar *str, glong len, glong *items_written) { return stub_funcs.ptr_g_utf8_to_ucs4_fast(str, len, items_written); }
gunichar * (g_utf16_to_ucs4)(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) { return stub_funcs.ptr_g_utf16_to_ucs4(str, len, items_read, items_written, error); }
gchar* (g_utf16_to_utf8)(const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) { return stub_funcs.ptr_g_utf16_to_utf8(str, len, items_read, items_written, error); }
gunichar2* (g_ucs4_to_utf16)(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) { return stub_funcs.ptr_g_ucs4_to_utf16(str, len, items_read, items_written, error); }
gchar* (g_ucs4_to_utf8)(const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) { return stub_funcs.ptr_g_ucs4_to_utf8(str, len, items_read, items_written, error); }
gint (g_unichar_to_utf8)(gunichar c, gchar *outbuf) { return stub_funcs.ptr_g_unichar_to_utf8(c, outbuf); }
gboolean (g_utf8_validate)(const gchar *str, gssize max_len, const gchar **end) { return stub_funcs.ptr_g_utf8_validate(str, max_len, end); }
gboolean (g_utf8_validate_len)(const gchar *str, gsize max_len, const gchar **end) { return stub_funcs.ptr_g_utf8_validate_len(str, max_len, end); }
gchar* (g_utf8_strup)(const gchar *str, gssize len) { return stub_funcs.ptr_g_utf8_strup(str, len); }
gchar* (g_utf8_strdown)(const gchar *str, gssize len) { return stub_funcs.ptr_g_utf8_strdown(str, len); }
gchar* (g_utf8_casefold)(const gchar *str, gssize len) { return stub_funcs.ptr_g_utf8_casefold(str, len); }
gchar* (g_utf8_normalize)(const gchar *str, gssize len, GNormalizeMode mode) { return stub_funcs.ptr_g_utf8_normalize(str, len, mode); }
gint (g_utf8_collate)(const gchar *str1, const gchar *str2) { return stub_funcs.ptr_g_utf8_collate(str1, str2); }
gchar* (g_utf8_collate_key)(const gchar *str, gssize len) { return stub_funcs.ptr_g_utf8_collate_key(str, len); }
gchar* (g_utf8_collate_key_for_filename)(const gchar *str, gssize len) { return stub_funcs.ptr_g_utf8_collate_key_for_filename(str, len); }
gchar* (g_utf8_make_valid)(const gchar *str, gssize len) { return stub_funcs.ptr_g_utf8_make_valid(str, len); }
guint32 (g_unicode_script_to_iso15924)(GUnicodeScript script) { return stub_funcs.ptr_g_unicode_script_to_iso15924(script); }
void (g_uri_unref)(GUri *uri) { stub_funcs.ptr_g_uri_unref(uri); }
gboolean (g_uri_split)(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **userinfo, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error) { return stub_funcs.ptr_g_uri_split(uri_ref, flags, scheme, userinfo, host, port, path, query, fragment, error); }
gboolean (g_uri_split_with_user)(const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error) { return stub_funcs.ptr_g_uri_split_with_user(uri_ref, flags, scheme, user, password, auth_params, host, port, path, query, fragment, error); }
gboolean (g_uri_split_network)(const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error) { return stub_funcs.ptr_g_uri_split_network(uri_string, flags, scheme, host, port, error); }
gboolean (g_uri_is_valid)(const gchar *uri_string, GUriFlags flags, GError **error) { return stub_funcs.ptr_g_uri_is_valid(uri_string, flags, error); }
gchar * (g_uri_join)(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment) { return stub_funcs.ptr_g_uri_join(flags, scheme, userinfo, host, port, path, query, fragment); }
gchar * (g_uri_join_with_user)(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment) { return stub_funcs.ptr_g_uri_join_with_user(flags, scheme, user, password, auth_params, host, port, path, query, fragment); }
GUri * (g_uri_parse)(const gchar *uri_string, GUriFlags flags, GError **error) { return stub_funcs.ptr_g_uri_parse(uri_string, flags, error); }
GUri * (g_uri_parse_relative)(GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error) { return stub_funcs.ptr_g_uri_parse_relative(base_uri, uri_ref, flags, error); }
gchar * (g_uri_resolve_relative)(const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error) { return stub_funcs.ptr_g_uri_resolve_relative(base_uri_string, uri_ref, flags, error); }
GUri * (g_uri_build)(GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment) { return stub_funcs.ptr_g_uri_build(flags, scheme, userinfo, host, port, path, query, fragment); }
GUri * (g_uri_build_with_user)(GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment) { return stub_funcs.ptr_g_uri_build_with_user(flags, scheme, user, password, auth_params, host, port, path, query, fragment); }
char * (g_uri_to_string)(GUri *uri) { return stub_funcs.ptr_g_uri_to_string(uri); }
char * (g_uri_to_string_partial)(GUri *uri, GUriHideFlags flags) { return stub_funcs.ptr_g_uri_to_string_partial(uri, flags); }
const gchar* (g_uri_get_scheme)(GUri *uri) { return stub_funcs.ptr_g_uri_get_scheme(uri); }
const gchar* (g_uri_get_userinfo)(GUri *uri) { return stub_funcs.ptr_g_uri_get_userinfo(uri); }
const gchar* (g_uri_get_user)(GUri *uri) { return stub_funcs.ptr_g_uri_get_user(uri); }
const gchar* (g_uri_get_password)(GUri *uri) { return stub_funcs.ptr_g_uri_get_password(uri); }
const gchar* (g_uri_get_auth_params)(GUri *uri) { return stub_funcs.ptr_g_uri_get_auth_params(uri); }
const gchar* (g_uri_get_host)(GUri *uri) { return stub_funcs.ptr_g_uri_get_host(uri); }
gint (g_uri_get_port)(GUri *uri) { return stub_funcs.ptr_g_uri_get_port(uri); }
const gchar* (g_uri_get_path)(GUri *uri) { return stub_funcs.ptr_g_uri_get_path(uri); }
const gchar* (g_uri_get_query)(GUri *uri) { return stub_funcs.ptr_g_uri_get_query(uri); }
const gchar* (g_uri_get_fragment)(GUri *uri) { return stub_funcs.ptr_g_uri_get_fragment(uri); }
GUriFlags (g_uri_get_flags)(GUri *uri) { return stub_funcs.ptr_g_uri_get_flags(uri); }
GHashTable* (g_uri_parse_params)(const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error) { return stub_funcs.ptr_g_uri_parse_params(params, length, separators, flags, error); }
void (g_uri_params_iter_init)(GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags) { stub_funcs.ptr_g_uri_params_iter_init(iter, params, length, separators, flags); }
gboolean (g_uri_params_iter_next)(GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error) { return stub_funcs.ptr_g_uri_params_iter_next(iter, attribute, value, error); }
GQuark (g_uri_error_quark)(void) { return stub_funcs.ptr_g_uri_error_quark(); }
char * (g_uri_unescape_string)(const char *escaped_string, const char *illegal_characters) { return stub_funcs.ptr_g_uri_unescape_string(escaped_string, illegal_characters); }
char * (g_uri_unescape_segment)(const char *escaped_string, const char *escaped_string_end, const char *illegal_characters) { return stub_funcs.ptr_g_uri_unescape_segment(escaped_string, escaped_string_end, illegal_characters); }
char * (g_uri_parse_scheme)(const char *uri) { return stub_funcs.ptr_g_uri_parse_scheme(uri); }
const char* (g_uri_peek_scheme)(const char *uri) { return stub_funcs.ptr_g_uri_peek_scheme(uri); }
char * (g_uri_escape_string)(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8) { return stub_funcs.ptr_g_uri_escape_string(unescaped, reserved_chars_allowed, allow_utf8); }
GBytes * (g_uri_unescape_bytes)(const char *escaped_string, gssize length, const char *illegal_characters, GError **error) { return stub_funcs.ptr_g_uri_unescape_bytes(escaped_string, length, illegal_characters, error); }
char * (g_uri_escape_bytes)(const guint8 *unescaped, gsize length, const char *reserved_chars_allowed) { return stub_funcs.ptr_g_uri_escape_bytes(unescaped, length, reserved_chars_allowed); }
const gchar * (g_get_real_name)(void) { return stub_funcs.ptr_g_get_real_name(); }
const gchar * (g_get_home_dir)(void) { return stub_funcs.ptr_g_get_home_dir(); }
const gchar * (g_get_tmp_dir)(void) { return stub_funcs.ptr_g_get_tmp_dir(); }
const gchar * (g_get_host_name)(void) { return stub_funcs.ptr_g_get_host_name(); }
const gchar * (g_get_prgname)(void) { return stub_funcs.ptr_g_get_prgname(); }
void (g_set_prgname)(const gchar *prgname) { stub_funcs.ptr_g_set_prgname(prgname); }
const gchar * (g_get_application_name)(void) { return stub_funcs.ptr_g_get_application_name(); }
void (g_set_application_name)(const gchar *application_name) { stub_funcs.ptr_g_set_application_name(application_name); }
gchar * (g_get_os_info)(const gchar *key_name) { return stub_funcs.ptr_g_get_os_info(key_name); }
void (g_reload_user_special_dirs_cache)(void) { stub_funcs.ptr_g_reload_user_special_dirs_cache(); }
const gchar * (g_get_user_data_dir)(void) { return stub_funcs.ptr_g_get_user_data_dir(); }
const gchar * (g_get_user_config_dir)(void) { return stub_funcs.ptr_g_get_user_config_dir(); }
const gchar * (g_get_user_cache_dir)(void) { return stub_funcs.ptr_g_get_user_cache_dir(); }
const gchar * (g_get_user_state_dir)(void) { return stub_funcs.ptr_g_get_user_state_dir(); }
const gchar * const * (g_get_system_data_dirs)(void) { return stub_funcs.ptr_g_get_system_data_dirs(); }
const gchar * const * (g_get_system_config_dirs)(void) { return stub_funcs.ptr_g_get_system_config_dirs(); }
const gchar * (g_get_user_runtime_dir)(void) { return stub_funcs.ptr_g_get_user_runtime_dir(); }
const gchar * (g_get_user_special_dir)(GUserDirectory directory) { return stub_funcs.ptr_g_get_user_special_dir(directory); }
guint (g_parse_debug_string)(const gchar *string, const GDebugKey *keys, guint nkeys) { return stub_funcs.ptr_g_parse_debug_string(string, keys, nkeys); }
gint (g_snprintf)(gchar *string, gulong n, gchar const *format, ...) { gint ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_vsnprintf(string, n, format, vaargs); va_end(vaargs); return ret; }
gint (g_vsnprintf)(gchar *string, gulong n, gchar const *format, va_list args) { return stub_funcs.ptr_g_vsnprintf(string, n, format, args); }
void (g_nullify_pointer)(gpointer *nullify_location) { stub_funcs.ptr_g_nullify_pointer(nullify_location); }
gchar* (g_format_size_full)(guint64 size, GFormatSizeFlags flags) { return stub_funcs.ptr_g_format_size_full(size, flags); }
gchar* (g_format_size)(guint64 size) { return stub_funcs.ptr_g_format_size(size); }
gchar* (g_format_size_for_display)(goffset size) { return stub_funcs.ptr_g_format_size_for_display(size); }
gchar* (g_find_program_in_path)(const gchar *program) { return stub_funcs.ptr_g_find_program_in_path(program); }
gint (g_bit_nth_lsf)(gulong mask, gint nth_bit) { return stub_funcs.ptr_g_bit_nth_lsf(mask, nth_bit); }
gint (g_bit_nth_msf)(gulong mask, gint nth_bit) { return stub_funcs.ptr_g_bit_nth_msf(mask, nth_bit); }
guint (g_bit_storage)(gulong number) { return stub_funcs.ptr_g_bit_storage(number); }
void (g_abort)(void) { stub_funcs.ptr_g_abort(); __builtin_unreachable(); /* oops rayo cosmico */  }
const gchar * (g_get_user_name)(void) { return stub_funcs.ptr_g_get_user_name(); }
gchar * (g_uuid_string_random)(void) { return stub_funcs.ptr_g_uuid_string_random(); }
gboolean (g_uuid_string_is_valid)(const gchar *str) { return stub_funcs.ptr_g_uuid_string_is_valid(str); }
GVariant * (g_variant_ref)(GVariant *value) { return stub_funcs.ptr_g_variant_ref(value); }
GVariant * (g_variant_ref_sink)(GVariant *value) { return stub_funcs.ptr_g_variant_ref_sink(value); }
gboolean (g_variant_is_floating)(GVariant *value) { return stub_funcs.ptr_g_variant_is_floating(value); }
GVariant * (g_variant_take_ref)(GVariant *value) { return stub_funcs.ptr_g_variant_take_ref(value); }
const GVariantType * (g_variant_get_type)(GVariant *value) { return stub_funcs.ptr_g_variant_get_type(value); }
const gchar * (g_variant_get_type_string)(GVariant *value) { return stub_funcs.ptr_g_variant_get_type_string(value); }
gboolean (g_variant_is_of_type)(GVariant *value, const GVariantType *type) { return stub_funcs.ptr_g_variant_is_of_type(value, type); }
gboolean (g_variant_is_container)(GVariant *value) { return stub_funcs.ptr_g_variant_is_container(value); }
GVariantClass (g_variant_classify)(GVariant *value) { return stub_funcs.ptr_g_variant_classify(value); }
GVariant * (g_variant_new_boolean)(gboolean value) { return stub_funcs.ptr_g_variant_new_boolean(value); }
GVariant * (g_variant_new_byte)(guint8 value) { return stub_funcs.ptr_g_variant_new_byte(value); }
GVariant * (g_variant_new_int16)(gint16 value) { return stub_funcs.ptr_g_variant_new_int16(value); }
GVariant * (g_variant_new_uint16)(guint16 value) { return stub_funcs.ptr_g_variant_new_uint16(value); }
GVariant * (g_variant_new_int32)(gint32 value) { return stub_funcs.ptr_g_variant_new_int32(value); }
GVariant * (g_variant_new_uint32)(guint32 value) { return stub_funcs.ptr_g_variant_new_uint32(value); }
GVariant * (g_variant_new_int64)(gint64 value) { return stub_funcs.ptr_g_variant_new_int64(value); }
GVariant * (g_variant_new_uint64)(guint64 value) { return stub_funcs.ptr_g_variant_new_uint64(value); }
GVariant * (g_variant_new_handle)(gint32 value) { return stub_funcs.ptr_g_variant_new_handle(value); }
GVariant * (g_variant_new_double)(gdouble value) { return stub_funcs.ptr_g_variant_new_double(value); }
GVariant * (g_variant_new_string)(const gchar *string) { return stub_funcs.ptr_g_variant_new_string(string); }
GVariant * (g_variant_new_take_string)(gchar *string) { return stub_funcs.ptr_g_variant_new_take_string(string); }
// Unable to locate va_equiv for g_variant_new_printf
GVariant * (g_variant_new_object_path)(const gchar *object_path) { return stub_funcs.ptr_g_variant_new_object_path(object_path); }
gboolean (g_variant_is_object_path)(const gchar *string) { return stub_funcs.ptr_g_variant_is_object_path(string); }
GVariant * (g_variant_new_signature)(const gchar *signature) { return stub_funcs.ptr_g_variant_new_signature(signature); }
gboolean (g_variant_is_signature)(const gchar *string) { return stub_funcs.ptr_g_variant_is_signature(string); }
GVariant * (g_variant_new_variant)(GVariant *value) { return stub_funcs.ptr_g_variant_new_variant(value); }
GVariant * (g_variant_new_strv)(const gchar * const *strv, gssize length) { return stub_funcs.ptr_g_variant_new_strv(strv, length); }
GVariant * (g_variant_new_objv)(const gchar * const *strv, gssize length) { return stub_funcs.ptr_g_variant_new_objv(strv, length); }
GVariant * (g_variant_new_bytestring)(const gchar *string) { return stub_funcs.ptr_g_variant_new_bytestring(string); }
GVariant * (g_variant_new_bytestring_array)(const gchar * const *strv, gssize length) { return stub_funcs.ptr_g_variant_new_bytestring_array(strv, length); }
GVariant * (g_variant_new_fixed_array)(const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size) { return stub_funcs.ptr_g_variant_new_fixed_array(element_type, elements, n_elements, element_size); }
gboolean (g_variant_get_boolean)(GVariant *value) { return stub_funcs.ptr_g_variant_get_boolean(value); }
guint8 (g_variant_get_byte)(GVariant *value) { return stub_funcs.ptr_g_variant_get_byte(value); }
gint16 (g_variant_get_int16)(GVariant *value) { return stub_funcs.ptr_g_variant_get_int16(value); }
guint16 (g_variant_get_uint16)(GVariant *value) { return stub_funcs.ptr_g_variant_get_uint16(value); }
gint32 (g_variant_get_int32)(GVariant *value) { return stub_funcs.ptr_g_variant_get_int32(value); }
guint32 (g_variant_get_uint32)(GVariant *value) { return stub_funcs.ptr_g_variant_get_uint32(value); }
gint64 (g_variant_get_int64)(GVariant *value) { return stub_funcs.ptr_g_variant_get_int64(value); }
guint64 (g_variant_get_uint64)(GVariant *value) { return stub_funcs.ptr_g_variant_get_uint64(value); }
gint32 (g_variant_get_handle)(GVariant *value) { return stub_funcs.ptr_g_variant_get_handle(value); }
gdouble (g_variant_get_double)(GVariant *value) { return stub_funcs.ptr_g_variant_get_double(value); }
GVariant * (g_variant_get_variant)(GVariant *value) { return stub_funcs.ptr_g_variant_get_variant(value); }
const gchar * (g_variant_get_string)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_get_string(value, length); }
gchar * (g_variant_dup_string)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_dup_string(value, length); }
const gchar ** (g_variant_get_strv)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_get_strv(value, length); }
gchar ** (g_variant_dup_strv)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_dup_strv(value, length); }
const gchar ** (g_variant_get_objv)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_get_objv(value, length); }
gchar ** (g_variant_dup_objv)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_dup_objv(value, length); }
const gchar * (g_variant_get_bytestring)(GVariant *value) { return stub_funcs.ptr_g_variant_get_bytestring(value); }
gchar * (g_variant_dup_bytestring)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_dup_bytestring(value, length); }
const gchar ** (g_variant_get_bytestring_array)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_get_bytestring_array(value, length); }
gchar ** (g_variant_dup_bytestring_array)(GVariant *value, gsize *length) { return stub_funcs.ptr_g_variant_dup_bytestring_array(value, length); }
GVariant * (g_variant_new_maybe)(const GVariantType *child_type, GVariant *child) { return stub_funcs.ptr_g_variant_new_maybe(child_type, child); }
GVariant * (g_variant_new_array)(const GVariantType *child_type, GVariant * const *children, gsize n_children) { return stub_funcs.ptr_g_variant_new_array(child_type, children, n_children); }
GVariant * (g_variant_new_tuple)(GVariant * const *children, gsize n_children) { return stub_funcs.ptr_g_variant_new_tuple(children, n_children); }
GVariant * (g_variant_new_dict_entry)(GVariant *key, GVariant *value) { return stub_funcs.ptr_g_variant_new_dict_entry(key, value); }
GVariant * (g_variant_get_maybe)(GVariant *value) { return stub_funcs.ptr_g_variant_get_maybe(value); }
gsize (g_variant_n_children)(GVariant *value) { return stub_funcs.ptr_g_variant_n_children(value); }
// Unable to locate va_equiv for g_variant_get_child
GVariant * (g_variant_get_child_value)(GVariant *value, gsize index_) { return stub_funcs.ptr_g_variant_get_child_value(value, index_); }
// Unable to locate va_equiv for g_variant_lookup
GVariant * (g_variant_lookup_value)(GVariant *dictionary, const gchar *key, const GVariantType *expected_type) { return stub_funcs.ptr_g_variant_lookup_value(dictionary, key, expected_type); }
gconstpointer (g_variant_get_fixed_array)(GVariant *value, gsize *n_elements, gsize element_size) { return stub_funcs.ptr_g_variant_get_fixed_array(value, n_elements, element_size); }
gsize (g_variant_get_size)(GVariant *value) { return stub_funcs.ptr_g_variant_get_size(value); }
gconstpointer (g_variant_get_data)(GVariant *value) { return stub_funcs.ptr_g_variant_get_data(value); }
GBytes * (g_variant_get_data_as_bytes)(GVariant *value) { return stub_funcs.ptr_g_variant_get_data_as_bytes(value); }
void (g_variant_store)(GVariant *value, gpointer data) { stub_funcs.ptr_g_variant_store(value, data); }
gchar * (g_variant_print)(GVariant *value, gboolean type_annotate) { return stub_funcs.ptr_g_variant_print(value, type_annotate); }
GString * (g_variant_print_string)(GVariant *value, GString *string, gboolean type_annotate) { return stub_funcs.ptr_g_variant_print_string(value, string, type_annotate); }
guint (g_variant_hash)(gconstpointer value) { return stub_funcs.ptr_g_variant_hash(value); }
gboolean (g_variant_equal)(gconstpointer one, gconstpointer two) { return stub_funcs.ptr_g_variant_equal(one, two); }
GVariant * (g_variant_get_normal_form)(GVariant *value) { return stub_funcs.ptr_g_variant_get_normal_form(value); }
gboolean (g_variant_is_normal_form)(GVariant *value) { return stub_funcs.ptr_g_variant_is_normal_form(value); }
GVariant * (g_variant_byteswap)(GVariant *value) { return stub_funcs.ptr_g_variant_byteswap(value); }
GVariant * (g_variant_new_from_bytes)(const GVariantType *type, GBytes *bytes, gboolean trusted) { return stub_funcs.ptr_g_variant_new_from_bytes(type, bytes, trusted); }
GVariant * (g_variant_new_from_data)(const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data) { return stub_funcs.ptr_g_variant_new_from_data(type, data, size, trusted, notify, user_data); }
GVariantIter * (g_variant_iter_new)(GVariant *value) { return stub_funcs.ptr_g_variant_iter_new(value); }
gsize (g_variant_iter_init)(GVariantIter *iter, GVariant *value) { return stub_funcs.ptr_g_variant_iter_init(iter, value); }
GVariantIter * (g_variant_iter_copy)(GVariantIter *iter) { return stub_funcs.ptr_g_variant_iter_copy(iter); }
gsize (g_variant_iter_n_children)(GVariantIter *iter) { return stub_funcs.ptr_g_variant_iter_n_children(iter); }
void (g_variant_iter_free)(GVariantIter *iter) { stub_funcs.ptr_g_variant_iter_free(iter); }
GVariant * (g_variant_iter_next_value)(GVariantIter *iter) { return stub_funcs.ptr_g_variant_iter_next_value(iter); }
// Unable to locate va_equiv for g_variant_iter_next
// Unable to locate va_equiv for g_variant_iter_loop
GQuark (g_variant_parser_get_error_quark)(void) { return stub_funcs.ptr_g_variant_parser_get_error_quark(); }
GQuark (g_variant_parse_error_quark)(void) { return stub_funcs.ptr_g_variant_parse_error_quark(); }
GVariantBuilder * (g_variant_builder_new)(const GVariantType *type) { return stub_funcs.ptr_g_variant_builder_new(type); }
void (g_variant_builder_unref)(GVariantBuilder *builder) { stub_funcs.ptr_g_variant_builder_unref(builder); }
GVariantBuilder * (g_variant_builder_ref)(GVariantBuilder *builder) { return stub_funcs.ptr_g_variant_builder_ref(builder); }
void (g_variant_builder_init)(GVariantBuilder *builder, const GVariantType *type) { stub_funcs.ptr_g_variant_builder_init(builder, type); }
GVariant * (g_variant_builder_end)(GVariantBuilder *builder) { return stub_funcs.ptr_g_variant_builder_end(builder); }
void (g_variant_builder_clear)(GVariantBuilder *builder) { stub_funcs.ptr_g_variant_builder_clear(builder); }
void (g_variant_builder_open)(GVariantBuilder *builder, const GVariantType *type) { stub_funcs.ptr_g_variant_builder_open(builder, type); }
void (g_variant_builder_close)(GVariantBuilder *builder) { stub_funcs.ptr_g_variant_builder_close(builder); }
void (g_variant_builder_add_value)(GVariantBuilder *builder, GVariant *value) { stub_funcs.ptr_g_variant_builder_add_value(builder, value); }
// Unable to locate va_equiv for g_variant_builder_add
// Unable to locate va_equiv for g_variant_builder_add_parsed
// Found va_equiv for func g_variant_new as func g_variant_new_va with pattern g_variant_new[_]*va*$, but err: args count mismatch
// Found va_equiv for func g_variant_get as func g_variant_get_va with pattern g_variant_get[_]*va*$, but err: args count mismatch
GVariant * (g_variant_new_va)(const gchar *format_string, const gchar **endptr, va_list *app) { return stub_funcs.ptr_g_variant_new_va(format_string, endptr, app); }
void (g_variant_get_va)(GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app) { stub_funcs.ptr_g_variant_get_va(value, format_string, endptr, app); }
gboolean (g_variant_check_format_string)(GVariant *value, const gchar *format_string, gboolean copy_only) { return stub_funcs.ptr_g_variant_check_format_string(value, format_string, copy_only); }
GVariant * (g_variant_parse)(const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error) { return stub_funcs.ptr_g_variant_parse(type, text, limit, endptr, error); }
GVariant * (g_variant_new_parsed)(const gchar *format, ...) { GVariant * ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_variant_new_parsed_va(format, &vaargs); va_end(vaargs); return ret; }
GVariant * (g_variant_new_parsed_va)(const gchar *format, va_list *app) { return stub_funcs.ptr_g_variant_new_parsed_va(format, app); }
gchar * (g_variant_parse_error_print_context)(GError *error, const gchar *source_str) { return stub_funcs.ptr_g_variant_parse_error_print_context(error, source_str); }
gint (g_variant_compare)(gconstpointer one, gconstpointer two) { return stub_funcs.ptr_g_variant_compare(one, two); }
GVariantDict * (g_variant_dict_new)(GVariant *from_asv) { return stub_funcs.ptr_g_variant_dict_new(from_asv); }
void (g_variant_dict_init)(GVariantDict *dict, GVariant *from_asv) { stub_funcs.ptr_g_variant_dict_init(dict, from_asv); }
// Unable to locate va_equiv for g_variant_dict_lookup
GVariant * (g_variant_dict_lookup_value)(GVariantDict *dict, const gchar *key, const GVariantType *expected_type) { return stub_funcs.ptr_g_variant_dict_lookup_value(dict, key, expected_type); }
gboolean (g_variant_dict_contains)(GVariantDict *dict, const gchar *key) { return stub_funcs.ptr_g_variant_dict_contains(dict, key); }
// Unable to locate va_equiv for g_variant_dict_insert
void (g_variant_dict_insert_value)(GVariantDict *dict, const gchar *key, GVariant *value) { stub_funcs.ptr_g_variant_dict_insert_value(dict, key, value); }
gboolean (g_variant_dict_remove)(GVariantDict *dict, const gchar *key) { return stub_funcs.ptr_g_variant_dict_remove(dict, key); }
void (g_variant_dict_clear)(GVariantDict *dict) { stub_funcs.ptr_g_variant_dict_clear(dict); }
GVariant * (g_variant_dict_end)(GVariantDict *dict) { return stub_funcs.ptr_g_variant_dict_end(dict); }
GVariantDict * (g_variant_dict_ref)(GVariantDict *dict) { return stub_funcs.ptr_g_variant_dict_ref(dict); }
void (g_variant_dict_unref)(GVariantDict *dict) { stub_funcs.ptr_g_variant_dict_unref(dict); }
void (g_variant_unref)(GVariant *value) { stub_funcs.ptr_g_variant_unref(value); }
gboolean (g_variant_type_string_scan)(const gchar *string, const gchar *limit, const gchar **endptr) { return stub_funcs.ptr_g_variant_type_string_scan(string, limit, endptr); }
void (g_variant_type_free)(GVariantType *type) { stub_funcs.ptr_g_variant_type_free(type); }
GVariantType * (g_variant_type_copy)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_copy(type); }
GVariantType * (g_variant_type_new)(const gchar *type_string) { return stub_funcs.ptr_g_variant_type_new(type_string); }
gsize (g_variant_type_get_string_length)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_get_string_length(type); }
const gchar * (g_variant_type_peek_string)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_peek_string(type); }
gchar * (g_variant_type_dup_string)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_dup_string(type); }
gboolean (g_variant_type_is_definite)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_definite(type); }
gboolean (g_variant_type_is_container)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_container(type); }
gboolean (g_variant_type_is_basic)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_basic(type); }
gboolean (g_variant_type_is_maybe)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_maybe(type); }
gboolean (g_variant_type_is_array)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_array(type); }
gboolean (g_variant_type_is_tuple)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_tuple(type); }
gboolean (g_variant_type_is_dict_entry)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_dict_entry(type); }
gboolean (g_variant_type_is_variant)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_is_variant(type); }
guint (g_variant_type_hash)(gconstpointer type) { return stub_funcs.ptr_g_variant_type_hash(type); }
gboolean (g_variant_type_equal)(gconstpointer type1, gconstpointer type2) { return stub_funcs.ptr_g_variant_type_equal(type1, type2); }
gboolean (g_variant_type_is_subtype_of)(const GVariantType *type, const GVariantType *supertype) { return stub_funcs.ptr_g_variant_type_is_subtype_of(type, supertype); }
const GVariantType * (g_variant_type_element)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_element(type); }
const GVariantType * (g_variant_type_first)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_first(type); }
const GVariantType * (g_variant_type_next)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_next(type); }
gsize (g_variant_type_n_items)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_n_items(type); }
const GVariantType * (g_variant_type_key)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_key(type); }
const GVariantType * (g_variant_type_value)(const GVariantType *type) { return stub_funcs.ptr_g_variant_type_value(type); }
GVariantType * (g_variant_type_new_array)(const GVariantType *element) { return stub_funcs.ptr_g_variant_type_new_array(element); }
GVariantType * (g_variant_type_new_maybe)(const GVariantType *element) { return stub_funcs.ptr_g_variant_type_new_maybe(element); }
GVariantType * (g_variant_type_new_tuple)(const GVariantType * const *items, gint length) { return stub_funcs.ptr_g_variant_type_new_tuple(items, length); }
GVariantType * (g_variant_type_new_dict_entry)(const GVariantType *key, const GVariantType *value) { return stub_funcs.ptr_g_variant_type_new_dict_entry(key, value); }
const GVariantType * (g_variant_type_checked_)(const gchar *type_string) { return stub_funcs.ptr_g_variant_type_checked_(type_string); }
gsize (g_variant_type_string_get_depth_)(const gchar *type_string) { return stub_funcs.ptr_g_variant_type_string_get_depth_(type_string); }
gboolean (g_variant_type_string_is_valid)(const gchar *type_string) { return stub_funcs.ptr_g_variant_type_string_is_valid(type_string); }
const gchar * (glib_check_version)(guint required_major, guint required_minor, guint required_micro) { return stub_funcs.ptr_glib_check_version(required_major, required_minor, required_micro); }
gboolean (g_unix_open_pipe)(gint *fds, gint flags, GError **error) { return stub_funcs.ptr_g_unix_open_pipe(fds, flags, error); }
gboolean (g_unix_set_fd_nonblocking)(gint fd, gboolean nonblock, GError **error) { return stub_funcs.ptr_g_unix_set_fd_nonblocking(fd, nonblock, error); }
GSource* (g_unix_signal_source_new)(gint signum) { return stub_funcs.ptr_g_unix_signal_source_new(signum); }
guint (g_unix_signal_add_full)(gint priority, gint signum, GSourceFunc handler, gpointer user_data, GDestroyNotify notify) { return stub_funcs.ptr_g_unix_signal_add_full(priority, signum, handler, user_data, notify); }
guint (g_unix_signal_add)(gint signum, GSourceFunc handler, gpointer user_data) { return stub_funcs.ptr_g_unix_signal_add(signum, handler, user_data); }
GSource* (g_unix_fd_source_new)(gint fd, GIOCondition condition) { return stub_funcs.ptr_g_unix_fd_source_new(fd, condition); }
guint (g_unix_fd_add_full)(gint priority, gint fd, GIOCondition condition, GUnixFDSourceFunc function, gpointer user_data, GDestroyNotify notify) { return stub_funcs.ptr_g_unix_fd_add_full(priority, fd, condition, function, user_data, notify); }
guint (g_unix_fd_add)(gint fd, GIOCondition condition, GUnixFDSourceFunc function, gpointer user_data) { return stub_funcs.ptr_g_unix_fd_add(fd, condition, function, user_data); }
struct passwd* (g_unix_get_passwd_entry)(const gchar *user_name, GError **error) { return stub_funcs.ptr_g_unix_get_passwd_entry(user_name, error); }
int (g_fdwalk_set_cloexec)(int lowfd) { return stub_funcs.ptr_g_fdwalk_set_cloexec(lowfd); }
GQuark (g_unix_error_quark)(void) { return stub_funcs.ptr_g_unix_error_quark(); }
GType (g_binding_flags_get_type)(void) { return stub_funcs.ptr_g_binding_flags_get_type(); }
GType (g_binding_get_type)(void) { return stub_funcs.ptr_g_binding_get_type(); }
GBindingFlags (g_binding_get_flags)(GBinding *binding) { return stub_funcs.ptr_g_binding_get_flags(binding); }
GObject * (g_binding_get_source)(GBinding *binding) { return stub_funcs.ptr_g_binding_get_source(binding); }
GObject * (g_binding_dup_source)(GBinding *binding) { return stub_funcs.ptr_g_binding_dup_source(binding); }
GObject * (g_binding_get_target)(GBinding *binding) { return stub_funcs.ptr_g_binding_get_target(binding); }
GObject * (g_binding_dup_target)(GBinding *binding) { return stub_funcs.ptr_g_binding_dup_target(binding); }
const gchar * (g_binding_get_source_property)(GBinding *binding) { return stub_funcs.ptr_g_binding_get_source_property(binding); }
const gchar * (g_binding_get_target_property)(GBinding *binding) { return stub_funcs.ptr_g_binding_get_target_property(binding); }
void (g_binding_unbind)(GBinding *binding) { stub_funcs.ptr_g_binding_unbind(binding); }
GBinding* (g_object_bind_property)(gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags) { return stub_funcs.ptr_g_object_bind_property(source, source_property, target, target_property, flags); }
GBinding* (g_object_bind_property_full)(gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify notify) { return stub_funcs.ptr_g_object_bind_property_full(source, source_property, target, target_property, flags, transform_to, transform_from, user_data, notify); }
GBinding* (g_object_bind_property_with_closures)(gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from) { return stub_funcs.ptr_g_object_bind_property_with_closures(source, source_property, target, target_property, flags, transform_to, transform_from); }
GType (g_binding_group_get_type)(void) { return stub_funcs.ptr_g_binding_group_get_type(); }
GBindingGroup* (g_binding_group_new)(void) { return stub_funcs.ptr_g_binding_group_new(); }
gpointer (g_binding_group_dup_source)(GBindingGroup *self) { return stub_funcs.ptr_g_binding_group_dup_source(self); }
void (g_binding_group_set_source)(GBindingGroup *self, gpointer source) { stub_funcs.ptr_g_binding_group_set_source(self, source); }
void (g_binding_group_bind)(GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags) { stub_funcs.ptr_g_binding_group_bind(self, source_property, target, target_property, flags); }
void (g_binding_group_bind_full)(GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify user_data_destroy) { stub_funcs.ptr_g_binding_group_bind_full(self, source_property, target, target_property, flags, transform_to, transform_from, user_data, user_data_destroy); }
void (g_binding_group_bind_with_closures)(GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from) { stub_funcs.ptr_g_binding_group_bind_with_closures(self, source_property, target, target_property, flags, transform_to, transform_from); }
gpointer (g_boxed_copy)(GType boxed_type, gconstpointer src_boxed) { return stub_funcs.ptr_g_boxed_copy(boxed_type, src_boxed); }
void (g_boxed_free)(GType boxed_type, gpointer boxed) { stub_funcs.ptr_g_boxed_free(boxed_type, boxed); }
void (g_value_set_boxed)(GValue *value, gconstpointer v_boxed) { stub_funcs.ptr_g_value_set_boxed(value, v_boxed); }
void (g_value_set_static_boxed)(GValue *value, gconstpointer v_boxed) { stub_funcs.ptr_g_value_set_static_boxed(value, v_boxed); }
void (g_value_take_boxed)(GValue *value, gconstpointer v_boxed) { stub_funcs.ptr_g_value_take_boxed(value, v_boxed); }
void (g_value_set_boxed_take_ownership)(GValue *value, gconstpointer v_boxed) { stub_funcs.ptr_g_value_set_boxed_take_ownership(value, v_boxed); }
gpointer (g_value_get_boxed)(const GValue *value) { return stub_funcs.ptr_g_value_get_boxed(value); }
gpointer (g_value_dup_boxed)(const GValue *value) { return stub_funcs.ptr_g_value_dup_boxed(value); }
GType (g_boxed_type_register_static)(const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free) { return stub_funcs.ptr_g_boxed_type_register_static(name, boxed_copy, boxed_free); }
GType (g_closure_get_type)(void) { return stub_funcs.ptr_g_closure_get_type(); }
GType (g_value_get_type)(void) { return stub_funcs.ptr_g_value_get_type(); }
GClosure* (g_cclosure_new_swap)(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data) { return stub_funcs.ptr_g_cclosure_new_swap(callback_func, user_data, destroy_data); }
GClosure* (g_signal_type_cclosure_new)(GType itype, guint struct_offset) { return stub_funcs.ptr_g_signal_type_cclosure_new(itype, struct_offset); }
GClosure* (g_closure_ref)(GClosure *closure) { return stub_funcs.ptr_g_closure_ref(closure); }
void (g_closure_sink)(GClosure *closure) { stub_funcs.ptr_g_closure_sink(closure); }
void (g_closure_unref)(GClosure *closure) { stub_funcs.ptr_g_closure_unref(closure); }
GClosure* (g_closure_new_simple)(guint sizeof_closure, gpointer data) { return stub_funcs.ptr_g_closure_new_simple(sizeof_closure, data); }
void (g_closure_add_finalize_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func) { stub_funcs.ptr_g_closure_add_finalize_notifier(closure, notify_data, notify_func); }
void (g_closure_remove_finalize_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func) { stub_funcs.ptr_g_closure_remove_finalize_notifier(closure, notify_data, notify_func); }
void (g_closure_add_invalidate_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func) { stub_funcs.ptr_g_closure_add_invalidate_notifier(closure, notify_data, notify_func); }
void (g_closure_remove_invalidate_notifier)(GClosure *closure, gpointer notify_data, GClosureNotify notify_func) { stub_funcs.ptr_g_closure_remove_invalidate_notifier(closure, notify_data, notify_func); }
void (g_closure_add_marshal_guards)(GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify) { stub_funcs.ptr_g_closure_add_marshal_guards(closure, pre_marshal_data, pre_marshal_notify, post_marshal_data, post_marshal_notify); }
void (g_closure_set_marshal)(GClosure *closure, GClosureMarshal marshal) { stub_funcs.ptr_g_closure_set_marshal(closure, marshal); }
void (g_closure_set_meta_marshal)(GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal) { stub_funcs.ptr_g_closure_set_meta_marshal(closure, marshal_data, meta_marshal); }
void (g_closure_invalidate)(GClosure *closure) { stub_funcs.ptr_g_closure_invalidate(closure); }
void (g_closure_invoke)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint) { stub_funcs.ptr_g_closure_invoke(closure, return_value, n_param_values, param_values, invocation_hint); }
void (g_cclosure_marshal_generic)(GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_generic(closure, return_gvalue, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_generic_va)(GClosure *closure, GValue *return_value, gpointer instance, va_list args_list, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_generic_va(closure, return_value, instance, args_list, marshal_data, n_params, param_types); }
GClosure* (g_cclosure_new)(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data) { return stub_funcs.ptr_g_cclosure_new(callback_func, user_data, destroy_data); }
GEnumValue* (g_enum_get_value)(GEnumClass *enum_class, gint value) { return stub_funcs.ptr_g_enum_get_value(enum_class, value); }
GEnumValue* (g_enum_get_value_by_name)(GEnumClass *enum_class, const gchar *name) { return stub_funcs.ptr_g_enum_get_value_by_name(enum_class, name); }
GEnumValue* (g_enum_get_value_by_nick)(GEnumClass *enum_class, const gchar *nick) { return stub_funcs.ptr_g_enum_get_value_by_nick(enum_class, nick); }
GFlagsValue* (g_flags_get_first_value)(GFlagsClass *flags_class, guint value) { return stub_funcs.ptr_g_flags_get_first_value(flags_class, value); }
GFlagsValue* (g_flags_get_value_by_name)(GFlagsClass *flags_class, const gchar *name) { return stub_funcs.ptr_g_flags_get_value_by_name(flags_class, name); }
GFlagsValue* (g_flags_get_value_by_nick)(GFlagsClass *flags_class, const gchar *nick) { return stub_funcs.ptr_g_flags_get_value_by_nick(flags_class, nick); }
gchar* (g_enum_to_string)(GType g_enum_type, gint value) { return stub_funcs.ptr_g_enum_to_string(g_enum_type, value); }
gchar* (g_flags_to_string)(GType flags_type, guint value) { return stub_funcs.ptr_g_flags_to_string(flags_type, value); }
void (g_value_set_enum)(GValue *value, gint v_enum) { stub_funcs.ptr_g_value_set_enum(value, v_enum); }
gint (g_value_get_enum)(const GValue *value) { return stub_funcs.ptr_g_value_get_enum(value); }
void (g_value_set_flags)(GValue *value, guint v_flags) { stub_funcs.ptr_g_value_set_flags(value, v_flags); }
guint (g_value_get_flags)(const GValue *value) { return stub_funcs.ptr_g_value_get_flags(value); }
GType (g_enum_register_static)(const gchar *name, const GEnumValue *const_static_values) { return stub_funcs.ptr_g_enum_register_static(name, const_static_values); }
GType (g_flags_register_static)(const gchar *name, const GFlagsValue *const_static_values) { return stub_funcs.ptr_g_flags_register_static(name, const_static_values); }
void (g_enum_complete_type_info)(GType g_enum_type, GTypeInfo *info, const GEnumValue *const_values) { stub_funcs.ptr_g_enum_complete_type_info(g_enum_type, info, const_values); }
void (g_flags_complete_type_info)(GType g_flags_type, GTypeInfo *info, const GFlagsValue *const_values) { stub_funcs.ptr_g_flags_complete_type_info(g_flags_type, info, const_values); }
GType (g_unicode_type_get_type)(void) { return stub_funcs.ptr_g_unicode_type_get_type(); }
GType (g_unicode_break_type_get_type)(void) { return stub_funcs.ptr_g_unicode_break_type_get_type(); }
GType (g_unicode_script_get_type)(void) { return stub_funcs.ptr_g_unicode_script_get_type(); }
GType (g_normalize_mode_get_type)(void) { return stub_funcs.ptr_g_normalize_mode_get_type(); }
GType (g_date_get_type)(void) { return stub_funcs.ptr_g_date_get_type(); }
GType (g_strv_get_type)(void) { return stub_funcs.ptr_g_strv_get_type(); }
GType (g_gstring_get_type)(void) { return stub_funcs.ptr_g_gstring_get_type(); }
GType (g_hash_table_get_type)(void) { return stub_funcs.ptr_g_hash_table_get_type(); }
GType (g_regex_get_type)(void) { return stub_funcs.ptr_g_regex_get_type(); }
GType (g_match_info_get_type)(void) { return stub_funcs.ptr_g_match_info_get_type(); }
GType (g_array_get_type)(void) { return stub_funcs.ptr_g_array_get_type(); }
GType (g_byte_array_get_type)(void) { return stub_funcs.ptr_g_byte_array_get_type(); }
GType (g_ptr_array_get_type)(void) { return stub_funcs.ptr_g_ptr_array_get_type(); }
GType (g_bytes_get_type)(void) { return stub_funcs.ptr_g_bytes_get_type(); }
GType (g_variant_type_get_gtype)(void) { return stub_funcs.ptr_g_variant_type_get_gtype(); }
GType (g_error_get_type)(void) { return stub_funcs.ptr_g_error_get_type(); }
GType (g_date_time_get_type)(void) { return stub_funcs.ptr_g_date_time_get_type(); }
GType (g_time_zone_get_type)(void) { return stub_funcs.ptr_g_time_zone_get_type(); }
GType (g_io_channel_get_type)(void) { return stub_funcs.ptr_g_io_channel_get_type(); }
GType (g_io_condition_get_type)(void) { return stub_funcs.ptr_g_io_condition_get_type(); }
GType (g_variant_builder_get_type)(void) { return stub_funcs.ptr_g_variant_builder_get_type(); }
GType (g_variant_dict_get_type)(void) { return stub_funcs.ptr_g_variant_dict_get_type(); }
GType (g_main_loop_get_type)(void) { return stub_funcs.ptr_g_main_loop_get_type(); }
GType (g_main_context_get_type)(void) { return stub_funcs.ptr_g_main_context_get_type(); }
GType (g_source_get_type)(void) { return stub_funcs.ptr_g_source_get_type(); }
GType (g_pollfd_get_type)(void) { return stub_funcs.ptr_g_pollfd_get_type(); }
GType (g_markup_parse_context_get_type)(void) { return stub_funcs.ptr_g_markup_parse_context_get_type(); }
GType (g_key_file_get_type)(void) { return stub_funcs.ptr_g_key_file_get_type(); }
GType (g_mapped_file_get_type)(void) { return stub_funcs.ptr_g_mapped_file_get_type(); }
GType (g_thread_get_type)(void) { return stub_funcs.ptr_g_thread_get_type(); }
GType (g_option_group_get_type)(void) { return stub_funcs.ptr_g_option_group_get_type(); }
GType (g_uri_get_type)(void) { return stub_funcs.ptr_g_uri_get_type(); }
GType (g_tree_get_type)(void) { return stub_funcs.ptr_g_tree_get_type(); }
GType (g_pattern_spec_get_type)(void) { return stub_funcs.ptr_g_pattern_spec_get_type(); }
GType (g_bookmark_file_get_type)(void) { return stub_funcs.ptr_g_bookmark_file_get_type(); }
GType (g_hmac_get_type)(void) { return stub_funcs.ptr_g_hmac_get_type(); }
GType (g_dir_get_type)(void) { return stub_funcs.ptr_g_dir_get_type(); }
GType (g_rand_get_type)(void) { return stub_funcs.ptr_g_rand_get_type(); }
GType (g_strv_builder_get_type)(void) { return stub_funcs.ptr_g_strv_builder_get_type(); }
GType (g_checksum_get_type)(void) { return stub_funcs.ptr_g_checksum_get_type(); }
GType (g_variant_get_gtype)(void) { return stub_funcs.ptr_g_variant_get_gtype(); }
void (g_cclosure_marshal_VOID__VOIDv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__VOIDv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__BOOLEAN)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__BOOLEAN(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__BOOLEANv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__BOOLEANv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__CHAR)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__CHAR(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__CHARv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__CHARv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__UCHAR)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__UCHAR(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__UCHARv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__UCHARv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__INT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__INT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__INTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__INTv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__UINT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__UINT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__UINTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__UINTv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__LONG)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__LONG(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__LONGv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__LONGv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__ULONG)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__ULONG(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__ULONGv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__ULONGv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__ENUM)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__ENUM(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__ENUMv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__ENUMv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__FLAGS)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__FLAGS(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__FLAGSv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__FLAGSv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__FLOAT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__FLOAT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__FLOATv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__FLOATv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__DOUBLE)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__DOUBLE(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__DOUBLEv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__DOUBLEv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__STRING)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__STRING(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__STRINGv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__STRINGv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__PARAM)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__PARAM(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__PARAMv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__PARAMv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__BOXED)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__BOXED(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__BOXEDv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__BOXEDv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__POINTER)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__POINTERv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__POINTERv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__OBJECT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__OBJECT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__OBJECTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__OBJECTv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__VARIANT)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__VARIANT(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__VARIANTv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__VARIANTv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__UINT_POINTER)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__UINT_POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_VOID__UINT_POINTERv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_VOID__UINT_POINTERv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_BOOLEAN__FLAGS)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__FLAGS(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_BOOLEAN__FLAGSv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__FLAGSv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_STRING__OBJECT_POINTER)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_STRING__OBJECT_POINTER(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_STRING__OBJECT_POINTERv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_STRING__OBJECT_POINTERv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_BOOLEAN__BOXED_BOXED)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
void (g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv)(GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types) { stub_funcs.ptr_g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure, return_value, instance, args, marshal_data, n_params, param_types); }
void (g_cclosure_marshal_VOID__VOID)(GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { stub_funcs.ptr_g_cclosure_marshal_VOID__VOID(closure, return_value, n_param_values, param_values, invocation_hint, marshal_data); }
GType (g_initially_unowned_get_type)(void) { return stub_funcs.ptr_g_initially_unowned_get_type(); }
void (g_object_class_install_property)(GObjectClass *oclass, guint property_id, GParamSpec *pspec) { stub_funcs.ptr_g_object_class_install_property(oclass, property_id, pspec); }
GParamSpec* (g_object_class_find_property)(GObjectClass *oclass, const gchar *property_name) { return stub_funcs.ptr_g_object_class_find_property(oclass, property_name); }
GParamSpec** (g_object_class_list_properties)(GObjectClass *oclass, guint *n_properties) { return stub_funcs.ptr_g_object_class_list_properties(oclass, n_properties); }
void (g_object_class_override_property)(GObjectClass *oclass, guint property_id, const gchar *name) { stub_funcs.ptr_g_object_class_override_property(oclass, property_id, name); }
void (g_object_class_install_properties)(GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs) { stub_funcs.ptr_g_object_class_install_properties(oclass, n_pspecs, pspecs); }
void (g_object_interface_install_property)(gpointer g_iface, GParamSpec *pspec) { stub_funcs.ptr_g_object_interface_install_property(g_iface, pspec); }
GParamSpec* (g_object_interface_find_property)(gpointer g_iface, const gchar *property_name) { return stub_funcs.ptr_g_object_interface_find_property(g_iface, property_name); }
GParamSpec** (g_object_interface_list_properties)(gpointer g_iface, guint *n_properties_p) { return stub_funcs.ptr_g_object_interface_list_properties(g_iface, n_properties_p); }
GType (g_object_get_type)(void) { return stub_funcs.ptr_g_object_get_type(); }
// Unable to locate va_equiv for g_object_new
GObject* (g_object_new_with_properties)(GType object_type, guint n_properties, const char *names[], const GValue values[]) { return stub_funcs.ptr_g_object_new_with_properties(object_type, n_properties, names, values); }
void (g_object_set)(gpointer object, const gchar *first_property_name, ...) { va_list vaargs; va_start(vaargs, first_property_name); stub_funcs.ptr_g_object_set_valist(object, first_property_name, vaargs); va_end(vaargs); }
void (g_object_get)(gpointer object, const gchar *first_property_name, ...) { va_list vaargs; va_start(vaargs, first_property_name); stub_funcs.ptr_g_object_get_valist(object, first_property_name, vaargs); va_end(vaargs); }
// Unable to locate va_equiv for g_object_connect
// Unable to locate va_equiv for g_object_disconnect
void (g_object_setv)(GObject *object, guint n_properties, const gchar *names[], const GValue values[]) { stub_funcs.ptr_g_object_setv(object, n_properties, names, values); }
void (g_object_set_valist)(GObject *object, const gchar *first_property_name, va_list var_args) { stub_funcs.ptr_g_object_set_valist(object, first_property_name, var_args); }
void (g_object_getv)(GObject *object, guint n_properties, const gchar *names[], GValue values[]) { stub_funcs.ptr_g_object_getv(object, n_properties, names, values); }
void (g_object_get_valist)(GObject *object, const gchar *first_property_name, va_list var_args) { stub_funcs.ptr_g_object_get_valist(object, first_property_name, var_args); }
void (g_object_set_property)(GObject *object, const gchar *property_name, const GValue *value) { stub_funcs.ptr_g_object_set_property(object, property_name, value); }
void (g_object_get_property)(GObject *object, const gchar *property_name, GValue *value) { stub_funcs.ptr_g_object_get_property(object, property_name, value); }
void (g_object_freeze_notify)(GObject *object) { stub_funcs.ptr_g_object_freeze_notify(object); }
void (g_object_notify)(GObject *object, const gchar *property_name) { stub_funcs.ptr_g_object_notify(object, property_name); }
void (g_object_notify_by_pspec)(GObject *object, GParamSpec *pspec) { stub_funcs.ptr_g_object_notify_by_pspec(object, pspec); }
void (g_object_thaw_notify)(GObject *object) { stub_funcs.ptr_g_object_thaw_notify(object); }
gboolean (g_object_is_floating)(gpointer object) { return stub_funcs.ptr_g_object_is_floating(object); }
gpointer (g_object_ref_sink)(gpointer object) { return stub_funcs.ptr_g_object_ref_sink(object); }
gpointer (g_object_take_ref)(gpointer object) { return stub_funcs.ptr_g_object_take_ref(object); }
gpointer (g_object_ref)(gpointer object) { return stub_funcs.ptr_g_object_ref(object); }
void (g_object_unref)(gpointer object) { stub_funcs.ptr_g_object_unref(object); }
void (g_object_weak_ref)(GObject *object, GWeakNotify notify, gpointer data) { stub_funcs.ptr_g_object_weak_ref(object, notify, data); }
void (g_object_weak_unref)(GObject *object, GWeakNotify notify, gpointer data) { stub_funcs.ptr_g_object_weak_unref(object, notify, data); }
void (g_object_add_weak_pointer)(GObject *object, gpointer *weak_pointer_location) { stub_funcs.ptr_g_object_add_weak_pointer(object, weak_pointer_location); }
void (g_object_remove_weak_pointer)(GObject *object, gpointer *weak_pointer_location) { stub_funcs.ptr_g_object_remove_weak_pointer(object, weak_pointer_location); }
void (g_object_add_toggle_ref)(GObject *object, GToggleNotify notify, gpointer data) { stub_funcs.ptr_g_object_add_toggle_ref(object, notify, data); }
void (g_object_remove_toggle_ref)(GObject *object, GToggleNotify notify, gpointer data) { stub_funcs.ptr_g_object_remove_toggle_ref(object, notify, data); }
gpointer (g_object_get_qdata)(GObject *object, GQuark quark) { return stub_funcs.ptr_g_object_get_qdata(object, quark); }
void (g_object_set_qdata)(GObject *object, GQuark quark, gpointer data) { stub_funcs.ptr_g_object_set_qdata(object, quark, data); }
void (g_object_set_qdata_full)(GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy) { stub_funcs.ptr_g_object_set_qdata_full(object, quark, data, destroy); }
gpointer (g_object_steal_qdata)(GObject *object, GQuark quark) { return stub_funcs.ptr_g_object_steal_qdata(object, quark); }
gpointer (g_object_dup_qdata)(GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data) { return stub_funcs.ptr_g_object_dup_qdata(object, quark, dup_func, user_data); }
gboolean (g_object_replace_qdata)(GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy) { return stub_funcs.ptr_g_object_replace_qdata(object, quark, oldval, newval, destroy, old_destroy); }
gpointer (g_object_get_data)(GObject *object, const gchar *key) { return stub_funcs.ptr_g_object_get_data(object, key); }
void (g_object_set_data)(GObject *object, const gchar *key, gpointer data) { stub_funcs.ptr_g_object_set_data(object, key, data); }
void (g_object_set_data_full)(GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy) { stub_funcs.ptr_g_object_set_data_full(object, key, data, destroy); }
gpointer (g_object_steal_data)(GObject *object, const gchar *key) { return stub_funcs.ptr_g_object_steal_data(object, key); }
gpointer (g_object_dup_data)(GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data) { return stub_funcs.ptr_g_object_dup_data(object, key, dup_func, user_data); }
gboolean (g_object_replace_data)(GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy) { return stub_funcs.ptr_g_object_replace_data(object, key, oldval, newval, destroy, old_destroy); }
void (g_object_watch_closure)(GObject *object, GClosure *closure) { stub_funcs.ptr_g_object_watch_closure(object, closure); }
GClosure* (g_cclosure_new_object)(GCallback callback_func, GObject *object) { return stub_funcs.ptr_g_cclosure_new_object(callback_func, object); }
GClosure* (g_cclosure_new_object_swap)(GCallback callback_func, GObject *object) { return stub_funcs.ptr_g_cclosure_new_object_swap(callback_func, object); }
GClosure* (g_closure_new_object)(guint sizeof_closure, GObject *object) { return stub_funcs.ptr_g_closure_new_object(sizeof_closure, object); }
void (g_value_set_object)(GValue *value, gpointer v_object) { stub_funcs.ptr_g_value_set_object(value, v_object); }
gpointer (g_value_get_object)(const GValue *value) { return stub_funcs.ptr_g_value_get_object(value); }
gpointer (g_value_dup_object)(const GValue *value) { return stub_funcs.ptr_g_value_dup_object(value); }
gulong (g_signal_connect_object)(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags) { return stub_funcs.ptr_g_signal_connect_object(instance, detailed_signal, c_handler, gobject, connect_flags); }
void (g_object_force_floating)(GObject *object) { stub_funcs.ptr_g_object_force_floating(object); }
void (g_object_run_dispose)(GObject *object) { stub_funcs.ptr_g_object_run_dispose(object); }
void (g_value_take_object)(GValue *value, gpointer v_object) { stub_funcs.ptr_g_value_take_object(value, v_object); }
void (g_value_set_object_take_ownership)(GValue *value, gpointer v_object) { stub_funcs.ptr_g_value_set_object_take_ownership(value, v_object); }
gsize (g_object_compat_control)(gsize what, gpointer data) { return stub_funcs.ptr_g_object_compat_control(what, data); }
void (g_clear_object)(GObject **object_ptr) { stub_funcs.ptr_g_clear_object(object_ptr); }
void (g_weak_ref_init)(GWeakRef *weak_ref, gpointer object) { stub_funcs.ptr_g_weak_ref_init(weak_ref, object); }
void (g_weak_ref_clear)(GWeakRef *weak_ref) { stub_funcs.ptr_g_weak_ref_clear(weak_ref); }
gpointer (g_weak_ref_get)(GWeakRef *weak_ref) { return stub_funcs.ptr_g_weak_ref_get(weak_ref); }
void (g_weak_ref_set)(GWeakRef *weak_ref, gpointer object) { stub_funcs.ptr_g_weak_ref_set(weak_ref, object); }
GParamSpec* (g_param_spec_ref)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_ref(pspec); }
void (g_param_spec_unref)(GParamSpec *pspec) { stub_funcs.ptr_g_param_spec_unref(pspec); }
void (g_param_spec_sink)(GParamSpec *pspec) { stub_funcs.ptr_g_param_spec_sink(pspec); }
GParamSpec* (g_param_spec_ref_sink)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_ref_sink(pspec); }
gpointer (g_param_spec_get_qdata)(GParamSpec *pspec, GQuark quark) { return stub_funcs.ptr_g_param_spec_get_qdata(pspec, quark); }
void (g_param_spec_set_qdata)(GParamSpec *pspec, GQuark quark, gpointer data) { stub_funcs.ptr_g_param_spec_set_qdata(pspec, quark, data); }
void (g_param_spec_set_qdata_full)(GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy) { stub_funcs.ptr_g_param_spec_set_qdata_full(pspec, quark, data, destroy); }
gpointer (g_param_spec_steal_qdata)(GParamSpec *pspec, GQuark quark) { return stub_funcs.ptr_g_param_spec_steal_qdata(pspec, quark); }
GParamSpec* (g_param_spec_get_redirect_target)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_get_redirect_target(pspec); }
void (g_param_value_set_default)(GParamSpec *pspec, GValue *value) { stub_funcs.ptr_g_param_value_set_default(pspec, value); }
gboolean (g_param_value_defaults)(GParamSpec *pspec, const GValue *value) { return stub_funcs.ptr_g_param_value_defaults(pspec, value); }
gboolean (g_param_value_validate)(GParamSpec *pspec, GValue *value) { return stub_funcs.ptr_g_param_value_validate(pspec, value); }
gboolean (g_param_value_is_valid)(GParamSpec *pspec, const GValue *value) { return stub_funcs.ptr_g_param_value_is_valid(pspec, value); }
gboolean (g_param_value_convert)(GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation) { return stub_funcs.ptr_g_param_value_convert(pspec, src_value, dest_value, strict_validation); }
gint (g_param_values_cmp)(GParamSpec *pspec, const GValue *value1, const GValue *value2) { return stub_funcs.ptr_g_param_values_cmp(pspec, value1, value2); }
const gchar * (g_param_spec_get_name)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_get_name(pspec); }
const gchar * (g_param_spec_get_nick)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_get_nick(pspec); }
const gchar * (g_param_spec_get_blurb)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_get_blurb(pspec); }
void (g_value_set_param)(GValue *value, GParamSpec *param) { stub_funcs.ptr_g_value_set_param(value, param); }
GParamSpec* (g_value_get_param)(const GValue *value) { return stub_funcs.ptr_g_value_get_param(value); }
GParamSpec* (g_value_dup_param)(const GValue *value) { return stub_funcs.ptr_g_value_dup_param(value); }
void (g_value_take_param)(GValue *value, GParamSpec *param) { stub_funcs.ptr_g_value_take_param(value, param); }
void (g_value_set_param_take_ownership)(GValue *value, GParamSpec *param) { stub_funcs.ptr_g_value_set_param_take_ownership(value, param); }
const GValue * (g_param_spec_get_default_value)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_get_default_value(pspec); }
GQuark (g_param_spec_get_name_quark)(GParamSpec *pspec) { return stub_funcs.ptr_g_param_spec_get_name_quark(pspec); }
GType (g_param_type_register_static)(const gchar *name, const GParamSpecTypeInfo *pspec_info) { return stub_funcs.ptr_g_param_type_register_static(name, pspec_info); }
gboolean (g_param_spec_is_valid_name)(const gchar *name) { return stub_funcs.ptr_g_param_spec_is_valid_name(name); }
GType (_g_param_type_register_static_constant)(const gchar *name, const GParamSpecTypeInfo *pspec_info, GType opt_type) { return stub_funcs.ptr__g_param_type_register_static_constant(name, pspec_info, opt_type); }
gpointer (g_param_spec_internal)(GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_internal(param_type, name, nick, blurb, flags); }
GParamSpecPool* (g_param_spec_pool_new)(gboolean type_prefixing) { return stub_funcs.ptr_g_param_spec_pool_new(type_prefixing); }
void (g_param_spec_pool_insert)(GParamSpecPool *pool, GParamSpec *pspec, GType owner_type) { stub_funcs.ptr_g_param_spec_pool_insert(pool, pspec, owner_type); }
void (g_param_spec_pool_remove)(GParamSpecPool *pool, GParamSpec *pspec) { stub_funcs.ptr_g_param_spec_pool_remove(pool, pspec); }
GParamSpec* (g_param_spec_pool_lookup)(GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors) { return stub_funcs.ptr_g_param_spec_pool_lookup(pool, param_name, owner_type, walk_ancestors); }
GList* (g_param_spec_pool_list_owned)(GParamSpecPool *pool, GType owner_type) { return stub_funcs.ptr_g_param_spec_pool_list_owned(pool, owner_type); }
GParamSpec** (g_param_spec_pool_list)(GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p) { return stub_funcs.ptr_g_param_spec_pool_list(pool, owner_type, n_pspecs_p); }
void (g_param_spec_pool_free)(GParamSpecPool *pool) { stub_funcs.ptr_g_param_spec_pool_free(pool); }
GParamSpec* (g_param_spec_char)(const gchar *name, const gchar *nick, const gchar *blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_char(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_uchar)(const gchar *name, const gchar *nick, const gchar *blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_uchar(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_boolean)(const gchar *name, const gchar *nick, const gchar *blurb, gboolean default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_boolean(name, nick, blurb, default_value, flags); }
GParamSpec* (g_param_spec_int)(const gchar *name, const gchar *nick, const gchar *blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_int(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_uint)(const gchar *name, const gchar *nick, const gchar *blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_uint(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_long)(const gchar *name, const gchar *nick, const gchar *blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_long(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_ulong)(const gchar *name, const gchar *nick, const gchar *blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_ulong(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_int64)(const gchar *name, const gchar *nick, const gchar *blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_int64(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_uint64)(const gchar *name, const gchar *nick, const gchar *blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_uint64(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_unichar)(const gchar *name, const gchar *nick, const gchar *blurb, gunichar default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_unichar(name, nick, blurb, default_value, flags); }
GParamSpec* (g_param_spec_enum)(const gchar *name, const gchar *nick, const gchar *blurb, GType enum_type, gint default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_enum(name, nick, blurb, enum_type, default_value, flags); }
GParamSpec* (g_param_spec_flags)(const gchar *name, const gchar *nick, const gchar *blurb, GType flags_type, guint default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_flags(name, nick, blurb, flags_type, default_value, flags); }
GParamSpec* (g_param_spec_float)(const gchar *name, const gchar *nick, const gchar *blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_float(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_double)(const gchar *name, const gchar *nick, const gchar *blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_double(name, nick, blurb, minimum, maximum, default_value, flags); }
GParamSpec* (g_param_spec_string)(const gchar *name, const gchar *nick, const gchar *blurb, const gchar *default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_string(name, nick, blurb, default_value, flags); }
GParamSpec* (g_param_spec_param)(const gchar *name, const gchar *nick, const gchar *blurb, GType param_type, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_param(name, nick, blurb, param_type, flags); }
GParamSpec* (g_param_spec_boxed)(const gchar *name, const gchar *nick, const gchar *blurb, GType boxed_type, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_boxed(name, nick, blurb, boxed_type, flags); }
GParamSpec* (g_param_spec_pointer)(const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_pointer(name, nick, blurb, flags); }
GParamSpec* (g_param_spec_value_array)(const gchar *name, const gchar *nick, const gchar *blurb, GParamSpec *element_spec, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_value_array(name, nick, blurb, element_spec, flags); }
GParamSpec* (g_param_spec_object)(const gchar *name, const gchar *nick, const gchar *blurb, GType object_type, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_object(name, nick, blurb, object_type, flags); }
GParamSpec* (g_param_spec_override)(const gchar *name, GParamSpec *overridden) { return stub_funcs.ptr_g_param_spec_override(name, overridden); }
GParamSpec* (g_param_spec_gtype)(const gchar *name, const gchar *nick, const gchar *blurb, GType is_a_type, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_gtype(name, nick, blurb, is_a_type, flags); }
GParamSpec* (g_param_spec_variant)(const gchar *name, const gchar *nick, const gchar *blurb, const GVariantType *type, GVariant *default_value, GParamFlags flags) { return stub_funcs.ptr_g_param_spec_variant(name, nick, blurb, type, default_value, flags); }
guint (g_signal_new_valist)(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args) { return stub_funcs.ptr_g_signal_new_valist(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, args); }
// Unable to locate va_equiv for g_signal_new_class_handler
void (g_signal_set_va_marshaller)(guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller) { stub_funcs.ptr_g_signal_set_va_marshaller(signal_id, instance_type, va_marshaller); }
void (g_signal_emitv)(const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value) { stub_funcs.ptr_g_signal_emitv(instance_and_params, signal_id, detail, return_value); }
void (g_signal_emit_valist)(gpointer instance, guint signal_id, GQuark detail, va_list var_args) { stub_funcs.ptr_g_signal_emit_valist(instance, signal_id, detail, var_args); }
void (g_signal_emit)(gpointer instance, guint signal_id, GQuark detail, ...) { va_list vaargs; va_start(vaargs, detail); stub_funcs.ptr_g_signal_emit_valist(instance, signal_id, detail, vaargs); va_end(vaargs); }
// Unable to locate va_equiv for g_signal_emit_by_name
guint (g_signal_lookup)(const gchar *name, GType itype) { return stub_funcs.ptr_g_signal_lookup(name, itype); }
const gchar * (g_signal_name)(guint signal_id) { return stub_funcs.ptr_g_signal_name(signal_id); }
void (g_signal_query)(guint signal_id, GSignalQuery *query) { stub_funcs.ptr_g_signal_query(signal_id, query); }
guint* (g_signal_list_ids)(GType itype, guint *n_ids) { return stub_funcs.ptr_g_signal_list_ids(itype, n_ids); }
gboolean (g_signal_is_valid_name)(const gchar *name) { return stub_funcs.ptr_g_signal_is_valid_name(name); }
gboolean (g_signal_parse_name)(const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark) { return stub_funcs.ptr_g_signal_parse_name(detailed_signal, itype, signal_id_p, detail_p, force_detail_quark); }
GSignalInvocationHint* (g_signal_get_invocation_hint)(gpointer instance) { return stub_funcs.ptr_g_signal_get_invocation_hint(instance); }
void (g_signal_stop_emission)(gpointer instance, guint signal_id, GQuark detail) { stub_funcs.ptr_g_signal_stop_emission(instance, signal_id, detail); }
void (g_signal_stop_emission_by_name)(gpointer instance, const gchar *detailed_signal) { stub_funcs.ptr_g_signal_stop_emission_by_name(instance, detailed_signal); }
gulong (g_signal_add_emission_hook)(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy) { return stub_funcs.ptr_g_signal_add_emission_hook(signal_id, detail, hook_func, hook_data, data_destroy); }
void (g_signal_remove_emission_hook)(guint signal_id, gulong hook_id) { stub_funcs.ptr_g_signal_remove_emission_hook(signal_id, hook_id); }
gboolean (g_signal_has_handler_pending)(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked) { return stub_funcs.ptr_g_signal_has_handler_pending(instance, signal_id, detail, may_be_blocked); }
gulong (g_signal_connect_closure_by_id)(gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after) { return stub_funcs.ptr_g_signal_connect_closure_by_id(instance, signal_id, detail, closure, after); }
gulong (g_signal_connect_closure)(gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after) { return stub_funcs.ptr_g_signal_connect_closure(instance, detailed_signal, closure, after); }
gulong (g_signal_connect_data)(gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags) { return stub_funcs.ptr_g_signal_connect_data(instance, detailed_signal, c_handler, data, destroy_data, connect_flags); }
void (g_signal_handler_block)(gpointer instance, gulong handler_id) { stub_funcs.ptr_g_signal_handler_block(instance, handler_id); }
void (g_signal_handler_unblock)(gpointer instance, gulong handler_id) { stub_funcs.ptr_g_signal_handler_unblock(instance, handler_id); }
void (g_signal_handler_disconnect)(gpointer instance, gulong handler_id) { stub_funcs.ptr_g_signal_handler_disconnect(instance, handler_id); }
gboolean (g_signal_handler_is_connected)(gpointer instance, gulong handler_id) { return stub_funcs.ptr_g_signal_handler_is_connected(instance, handler_id); }
gulong (g_signal_handler_find)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data) { return stub_funcs.ptr_g_signal_handler_find(instance, mask, signal_id, detail, closure, func, data); }
guint (g_signal_handlers_block_matched)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data) { return stub_funcs.ptr_g_signal_handlers_block_matched(instance, mask, signal_id, detail, closure, func, data); }
guint (g_signal_handlers_unblock_matched)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data) { return stub_funcs.ptr_g_signal_handlers_unblock_matched(instance, mask, signal_id, detail, closure, func, data); }
guint (g_signal_handlers_disconnect_matched)(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data) { return stub_funcs.ptr_g_signal_handlers_disconnect_matched(instance, mask, signal_id, detail, closure, func, data); }
void (g_clear_signal_handler)(gulong *handler_id_ptr, gpointer instance) { stub_funcs.ptr_g_clear_signal_handler(handler_id_ptr, instance); }
void (g_signal_override_class_closure)(guint signal_id, GType instance_type, GClosure *class_closure) { stub_funcs.ptr_g_signal_override_class_closure(signal_id, instance_type, class_closure); }
void (g_signal_override_class_handler)(const gchar *signal_name, GType instance_type, GCallback class_handler) { stub_funcs.ptr_g_signal_override_class_handler(signal_name, instance_type, class_handler); }
void (g_signal_chain_from_overridden)(const GValue *instance_and_params, GValue *return_value) { stub_funcs.ptr_g_signal_chain_from_overridden(instance_and_params, return_value); }
// Unable to locate va_equiv for g_signal_chain_from_overridden_handler
gboolean (g_signal_accumulator_true_handled)(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy) { return stub_funcs.ptr_g_signal_accumulator_true_handled(ihint, return_accu, handler_return, dummy); }
gboolean (g_signal_accumulator_first_wins)(GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy) { return stub_funcs.ptr_g_signal_accumulator_first_wins(ihint, return_accu, handler_return, dummy); }
void (g_signal_handlers_destroy)(gpointer instance) { stub_funcs.ptr_g_signal_handlers_destroy(instance); }
void (_g_signals_destroy)(GType itype) { stub_funcs.ptr__g_signals_destroy(itype); }
guint (g_signal_newv)(const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types) { return stub_funcs.ptr_g_signal_newv(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, param_types); }
GType (g_signal_group_get_type)(void) { return stub_funcs.ptr_g_signal_group_get_type(); }
GSignalGroup* (g_signal_group_new)(GType target_type) { return stub_funcs.ptr_g_signal_group_new(target_type); }
void (g_signal_group_set_target)(GSignalGroup *self, gpointer target) { stub_funcs.ptr_g_signal_group_set_target(self, target); }
gpointer (g_signal_group_dup_target)(GSignalGroup *self) { return stub_funcs.ptr_g_signal_group_dup_target(self); }
void (g_signal_group_block)(GSignalGroup *self) { stub_funcs.ptr_g_signal_group_block(self); }
void (g_signal_group_unblock)(GSignalGroup *self) { stub_funcs.ptr_g_signal_group_unblock(self); }
void (g_signal_group_connect_closure)(GSignalGroup *self, const gchar *detailed_signal, GClosure *closure, gboolean after) { stub_funcs.ptr_g_signal_group_connect_closure(self, detailed_signal, closure, after); }
void (g_signal_group_connect_object)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer object, GConnectFlags flags) { stub_funcs.ptr_g_signal_group_connect_object(self, detailed_signal, c_handler, object, flags); }
void (g_signal_group_connect_data)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify notify, GConnectFlags flags) { stub_funcs.ptr_g_signal_group_connect_data(self, detailed_signal, c_handler, data, notify, flags); }
void (g_signal_group_connect)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data) { stub_funcs.ptr_g_signal_group_connect(self, detailed_signal, c_handler, data); }
void (g_signal_group_connect_after)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data) { stub_funcs.ptr_g_signal_group_connect_after(self, detailed_signal, c_handler, data); }
void (g_signal_group_connect_swapped)(GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data) { stub_funcs.ptr_g_signal_group_connect_swapped(self, detailed_signal, c_handler, data); }
void (g_source_set_dummy_callback)(GSource *source) { stub_funcs.ptr_g_source_set_dummy_callback(source); }
void (g_source_set_closure)(GSource *source, GClosure *closure) { stub_funcs.ptr_g_source_set_closure(source, closure); }
void (g_type_init_with_debug_flags)(GTypeDebugFlags debug_flags) { stub_funcs.ptr_g_type_init_with_debug_flags(debug_flags); }
GQuark (g_type_qname)(GType type) { return stub_funcs.ptr_g_type_qname(type); }
GType (g_type_from_name)(const gchar *name) { return stub_funcs.ptr_g_type_from_name(name); }
GType (g_type_parent)(GType type) { return stub_funcs.ptr_g_type_parent(type); }
guint (g_type_depth)(GType type) { return stub_funcs.ptr_g_type_depth(type); }
GType (g_type_next_base)(GType leaf_type, GType root_type) { return stub_funcs.ptr_g_type_next_base(leaf_type, root_type); }
gboolean (g_type_is_a)(GType type, GType is_a_type) { return stub_funcs.ptr_g_type_is_a(type, is_a_type); }
gpointer (g_type_class_ref)(GType type) { return stub_funcs.ptr_g_type_class_ref(type); }
gpointer (g_type_class_peek)(GType type) { return stub_funcs.ptr_g_type_class_peek(type); }
gpointer (g_type_class_peek_static)(GType type) { return stub_funcs.ptr_g_type_class_peek_static(type); }
void (g_type_class_unref)(gpointer g_class) { stub_funcs.ptr_g_type_class_unref(g_class); }
gpointer (g_type_class_peek_parent)(gpointer g_class) { return stub_funcs.ptr_g_type_class_peek_parent(g_class); }
gpointer (g_type_interface_peek)(gpointer instance_class, GType iface_type) { return stub_funcs.ptr_g_type_interface_peek(instance_class, iface_type); }
gpointer (g_type_interface_peek_parent)(gpointer g_iface) { return stub_funcs.ptr_g_type_interface_peek_parent(g_iface); }
gpointer (g_type_default_interface_ref)(GType g_type) { return stub_funcs.ptr_g_type_default_interface_ref(g_type); }
gpointer (g_type_default_interface_peek)(GType g_type) { return stub_funcs.ptr_g_type_default_interface_peek(g_type); }
void (g_type_default_interface_unref)(gpointer g_iface) { stub_funcs.ptr_g_type_default_interface_unref(g_iface); }
GType* (g_type_children)(GType type, guint *n_children) { return stub_funcs.ptr_g_type_children(type, n_children); }
GType* (g_type_interfaces)(GType type, guint *n_interfaces) { return stub_funcs.ptr_g_type_interfaces(type, n_interfaces); }
void (g_type_set_qdata)(GType type, GQuark quark, gpointer data) { stub_funcs.ptr_g_type_set_qdata(type, quark, data); }
gpointer (g_type_get_qdata)(GType type, GQuark quark) { return stub_funcs.ptr_g_type_get_qdata(type, quark); }
void (g_type_query)(GType type, GTypeQuery *query) { stub_funcs.ptr_g_type_query(type, query); }
int (g_type_get_instance_count)(GType type) { return stub_funcs.ptr_g_type_get_instance_count(type); }
GType (g_type_register_static_simple)(GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags) { return stub_funcs.ptr_g_type_register_static_simple(parent_type, type_name, class_size, class_init, instance_size, instance_init, flags); }
GType (g_type_register_dynamic)(GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags) { return stub_funcs.ptr_g_type_register_dynamic(parent_type, type_name, plugin, flags); }
GType (g_type_register_fundamental)(GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags) { return stub_funcs.ptr_g_type_register_fundamental(type_id, type_name, info, finfo, flags); }
void (g_type_add_interface_static)(GType instance_type, GType interface_type, const GInterfaceInfo *info) { stub_funcs.ptr_g_type_add_interface_static(instance_type, interface_type, info); }
void (g_type_add_interface_dynamic)(GType instance_type, GType interface_type, GTypePlugin *plugin) { stub_funcs.ptr_g_type_add_interface_dynamic(instance_type, interface_type, plugin); }
void (g_type_interface_add_prerequisite)(GType interface_type, GType prerequisite_type) { stub_funcs.ptr_g_type_interface_add_prerequisite(interface_type, prerequisite_type); }
GType* (g_type_interface_prerequisites)(GType interface_type, guint *n_prerequisites) { return stub_funcs.ptr_g_type_interface_prerequisites(interface_type, n_prerequisites); }
GType (g_type_interface_instantiatable_prerequisite)(GType interface_type) { return stub_funcs.ptr_g_type_interface_instantiatable_prerequisite(interface_type); }
void (g_type_class_add_private)(gpointer g_class, gsize private_size) { stub_funcs.ptr_g_type_class_add_private(g_class, private_size); }
gint (g_type_add_instance_private)(GType class_type, gsize private_size) { return stub_funcs.ptr_g_type_add_instance_private(class_type, private_size); }
gpointer (g_type_instance_get_private)(GTypeInstance *instance, GType private_type) { return stub_funcs.ptr_g_type_instance_get_private(instance, private_type); }
void (g_type_class_adjust_private_offset)(gpointer g_class, gint *private_size_or_offset) { stub_funcs.ptr_g_type_class_adjust_private_offset(g_class, private_size_or_offset); }
void (g_type_add_class_private)(GType class_type, gsize private_size) { stub_funcs.ptr_g_type_add_class_private(class_type, private_size); }
gpointer (g_type_class_get_private)(GTypeClass *klass, GType private_type) { return stub_funcs.ptr_g_type_class_get_private(klass, private_type); }
gint (g_type_class_get_instance_private_offset)(gpointer g_class) { return stub_funcs.ptr_g_type_class_get_instance_private_offset(g_class); }
void (g_type_ensure)(GType type) { stub_funcs.ptr_g_type_ensure(type); }
guint (g_type_get_type_registration_serial)(void) { return stub_funcs.ptr_g_type_get_type_registration_serial(); }
GTypePlugin* (g_type_get_plugin)(GType type) { return stub_funcs.ptr_g_type_get_plugin(type); }
GTypePlugin* (g_type_interface_get_plugin)(GType instance_type, GType interface_type) { return stub_funcs.ptr_g_type_interface_get_plugin(instance_type, interface_type); }
GType (g_type_fundamental_next)(void) { return stub_funcs.ptr_g_type_fundamental_next(); }
GType (g_type_fundamental)(GType type_id) { return stub_funcs.ptr_g_type_fundamental(type_id); }
GTypeInstance* (g_type_create_instance)(GType type) { return stub_funcs.ptr_g_type_create_instance(type); }
void (g_type_free_instance)(GTypeInstance *instance) { stub_funcs.ptr_g_type_free_instance(instance); }
void (g_type_add_class_cache_func)(gpointer cache_data, GTypeClassCacheFunc cache_func) { stub_funcs.ptr_g_type_add_class_cache_func(cache_data, cache_func); }
void (g_type_remove_class_cache_func)(gpointer cache_data, GTypeClassCacheFunc cache_func) { stub_funcs.ptr_g_type_remove_class_cache_func(cache_data, cache_func); }
void (g_type_class_unref_uncached)(gpointer g_class) { stub_funcs.ptr_g_type_class_unref_uncached(g_class); }
void (g_type_add_interface_check)(gpointer check_data, GTypeInterfaceCheckFunc check_func) { stub_funcs.ptr_g_type_add_interface_check(check_data, check_func); }
void (g_type_remove_interface_check)(gpointer check_data, GTypeInterfaceCheckFunc check_func) { stub_funcs.ptr_g_type_remove_interface_check(check_data, check_func); }
GTypeValueTable* (g_type_value_table_peek)(GType type) { return stub_funcs.ptr_g_type_value_table_peek(type); }
gboolean (g_type_check_instance)(GTypeInstance *instance) { return stub_funcs.ptr_g_type_check_instance(instance); }
GTypeInstance* (g_type_check_instance_cast)(GTypeInstance *instance, GType iface_type) { return stub_funcs.ptr_g_type_check_instance_cast(instance, iface_type); }
gboolean (g_type_check_instance_is_a)(GTypeInstance *instance, GType iface_type) { return stub_funcs.ptr_g_type_check_instance_is_a(instance, iface_type); }
gboolean (g_type_check_instance_is_fundamentally_a)(GTypeInstance *instance, GType fundamental_type) { return stub_funcs.ptr_g_type_check_instance_is_fundamentally_a(instance, fundamental_type); }
GTypeClass* (g_type_check_class_cast)(GTypeClass *g_class, GType is_a_type) { return stub_funcs.ptr_g_type_check_class_cast(g_class, is_a_type); }
gboolean (g_type_check_class_is_a)(GTypeClass *g_class, GType is_a_type) { return stub_funcs.ptr_g_type_check_class_is_a(g_class, is_a_type); }
gboolean (g_type_check_is_value_type)(GType type) { return stub_funcs.ptr_g_type_check_is_value_type(type); }
gboolean (g_type_check_value)(const GValue *value) { return stub_funcs.ptr_g_type_check_value(value); }
gboolean (g_type_check_value_holds)(const GValue *value, GType type) { return stub_funcs.ptr_g_type_check_value_holds(value, type); }
gboolean (g_type_test_flags)(GType type, guint flags) { return stub_funcs.ptr_g_type_test_flags(type, flags); }
const gchar * (g_type_name_from_instance)(GTypeInstance *instance) { return stub_funcs.ptr_g_type_name_from_instance(instance); }
const gchar * (g_type_name_from_class)(GTypeClass *g_class) { return stub_funcs.ptr_g_type_name_from_class(g_class); }
GType (g_type_module_get_type)(void) { return stub_funcs.ptr_g_type_module_get_type(); }
gboolean (g_type_module_use)(GTypeModule *module) { return stub_funcs.ptr_g_type_module_use(module); }
void (g_type_module_unuse)(GTypeModule *module) { stub_funcs.ptr_g_type_module_unuse(module); }
void (g_type_module_set_name)(GTypeModule *module, const gchar *name) { stub_funcs.ptr_g_type_module_set_name(module, name); }
GType (g_type_module_register_type)(GTypeModule *module, GType parent_type, const gchar *type_name, const GTypeInfo *type_info, GTypeFlags flags) { return stub_funcs.ptr_g_type_module_register_type(module, parent_type, type_name, type_info, flags); }
void (g_type_module_add_interface)(GTypeModule *module, GType instance_type, GType interface_type, const GInterfaceInfo *interface_info) { stub_funcs.ptr_g_type_module_add_interface(module, instance_type, interface_type, interface_info); }
GType (g_type_module_register_enum)(GTypeModule *module, const gchar *name, const GEnumValue *const_static_values) { return stub_funcs.ptr_g_type_module_register_enum(module, name, const_static_values); }
GType (g_type_module_register_flags)(GTypeModule *module, const gchar *name, const GFlagsValue *const_static_values) { return stub_funcs.ptr_g_type_module_register_flags(module, name, const_static_values); }
GType (g_type_plugin_get_type)(void) { return stub_funcs.ptr_g_type_plugin_get_type(); }
void (g_type_plugin_use)(GTypePlugin *plugin) { stub_funcs.ptr_g_type_plugin_use(plugin); }
void (g_type_plugin_unuse)(GTypePlugin *plugin) { stub_funcs.ptr_g_type_plugin_unuse(plugin); }
void (g_type_plugin_complete_type_info)(GTypePlugin *plugin, GType g_type, GTypeInfo *info, GTypeValueTable *value_table) { stub_funcs.ptr_g_type_plugin_complete_type_info(plugin, g_type, info, value_table); }
void (g_type_plugin_complete_interface_info)(GTypePlugin *plugin, GType instance_type, GType interface_type, GInterfaceInfo *info) { stub_funcs.ptr_g_type_plugin_complete_interface_info(plugin, instance_type, interface_type, info); }
void (g_value_copy)(const GValue *src_value, GValue *dest_value) { stub_funcs.ptr_g_value_copy(src_value, dest_value); }
GValue* (g_value_reset)(GValue *value) { return stub_funcs.ptr_g_value_reset(value); }
void (g_value_unset)(GValue *value) { stub_funcs.ptr_g_value_unset(value); }
void (g_value_set_instance)(GValue *value, gpointer instance) { stub_funcs.ptr_g_value_set_instance(value, instance); }
void (g_value_init_from_instance)(GValue *value, gpointer instance) { stub_funcs.ptr_g_value_init_from_instance(value, instance); }
gboolean (g_value_fits_pointer)(const GValue *value) { return stub_funcs.ptr_g_value_fits_pointer(value); }
gpointer (g_value_peek_pointer)(const GValue *value) { return stub_funcs.ptr_g_value_peek_pointer(value); }
gboolean (g_value_type_compatible)(GType src_type, GType dest_type) { return stub_funcs.ptr_g_value_type_compatible(src_type, dest_type); }
gboolean (g_value_type_transformable)(GType src_type, GType dest_type) { return stub_funcs.ptr_g_value_type_transformable(src_type, dest_type); }
gboolean (g_value_transform)(const GValue *src_value, GValue *dest_value) { return stub_funcs.ptr_g_value_transform(src_value, dest_value); }
void (g_value_register_transform_func)(GType src_type, GType dest_type, GValueTransform transform_func) { stub_funcs.ptr_g_value_register_transform_func(src_type, dest_type, transform_func); }
GValue* (g_value_init)(GValue *value, GType g_type) { return stub_funcs.ptr_g_value_init(value, g_type); }
GType (g_value_array_get_type)(void) { return stub_funcs.ptr_g_value_array_get_type(); }
GValue* (g_value_array_get_nth)(GValueArray *value_array, guint index_) { return stub_funcs.ptr_g_value_array_get_nth(value_array, index_); }
GValueArray* (g_value_array_new)(guint n_prealloced) { return stub_funcs.ptr_g_value_array_new(n_prealloced); }
void (g_value_array_free)(GValueArray *value_array) { stub_funcs.ptr_g_value_array_free(value_array); }
GValueArray* (g_value_array_copy)(const GValueArray *value_array) { return stub_funcs.ptr_g_value_array_copy(value_array); }
GValueArray* (g_value_array_prepend)(GValueArray *value_array, const GValue *value) { return stub_funcs.ptr_g_value_array_prepend(value_array, value); }
GValueArray* (g_value_array_append)(GValueArray *value_array, const GValue *value) { return stub_funcs.ptr_g_value_array_append(value_array, value); }
GValueArray* (g_value_array_insert)(GValueArray *value_array, guint index_, const GValue *value) { return stub_funcs.ptr_g_value_array_insert(value_array, index_, value); }
GValueArray* (g_value_array_remove)(GValueArray *value_array, guint index_) { return stub_funcs.ptr_g_value_array_remove(value_array, index_); }
GValueArray* (g_value_array_sort)(GValueArray *value_array, GCompareFunc compare_func) { return stub_funcs.ptr_g_value_array_sort(value_array, compare_func); }
GValueArray* (g_value_array_sort_with_data)(GValueArray *value_array, GCompareDataFunc compare_func, gpointer user_data) { return stub_funcs.ptr_g_value_array_sort_with_data(value_array, compare_func, user_data); }
gchar (g_value_get_char)(const GValue *value) { return stub_funcs.ptr_g_value_get_char(value); }
void (g_value_set_schar)(GValue *value, gint8 v_char) { stub_funcs.ptr_g_value_set_schar(value, v_char); }
gint8 (g_value_get_schar)(const GValue *value) { return stub_funcs.ptr_g_value_get_schar(value); }
void (g_value_set_uchar)(GValue *value, guchar v_uchar) { stub_funcs.ptr_g_value_set_uchar(value, v_uchar); }
guchar (g_value_get_uchar)(const GValue *value) { return stub_funcs.ptr_g_value_get_uchar(value); }
void (g_value_set_boolean)(GValue *value, gboolean v_boolean) { stub_funcs.ptr_g_value_set_boolean(value, v_boolean); }
gboolean (g_value_get_boolean)(const GValue *value) { return stub_funcs.ptr_g_value_get_boolean(value); }
void (g_value_set_int)(GValue *value, gint v_int) { stub_funcs.ptr_g_value_set_int(value, v_int); }
gint (g_value_get_int)(const GValue *value) { return stub_funcs.ptr_g_value_get_int(value); }
void (g_value_set_uint)(GValue *value, guint v_uint) { stub_funcs.ptr_g_value_set_uint(value, v_uint); }
guint (g_value_get_uint)(const GValue *value) { return stub_funcs.ptr_g_value_get_uint(value); }
void (g_value_set_long)(GValue *value, glong v_long) { stub_funcs.ptr_g_value_set_long(value, v_long); }
glong (g_value_get_long)(const GValue *value) { return stub_funcs.ptr_g_value_get_long(value); }
void (g_value_set_ulong)(GValue *value, gulong v_ulong) { stub_funcs.ptr_g_value_set_ulong(value, v_ulong); }
gulong (g_value_get_ulong)(const GValue *value) { return stub_funcs.ptr_g_value_get_ulong(value); }
void (g_value_set_int64)(GValue *value, gint64 v_int64) { stub_funcs.ptr_g_value_set_int64(value, v_int64); }
gint64 (g_value_get_int64)(const GValue *value) { return stub_funcs.ptr_g_value_get_int64(value); }
void (g_value_set_uint64)(GValue *value, guint64 v_uint64) { stub_funcs.ptr_g_value_set_uint64(value, v_uint64); }
guint64 (g_value_get_uint64)(const GValue *value) { return stub_funcs.ptr_g_value_get_uint64(value); }
void (g_value_set_float)(GValue *value, gfloat v_float) { stub_funcs.ptr_g_value_set_float(value, v_float); }
gfloat (g_value_get_float)(const GValue *value) { return stub_funcs.ptr_g_value_get_float(value); }
void (g_value_set_double)(GValue *value, gdouble v_double) { stub_funcs.ptr_g_value_set_double(value, v_double); }
gdouble (g_value_get_double)(const GValue *value) { return stub_funcs.ptr_g_value_get_double(value); }
void (g_value_set_string)(GValue *value, const gchar *v_string) { stub_funcs.ptr_g_value_set_string(value, v_string); }
void (g_value_set_static_string)(GValue *value, const gchar *v_string) { stub_funcs.ptr_g_value_set_static_string(value, v_string); }
void (g_value_set_interned_string)(GValue *value, const gchar *v_string) { stub_funcs.ptr_g_value_set_interned_string(value, v_string); }
const gchar * (g_value_get_string)(const GValue *value) { return stub_funcs.ptr_g_value_get_string(value); }
gchar* (g_value_dup_string)(const GValue *value) { return stub_funcs.ptr_g_value_dup_string(value); }
gchar* (g_value_steal_string)(GValue *value) { return stub_funcs.ptr_g_value_steal_string(value); }
void (g_value_set_pointer)(GValue *value, gpointer v_pointer) { stub_funcs.ptr_g_value_set_pointer(value, v_pointer); }
gpointer (g_value_get_pointer)(const GValue *value) { return stub_funcs.ptr_g_value_get_pointer(value); }
GType (g_gtype_get_type)(void) { return stub_funcs.ptr_g_gtype_get_type(); }
void (g_value_set_gtype)(GValue *value, GType v_gtype) { stub_funcs.ptr_g_value_set_gtype(value, v_gtype); }
GType (g_value_get_gtype)(const GValue *value) { return stub_funcs.ptr_g_value_get_gtype(value); }
void (g_value_set_variant)(GValue *value, GVariant *variant) { stub_funcs.ptr_g_value_set_variant(value, variant); }
void (g_value_take_variant)(GValue *value, GVariant *variant) { stub_funcs.ptr_g_value_take_variant(value, variant); }
GVariant* (g_value_get_variant)(const GValue *value) { return stub_funcs.ptr_g_value_get_variant(value); }
GVariant* (g_value_dup_variant)(const GValue *value) { return stub_funcs.ptr_g_value_dup_variant(value); }
GType (g_pointer_type_register_static)(const gchar *name) { return stub_funcs.ptr_g_pointer_type_register_static(name); }
gchar* (g_strdup_value_contents)(const GValue *value) { return stub_funcs.ptr_g_strdup_value_contents(value); }
void (g_value_take_string)(GValue *value, gchar *v_string) { stub_funcs.ptr_g_value_take_string(value, v_string); }
void (g_value_set_string_take_ownership)(GValue *value, gchar *v_string) { stub_funcs.ptr_g_value_set_string_take_ownership(value, v_string); }
void (g_value_set_char)(GValue *value, gchar v_char) { stub_funcs.ptr_g_value_set_char(value, v_char); }
GType (g_action_get_type)(void) { return stub_funcs.ptr_g_action_get_type(); }
const gchar * (g_action_get_name)(GAction *action) { return stub_funcs.ptr_g_action_get_name(action); }
const GVariantType * (g_action_get_parameter_type)(GAction *action) { return stub_funcs.ptr_g_action_get_parameter_type(action); }
const GVariantType * (g_action_get_state_type)(GAction *action) { return stub_funcs.ptr_g_action_get_state_type(action); }
GVariant * (g_action_get_state_hint)(GAction *action) { return stub_funcs.ptr_g_action_get_state_hint(action); }
gboolean (g_action_get_enabled)(GAction *action) { return stub_funcs.ptr_g_action_get_enabled(action); }
GVariant * (g_action_get_state)(GAction *action) { return stub_funcs.ptr_g_action_get_state(action); }
void (g_action_change_state)(GAction *action, GVariant *value) { stub_funcs.ptr_g_action_change_state(action, value); }
void (g_action_activate)(GAction *action, GVariant *parameter) { stub_funcs.ptr_g_action_activate(action, parameter); }
gboolean (g_action_name_is_valid)(const gchar *action_name) { return stub_funcs.ptr_g_action_name_is_valid(action_name); }
gboolean (g_action_parse_detailed_name)(const gchar *detailed_name, gchar **action_name, GVariant **target_value, GError **error) { return stub_funcs.ptr_g_action_parse_detailed_name(detailed_name, action_name, target_value, error); }
gchar * (g_action_print_detailed_name)(const gchar *action_name, GVariant *target_value) { return stub_funcs.ptr_g_action_print_detailed_name(action_name, target_value); }
GType (g_action_group_get_type)(void) { return stub_funcs.ptr_g_action_group_get_type(); }
gboolean (g_action_group_has_action)(GActionGroup *action_group, const gchar *action_name) { return stub_funcs.ptr_g_action_group_has_action(action_group, action_name); }
gchar ** (g_action_group_list_actions)(GActionGroup *action_group) { return stub_funcs.ptr_g_action_group_list_actions(action_group); }
const GVariantType * (g_action_group_get_action_parameter_type)(GActionGroup *action_group, const gchar *action_name) { return stub_funcs.ptr_g_action_group_get_action_parameter_type(action_group, action_name); }
const GVariantType * (g_action_group_get_action_state_type)(GActionGroup *action_group, const gchar *action_name) { return stub_funcs.ptr_g_action_group_get_action_state_type(action_group, action_name); }
GVariant * (g_action_group_get_action_state_hint)(GActionGroup *action_group, const gchar *action_name) { return stub_funcs.ptr_g_action_group_get_action_state_hint(action_group, action_name); }
gboolean (g_action_group_get_action_enabled)(GActionGroup *action_group, const gchar *action_name) { return stub_funcs.ptr_g_action_group_get_action_enabled(action_group, action_name); }
GVariant * (g_action_group_get_action_state)(GActionGroup *action_group, const gchar *action_name) { return stub_funcs.ptr_g_action_group_get_action_state(action_group, action_name); }
void (g_action_group_change_action_state)(GActionGroup *action_group, const gchar *action_name, GVariant *value) { stub_funcs.ptr_g_action_group_change_action_state(action_group, action_name, value); }
void (g_action_group_activate_action)(GActionGroup *action_group, const gchar *action_name, GVariant *parameter) { stub_funcs.ptr_g_action_group_activate_action(action_group, action_name, parameter); }
void (g_action_group_action_added)(GActionGroup *action_group, const gchar *action_name) { stub_funcs.ptr_g_action_group_action_added(action_group, action_name); }
void (g_action_group_action_removed)(GActionGroup *action_group, const gchar *action_name) { stub_funcs.ptr_g_action_group_action_removed(action_group, action_name); }
void (g_action_group_action_enabled_changed)(GActionGroup *action_group, const gchar *action_name, gboolean enabled) { stub_funcs.ptr_g_action_group_action_enabled_changed(action_group, action_name, enabled); }
void (g_action_group_action_state_changed)(GActionGroup *action_group, const gchar *action_name, GVariant *state) { stub_funcs.ptr_g_action_group_action_state_changed(action_group, action_name, state); }
gboolean (g_action_group_query_action)(GActionGroup *action_group, const gchar *action_name, gboolean *enabled, const GVariantType **parameter_type, const GVariantType **state_type, GVariant **state_hint, GVariant **state) { return stub_funcs.ptr_g_action_group_query_action(action_group, action_name, enabled, parameter_type, state_type, state_hint, state); }
void (g_dbus_connection_unexport_action_group)(GDBusConnection *connection, guint export_id) { stub_funcs.ptr_g_dbus_connection_unexport_action_group(connection, export_id); }
guint (g_dbus_connection_export_action_group)(GDBusConnection *connection, const gchar *object_path, GActionGroup *action_group, GError **error) { return stub_funcs.ptr_g_dbus_connection_export_action_group(connection, object_path, action_group, error); }
GType (g_action_map_get_type)(void) { return stub_funcs.ptr_g_action_map_get_type(); }
GAction * (g_action_map_lookup_action)(GActionMap *action_map, const gchar *action_name) { return stub_funcs.ptr_g_action_map_lookup_action(action_map, action_name); }
void (g_action_map_add_action)(GActionMap *action_map, GAction *action) { stub_funcs.ptr_g_action_map_add_action(action_map, action); }
void (g_action_map_remove_action)(GActionMap *action_map, const gchar *action_name) { stub_funcs.ptr_g_action_map_remove_action(action_map, action_name); }
void (g_action_map_add_action_entries)(GActionMap *action_map, const GActionEntry *entries, gint n_entries, gpointer user_data) { stub_funcs.ptr_g_action_map_add_action_entries(action_map, entries, n_entries, user_data); }
void (g_action_map_remove_action_entries)(GActionMap *action_map, const GActionEntry *entries, gint n_entries) { stub_funcs.ptr_g_action_map_remove_action_entries(action_map, entries, n_entries); }
GType (g_app_info_get_type)(void) { return stub_funcs.ptr_g_app_info_get_type(); }
GType (g_app_launch_context_get_type)(void) { return stub_funcs.ptr_g_app_launch_context_get_type(); }
GAppInfo * (g_app_info_create_from_commandline)(const char *commandline, const char *application_name, GAppInfoCreateFlags flags, GError **error) { return stub_funcs.ptr_g_app_info_create_from_commandline(commandline, application_name, flags, error); }
GAppInfo * (g_app_info_dup)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_dup(appinfo); }
gboolean (g_app_info_equal)(GAppInfo *appinfo1, GAppInfo *appinfo2) { return stub_funcs.ptr_g_app_info_equal(appinfo1, appinfo2); }
const char* (g_app_info_get_id)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_id(appinfo); }
const char* (g_app_info_get_name)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_name(appinfo); }
const char* (g_app_info_get_display_name)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_display_name(appinfo); }
const char* (g_app_info_get_description)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_description(appinfo); }
const char* (g_app_info_get_executable)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_executable(appinfo); }
const char* (g_app_info_get_commandline)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_commandline(appinfo); }
GIcon * (g_app_info_get_icon)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_icon(appinfo); }
gboolean (g_app_info_launch)(GAppInfo *appinfo, GList *files, GAppLaunchContext *context, GError **error) { return stub_funcs.ptr_g_app_info_launch(appinfo, files, context, error); }
gboolean (g_app_info_supports_uris)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_supports_uris(appinfo); }
gboolean (g_app_info_supports_files)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_supports_files(appinfo); }
gboolean (g_app_info_launch_uris)(GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GError **error) { return stub_funcs.ptr_g_app_info_launch_uris(appinfo, uris, context, error); }
void (g_app_info_launch_uris_async)(GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_app_info_launch_uris_async(appinfo, uris, context, cancellable, callback, user_data); }
gboolean (g_app_info_launch_uris_finish)(GAppInfo *appinfo, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_app_info_launch_uris_finish(appinfo, result, error); }
gboolean (g_app_info_should_show)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_should_show(appinfo); }
gboolean (g_app_info_set_as_default_for_type)(GAppInfo *appinfo, const char *content_type, GError **error) { return stub_funcs.ptr_g_app_info_set_as_default_for_type(appinfo, content_type, error); }
gboolean (g_app_info_set_as_default_for_extension)(GAppInfo *appinfo, const char *extension, GError **error) { return stub_funcs.ptr_g_app_info_set_as_default_for_extension(appinfo, extension, error); }
gboolean (g_app_info_add_supports_type)(GAppInfo *appinfo, const char *content_type, GError **error) { return stub_funcs.ptr_g_app_info_add_supports_type(appinfo, content_type, error); }
gboolean (g_app_info_can_remove_supports_type)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_can_remove_supports_type(appinfo); }
gboolean (g_app_info_remove_supports_type)(GAppInfo *appinfo, const char *content_type, GError **error) { return stub_funcs.ptr_g_app_info_remove_supports_type(appinfo, content_type, error); }
const char** (g_app_info_get_supported_types)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_get_supported_types(appinfo); }
gboolean (g_app_info_can_delete)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_can_delete(appinfo); }
gboolean (g_app_info_delete)(GAppInfo *appinfo) { return stub_funcs.ptr_g_app_info_delete(appinfo); }
gboolean (g_app_info_set_as_last_used_for_type)(GAppInfo *appinfo, const char *content_type, GError **error) { return stub_funcs.ptr_g_app_info_set_as_last_used_for_type(appinfo, content_type, error); }
GList * (g_app_info_get_all)(void) { return stub_funcs.ptr_g_app_info_get_all(); }
GList * (g_app_info_get_all_for_type)(const char *content_type) { return stub_funcs.ptr_g_app_info_get_all_for_type(content_type); }
GList * (g_app_info_get_recommended_for_type)(const gchar *content_type) { return stub_funcs.ptr_g_app_info_get_recommended_for_type(content_type); }
GList * (g_app_info_get_fallback_for_type)(const gchar *content_type) { return stub_funcs.ptr_g_app_info_get_fallback_for_type(content_type); }
void (g_app_info_reset_type_associations)(const char *content_type) { stub_funcs.ptr_g_app_info_reset_type_associations(content_type); }
GAppInfo* (g_app_info_get_default_for_type)(const char *content_type, gboolean must_support_uris) { return stub_funcs.ptr_g_app_info_get_default_for_type(content_type, must_support_uris); }
void (g_app_info_get_default_for_type_async)(const char *content_type, gboolean must_support_uris, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_app_info_get_default_for_type_async(content_type, must_support_uris, cancellable, callback, user_data); }
GAppInfo* (g_app_info_get_default_for_type_finish)(GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_app_info_get_default_for_type_finish(result, error); }
GAppInfo* (g_app_info_get_default_for_uri_scheme)(const char *uri_scheme) { return stub_funcs.ptr_g_app_info_get_default_for_uri_scheme(uri_scheme); }
void (g_app_info_get_default_for_uri_scheme_async)(const char *uri_scheme, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_app_info_get_default_for_uri_scheme_async(uri_scheme, cancellable, callback, user_data); }
GAppInfo* (g_app_info_get_default_for_uri_scheme_finish)(GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_app_info_get_default_for_uri_scheme_finish(result, error); }
gboolean (g_app_info_launch_default_for_uri)(const char *uri, GAppLaunchContext *context, GError **error) { return stub_funcs.ptr_g_app_info_launch_default_for_uri(uri, context, error); }
void (g_app_info_launch_default_for_uri_async)(const char *uri, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_app_info_launch_default_for_uri_async(uri, context, cancellable, callback, user_data); }
gboolean (g_app_info_launch_default_for_uri_finish)(GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_app_info_launch_default_for_uri_finish(result, error); }
GAppLaunchContext* (g_app_launch_context_new)(void) { return stub_funcs.ptr_g_app_launch_context_new(); }
void (g_app_launch_context_setenv)(GAppLaunchContext *context, const char *variable, const char *value) { stub_funcs.ptr_g_app_launch_context_setenv(context, variable, value); }
void (g_app_launch_context_unsetenv)(GAppLaunchContext *context, const char *variable) { stub_funcs.ptr_g_app_launch_context_unsetenv(context, variable); }
char ** (g_app_launch_context_get_environment)(GAppLaunchContext *context) { return stub_funcs.ptr_g_app_launch_context_get_environment(context); }
char * (g_app_launch_context_get_display)(GAppLaunchContext *context, GAppInfo *info, GList *files) { return stub_funcs.ptr_g_app_launch_context_get_display(context, info, files); }
char * (g_app_launch_context_get_startup_notify_id)(GAppLaunchContext *context, GAppInfo *info, GList *files) { return stub_funcs.ptr_g_app_launch_context_get_startup_notify_id(context, info, files); }
void (g_app_launch_context_launch_failed)(GAppLaunchContext *context, const char * startup_notify_id) { stub_funcs.ptr_g_app_launch_context_launch_failed(context, startup_notify_id); }
GType (g_app_info_monitor_get_type)(void) { return stub_funcs.ptr_g_app_info_monitor_get_type(); }
GAppInfoMonitor * (g_app_info_monitor_get)(void) { return stub_funcs.ptr_g_app_info_monitor_get(); }
GType (g_application_get_type)(void) { return stub_funcs.ptr_g_application_get_type(); }
gboolean (g_application_id_is_valid)(const gchar *application_id) { return stub_funcs.ptr_g_application_id_is_valid(application_id); }
GApplication * (g_application_new)(const gchar *application_id, GApplicationFlags flags) { return stub_funcs.ptr_g_application_new(application_id, flags); }
const gchar * (g_application_get_application_id)(GApplication *application) { return stub_funcs.ptr_g_application_get_application_id(application); }
void (g_application_set_application_id)(GApplication *application, const gchar *application_id) { stub_funcs.ptr_g_application_set_application_id(application, application_id); }
const gchar * (g_application_get_version)(GApplication *application) { return stub_funcs.ptr_g_application_get_version(application); }
void (g_application_set_version)(GApplication *application, const gchar *version) { stub_funcs.ptr_g_application_set_version(application, version); }
GDBusConnection * (g_application_get_dbus_connection)(GApplication *application) { return stub_funcs.ptr_g_application_get_dbus_connection(application); }
const gchar * (g_application_get_dbus_object_path)(GApplication *application) { return stub_funcs.ptr_g_application_get_dbus_object_path(application); }
guint (g_application_get_inactivity_timeout)(GApplication *application) { return stub_funcs.ptr_g_application_get_inactivity_timeout(application); }
void (g_application_set_inactivity_timeout)(GApplication *application, guint inactivity_timeout) { stub_funcs.ptr_g_application_set_inactivity_timeout(application, inactivity_timeout); }
GApplicationFlags (g_application_get_flags)(GApplication *application) { return stub_funcs.ptr_g_application_get_flags(application); }
void (g_application_set_flags)(GApplication *application, GApplicationFlags flags) { stub_funcs.ptr_g_application_set_flags(application, flags); }
const gchar * (g_application_get_resource_base_path)(GApplication *application) { return stub_funcs.ptr_g_application_get_resource_base_path(application); }
void (g_application_set_resource_base_path)(GApplication *application, const gchar *resource_path) { stub_funcs.ptr_g_application_set_resource_base_path(application, resource_path); }
void (g_application_set_action_group)(GApplication *application, GActionGroup *action_group) { stub_funcs.ptr_g_application_set_action_group(application, action_group); }
void (g_application_add_main_option_entries)(GApplication *application, const GOptionEntry *entries) { stub_funcs.ptr_g_application_add_main_option_entries(application, entries); }
void (g_application_add_main_option)(GApplication *application, const char *long_name, char short_name, GOptionFlags flags, GOptionArg arg, const char *description, const char *arg_description) { stub_funcs.ptr_g_application_add_main_option(application, long_name, short_name, flags, arg, description, arg_description); }
void (g_application_add_option_group)(GApplication *application, GOptionGroup *group) { stub_funcs.ptr_g_application_add_option_group(application, group); }
void (g_application_set_option_context_parameter_string)(GApplication *application, const gchar *parameter_string) { stub_funcs.ptr_g_application_set_option_context_parameter_string(application, parameter_string); }
void (g_application_set_option_context_summary)(GApplication *application, const gchar *summary) { stub_funcs.ptr_g_application_set_option_context_summary(application, summary); }
void (g_application_set_option_context_description)(GApplication *application, const gchar *description) { stub_funcs.ptr_g_application_set_option_context_description(application, description); }
gboolean (g_application_get_is_registered)(GApplication *application) { return stub_funcs.ptr_g_application_get_is_registered(application); }
gboolean (g_application_get_is_remote)(GApplication *application) { return stub_funcs.ptr_g_application_get_is_remote(application); }
gboolean (g_application_register)(GApplication *application, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_application_register(application, cancellable, error); }
void (g_application_hold)(GApplication *application) { stub_funcs.ptr_g_application_hold(application); }
void (g_application_release)(GApplication *application) { stub_funcs.ptr_g_application_release(application); }
void (g_application_activate)(GApplication *application) { stub_funcs.ptr_g_application_activate(application); }
void (g_application_open)(GApplication *application, GFile **files, gint n_files, const gchar *hint) { stub_funcs.ptr_g_application_open(application, files, n_files, hint); }
int (g_application_run)(GApplication *application, int argc, char **argv) { return stub_funcs.ptr_g_application_run(application, argc, argv); }
void (g_application_quit)(GApplication *application) { stub_funcs.ptr_g_application_quit(application); }
GApplication * (g_application_get_default)(void) { return stub_funcs.ptr_g_application_get_default(); }
void (g_application_set_default)(GApplication *application) { stub_funcs.ptr_g_application_set_default(application); }
void (g_application_mark_busy)(GApplication *application) { stub_funcs.ptr_g_application_mark_busy(application); }
void (g_application_unmark_busy)(GApplication *application) { stub_funcs.ptr_g_application_unmark_busy(application); }
gboolean (g_application_get_is_busy)(GApplication *application) { return stub_funcs.ptr_g_application_get_is_busy(application); }
void (g_application_send_notification)(GApplication *application, const gchar *id, GNotification *notification) { stub_funcs.ptr_g_application_send_notification(application, id, notification); }
void (g_application_withdraw_notification)(GApplication *application, const gchar *id) { stub_funcs.ptr_g_application_withdraw_notification(application, id); }
void (g_application_bind_busy_property)(GApplication *application, gpointer object, const gchar *property) { stub_funcs.ptr_g_application_bind_busy_property(application, object, property); }
void (g_application_unbind_busy_property)(GApplication *application, gpointer object, const gchar *property) { stub_funcs.ptr_g_application_unbind_busy_property(application, object, property); }
GType (g_application_command_line_get_type)(void) { return stub_funcs.ptr_g_application_command_line_get_type(); }
gchar ** (g_application_command_line_get_arguments)(GApplicationCommandLine *cmdline, int *argc) { return stub_funcs.ptr_g_application_command_line_get_arguments(cmdline, argc); }
GVariantDict * (g_application_command_line_get_options_dict)(GApplicationCommandLine *cmdline) { return stub_funcs.ptr_g_application_command_line_get_options_dict(cmdline); }
GInputStream * (g_application_command_line_get_stdin)(GApplicationCommandLine *cmdline) { return stub_funcs.ptr_g_application_command_line_get_stdin(cmdline); }
const gchar * const * (g_application_command_line_get_environ)(GApplicationCommandLine *cmdline) { return stub_funcs.ptr_g_application_command_line_get_environ(cmdline); }
const gchar * (g_application_command_line_getenv)(GApplicationCommandLine *cmdline, const gchar *name) { return stub_funcs.ptr_g_application_command_line_getenv(cmdline, name); }
const gchar * (g_application_command_line_get_cwd)(GApplicationCommandLine *cmdline) { return stub_funcs.ptr_g_application_command_line_get_cwd(cmdline); }
gboolean (g_application_command_line_get_is_remote)(GApplicationCommandLine *cmdline) { return stub_funcs.ptr_g_application_command_line_get_is_remote(cmdline); }
void (g_application_command_line_print_literal)(GApplicationCommandLine *cmdline, const gchar *message) { stub_funcs.ptr_g_application_command_line_print_literal(cmdline, message); }
void (g_application_command_line_printerr_literal)(GApplicationCommandLine *cmdline, const gchar *message) { stub_funcs.ptr_g_application_command_line_printerr_literal(cmdline, message); }
// Unable to locate va_equiv for g_application_command_line_print
// Unable to locate va_equiv for g_application_command_line_printerr
int (g_application_command_line_get_exit_status)(GApplicationCommandLine *cmdline) { return stub_funcs.ptr_g_application_command_line_get_exit_status(cmdline); }
void (g_application_command_line_set_exit_status)(GApplicationCommandLine *cmdline, int exit_status) { stub_funcs.ptr_g_application_command_line_set_exit_status(cmdline, exit_status); }
GVariant * (g_application_command_line_get_platform_data)(GApplicationCommandLine *cmdline) { return stub_funcs.ptr_g_application_command_line_get_platform_data(cmdline); }
GFile * (g_application_command_line_create_file_for_arg)(GApplicationCommandLine *cmdline, const gchar *arg) { return stub_funcs.ptr_g_application_command_line_create_file_for_arg(cmdline, arg); }
void (g_application_command_line_done)(GApplicationCommandLine *cmdline) { stub_funcs.ptr_g_application_command_line_done(cmdline); }
GType (g_async_initable_get_type)(void) { return stub_funcs.ptr_g_async_initable_get_type(); }
void (g_async_initable_init_async)(GAsyncInitable *initable, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_async_initable_init_async(initable, io_priority, cancellable, callback, user_data); }
gboolean (g_async_initable_init_finish)(GAsyncInitable *initable, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_async_initable_init_finish(initable, res, error); }
// Unable to locate va_equiv for g_async_initable_new_async
GObject* (g_async_initable_new_finish)(GAsyncInitable *initable, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_async_initable_new_finish(initable, res, error); }
GType (g_async_result_get_type)(void) { return stub_funcs.ptr_g_async_result_get_type(); }
gpointer (g_async_result_get_user_data)(GAsyncResult *res) { return stub_funcs.ptr_g_async_result_get_user_data(res); }
GObject* (g_async_result_get_source_object)(GAsyncResult *res) { return stub_funcs.ptr_g_async_result_get_source_object(res); }
gboolean (g_async_result_legacy_propagate_error)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_async_result_legacy_propagate_error(res, error); }
gboolean (g_async_result_is_tagged)(GAsyncResult *res, gpointer source_tag) { return stub_funcs.ptr_g_async_result_is_tagged(res, source_tag); }
GType (g_buffered_input_stream_get_type)(void) { return stub_funcs.ptr_g_buffered_input_stream_get_type(); }
GInputStream* (g_buffered_input_stream_new)(GInputStream *base_stream) { return stub_funcs.ptr_g_buffered_input_stream_new(base_stream); }
GInputStream* (g_buffered_input_stream_new_sized)(GInputStream *base_stream, gsize size) { return stub_funcs.ptr_g_buffered_input_stream_new_sized(base_stream, size); }
gsize (g_buffered_input_stream_get_buffer_size)(GBufferedInputStream *stream) { return stub_funcs.ptr_g_buffered_input_stream_get_buffer_size(stream); }
void (g_buffered_input_stream_set_buffer_size)(GBufferedInputStream *stream, gsize size) { stub_funcs.ptr_g_buffered_input_stream_set_buffer_size(stream, size); }
gsize (g_buffered_input_stream_get_available)(GBufferedInputStream *stream) { return stub_funcs.ptr_g_buffered_input_stream_get_available(stream); }
gsize (g_buffered_input_stream_peek)(GBufferedInputStream *stream, void *buffer, gsize offset, gsize count) { return stub_funcs.ptr_g_buffered_input_stream_peek(stream, buffer, offset, count); }
const void* (g_buffered_input_stream_peek_buffer)(GBufferedInputStream *stream, gsize *count) { return stub_funcs.ptr_g_buffered_input_stream_peek_buffer(stream, count); }
gssize (g_buffered_input_stream_fill)(GBufferedInputStream *stream, gssize count, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_buffered_input_stream_fill(stream, count, cancellable, error); }
void (g_buffered_input_stream_fill_async)(GBufferedInputStream *stream, gssize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_buffered_input_stream_fill_async(stream, count, io_priority, cancellable, callback, user_data); }
gssize (g_buffered_input_stream_fill_finish)(GBufferedInputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_buffered_input_stream_fill_finish(stream, result, error); }
int (g_buffered_input_stream_read_byte)(GBufferedInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_buffered_input_stream_read_byte(stream, cancellable, error); }
GType (g_buffered_output_stream_get_type)(void) { return stub_funcs.ptr_g_buffered_output_stream_get_type(); }
GOutputStream* (g_buffered_output_stream_new)(GOutputStream *base_stream) { return stub_funcs.ptr_g_buffered_output_stream_new(base_stream); }
GOutputStream* (g_buffered_output_stream_new_sized)(GOutputStream *base_stream, gsize size) { return stub_funcs.ptr_g_buffered_output_stream_new_sized(base_stream, size); }
gsize (g_buffered_output_stream_get_buffer_size)(GBufferedOutputStream *stream) { return stub_funcs.ptr_g_buffered_output_stream_get_buffer_size(stream); }
void (g_buffered_output_stream_set_buffer_size)(GBufferedOutputStream *stream, gsize size) { stub_funcs.ptr_g_buffered_output_stream_set_buffer_size(stream, size); }
gboolean (g_buffered_output_stream_get_auto_grow)(GBufferedOutputStream *stream) { return stub_funcs.ptr_g_buffered_output_stream_get_auto_grow(stream); }
void (g_buffered_output_stream_set_auto_grow)(GBufferedOutputStream *stream, gboolean auto_grow) { stub_funcs.ptr_g_buffered_output_stream_set_auto_grow(stream, auto_grow); }
GType (g_bytes_icon_get_type)(void) { return stub_funcs.ptr_g_bytes_icon_get_type(); }
GIcon * (g_bytes_icon_new)(GBytes *bytes) { return stub_funcs.ptr_g_bytes_icon_new(bytes); }
GBytes * (g_bytes_icon_get_bytes)(GBytesIcon *icon) { return stub_funcs.ptr_g_bytes_icon_get_bytes(icon); }
GType (g_cancellable_get_type)(void) { return stub_funcs.ptr_g_cancellable_get_type(); }
GCancellable* (g_cancellable_new)(void) { return stub_funcs.ptr_g_cancellable_new(); }
gboolean (g_cancellable_is_cancelled)(GCancellable *cancellable) { return stub_funcs.ptr_g_cancellable_is_cancelled(cancellable); }
gboolean (g_cancellable_set_error_if_cancelled)(GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_cancellable_set_error_if_cancelled(cancellable, error); }
int (g_cancellable_get_fd)(GCancellable *cancellable) { return stub_funcs.ptr_g_cancellable_get_fd(cancellable); }
gboolean (g_cancellable_make_pollfd)(GCancellable *cancellable, GPollFD *pollfd) { return stub_funcs.ptr_g_cancellable_make_pollfd(cancellable, pollfd); }
void (g_cancellable_release_fd)(GCancellable *cancellable) { stub_funcs.ptr_g_cancellable_release_fd(cancellable); }
GSource * (g_cancellable_source_new)(GCancellable *cancellable) { return stub_funcs.ptr_g_cancellable_source_new(cancellable); }
GCancellable* (g_cancellable_get_current)(void) { return stub_funcs.ptr_g_cancellable_get_current(); }
void (g_cancellable_push_current)(GCancellable *cancellable) { stub_funcs.ptr_g_cancellable_push_current(cancellable); }
void (g_cancellable_pop_current)(GCancellable *cancellable) { stub_funcs.ptr_g_cancellable_pop_current(cancellable); }
void (g_cancellable_reset)(GCancellable *cancellable) { stub_funcs.ptr_g_cancellable_reset(cancellable); }
gulong (g_cancellable_connect)(GCancellable *cancellable, GCallback callback, gpointer data, GDestroyNotify data_destroy_func) { return stub_funcs.ptr_g_cancellable_connect(cancellable, callback, data, data_destroy_func); }
void (g_cancellable_disconnect)(GCancellable *cancellable, gulong handler_id) { stub_funcs.ptr_g_cancellable_disconnect(cancellable, handler_id); }
void (g_cancellable_cancel)(GCancellable *cancellable) { stub_funcs.ptr_g_cancellable_cancel(cancellable); }
GType (g_charset_converter_get_type)(void) { return stub_funcs.ptr_g_charset_converter_get_type(); }
GCharsetConverter* (g_charset_converter_new)(const gchar *to_charset, const gchar *from_charset, GError **error) { return stub_funcs.ptr_g_charset_converter_new(to_charset, from_charset, error); }
void (g_charset_converter_set_use_fallback)(GCharsetConverter *converter, gboolean use_fallback) { stub_funcs.ptr_g_charset_converter_set_use_fallback(converter, use_fallback); }
gboolean (g_charset_converter_get_use_fallback)(GCharsetConverter *converter) { return stub_funcs.ptr_g_charset_converter_get_use_fallback(converter); }
guint (g_charset_converter_get_num_fallbacks)(GCharsetConverter *converter) { return stub_funcs.ptr_g_charset_converter_get_num_fallbacks(converter); }
gboolean (g_content_type_is_a)(const gchar *type, const gchar *supertype) { return stub_funcs.ptr_g_content_type_is_a(type, supertype); }
gboolean (g_content_type_is_mime_type)(const gchar *type, const gchar *mime_type) { return stub_funcs.ptr_g_content_type_is_mime_type(type, mime_type); }
gboolean (g_content_type_is_unknown)(const gchar *type) { return stub_funcs.ptr_g_content_type_is_unknown(type); }
gchar * (g_content_type_get_description)(const gchar *type) { return stub_funcs.ptr_g_content_type_get_description(type); }
gchar * (g_content_type_get_mime_type)(const gchar *type) { return stub_funcs.ptr_g_content_type_get_mime_type(type); }
GIcon * (g_content_type_get_icon)(const gchar *type) { return stub_funcs.ptr_g_content_type_get_icon(type); }
GIcon * (g_content_type_get_symbolic_icon)(const gchar *type) { return stub_funcs.ptr_g_content_type_get_symbolic_icon(type); }
gchar * (g_content_type_get_generic_icon_name)(const gchar *type) { return stub_funcs.ptr_g_content_type_get_generic_icon_name(type); }
gboolean (g_content_type_can_be_executable)(const gchar *type) { return stub_funcs.ptr_g_content_type_can_be_executable(type); }
gchar * (g_content_type_from_mime_type)(const gchar *mime_type) { return stub_funcs.ptr_g_content_type_from_mime_type(mime_type); }
gchar * (g_content_type_guess)(const gchar *filename, const guchar *data, gsize data_size, gboolean *result_uncertain) { return stub_funcs.ptr_g_content_type_guess(filename, data, data_size, result_uncertain); }
gchar ** (g_content_type_guess_for_tree)(GFile *root) { return stub_funcs.ptr_g_content_type_guess_for_tree(root); }
GList * (g_content_types_get_registered)(void) { return stub_funcs.ptr_g_content_types_get_registered(); }
const gchar * const* (g_content_type_get_mime_dirs)(void) { return stub_funcs.ptr_g_content_type_get_mime_dirs(); }
void (g_content_type_set_mime_dirs)(const gchar * const *dirs) { stub_funcs.ptr_g_content_type_set_mime_dirs(dirs); }
gboolean (g_content_type_equals)(const gchar *type1, const gchar *type2) { return stub_funcs.ptr_g_content_type_equals(type1, type2); }
GType (g_converter_get_type)(void) { return stub_funcs.ptr_g_converter_get_type(); }
GConverterResult (g_converter_convert)(GConverter *converter, const void *inbuf, gsize inbuf_size, void *outbuf, gsize outbuf_size, GConverterFlags flags, gsize *bytes_read, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_converter_convert(converter, inbuf, inbuf_size, outbuf, outbuf_size, flags, bytes_read, bytes_written, error); }
void (g_converter_reset)(GConverter *converter) { stub_funcs.ptr_g_converter_reset(converter); }
GType (g_converter_input_stream_get_type)(void) { return stub_funcs.ptr_g_converter_input_stream_get_type(); }
GInputStream* (g_converter_input_stream_new)(GInputStream *base_stream, GConverter *converter) { return stub_funcs.ptr_g_converter_input_stream_new(base_stream, converter); }
GConverter* (g_converter_input_stream_get_converter)(GConverterInputStream *converter_stream) { return stub_funcs.ptr_g_converter_input_stream_get_converter(converter_stream); }
GType (g_converter_output_stream_get_type)(void) { return stub_funcs.ptr_g_converter_output_stream_get_type(); }
GOutputStream* (g_converter_output_stream_new)(GOutputStream *base_stream, GConverter *converter) { return stub_funcs.ptr_g_converter_output_stream_new(base_stream, converter); }
GConverter* (g_converter_output_stream_get_converter)(GConverterOutputStream *converter_stream) { return stub_funcs.ptr_g_converter_output_stream_get_converter(converter_stream); }
GType (g_credentials_get_type)(void) { return stub_funcs.ptr_g_credentials_get_type(); }
GCredentials* (g_credentials_new)(void) { return stub_funcs.ptr_g_credentials_new(); }
gchar* (g_credentials_to_string)(GCredentials *credentials) { return stub_funcs.ptr_g_credentials_to_string(credentials); }
gpointer (g_credentials_get_native)(GCredentials *credentials, GCredentialsType native_type) { return stub_funcs.ptr_g_credentials_get_native(credentials, native_type); }
void (g_credentials_set_native)(GCredentials *credentials, GCredentialsType native_type, gpointer native) { stub_funcs.ptr_g_credentials_set_native(credentials, native_type, native); }
gboolean (g_credentials_is_same_user)(GCredentials *credentials, GCredentials *other_credentials, GError **error) { return stub_funcs.ptr_g_credentials_is_same_user(credentials, other_credentials, error); }
pid_t (g_credentials_get_unix_pid)(GCredentials *credentials, GError **error) { return stub_funcs.ptr_g_credentials_get_unix_pid(credentials, error); }
uid_t (g_credentials_get_unix_user)(GCredentials *credentials, GError **error) { return stub_funcs.ptr_g_credentials_get_unix_user(credentials, error); }
gboolean (g_credentials_set_unix_user)(GCredentials *credentials, uid_t uid, GError **error) { return stub_funcs.ptr_g_credentials_set_unix_user(credentials, uid, error); }
GType (g_datagram_based_get_type)(void) { return stub_funcs.ptr_g_datagram_based_get_type(); }
gint (g_datagram_based_receive_messages)(GDatagramBased *datagram_based, GInputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_datagram_based_receive_messages(datagram_based, messages, num_messages, flags, timeout, cancellable, error); }
gint (g_datagram_based_send_messages)(GDatagramBased *datagram_based, GOutputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_datagram_based_send_messages(datagram_based, messages, num_messages, flags, timeout, cancellable, error); }
GSource * (g_datagram_based_create_source)(GDatagramBased *datagram_based, GIOCondition condition, GCancellable *cancellable) { return stub_funcs.ptr_g_datagram_based_create_source(datagram_based, condition, cancellable); }
GIOCondition (g_datagram_based_condition_check)(GDatagramBased *datagram_based, GIOCondition condition) { return stub_funcs.ptr_g_datagram_based_condition_check(datagram_based, condition); }
gboolean (g_datagram_based_condition_wait)(GDatagramBased *datagram_based, GIOCondition condition, gint64 timeout, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_datagram_based_condition_wait(datagram_based, condition, timeout, cancellable, error); }
GType (g_data_input_stream_get_type)(void) { return stub_funcs.ptr_g_data_input_stream_get_type(); }
GDataInputStream * (g_data_input_stream_new)(GInputStream *base_stream) { return stub_funcs.ptr_g_data_input_stream_new(base_stream); }
void (g_data_input_stream_set_byte_order)(GDataInputStream *stream, GDataStreamByteOrder order) { stub_funcs.ptr_g_data_input_stream_set_byte_order(stream, order); }
GDataStreamByteOrder (g_data_input_stream_get_byte_order)(GDataInputStream *stream) { return stub_funcs.ptr_g_data_input_stream_get_byte_order(stream); }
void (g_data_input_stream_set_newline_type)(GDataInputStream *stream, GDataStreamNewlineType type) { stub_funcs.ptr_g_data_input_stream_set_newline_type(stream, type); }
GDataStreamNewlineType (g_data_input_stream_get_newline_type)(GDataInputStream *stream) { return stub_funcs.ptr_g_data_input_stream_get_newline_type(stream); }
guchar (g_data_input_stream_read_byte)(GDataInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_byte(stream, cancellable, error); }
gint16 (g_data_input_stream_read_int16)(GDataInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_int16(stream, cancellable, error); }
guint16 (g_data_input_stream_read_uint16)(GDataInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_uint16(stream, cancellable, error); }
gint32 (g_data_input_stream_read_int32)(GDataInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_int32(stream, cancellable, error); }
guint32 (g_data_input_stream_read_uint32)(GDataInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_uint32(stream, cancellable, error); }
gint64 (g_data_input_stream_read_int64)(GDataInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_int64(stream, cancellable, error); }
guint64 (g_data_input_stream_read_uint64)(GDataInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_uint64(stream, cancellable, error); }
char * (g_data_input_stream_read_line)(GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_line(stream, length, cancellable, error); }
char * (g_data_input_stream_read_line_utf8)(GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_line_utf8(stream, length, cancellable, error); }
void (g_data_input_stream_read_line_async)(GDataInputStream *stream, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_data_input_stream_read_line_async(stream, io_priority, cancellable, callback, user_data); }
char * (g_data_input_stream_read_line_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_line_finish(stream, result, length, error); }
char * (g_data_input_stream_read_line_finish_utf8)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_line_finish_utf8(stream, result, length, error); }
char * (g_data_input_stream_read_until)(GDataInputStream *stream, const gchar *stop_chars, gsize *length, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_until(stream, stop_chars, length, cancellable, error); }
void (g_data_input_stream_read_until_async)(GDataInputStream *stream, const gchar *stop_chars, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_data_input_stream_read_until_async(stream, stop_chars, io_priority, cancellable, callback, user_data); }
char * (g_data_input_stream_read_until_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_until_finish(stream, result, length, error); }
char * (g_data_input_stream_read_upto)(GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gsize *length, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_upto(stream, stop_chars, stop_chars_len, length, cancellable, error); }
void (g_data_input_stream_read_upto_async)(GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_data_input_stream_read_upto_async(stream, stop_chars, stop_chars_len, io_priority, cancellable, callback, user_data); }
char * (g_data_input_stream_read_upto_finish)(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error) { return stub_funcs.ptr_g_data_input_stream_read_upto_finish(stream, result, length, error); }
GType (g_data_output_stream_get_type)(void) { return stub_funcs.ptr_g_data_output_stream_get_type(); }
GDataOutputStream * (g_data_output_stream_new)(GOutputStream *base_stream) { return stub_funcs.ptr_g_data_output_stream_new(base_stream); }
void (g_data_output_stream_set_byte_order)(GDataOutputStream *stream, GDataStreamByteOrder order) { stub_funcs.ptr_g_data_output_stream_set_byte_order(stream, order); }
GDataStreamByteOrder (g_data_output_stream_get_byte_order)(GDataOutputStream *stream) { return stub_funcs.ptr_g_data_output_stream_get_byte_order(stream); }
gboolean (g_data_output_stream_put_byte)(GDataOutputStream *stream, guchar data, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_byte(stream, data, cancellable, error); }
gboolean (g_data_output_stream_put_int16)(GDataOutputStream *stream, gint16 data, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_int16(stream, data, cancellable, error); }
gboolean (g_data_output_stream_put_uint16)(GDataOutputStream *stream, guint16 data, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_uint16(stream, data, cancellable, error); }
gboolean (g_data_output_stream_put_int32)(GDataOutputStream *stream, gint32 data, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_int32(stream, data, cancellable, error); }
gboolean (g_data_output_stream_put_uint32)(GDataOutputStream *stream, guint32 data, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_uint32(stream, data, cancellable, error); }
gboolean (g_data_output_stream_put_int64)(GDataOutputStream *stream, gint64 data, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_int64(stream, data, cancellable, error); }
gboolean (g_data_output_stream_put_uint64)(GDataOutputStream *stream, guint64 data, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_uint64(stream, data, cancellable, error); }
gboolean (g_data_output_stream_put_string)(GDataOutputStream *stream, const char *str, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_data_output_stream_put_string(stream, str, cancellable, error); }
GType (g_dbus_action_group_get_type)(void) { return stub_funcs.ptr_g_dbus_action_group_get_type(); }
GDBusActionGroup * (g_dbus_action_group_get)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path) { return stub_funcs.ptr_g_dbus_action_group_get(connection, bus_name, object_path); }
gboolean (g_dbus_is_address)(const gchar *string) { return stub_funcs.ptr_g_dbus_is_address(string); }
gboolean (g_dbus_is_supported_address)(const gchar *string, GError **error) { return stub_funcs.ptr_g_dbus_is_supported_address(string, error); }
void (g_dbus_address_get_stream)(const gchar *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_address_get_stream(address, cancellable, callback, user_data); }
GIOStream* (g_dbus_address_get_stream_finish)(GAsyncResult *res, gchar **out_guid, GError **error) { return stub_funcs.ptr_g_dbus_address_get_stream_finish(res, out_guid, error); }
GIOStream* (g_dbus_address_get_stream_sync)(const gchar *address, gchar **out_guid, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_address_get_stream_sync(address, out_guid, cancellable, error); }
gchar* (g_dbus_address_get_for_bus_sync)(GBusType bus_type, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_address_get_for_bus_sync(bus_type, cancellable, error); }
gchar* (g_dbus_address_escape_value)(const gchar *string) { return stub_funcs.ptr_g_dbus_address_escape_value(string); }
GType (g_dbus_auth_observer_get_type)(void) { return stub_funcs.ptr_g_dbus_auth_observer_get_type(); }
GDBusAuthObserver* (g_dbus_auth_observer_new)(void) { return stub_funcs.ptr_g_dbus_auth_observer_new(); }
gboolean (g_dbus_auth_observer_authorize_authenticated_peer)(GDBusAuthObserver *observer, GIOStream *stream, GCredentials *credentials) { return stub_funcs.ptr_g_dbus_auth_observer_authorize_authenticated_peer(observer, stream, credentials); }
gboolean (g_dbus_auth_observer_allow_mechanism)(GDBusAuthObserver *observer, const gchar *mechanism) { return stub_funcs.ptr_g_dbus_auth_observer_allow_mechanism(observer, mechanism); }
GType (g_dbus_connection_get_type)(void) { return stub_funcs.ptr_g_dbus_connection_get_type(); }
void (g_bus_get)(GBusType bus_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_bus_get(bus_type, cancellable, callback, user_data); }
GDBusConnection* (g_bus_get_finish)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_bus_get_finish(res, error); }
GDBusConnection* (g_bus_get_sync)(GBusType bus_type, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_bus_get_sync(bus_type, cancellable, error); }
void (g_dbus_connection_new)(GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_connection_new(stream, guid, flags, observer, cancellable, callback, user_data); }
GDBusConnection* (g_dbus_connection_new_finish)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_connection_new_finish(res, error); }
GDBusConnection* (g_dbus_connection_new_sync)(GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable, error); }
void (g_dbus_connection_new_for_address)(const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_connection_new_for_address(address, flags, observer, cancellable, callback, user_data); }
GDBusConnection* (g_dbus_connection_new_for_address_finish)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_connection_new_for_address_finish(res, error); }
GDBusConnection* (g_dbus_connection_new_for_address_sync)(const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_connection_new_for_address_sync(address, flags, observer, cancellable, error); }
void (g_dbus_connection_start_message_processing)(GDBusConnection *connection) { stub_funcs.ptr_g_dbus_connection_start_message_processing(connection); }
gboolean (g_dbus_connection_is_closed)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_is_closed(connection); }
GIOStream* (g_dbus_connection_get_stream)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_stream(connection); }
const gchar* (g_dbus_connection_get_guid)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_guid(connection); }
const gchar* (g_dbus_connection_get_unique_name)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_unique_name(connection); }
GCredentials* (g_dbus_connection_get_peer_credentials)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_peer_credentials(connection); }
guint32 (g_dbus_connection_get_last_serial)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_last_serial(connection); }
gboolean (g_dbus_connection_get_exit_on_close)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_exit_on_close(connection); }
void (g_dbus_connection_set_exit_on_close)(GDBusConnection *connection, gboolean exit_on_close) { stub_funcs.ptr_g_dbus_connection_set_exit_on_close(connection, exit_on_close); }
GDBusCapabilityFlags (g_dbus_connection_get_capabilities)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_capabilities(connection); }
GDBusConnectionFlags (g_dbus_connection_get_flags)(GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_connection_get_flags(connection); }
void (g_dbus_connection_close)(GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_connection_close(connection, cancellable, callback, user_data); }
gboolean (g_dbus_connection_close_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_connection_close_finish(connection, res, error); }
gboolean (g_dbus_connection_close_sync)(GDBusConnection *connection, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_connection_close_sync(connection, cancellable, error); }
void (g_dbus_connection_flush)(GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_connection_flush(connection, cancellable, callback, user_data); }
gboolean (g_dbus_connection_flush_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_connection_flush_finish(connection, res, error); }
gboolean (g_dbus_connection_flush_sync)(GDBusConnection *connection, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_connection_flush_sync(connection, cancellable, error); }
gboolean (g_dbus_connection_send_message)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, volatile guint32 *out_serial, GError **error) { return stub_funcs.ptr_g_dbus_connection_send_message(connection, message, flags, out_serial, error); }
void (g_dbus_connection_send_message_with_reply)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_connection_send_message_with_reply(connection, message, flags, timeout_msec, out_serial, cancellable, callback, user_data); }
GDBusMessage* (g_dbus_connection_send_message_with_reply_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_connection_send_message_with_reply_finish(connection, res, error); }
GDBusMessage* (g_dbus_connection_send_message_with_reply_sync)(GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_connection_send_message_with_reply_sync(connection, message, flags, timeout_msec, out_serial, cancellable, error); }
gboolean (g_dbus_connection_emit_signal)(GDBusConnection *connection, const gchar *destination_bus_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, GError **error) { return stub_funcs.ptr_g_dbus_connection_emit_signal(connection, destination_bus_name, object_path, interface_name, signal_name, parameters, error); }
void (g_dbus_connection_call)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_connection_call(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, callback, user_data); }
GVariant* (g_dbus_connection_call_finish)(GDBusConnection *connection, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_connection_call_finish(connection, res, error); }
GVariant* (g_dbus_connection_call_sync)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_connection_call_sync(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, error); }
void (g_dbus_connection_call_with_unix_fd_list)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_connection_call_with_unix_fd_list(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, cancellable, callback, user_data); }
GVariant* (g_dbus_connection_call_with_unix_fd_list_finish)(GDBusConnection *connection, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_connection_call_with_unix_fd_list_finish(connection, out_fd_list, res, error); }
GVariant* (g_dbus_connection_call_with_unix_fd_list_sync)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_connection_call_with_unix_fd_list_sync(connection, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, out_fd_list, cancellable, error); }
guint (g_dbus_connection_register_object)(GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, const GDBusInterfaceVTable *vtable, gpointer user_data, GDestroyNotify user_data_free_func, GError **error) { return stub_funcs.ptr_g_dbus_connection_register_object(connection, object_path, interface_info, vtable, user_data, user_data_free_func, error); }
guint (g_dbus_connection_register_object_with_closures)(GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, GClosure *method_call_closure, GClosure *get_property_closure, GClosure *set_property_closure, GError **error) { return stub_funcs.ptr_g_dbus_connection_register_object_with_closures(connection, object_path, interface_info, method_call_closure, get_property_closure, set_property_closure, error); }
gboolean (g_dbus_connection_unregister_object)(GDBusConnection *connection, guint registration_id) { return stub_funcs.ptr_g_dbus_connection_unregister_object(connection, registration_id); }
guint (g_dbus_connection_register_subtree)(GDBusConnection *connection, const gchar *object_path, const GDBusSubtreeVTable *vtable, GDBusSubtreeFlags flags, gpointer user_data, GDestroyNotify user_data_free_func, GError **error) { return stub_funcs.ptr_g_dbus_connection_register_subtree(connection, object_path, vtable, flags, user_data, user_data_free_func, error); }
gboolean (g_dbus_connection_unregister_subtree)(GDBusConnection *connection, guint registration_id) { return stub_funcs.ptr_g_dbus_connection_unregister_subtree(connection, registration_id); }
guint (g_dbus_connection_signal_subscribe)(GDBusConnection *connection, const gchar *sender, const gchar *interface_name, const gchar *member, const gchar *object_path, const gchar *arg0, GDBusSignalFlags flags, GDBusSignalCallback callback, gpointer user_data, GDestroyNotify user_data_free_func) { return stub_funcs.ptr_g_dbus_connection_signal_subscribe(connection, sender, interface_name, member, object_path, arg0, flags, callback, user_data, user_data_free_func); }
void (g_dbus_connection_signal_unsubscribe)(GDBusConnection *connection, guint subscription_id) { stub_funcs.ptr_g_dbus_connection_signal_unsubscribe(connection, subscription_id); }
guint (g_dbus_connection_add_filter)(GDBusConnection *connection, GDBusMessageFilterFunction filter_function, gpointer user_data, GDestroyNotify user_data_free_func) { return stub_funcs.ptr_g_dbus_connection_add_filter(connection, filter_function, user_data, user_data_free_func); }
void (g_dbus_connection_remove_filter)(GDBusConnection *connection, guint filter_id) { stub_funcs.ptr_g_dbus_connection_remove_filter(connection, filter_id); }
gboolean (g_dbus_error_is_remote_error)(const GError *error) { return stub_funcs.ptr_g_dbus_error_is_remote_error(error); }
gchar* (g_dbus_error_get_remote_error)(const GError *error) { return stub_funcs.ptr_g_dbus_error_get_remote_error(error); }
gboolean (g_dbus_error_strip_remote_error)(GError *error) { return stub_funcs.ptr_g_dbus_error_strip_remote_error(error); }
gboolean (g_dbus_error_register_error)(GQuark error_domain, gint error_code, const gchar *dbus_error_name) { return stub_funcs.ptr_g_dbus_error_register_error(error_domain, error_code, dbus_error_name); }
gboolean (g_dbus_error_unregister_error)(GQuark error_domain, gint error_code, const gchar *dbus_error_name) { return stub_funcs.ptr_g_dbus_error_unregister_error(error_domain, error_code, dbus_error_name); }
void (g_dbus_error_register_error_domain)(const gchar *error_domain_quark_name, volatile gsize *quark_volatile, const GDBusErrorEntry *entries, guint num_entries) { stub_funcs.ptr_g_dbus_error_register_error_domain(error_domain_quark_name, quark_volatile, entries, num_entries); }
GError* (g_dbus_error_new_for_dbus_error)(const gchar *dbus_error_name, const gchar *dbus_error_message) { return stub_funcs.ptr_g_dbus_error_new_for_dbus_error(dbus_error_name, dbus_error_message); }
void (g_dbus_error_set_dbus_error)(GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, ...) { va_list vaargs; va_start(vaargs, format); stub_funcs.ptr_g_dbus_error_set_dbus_error_valist(error, dbus_error_name, dbus_error_message, format, vaargs); va_end(vaargs); }
void (g_dbus_error_set_dbus_error_valist)(GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, va_list var_args) { stub_funcs.ptr_g_dbus_error_set_dbus_error_valist(error, dbus_error_name, dbus_error_message, format, var_args); }
gchar* (g_dbus_error_encode_gerror)(const GError *error) { return stub_funcs.ptr_g_dbus_error_encode_gerror(error); }
GQuark (g_dbus_error_quark)(void) { return stub_funcs.ptr_g_dbus_error_quark(); }
GType (g_dbus_interface_get_type)(void) { return stub_funcs.ptr_g_dbus_interface_get_type(); }
GDBusInterfaceInfo* (g_dbus_interface_get_info)(GDBusInterface *interface_) { return stub_funcs.ptr_g_dbus_interface_get_info(interface_); }
GDBusObject* (g_dbus_interface_get_object)(GDBusInterface *interface_) { return stub_funcs.ptr_g_dbus_interface_get_object(interface_); }
void (g_dbus_interface_set_object)(GDBusInterface *interface_, GDBusObject *object) { stub_funcs.ptr_g_dbus_interface_set_object(interface_, object); }
GDBusObject* (g_dbus_interface_dup_object)(GDBusInterface *interface_) { return stub_funcs.ptr_g_dbus_interface_dup_object(interface_); }
GType (g_dbus_interface_skeleton_get_type)(void) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_type(); }
GDBusInterfaceSkeletonFlags (g_dbus_interface_skeleton_get_flags)(GDBusInterfaceSkeleton *interface_) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_flags(interface_); }
void (g_dbus_interface_skeleton_set_flags)(GDBusInterfaceSkeleton *interface_, GDBusInterfaceSkeletonFlags flags) { stub_funcs.ptr_g_dbus_interface_skeleton_set_flags(interface_, flags); }
GDBusInterfaceInfo* (g_dbus_interface_skeleton_get_info)(GDBusInterfaceSkeleton *interface_) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_info(interface_); }
GDBusInterfaceVTable* (g_dbus_interface_skeleton_get_vtable)(GDBusInterfaceSkeleton *interface_) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_vtable(interface_); }
GVariant* (g_dbus_interface_skeleton_get_properties)(GDBusInterfaceSkeleton *interface_) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_properties(interface_); }
void (g_dbus_interface_skeleton_flush)(GDBusInterfaceSkeleton *interface_) { stub_funcs.ptr_g_dbus_interface_skeleton_flush(interface_); }
gboolean (g_dbus_interface_skeleton_export)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection, const gchar *object_path, GError **error) { return stub_funcs.ptr_g_dbus_interface_skeleton_export(interface_, connection, object_path, error); }
void (g_dbus_interface_skeleton_unexport)(GDBusInterfaceSkeleton *interface_) { stub_funcs.ptr_g_dbus_interface_skeleton_unexport(interface_); }
void (g_dbus_interface_skeleton_unexport_from_connection)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection) { stub_funcs.ptr_g_dbus_interface_skeleton_unexport_from_connection(interface_, connection); }
GDBusConnection* (g_dbus_interface_skeleton_get_connection)(GDBusInterfaceSkeleton *interface_) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_connection(interface_); }
GList* (g_dbus_interface_skeleton_get_connections)(GDBusInterfaceSkeleton *interface_) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_connections(interface_); }
gboolean (g_dbus_interface_skeleton_has_connection)(GDBusInterfaceSkeleton *interface_, GDBusConnection *connection) { return stub_funcs.ptr_g_dbus_interface_skeleton_has_connection(interface_, connection); }
const gchar* (g_dbus_interface_skeleton_get_object_path)(GDBusInterfaceSkeleton *interface_) { return stub_funcs.ptr_g_dbus_interface_skeleton_get_object_path(interface_); }
GDBusMethodInfo* (g_dbus_interface_info_lookup_method)(GDBusInterfaceInfo *info, const gchar *name) { return stub_funcs.ptr_g_dbus_interface_info_lookup_method(info, name); }
GDBusSignalInfo* (g_dbus_interface_info_lookup_signal)(GDBusInterfaceInfo *info, const gchar *name) { return stub_funcs.ptr_g_dbus_interface_info_lookup_signal(info, name); }
GDBusPropertyInfo* (g_dbus_interface_info_lookup_property)(GDBusInterfaceInfo *info, const gchar *name) { return stub_funcs.ptr_g_dbus_interface_info_lookup_property(info, name); }
void (g_dbus_interface_info_cache_build)(GDBusInterfaceInfo *info) { stub_funcs.ptr_g_dbus_interface_info_cache_build(info); }
void (g_dbus_interface_info_cache_release)(GDBusInterfaceInfo *info) { stub_funcs.ptr_g_dbus_interface_info_cache_release(info); }
void (g_dbus_interface_info_generate_xml)(GDBusInterfaceInfo *info, guint indent, GString *string_builder) { stub_funcs.ptr_g_dbus_interface_info_generate_xml(info, indent, string_builder); }
GDBusNodeInfo* (g_dbus_node_info_new_for_xml)(const gchar *xml_data, GError **error) { return stub_funcs.ptr_g_dbus_node_info_new_for_xml(xml_data, error); }
GDBusInterfaceInfo* (g_dbus_node_info_lookup_interface)(GDBusNodeInfo *info, const gchar *name) { return stub_funcs.ptr_g_dbus_node_info_lookup_interface(info, name); }
void (g_dbus_node_info_generate_xml)(GDBusNodeInfo *info, guint indent, GString *string_builder) { stub_funcs.ptr_g_dbus_node_info_generate_xml(info, indent, string_builder); }
GDBusNodeInfo* (g_dbus_node_info_ref)(GDBusNodeInfo *info) { return stub_funcs.ptr_g_dbus_node_info_ref(info); }
GDBusInterfaceInfo* (g_dbus_interface_info_ref)(GDBusInterfaceInfo *info) { return stub_funcs.ptr_g_dbus_interface_info_ref(info); }
GDBusMethodInfo* (g_dbus_method_info_ref)(GDBusMethodInfo *info) { return stub_funcs.ptr_g_dbus_method_info_ref(info); }
GDBusSignalInfo* (g_dbus_signal_info_ref)(GDBusSignalInfo *info) { return stub_funcs.ptr_g_dbus_signal_info_ref(info); }
GDBusPropertyInfo* (g_dbus_property_info_ref)(GDBusPropertyInfo *info) { return stub_funcs.ptr_g_dbus_property_info_ref(info); }
GDBusArgInfo* (g_dbus_arg_info_ref)(GDBusArgInfo *info) { return stub_funcs.ptr_g_dbus_arg_info_ref(info); }
GDBusAnnotationInfo* (g_dbus_annotation_info_ref)(GDBusAnnotationInfo *info) { return stub_funcs.ptr_g_dbus_annotation_info_ref(info); }
void (g_dbus_node_info_unref)(GDBusNodeInfo *info) { stub_funcs.ptr_g_dbus_node_info_unref(info); }
void (g_dbus_interface_info_unref)(GDBusInterfaceInfo *info) { stub_funcs.ptr_g_dbus_interface_info_unref(info); }
void (g_dbus_method_info_unref)(GDBusMethodInfo *info) { stub_funcs.ptr_g_dbus_method_info_unref(info); }
void (g_dbus_signal_info_unref)(GDBusSignalInfo *info) { stub_funcs.ptr_g_dbus_signal_info_unref(info); }
void (g_dbus_property_info_unref)(GDBusPropertyInfo *info) { stub_funcs.ptr_g_dbus_property_info_unref(info); }
void (g_dbus_arg_info_unref)(GDBusArgInfo *info) { stub_funcs.ptr_g_dbus_arg_info_unref(info); }
void (g_dbus_annotation_info_unref)(GDBusAnnotationInfo *info) { stub_funcs.ptr_g_dbus_annotation_info_unref(info); }
GType (g_dbus_node_info_get_type)(void) { return stub_funcs.ptr_g_dbus_node_info_get_type(); }
GType (g_dbus_interface_info_get_type)(void) { return stub_funcs.ptr_g_dbus_interface_info_get_type(); }
GType (g_dbus_method_info_get_type)(void) { return stub_funcs.ptr_g_dbus_method_info_get_type(); }
GType (g_dbus_signal_info_get_type)(void) { return stub_funcs.ptr_g_dbus_signal_info_get_type(); }
GType (g_dbus_property_info_get_type)(void) { return stub_funcs.ptr_g_dbus_property_info_get_type(); }
GType (g_dbus_arg_info_get_type)(void) { return stub_funcs.ptr_g_dbus_arg_info_get_type(); }
GType (g_dbus_annotation_info_get_type)(void) { return stub_funcs.ptr_g_dbus_annotation_info_get_type(); }
const gchar* (g_dbus_annotation_info_lookup)(GDBusAnnotationInfo **annotations, const gchar *name) { return stub_funcs.ptr_g_dbus_annotation_info_lookup(annotations, name); }
GType (g_dbus_menu_model_get_type)(void) { return stub_funcs.ptr_g_dbus_menu_model_get_type(); }
GDBusMenuModel * (g_dbus_menu_model_get)(GDBusConnection *connection, const gchar *bus_name, const gchar *object_path) { return stub_funcs.ptr_g_dbus_menu_model_get(connection, bus_name, object_path); }
GType (g_dbus_message_get_type)(void) { return stub_funcs.ptr_g_dbus_message_get_type(); }
GDBusMessage* (g_dbus_message_new)(void) { return stub_funcs.ptr_g_dbus_message_new(); }
GDBusMessage* (g_dbus_message_new_signal)(const gchar *path, const gchar *interface_, const gchar *signal) { return stub_funcs.ptr_g_dbus_message_new_signal(path, interface_, signal); }
GDBusMessage* (g_dbus_message_new_method_call)(const gchar *name, const gchar *path, const gchar *interface_, const gchar *method) { return stub_funcs.ptr_g_dbus_message_new_method_call(name, path, interface_, method); }
GDBusMessage* (g_dbus_message_new_method_reply)(GDBusMessage *method_call_message) { return stub_funcs.ptr_g_dbus_message_new_method_reply(method_call_message); }
GDBusMessage* (g_dbus_message_new_method_error)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, ...) { GDBusMessage* ret; va_list vaargs; va_start(vaargs, error_message_format); ret = stub_funcs.ptr_g_dbus_message_new_method_error_valist(method_call_message, error_name, error_message_format, vaargs); va_end(vaargs); return ret; }
GDBusMessage* (g_dbus_message_new_method_error_valist)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, va_list var_args) { return stub_funcs.ptr_g_dbus_message_new_method_error_valist(method_call_message, error_name, error_message_format, var_args); }
GDBusMessage* (g_dbus_message_new_method_error_literal)(GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message) { return stub_funcs.ptr_g_dbus_message_new_method_error_literal(method_call_message, error_name, error_message); }
gchar* (g_dbus_message_print)(GDBusMessage *message, guint indent) { return stub_funcs.ptr_g_dbus_message_print(message, indent); }
gboolean (g_dbus_message_get_locked)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_locked(message); }
void (g_dbus_message_lock)(GDBusMessage *message) { stub_funcs.ptr_g_dbus_message_lock(message); }
GDBusMessage* (g_dbus_message_copy)(GDBusMessage *message, GError **error) { return stub_funcs.ptr_g_dbus_message_copy(message, error); }
GDBusMessageByteOrder (g_dbus_message_get_byte_order)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_byte_order(message); }
void (g_dbus_message_set_byte_order)(GDBusMessage *message, GDBusMessageByteOrder byte_order) { stub_funcs.ptr_g_dbus_message_set_byte_order(message, byte_order); }
GDBusMessageType (g_dbus_message_get_message_type)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_message_type(message); }
void (g_dbus_message_set_message_type)(GDBusMessage *message, GDBusMessageType type) { stub_funcs.ptr_g_dbus_message_set_message_type(message, type); }
GDBusMessageFlags (g_dbus_message_get_flags)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_flags(message); }
void (g_dbus_message_set_flags)(GDBusMessage *message, GDBusMessageFlags flags) { stub_funcs.ptr_g_dbus_message_set_flags(message, flags); }
guint32 (g_dbus_message_get_serial)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_serial(message); }
void (g_dbus_message_set_serial)(GDBusMessage *message, guint32 serial) { stub_funcs.ptr_g_dbus_message_set_serial(message, serial); }
GVariant* (g_dbus_message_get_header)(GDBusMessage *message, GDBusMessageHeaderField header_field) { return stub_funcs.ptr_g_dbus_message_get_header(message, header_field); }
void (g_dbus_message_set_header)(GDBusMessage *message, GDBusMessageHeaderField header_field, GVariant *value) { stub_funcs.ptr_g_dbus_message_set_header(message, header_field, value); }
guchar* (g_dbus_message_get_header_fields)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_header_fields(message); }
GVariant* (g_dbus_message_get_body)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_body(message); }
void (g_dbus_message_set_body)(GDBusMessage *message, GVariant *body) { stub_funcs.ptr_g_dbus_message_set_body(message, body); }
GUnixFDList* (g_dbus_message_get_unix_fd_list)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_unix_fd_list(message); }
void (g_dbus_message_set_unix_fd_list)(GDBusMessage *message, GUnixFDList *fd_list) { stub_funcs.ptr_g_dbus_message_set_unix_fd_list(message, fd_list); }
guint32 (g_dbus_message_get_reply_serial)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_reply_serial(message); }
void (g_dbus_message_set_reply_serial)(GDBusMessage *message, guint32 value) { stub_funcs.ptr_g_dbus_message_set_reply_serial(message, value); }
const gchar* (g_dbus_message_get_interface)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_interface(message); }
void (g_dbus_message_set_interface)(GDBusMessage *message, const gchar *value) { stub_funcs.ptr_g_dbus_message_set_interface(message, value); }
const gchar* (g_dbus_message_get_member)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_member(message); }
void (g_dbus_message_set_member)(GDBusMessage *message, const gchar *value) { stub_funcs.ptr_g_dbus_message_set_member(message, value); }
const gchar* (g_dbus_message_get_path)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_path(message); }
void (g_dbus_message_set_path)(GDBusMessage *message, const gchar *value) { stub_funcs.ptr_g_dbus_message_set_path(message, value); }
const gchar* (g_dbus_message_get_sender)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_sender(message); }
void (g_dbus_message_set_sender)(GDBusMessage *message, const gchar *value) { stub_funcs.ptr_g_dbus_message_set_sender(message, value); }
const gchar* (g_dbus_message_get_destination)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_destination(message); }
void (g_dbus_message_set_destination)(GDBusMessage *message, const gchar *value) { stub_funcs.ptr_g_dbus_message_set_destination(message, value); }
const gchar* (g_dbus_message_get_error_name)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_error_name(message); }
void (g_dbus_message_set_error_name)(GDBusMessage *message, const gchar *value) { stub_funcs.ptr_g_dbus_message_set_error_name(message, value); }
const gchar* (g_dbus_message_get_signature)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_signature(message); }
void (g_dbus_message_set_signature)(GDBusMessage *message, const gchar *value) { stub_funcs.ptr_g_dbus_message_set_signature(message, value); }
guint32 (g_dbus_message_get_num_unix_fds)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_num_unix_fds(message); }
void (g_dbus_message_set_num_unix_fds)(GDBusMessage *message, guint32 value) { stub_funcs.ptr_g_dbus_message_set_num_unix_fds(message, value); }
const gchar* (g_dbus_message_get_arg0)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_arg0(message); }
const gchar* (g_dbus_message_get_arg0_path)(GDBusMessage *message) { return stub_funcs.ptr_g_dbus_message_get_arg0_path(message); }
GDBusMessage* (g_dbus_message_new_from_blob)(guchar *blob, gsize blob_len, GDBusCapabilityFlags capabilities, GError **error) { return stub_funcs.ptr_g_dbus_message_new_from_blob(blob, blob_len, capabilities, error); }
gssize (g_dbus_message_bytes_needed)(guchar *blob, gsize blob_len, GError **error) { return stub_funcs.ptr_g_dbus_message_bytes_needed(blob, blob_len, error); }
guchar* (g_dbus_message_to_blob)(GDBusMessage *message, gsize *out_size, GDBusCapabilityFlags capabilities, GError **error) { return stub_funcs.ptr_g_dbus_message_to_blob(message, out_size, capabilities, error); }
gboolean (g_dbus_message_to_gerror)(GDBusMessage *message, GError **error) { return stub_funcs.ptr_g_dbus_message_to_gerror(message, error); }
GType (g_dbus_method_invocation_get_type)(void) { return stub_funcs.ptr_g_dbus_method_invocation_get_type(); }
const gchar* (g_dbus_method_invocation_get_sender)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_sender(invocation); }
const gchar* (g_dbus_method_invocation_get_object_path)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_object_path(invocation); }
const gchar* (g_dbus_method_invocation_get_interface_name)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_interface_name(invocation); }
const gchar* (g_dbus_method_invocation_get_method_name)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_method_name(invocation); }
const GDBusMethodInfo* (g_dbus_method_invocation_get_method_info)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_method_info(invocation); }
const GDBusPropertyInfo* (g_dbus_method_invocation_get_property_info)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_property_info(invocation); }
GDBusConnection* (g_dbus_method_invocation_get_connection)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_connection(invocation); }
GDBusMessage* (g_dbus_method_invocation_get_message)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_message(invocation); }
GVariant* (g_dbus_method_invocation_get_parameters)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_parameters(invocation); }
gpointer (g_dbus_method_invocation_get_user_data)(GDBusMethodInvocation *invocation) { return stub_funcs.ptr_g_dbus_method_invocation_get_user_data(invocation); }
void (g_dbus_method_invocation_return_value)(GDBusMethodInvocation *invocation, GVariant *parameters) { stub_funcs.ptr_g_dbus_method_invocation_return_value(invocation, parameters); }
void (g_dbus_method_invocation_return_value_with_unix_fd_list)(GDBusMethodInvocation *invocation, GVariant *parameters, GUnixFDList *fd_list) { stub_funcs.ptr_g_dbus_method_invocation_return_value_with_unix_fd_list(invocation, parameters, fd_list); }
void (g_dbus_method_invocation_return_error)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, ...) { va_list vaargs; va_start(vaargs, format); stub_funcs.ptr_g_dbus_method_invocation_return_error_valist(invocation, domain, code, format, vaargs); va_end(vaargs); }
void (g_dbus_method_invocation_return_error_valist)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, va_list var_args) { stub_funcs.ptr_g_dbus_method_invocation_return_error_valist(invocation, domain, code, format, var_args); }
void (g_dbus_method_invocation_return_error_literal)(GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *message) { stub_funcs.ptr_g_dbus_method_invocation_return_error_literal(invocation, domain, code, message); }
void (g_dbus_method_invocation_return_gerror)(GDBusMethodInvocation *invocation, const GError *error) { stub_funcs.ptr_g_dbus_method_invocation_return_gerror(invocation, error); }
void (g_dbus_method_invocation_take_error)(GDBusMethodInvocation *invocation, GError *error) { stub_funcs.ptr_g_dbus_method_invocation_take_error(invocation, error); }
void (g_dbus_method_invocation_return_dbus_error)(GDBusMethodInvocation *invocation, const gchar *error_name, const gchar *error_message) { stub_funcs.ptr_g_dbus_method_invocation_return_dbus_error(invocation, error_name, error_message); }
guint (g_bus_own_name_on_connection)(GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func) { return stub_funcs.ptr_g_bus_own_name_on_connection(connection, name, flags, name_acquired_handler, name_lost_handler, user_data, user_data_free_func); }
guint (g_bus_own_name_with_closures)(GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GClosure *bus_acquired_closure, GClosure *name_acquired_closure, GClosure *name_lost_closure) { return stub_funcs.ptr_g_bus_own_name_with_closures(bus_type, name, flags, bus_acquired_closure, name_acquired_closure, name_lost_closure); }
guint (g_bus_own_name_on_connection_with_closures)( GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GClosure *name_acquired_closure, GClosure *name_lost_closure) { return stub_funcs.ptr_g_bus_own_name_on_connection_with_closures(connection, name, flags, name_acquired_closure, name_lost_closure); }
void (g_bus_unown_name)(guint owner_id) { stub_funcs.ptr_g_bus_unown_name(owner_id); }
guint (g_bus_own_name)(GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GBusAcquiredCallback bus_acquired_handler, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func) { return stub_funcs.ptr_g_bus_own_name(bus_type, name, flags, bus_acquired_handler, name_acquired_handler, name_lost_handler, user_data, user_data_free_func); }
guint (g_bus_watch_name_on_connection)(GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func) { return stub_funcs.ptr_g_bus_watch_name_on_connection(connection, name, flags, name_appeared_handler, name_vanished_handler, user_data, user_data_free_func); }
guint (g_bus_watch_name_with_closures)(GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure) { return stub_funcs.ptr_g_bus_watch_name_with_closures(bus_type, name, flags, name_appeared_closure, name_vanished_closure); }
guint (g_bus_watch_name_on_connection_with_closures)( GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure) { return stub_funcs.ptr_g_bus_watch_name_on_connection_with_closures(connection, name, flags, name_appeared_closure, name_vanished_closure); }
void (g_bus_unwatch_name)(guint watcher_id) { stub_funcs.ptr_g_bus_unwatch_name(watcher_id); }
guint (g_bus_watch_name)(GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func) { return stub_funcs.ptr_g_bus_watch_name(bus_type, name, flags, name_appeared_handler, name_vanished_handler, user_data, user_data_free_func); }
GType (g_dbus_object_get_type)(void) { return stub_funcs.ptr_g_dbus_object_get_type(); }
const gchar* (g_dbus_object_get_object_path)(GDBusObject *object) { return stub_funcs.ptr_g_dbus_object_get_object_path(object); }
GList* (g_dbus_object_get_interfaces)(GDBusObject *object) { return stub_funcs.ptr_g_dbus_object_get_interfaces(object); }
GDBusInterface* (g_dbus_object_get_interface)(GDBusObject *object, const gchar *interface_name) { return stub_funcs.ptr_g_dbus_object_get_interface(object, interface_name); }
GType (g_dbus_object_manager_get_type)(void) { return stub_funcs.ptr_g_dbus_object_manager_get_type(); }
const gchar* (g_dbus_object_manager_get_object_path)(GDBusObjectManager *manager) { return stub_funcs.ptr_g_dbus_object_manager_get_object_path(manager); }
GList* (g_dbus_object_manager_get_objects)(GDBusObjectManager *manager) { return stub_funcs.ptr_g_dbus_object_manager_get_objects(manager); }
GDBusObject* (g_dbus_object_manager_get_object)(GDBusObjectManager *manager, const gchar *object_path) { return stub_funcs.ptr_g_dbus_object_manager_get_object(manager, object_path); }
GDBusInterface* (g_dbus_object_manager_get_interface)(GDBusObjectManager *manager, const gchar *object_path, const gchar *interface_name) { return stub_funcs.ptr_g_dbus_object_manager_get_interface(manager, object_path, interface_name); }
GType (g_dbus_object_manager_client_get_type)(void) { return stub_funcs.ptr_g_dbus_object_manager_client_get_type(); }
void (g_dbus_object_manager_client_new)(GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_object_manager_client_new(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data); }
GDBusObjectManager* (g_dbus_object_manager_client_new_finish)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_object_manager_client_new_finish(res, error); }
GDBusObjectManager* (g_dbus_object_manager_client_new_sync)(GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_object_manager_client_new_sync(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error); }
void (g_dbus_object_manager_client_new_for_bus)(GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_object_manager_client_new_for_bus(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data); }
GDBusObjectManager* (g_dbus_object_manager_client_new_for_bus_finish)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_object_manager_client_new_for_bus_finish(res, error); }
GDBusObjectManager* (g_dbus_object_manager_client_new_for_bus_sync)(GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_object_manager_client_new_for_bus_sync(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error); }
GDBusConnection* (g_dbus_object_manager_client_get_connection)(GDBusObjectManagerClient *manager) { return stub_funcs.ptr_g_dbus_object_manager_client_get_connection(manager); }
GDBusObjectManagerClientFlags (g_dbus_object_manager_client_get_flags)(GDBusObjectManagerClient *manager) { return stub_funcs.ptr_g_dbus_object_manager_client_get_flags(manager); }
const gchar* (g_dbus_object_manager_client_get_name)(GDBusObjectManagerClient *manager) { return stub_funcs.ptr_g_dbus_object_manager_client_get_name(manager); }
gchar* (g_dbus_object_manager_client_get_name_owner)(GDBusObjectManagerClient *manager) { return stub_funcs.ptr_g_dbus_object_manager_client_get_name_owner(manager); }
GType (g_dbus_object_manager_server_get_type)(void) { return stub_funcs.ptr_g_dbus_object_manager_server_get_type(); }
GDBusObjectManagerServer* (g_dbus_object_manager_server_new)(const gchar *object_path) { return stub_funcs.ptr_g_dbus_object_manager_server_new(object_path); }
GDBusConnection* (g_dbus_object_manager_server_get_connection)(GDBusObjectManagerServer *manager) { return stub_funcs.ptr_g_dbus_object_manager_server_get_connection(manager); }
void (g_dbus_object_manager_server_set_connection)(GDBusObjectManagerServer *manager, GDBusConnection *connection) { stub_funcs.ptr_g_dbus_object_manager_server_set_connection(manager, connection); }
void (g_dbus_object_manager_server_export)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object) { stub_funcs.ptr_g_dbus_object_manager_server_export(manager, object); }
void (g_dbus_object_manager_server_export_uniquely)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object) { stub_funcs.ptr_g_dbus_object_manager_server_export_uniquely(manager, object); }
gboolean (g_dbus_object_manager_server_is_exported)(GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object) { return stub_funcs.ptr_g_dbus_object_manager_server_is_exported(manager, object); }
gboolean (g_dbus_object_manager_server_unexport)(GDBusObjectManagerServer *manager, const gchar *object_path) { return stub_funcs.ptr_g_dbus_object_manager_server_unexport(manager, object_path); }
GType (g_dbus_object_proxy_get_type)(void) { return stub_funcs.ptr_g_dbus_object_proxy_get_type(); }
GDBusObjectProxy* (g_dbus_object_proxy_new)(GDBusConnection *connection, const gchar *object_path) { return stub_funcs.ptr_g_dbus_object_proxy_new(connection, object_path); }
GDBusConnection* (g_dbus_object_proxy_get_connection)(GDBusObjectProxy *proxy) { return stub_funcs.ptr_g_dbus_object_proxy_get_connection(proxy); }
GType (g_dbus_object_skeleton_get_type)(void) { return stub_funcs.ptr_g_dbus_object_skeleton_get_type(); }
GDBusObjectSkeleton* (g_dbus_object_skeleton_new)(const gchar *object_path) { return stub_funcs.ptr_g_dbus_object_skeleton_new(object_path); }
void (g_dbus_object_skeleton_flush)(GDBusObjectSkeleton *object) { stub_funcs.ptr_g_dbus_object_skeleton_flush(object); }
void (g_dbus_object_skeleton_add_interface)(GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_) { stub_funcs.ptr_g_dbus_object_skeleton_add_interface(object, interface_); }
void (g_dbus_object_skeleton_remove_interface)(GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_) { stub_funcs.ptr_g_dbus_object_skeleton_remove_interface(object, interface_); }
void (g_dbus_object_skeleton_remove_interface_by_name)(GDBusObjectSkeleton *object, const gchar *interface_name) { stub_funcs.ptr_g_dbus_object_skeleton_remove_interface_by_name(object, interface_name); }
void (g_dbus_object_skeleton_set_object_path)(GDBusObjectSkeleton *object, const gchar *object_path) { stub_funcs.ptr_g_dbus_object_skeleton_set_object_path(object, object_path); }
GType (g_dbus_proxy_get_type)(void) { return stub_funcs.ptr_g_dbus_proxy_get_type(); }
void (g_dbus_proxy_new)(GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_proxy_new(connection, flags, info, name, object_path, interface_name, cancellable, callback, user_data); }
GDBusProxy* (g_dbus_proxy_new_finish)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_proxy_new_finish(res, error); }
GDBusProxy* (g_dbus_proxy_new_sync)(GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_proxy_new_sync(connection, flags, info, name, object_path, interface_name, cancellable, error); }
void (g_dbus_proxy_new_for_bus)(GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_proxy_new_for_bus(bus_type, flags, info, name, object_path, interface_name, cancellable, callback, user_data); }
GDBusProxy* (g_dbus_proxy_new_for_bus_finish)(GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_proxy_new_for_bus_finish(res, error); }
GDBusProxy* (g_dbus_proxy_new_for_bus_sync)(GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_proxy_new_for_bus_sync(bus_type, flags, info, name, object_path, interface_name, cancellable, error); }
GDBusConnection* (g_dbus_proxy_get_connection)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_connection(proxy); }
GDBusProxyFlags (g_dbus_proxy_get_flags)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_flags(proxy); }
const gchar* (g_dbus_proxy_get_name)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_name(proxy); }
gchar* (g_dbus_proxy_get_name_owner)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_name_owner(proxy); }
const gchar* (g_dbus_proxy_get_object_path)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_object_path(proxy); }
const gchar* (g_dbus_proxy_get_interface_name)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_interface_name(proxy); }
gint (g_dbus_proxy_get_default_timeout)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_default_timeout(proxy); }
void (g_dbus_proxy_set_default_timeout)(GDBusProxy *proxy, gint timeout_msec) { stub_funcs.ptr_g_dbus_proxy_set_default_timeout(proxy, timeout_msec); }
GDBusInterfaceInfo* (g_dbus_proxy_get_interface_info)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_interface_info(proxy); }
void (g_dbus_proxy_set_interface_info)(GDBusProxy *proxy, GDBusInterfaceInfo *info) { stub_funcs.ptr_g_dbus_proxy_set_interface_info(proxy, info); }
GVariant* (g_dbus_proxy_get_cached_property)(GDBusProxy *proxy, const gchar *property_name) { return stub_funcs.ptr_g_dbus_proxy_get_cached_property(proxy, property_name); }
void (g_dbus_proxy_set_cached_property)(GDBusProxy *proxy, const gchar *property_name, GVariant *value) { stub_funcs.ptr_g_dbus_proxy_set_cached_property(proxy, property_name, value); }
gchar** (g_dbus_proxy_get_cached_property_names)(GDBusProxy *proxy) { return stub_funcs.ptr_g_dbus_proxy_get_cached_property_names(proxy); }
void (g_dbus_proxy_call)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_proxy_call(proxy, method_name, parameters, flags, timeout_msec, cancellable, callback, user_data); }
GVariant* (g_dbus_proxy_call_finish)(GDBusProxy *proxy, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_proxy_call_finish(proxy, res, error); }
GVariant* (g_dbus_proxy_call_sync)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_proxy_call_sync(proxy, method_name, parameters, flags, timeout_msec, cancellable, error); }
void (g_dbus_proxy_call_with_unix_fd_list)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dbus_proxy_call_with_unix_fd_list(proxy, method_name, parameters, flags, timeout_msec, fd_list, cancellable, callback, user_data); }
GVariant* (g_dbus_proxy_call_with_unix_fd_list_finish)(GDBusProxy *proxy, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_dbus_proxy_call_with_unix_fd_list_finish(proxy, out_fd_list, res, error); }
GVariant* (g_dbus_proxy_call_with_unix_fd_list_sync)(GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_proxy_call_with_unix_fd_list_sync(proxy, method_name, parameters, flags, timeout_msec, fd_list, out_fd_list, cancellable, error); }
GType (g_dbus_server_get_type)(void) { return stub_funcs.ptr_g_dbus_server_get_type(); }
GDBusServer* (g_dbus_server_new_sync)(const gchar *address, GDBusServerFlags flags, const gchar *guid, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dbus_server_new_sync(address, flags, guid, observer, cancellable, error); }
const gchar* (g_dbus_server_get_client_address)(GDBusServer *server) { return stub_funcs.ptr_g_dbus_server_get_client_address(server); }
const gchar* (g_dbus_server_get_guid)(GDBusServer *server) { return stub_funcs.ptr_g_dbus_server_get_guid(server); }
GDBusServerFlags (g_dbus_server_get_flags)(GDBusServer *server) { return stub_funcs.ptr_g_dbus_server_get_flags(server); }
void (g_dbus_server_start)(GDBusServer *server) { stub_funcs.ptr_g_dbus_server_start(server); }
void (g_dbus_server_stop)(GDBusServer *server) { stub_funcs.ptr_g_dbus_server_stop(server); }
gboolean (g_dbus_server_is_active)(GDBusServer *server) { return stub_funcs.ptr_g_dbus_server_is_active(server); }
gchar* (g_dbus_generate_guid)(void) { return stub_funcs.ptr_g_dbus_generate_guid(); }
gboolean (g_dbus_is_name)(const gchar *string) { return stub_funcs.ptr_g_dbus_is_name(string); }
gboolean (g_dbus_is_unique_name)(const gchar *string) { return stub_funcs.ptr_g_dbus_is_unique_name(string); }
gboolean (g_dbus_is_member_name)(const gchar *string) { return stub_funcs.ptr_g_dbus_is_member_name(string); }
gboolean (g_dbus_is_interface_name)(const gchar *string) { return stub_funcs.ptr_g_dbus_is_interface_name(string); }
gboolean (g_dbus_is_error_name)(const gchar *string) { return stub_funcs.ptr_g_dbus_is_error_name(string); }
void (g_dbus_gvariant_to_gvalue)(GVariant *value, GValue *out_gvalue) { stub_funcs.ptr_g_dbus_gvariant_to_gvalue(value, out_gvalue); }
GVariant* (g_dbus_gvalue_to_gvariant)(const GValue *gvalue, const GVariantType *type) { return stub_funcs.ptr_g_dbus_gvalue_to_gvariant(gvalue, type); }
gchar* (g_dbus_escape_object_path_bytestring)(const guint8 *bytes) { return stub_funcs.ptr_g_dbus_escape_object_path_bytestring(bytes); }
gchar* (g_dbus_escape_object_path)(const gchar *s) { return stub_funcs.ptr_g_dbus_escape_object_path(s); }
guint8* (g_dbus_unescape_object_path)(const gchar *s) { return stub_funcs.ptr_g_dbus_unescape_object_path(s); }
gboolean (g_dbus_is_guid)(const gchar *string) { return stub_funcs.ptr_g_dbus_is_guid(string); }
GType (g_debug_controller_get_type)(void) { return stub_funcs.ptr_g_debug_controller_get_type(); }
void (g_debug_controller_set_debug_enabled)(GDebugController *self, gboolean debug_enabled) { stub_funcs.ptr_g_debug_controller_set_debug_enabled(self, debug_enabled); }
GType (g_debug_controller_dbus_get_type)(void) { return stub_funcs.ptr_g_debug_controller_dbus_get_type(); }
GDebugControllerDBus* (g_debug_controller_dbus_new)(GDBusConnection *connection, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_debug_controller_dbus_new(connection, cancellable, error); }
void (g_debug_controller_dbus_stop)(GDebugControllerDBus *self) { stub_funcs.ptr_g_debug_controller_dbus_stop(self); }
GType (g_drive_get_type)(void) { return stub_funcs.ptr_g_drive_get_type(); }
char * (g_drive_get_name)(GDrive *drive) { return stub_funcs.ptr_g_drive_get_name(drive); }
GIcon * (g_drive_get_icon)(GDrive *drive) { return stub_funcs.ptr_g_drive_get_icon(drive); }
GIcon * (g_drive_get_symbolic_icon)(GDrive *drive) { return stub_funcs.ptr_g_drive_get_symbolic_icon(drive); }
gboolean (g_drive_has_volumes)(GDrive *drive) { return stub_funcs.ptr_g_drive_has_volumes(drive); }
GList * (g_drive_get_volumes)(GDrive *drive) { return stub_funcs.ptr_g_drive_get_volumes(drive); }
gboolean (g_drive_is_removable)(GDrive *drive) { return stub_funcs.ptr_g_drive_is_removable(drive); }
gboolean (g_drive_is_media_removable)(GDrive *drive) { return stub_funcs.ptr_g_drive_is_media_removable(drive); }
gboolean (g_drive_has_media)(GDrive *drive) { return stub_funcs.ptr_g_drive_has_media(drive); }
gboolean (g_drive_is_media_check_automatic)(GDrive *drive) { return stub_funcs.ptr_g_drive_is_media_check_automatic(drive); }
gboolean (g_drive_can_poll_for_media)(GDrive *drive) { return stub_funcs.ptr_g_drive_can_poll_for_media(drive); }
gboolean (g_drive_can_eject)(GDrive *drive) { return stub_funcs.ptr_g_drive_can_eject(drive); }
void (g_drive_eject)(GDrive *drive, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_drive_eject(drive, flags, cancellable, callback, user_data); }
gboolean (g_drive_eject_finish)(GDrive *drive, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_drive_eject_finish(drive, result, error); }
void (g_drive_poll_for_media)(GDrive *drive, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_drive_poll_for_media(drive, cancellable, callback, user_data); }
gboolean (g_drive_poll_for_media_finish)(GDrive *drive, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_drive_poll_for_media_finish(drive, result, error); }
char * (g_drive_get_identifier)(GDrive *drive, const char *kind) { return stub_funcs.ptr_g_drive_get_identifier(drive, kind); }
char ** (g_drive_enumerate_identifiers)(GDrive *drive) { return stub_funcs.ptr_g_drive_enumerate_identifiers(drive); }
GDriveStartStopType (g_drive_get_start_stop_type)(GDrive *drive) { return stub_funcs.ptr_g_drive_get_start_stop_type(drive); }
gboolean (g_drive_can_start)(GDrive *drive) { return stub_funcs.ptr_g_drive_can_start(drive); }
gboolean (g_drive_can_start_degraded)(GDrive *drive) { return stub_funcs.ptr_g_drive_can_start_degraded(drive); }
void (g_drive_start)(GDrive *drive, GDriveStartFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_drive_start(drive, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_drive_start_finish)(GDrive *drive, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_drive_start_finish(drive, result, error); }
gboolean (g_drive_can_stop)(GDrive *drive) { return stub_funcs.ptr_g_drive_can_stop(drive); }
void (g_drive_stop)(GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_drive_stop(drive, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_drive_stop_finish)(GDrive *drive, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_drive_stop_finish(drive, result, error); }
void (g_drive_eject_with_operation)(GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_drive_eject_with_operation(drive, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_drive_eject_with_operation_finish)(GDrive *drive, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_drive_eject_with_operation_finish(drive, result, error); }
const gchar* (g_drive_get_sort_key)(GDrive *drive) { return stub_funcs.ptr_g_drive_get_sort_key(drive); }
GType (g_dtls_client_connection_get_type)(void) { return stub_funcs.ptr_g_dtls_client_connection_get_type(); }
GDatagramBased* (g_dtls_client_connection_new)(GDatagramBased *base_socket, GSocketConnectable *server_identity, GError **error) { return stub_funcs.ptr_g_dtls_client_connection_new(base_socket, server_identity, error); }
GTlsCertificateFlags (g_dtls_client_connection_get_validation_flags)(GDtlsClientConnection *conn) { return stub_funcs.ptr_g_dtls_client_connection_get_validation_flags(conn); }
void (g_dtls_client_connection_set_validation_flags)(GDtlsClientConnection *conn, GTlsCertificateFlags flags) { stub_funcs.ptr_g_dtls_client_connection_set_validation_flags(conn, flags); }
GSocketConnectable* (g_dtls_client_connection_get_server_identity)(GDtlsClientConnection *conn) { return stub_funcs.ptr_g_dtls_client_connection_get_server_identity(conn); }
void (g_dtls_client_connection_set_server_identity)(GDtlsClientConnection *conn, GSocketConnectable *identity) { stub_funcs.ptr_g_dtls_client_connection_set_server_identity(conn, identity); }
GList * (g_dtls_client_connection_get_accepted_cas)(GDtlsClientConnection *conn) { return stub_funcs.ptr_g_dtls_client_connection_get_accepted_cas(conn); }
GType (g_dtls_connection_get_type)(void) { return stub_funcs.ptr_g_dtls_connection_get_type(); }
void (g_dtls_connection_set_database)(GDtlsConnection *conn, GTlsDatabase *database) { stub_funcs.ptr_g_dtls_connection_set_database(conn, database); }
GTlsDatabase* (g_dtls_connection_get_database)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_database(conn); }
void (g_dtls_connection_set_certificate)(GDtlsConnection *conn, GTlsCertificate *certificate) { stub_funcs.ptr_g_dtls_connection_set_certificate(conn, certificate); }
GTlsCertificate* (g_dtls_connection_get_certificate)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_certificate(conn); }
void (g_dtls_connection_set_interaction)(GDtlsConnection *conn, GTlsInteraction *interaction) { stub_funcs.ptr_g_dtls_connection_set_interaction(conn, interaction); }
GTlsInteraction* (g_dtls_connection_get_interaction)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_interaction(conn); }
GTlsCertificate* (g_dtls_connection_get_peer_certificate)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_peer_certificate(conn); }
GTlsCertificateFlags (g_dtls_connection_get_peer_certificate_errors)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_peer_certificate_errors(conn); }
void (g_dtls_connection_set_require_close_notify)(GDtlsConnection *conn, gboolean require_close_notify) { stub_funcs.ptr_g_dtls_connection_set_require_close_notify(conn, require_close_notify); }
gboolean (g_dtls_connection_get_require_close_notify)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_require_close_notify(conn); }
GTlsRehandshakeMode (g_dtls_connection_get_rehandshake_mode)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_rehandshake_mode(conn); }
void (g_dtls_connection_handshake_async)(GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dtls_connection_handshake_async(conn, io_priority, cancellable, callback, user_data); }
gboolean (g_dtls_connection_handshake_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_dtls_connection_handshake_finish(conn, result, error); }
gboolean (g_dtls_connection_shutdown)(GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dtls_connection_shutdown(conn, shutdown_read, shutdown_write, cancellable, error); }
void (g_dtls_connection_shutdown_async)(GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dtls_connection_shutdown_async(conn, shutdown_read, shutdown_write, io_priority, cancellable, callback, user_data); }
gboolean (g_dtls_connection_shutdown_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_dtls_connection_shutdown_finish(conn, result, error); }
gboolean (g_dtls_connection_close)(GDtlsConnection *conn, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_dtls_connection_close(conn, cancellable, error); }
void (g_dtls_connection_close_async)(GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_dtls_connection_close_async(conn, io_priority, cancellable, callback, user_data); }
gboolean (g_dtls_connection_close_finish)(GDtlsConnection *conn, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_dtls_connection_close_finish(conn, result, error); }
gboolean (g_dtls_connection_emit_accept_certificate)(GDtlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors) { return stub_funcs.ptr_g_dtls_connection_emit_accept_certificate(conn, peer_cert, errors); }
void (g_dtls_connection_set_advertised_protocols)(GDtlsConnection *conn, const gchar * const *protocols) { stub_funcs.ptr_g_dtls_connection_set_advertised_protocols(conn, protocols); }
const gchar * (g_dtls_connection_get_negotiated_protocol)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_negotiated_protocol(conn); }
gchar * (g_dtls_connection_get_ciphersuite_name)(GDtlsConnection *conn) { return stub_funcs.ptr_g_dtls_connection_get_ciphersuite_name(conn); }
GType (g_dtls_server_connection_get_type)(void) { return stub_funcs.ptr_g_dtls_server_connection_get_type(); }
GDatagramBased* (g_dtls_server_connection_new)(GDatagramBased *base_socket, GTlsCertificate *certificate, GError **error) { return stub_funcs.ptr_g_dtls_server_connection_new(base_socket, certificate, error); }
GType (g_emblem_get_type)(void) { return stub_funcs.ptr_g_emblem_get_type(); }
GEmblem* (g_emblem_new)(GIcon *icon) { return stub_funcs.ptr_g_emblem_new(icon); }
GEmblem* (g_emblem_new_with_origin)(GIcon *icon, GEmblemOrigin origin) { return stub_funcs.ptr_g_emblem_new_with_origin(icon, origin); }
GIcon* (g_emblem_get_icon)(GEmblem *emblem) { return stub_funcs.ptr_g_emblem_get_icon(emblem); }
GEmblemOrigin (g_emblem_get_origin)(GEmblem *emblem) { return stub_funcs.ptr_g_emblem_get_origin(emblem); }
GType (g_emblemed_icon_get_type)(void) { return stub_funcs.ptr_g_emblemed_icon_get_type(); }
GIcon* (g_emblemed_icon_new)(GIcon *icon, GEmblem *emblem) { return stub_funcs.ptr_g_emblemed_icon_new(icon, emblem); }
GIcon* (g_emblemed_icon_get_icon)(GEmblemedIcon *emblemed) { return stub_funcs.ptr_g_emblemed_icon_get_icon(emblemed); }
GList* (g_emblemed_icon_get_emblems)(GEmblemedIcon *emblemed) { return stub_funcs.ptr_g_emblemed_icon_get_emblems(emblemed); }
void (g_emblemed_icon_add_emblem)(GEmblemedIcon *emblemed, GEmblem *emblem) { stub_funcs.ptr_g_emblemed_icon_add_emblem(emblemed, emblem); }
void (g_emblemed_icon_clear_emblems)(GEmblemedIcon *emblemed) { stub_funcs.ptr_g_emblemed_icon_clear_emblems(emblemed); }
GType (g_file_get_type)(void) { return stub_funcs.ptr_g_file_get_type(); }
GFile * (g_file_new_for_path)(const char *path) { return stub_funcs.ptr_g_file_new_for_path(path); }
GFile * (g_file_new_for_uri)(const char *uri) { return stub_funcs.ptr_g_file_new_for_uri(uri); }
GFile * (g_file_new_for_commandline_arg)(const char *arg) { return stub_funcs.ptr_g_file_new_for_commandline_arg(arg); }
GFile * (g_file_new_for_commandline_arg_and_cwd)(const gchar *arg, const gchar *cwd) { return stub_funcs.ptr_g_file_new_for_commandline_arg_and_cwd(arg, cwd); }
GFile * (g_file_new_tmp)(const char *tmpl, GFileIOStream **iostream, GError **error) { return stub_funcs.ptr_g_file_new_tmp(tmpl, iostream, error); }
void (g_file_new_tmp_async)(const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_new_tmp_async(tmpl, io_priority, cancellable, callback, user_data); }
GFile * (g_file_new_tmp_finish)(GAsyncResult *result, GFileIOStream **iostream, GError **error) { return stub_funcs.ptr_g_file_new_tmp_finish(result, iostream, error); }
void (g_file_new_tmp_dir_async)(const char *tmpl, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_new_tmp_dir_async(tmpl, io_priority, cancellable, callback, user_data); }
GFile * (g_file_new_tmp_dir_finish)(GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_new_tmp_dir_finish(result, error); }
GFile * (g_file_parse_name)(const char *parse_name) { return stub_funcs.ptr_g_file_parse_name(parse_name); }
// Found va_equiv for func g_file_new_build_filename as func g_file_new_build_filenamev with pattern g_file_new_build_filename[_]*va*$, but err: va_list missing
GFile * (g_file_new_build_filenamev)(const gchar * const *args) { return stub_funcs.ptr_g_file_new_build_filenamev(args); }
GFile * (g_file_dup)(GFile *file) { return stub_funcs.ptr_g_file_dup(file); }
guint (g_file_hash)(gconstpointer file) { return stub_funcs.ptr_g_file_hash(file); }
gboolean (g_file_equal)(GFile *file1, GFile *file2) { return stub_funcs.ptr_g_file_equal(file1, file2); }
char * (g_file_get_basename)(GFile *file) { return stub_funcs.ptr_g_file_get_basename(file); }
char * (g_file_get_path)(GFile *file) { return stub_funcs.ptr_g_file_get_path(file); }
const char * (g_file_peek_path)(GFile *file) { return stub_funcs.ptr_g_file_peek_path(file); }
char * (g_file_get_uri)(GFile *file) { return stub_funcs.ptr_g_file_get_uri(file); }
char * (g_file_get_parse_name)(GFile *file) { return stub_funcs.ptr_g_file_get_parse_name(file); }
GFile * (g_file_get_parent)(GFile *file) { return stub_funcs.ptr_g_file_get_parent(file); }
gboolean (g_file_has_parent)(GFile *file, GFile *parent) { return stub_funcs.ptr_g_file_has_parent(file, parent); }
GFile * (g_file_get_child)(GFile *file, const char *name) { return stub_funcs.ptr_g_file_get_child(file, name); }
GFile * (g_file_get_child_for_display_name)(GFile *file, const char *display_name, GError **error) { return stub_funcs.ptr_g_file_get_child_for_display_name(file, display_name, error); }
gboolean (g_file_has_prefix)(GFile *file, GFile *prefix) { return stub_funcs.ptr_g_file_has_prefix(file, prefix); }
char * (g_file_get_relative_path)(GFile *parent, GFile *descendant) { return stub_funcs.ptr_g_file_get_relative_path(parent, descendant); }
GFile * (g_file_resolve_relative_path)(GFile *file, const char *relative_path) { return stub_funcs.ptr_g_file_resolve_relative_path(file, relative_path); }
gboolean (g_file_is_native)(GFile *file) { return stub_funcs.ptr_g_file_is_native(file); }
gboolean (g_file_has_uri_scheme)(GFile *file, const char *uri_scheme) { return stub_funcs.ptr_g_file_has_uri_scheme(file, uri_scheme); }
char * (g_file_get_uri_scheme)(GFile *file) { return stub_funcs.ptr_g_file_get_uri_scheme(file); }
GFileInputStream * (g_file_read)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_read(file, cancellable, error); }
void (g_file_read_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_read_async(file, io_priority, cancellable, callback, user_data); }
GFileInputStream * (g_file_read_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_read_finish(file, res, error); }
GFileOutputStream * (g_file_append_to)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_append_to(file, flags, cancellable, error); }
GFileOutputStream * (g_file_create)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_create(file, flags, cancellable, error); }
GFileOutputStream * (g_file_replace)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_replace(file, etag, make_backup, flags, cancellable, error); }
void (g_file_append_to_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_append_to_async(file, flags, io_priority, cancellable, callback, user_data); }
GFileOutputStream * (g_file_append_to_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_append_to_finish(file, res, error); }
void (g_file_create_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_create_async(file, flags, io_priority, cancellable, callback, user_data); }
GFileOutputStream * (g_file_create_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_create_finish(file, res, error); }
void (g_file_replace_async)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_replace_async(file, etag, make_backup, flags, io_priority, cancellable, callback, user_data); }
GFileOutputStream * (g_file_replace_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_replace_finish(file, res, error); }
GFileIOStream * (g_file_open_readwrite)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_open_readwrite(file, cancellable, error); }
void (g_file_open_readwrite_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_open_readwrite_async(file, io_priority, cancellable, callback, user_data); }
GFileIOStream * (g_file_open_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_open_readwrite_finish(file, res, error); }
GFileIOStream * (g_file_create_readwrite)(GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_create_readwrite(file, flags, cancellable, error); }
void (g_file_create_readwrite_async)(GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_create_readwrite_async(file, flags, io_priority, cancellable, callback, user_data); }
GFileIOStream * (g_file_create_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_create_readwrite_finish(file, res, error); }
GFileIOStream * (g_file_replace_readwrite)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_replace_readwrite(file, etag, make_backup, flags, cancellable, error); }
void (g_file_replace_readwrite_async)(GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_replace_readwrite_async(file, etag, make_backup, flags, io_priority, cancellable, callback, user_data); }
GFileIOStream * (g_file_replace_readwrite_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_replace_readwrite_finish(file, res, error); }
gboolean (g_file_query_exists)(GFile *file, GCancellable *cancellable) { return stub_funcs.ptr_g_file_query_exists(file, cancellable); }
GFileType (g_file_query_file_type)(GFile *file, GFileQueryInfoFlags flags, GCancellable *cancellable) { return stub_funcs.ptr_g_file_query_file_type(file, flags, cancellable); }
GFileInfo * (g_file_query_info)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_query_info(file, attributes, flags, cancellable, error); }
void (g_file_query_info_async)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_query_info_async(file, attributes, flags, io_priority, cancellable, callback, user_data); }
GFileInfo * (g_file_query_info_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_query_info_finish(file, res, error); }
GFileInfo * (g_file_query_filesystem_info)(GFile *file, const char *attributes, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_query_filesystem_info(file, attributes, cancellable, error); }
void (g_file_query_filesystem_info_async)(GFile *file, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_query_filesystem_info_async(file, attributes, io_priority, cancellable, callback, user_data); }
GFileInfo * (g_file_query_filesystem_info_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_query_filesystem_info_finish(file, res, error); }
GMount * (g_file_find_enclosing_mount)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_find_enclosing_mount(file, cancellable, error); }
void (g_file_find_enclosing_mount_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_find_enclosing_mount_async(file, io_priority, cancellable, callback, user_data); }
GMount * (g_file_find_enclosing_mount_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_find_enclosing_mount_finish(file, res, error); }
GFileEnumerator * (g_file_enumerate_children)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_enumerate_children(file, attributes, flags, cancellable, error); }
void (g_file_enumerate_children_async)(GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_enumerate_children_async(file, attributes, flags, io_priority, cancellable, callback, user_data); }
GFileEnumerator * (g_file_enumerate_children_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_enumerate_children_finish(file, res, error); }
GFile * (g_file_set_display_name)(GFile *file, const char *display_name, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_display_name(file, display_name, cancellable, error); }
void (g_file_set_display_name_async)(GFile *file, const char *display_name, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_set_display_name_async(file, display_name, io_priority, cancellable, callback, user_data); }
GFile * (g_file_set_display_name_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_set_display_name_finish(file, res, error); }
gboolean (g_file_delete)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_delete(file, cancellable, error); }
void (g_file_delete_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_delete_async(file, io_priority, cancellable, callback, user_data); }
gboolean (g_file_delete_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_delete_finish(file, result, error); }
gboolean (g_file_trash)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_trash(file, cancellable, error); }
void (g_file_trash_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_trash_async(file, io_priority, cancellable, callback, user_data); }
gboolean (g_file_trash_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_trash_finish(file, result, error); }
gboolean (g_file_copy)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error) { return stub_funcs.ptr_g_file_copy(source, destination, flags, cancellable, progress_callback, progress_callback_data, error); }
void (g_file_copy_async)(GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_copy_async(source, destination, flags, io_priority, cancellable, progress_callback, progress_callback_data, callback, user_data); }
gboolean (g_file_copy_finish)(GFile *file, GAsyncResult *res, GError **error) { return stub_funcs.ptr_g_file_copy_finish(file, res, error); }
gboolean (g_file_move)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error) { return stub_funcs.ptr_g_file_move(source, destination, flags, cancellable, progress_callback, progress_callback_data, error); }
void (g_file_move_async)(GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_move_async(source, destination, flags, io_priority, cancellable, progress_callback, progress_callback_data, callback, user_data); }
gboolean (g_file_move_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_move_finish(file, result, error); }
gboolean (g_file_make_directory)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_make_directory(file, cancellable, error); }
void (g_file_make_directory_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_make_directory_async(file, io_priority, cancellable, callback, user_data); }
gboolean (g_file_make_directory_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_make_directory_finish(file, result, error); }
gboolean (g_file_make_directory_with_parents)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_make_directory_with_parents(file, cancellable, error); }
gboolean (g_file_make_symbolic_link)(GFile *file, const char *symlink_value, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_make_symbolic_link(file, symlink_value, cancellable, error); }
void (g_file_make_symbolic_link_async)(GFile *file, const char *symlink_value, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_make_symbolic_link_async(file, symlink_value, io_priority, cancellable, callback, user_data); }
gboolean (g_file_make_symbolic_link_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_make_symbolic_link_finish(file, result, error); }
GFileAttributeInfoList* (g_file_query_settable_attributes)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_query_settable_attributes(file, cancellable, error); }
GFileAttributeInfoList* (g_file_query_writable_namespaces)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_query_writable_namespaces(file, cancellable, error); }
gboolean (g_file_set_attribute)(GFile *file, const char *attribute, GFileAttributeType type, gpointer value_p, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attribute(file, attribute, type, value_p, flags, cancellable, error); }
gboolean (g_file_set_attributes_from_info)(GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attributes_from_info(file, info, flags, cancellable, error); }
void (g_file_set_attributes_async)(GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_set_attributes_async(file, info, flags, io_priority, cancellable, callback, user_data); }
gboolean (g_file_set_attributes_finish)(GFile *file, GAsyncResult *result, GFileInfo **info, GError **error) { return stub_funcs.ptr_g_file_set_attributes_finish(file, result, info, error); }
gboolean (g_file_set_attribute_string)(GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attribute_string(file, attribute, value, flags, cancellable, error); }
gboolean (g_file_set_attribute_byte_string)(GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attribute_byte_string(file, attribute, value, flags, cancellable, error); }
gboolean (g_file_set_attribute_uint32)(GFile *file, const char *attribute, guint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attribute_uint32(file, attribute, value, flags, cancellable, error); }
gboolean (g_file_set_attribute_int32)(GFile *file, const char *attribute, gint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attribute_int32(file, attribute, value, flags, cancellable, error); }
gboolean (g_file_set_attribute_uint64)(GFile *file, const char *attribute, guint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attribute_uint64(file, attribute, value, flags, cancellable, error); }
gboolean (g_file_set_attribute_int64)(GFile *file, const char *attribute, gint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_set_attribute_int64(file, attribute, value, flags, cancellable, error); }
void (g_file_mount_enclosing_volume)(GFile *location, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_mount_enclosing_volume(location, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_file_mount_enclosing_volume_finish)(GFile *location, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_mount_enclosing_volume_finish(location, result, error); }
void (g_file_mount_mountable)(GFile *file, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_mount_mountable(file, flags, mount_operation, cancellable, callback, user_data); }
GFile * (g_file_mount_mountable_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_mount_mountable_finish(file, result, error); }
void (g_file_unmount_mountable)(GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_unmount_mountable(file, flags, cancellable, callback, user_data); }
gboolean (g_file_unmount_mountable_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_unmount_mountable_finish(file, result, error); }
void (g_file_unmount_mountable_with_operation)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_unmount_mountable_with_operation(file, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_file_unmount_mountable_with_operation_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_unmount_mountable_with_operation_finish(file, result, error); }
void (g_file_eject_mountable)(GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_eject_mountable(file, flags, cancellable, callback, user_data); }
gboolean (g_file_eject_mountable_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_eject_mountable_finish(file, result, error); }
void (g_file_eject_mountable_with_operation)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_eject_mountable_with_operation(file, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_file_eject_mountable_with_operation_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_eject_mountable_with_operation_finish(file, result, error); }
char * (g_file_build_attribute_list_for_copy)(GFile *file, GFileCopyFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_build_attribute_list_for_copy(file, flags, cancellable, error); }
gboolean (g_file_copy_attributes)(GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_copy_attributes(source, destination, flags, cancellable, error); }
GFileMonitor* (g_file_monitor_directory)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_monitor_directory(file, flags, cancellable, error); }
GFileMonitor* (g_file_monitor_file)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_monitor_file(file, flags, cancellable, error); }
GFileMonitor* (g_file_monitor)(GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_monitor(file, flags, cancellable, error); }
gboolean (g_file_measure_disk_usage)(GFile *file, GFileMeasureFlags flags, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error) { return stub_funcs.ptr_g_file_measure_disk_usage(file, flags, cancellable, progress_callback, progress_data, disk_usage, num_dirs, num_files, error); }
void (g_file_measure_disk_usage_async)(GFile *file, GFileMeasureFlags flags, gint io_priority, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_measure_disk_usage_async(file, flags, io_priority, cancellable, progress_callback, progress_data, callback, user_data); }
gboolean (g_file_measure_disk_usage_finish)(GFile *file, GAsyncResult *result, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error) { return stub_funcs.ptr_g_file_measure_disk_usage_finish(file, result, disk_usage, num_dirs, num_files, error); }
void (g_file_start_mountable)(GFile *file, GDriveStartFlags flags, GMountOperation *start_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_start_mountable(file, flags, start_operation, cancellable, callback, user_data); }
gboolean (g_file_start_mountable_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_start_mountable_finish(file, result, error); }
void (g_file_stop_mountable)(GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_stop_mountable(file, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_file_stop_mountable_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_stop_mountable_finish(file, result, error); }
void (g_file_poll_mountable)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_poll_mountable(file, cancellable, callback, user_data); }
gboolean (g_file_poll_mountable_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_poll_mountable_finish(file, result, error); }
GAppInfo* (g_file_query_default_handler)(GFile *file, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_query_default_handler(file, cancellable, error); }
void (g_file_query_default_handler_async)(GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_query_default_handler_async(file, io_priority, cancellable, callback, user_data); }
GAppInfo* (g_file_query_default_handler_finish)(GFile *file, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_query_default_handler_finish(file, result, error); }
gboolean (g_file_load_contents)(GFile *file, GCancellable *cancellable, char **contents, gsize *length, char **etag_out, GError **error) { return stub_funcs.ptr_g_file_load_contents(file, cancellable, contents, length, etag_out, error); }
void (g_file_load_contents_async)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_load_contents_async(file, cancellable, callback, user_data); }
gboolean (g_file_load_contents_finish)(GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error) { return stub_funcs.ptr_g_file_load_contents_finish(file, res, contents, length, etag_out, error); }
void (g_file_load_partial_contents_async)(GFile *file, GCancellable *cancellable, GFileReadMoreCallback read_more_callback, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_load_partial_contents_async(file, cancellable, read_more_callback, callback, user_data); }
gboolean (g_file_load_partial_contents_finish)(GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error) { return stub_funcs.ptr_g_file_load_partial_contents_finish(file, res, contents, length, etag_out, error); }
gboolean (g_file_replace_contents)(GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, char **new_etag, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_replace_contents(file, contents, length, etag, make_backup, flags, new_etag, cancellable, error); }
void (g_file_replace_contents_async)(GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_replace_contents_async(file, contents, length, etag, make_backup, flags, cancellable, callback, user_data); }
void (g_file_replace_contents_bytes_async)(GFile *file, GBytes *contents, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_replace_contents_bytes_async(file, contents, etag, make_backup, flags, cancellable, callback, user_data); }
gboolean (g_file_replace_contents_finish)(GFile *file, GAsyncResult *res, char **new_etag, GError **error) { return stub_funcs.ptr_g_file_replace_contents_finish(file, res, new_etag, error); }
gboolean (g_file_supports_thread_contexts)(GFile *file) { return stub_funcs.ptr_g_file_supports_thread_contexts(file); }
GBytes* (g_file_load_bytes)(GFile *file, GCancellable *cancellable, gchar **etag_out, GError **error) { return stub_funcs.ptr_g_file_load_bytes(file, cancellable, etag_out, error); }
void (g_file_load_bytes_async)(GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_load_bytes_async(file, cancellable, callback, user_data); }
GBytes* (g_file_load_bytes_finish)(GFile *file, GAsyncResult *result, gchar **etag_out, GError **error) { return stub_funcs.ptr_g_file_load_bytes_finish(file, result, etag_out, error); }
GType (g_file_attribute_info_list_get_type)(void) { return stub_funcs.ptr_g_file_attribute_info_list_get_type(); }
GFileAttributeInfoList * (g_file_attribute_info_list_new)(void) { return stub_funcs.ptr_g_file_attribute_info_list_new(); }
GFileAttributeInfoList * (g_file_attribute_info_list_ref)(GFileAttributeInfoList *list) { return stub_funcs.ptr_g_file_attribute_info_list_ref(list); }
void (g_file_attribute_info_list_unref)(GFileAttributeInfoList *list) { stub_funcs.ptr_g_file_attribute_info_list_unref(list); }
GFileAttributeInfoList * (g_file_attribute_info_list_dup)(GFileAttributeInfoList *list) { return stub_funcs.ptr_g_file_attribute_info_list_dup(list); }
const GFileAttributeInfo* (g_file_attribute_info_list_lookup)(GFileAttributeInfoList *list, const char *name) { return stub_funcs.ptr_g_file_attribute_info_list_lookup(list, name); }
void (g_file_attribute_info_list_add)(GFileAttributeInfoList *list, const char *name, GFileAttributeType type, GFileAttributeInfoFlags flags) { stub_funcs.ptr_g_file_attribute_info_list_add(list, name, type, flags); }
GType (g_file_enumerator_get_type)(void) { return stub_funcs.ptr_g_file_enumerator_get_type(); }
GFileInfo* (g_file_enumerator_next_file)(GFileEnumerator *enumerator, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_enumerator_next_file(enumerator, cancellable, error); }
gboolean (g_file_enumerator_close)(GFileEnumerator *enumerator, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_enumerator_close(enumerator, cancellable, error); }
void (g_file_enumerator_next_files_async)(GFileEnumerator *enumerator, int num_files, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_enumerator_next_files_async(enumerator, num_files, io_priority, cancellable, callback, user_data); }
GList * (g_file_enumerator_next_files_finish)(GFileEnumerator *enumerator, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_enumerator_next_files_finish(enumerator, result, error); }
void (g_file_enumerator_close_async)(GFileEnumerator *enumerator, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_enumerator_close_async(enumerator, io_priority, cancellable, callback, user_data); }
gboolean (g_file_enumerator_close_finish)(GFileEnumerator *enumerator, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_enumerator_close_finish(enumerator, result, error); }
gboolean (g_file_enumerator_is_closed)(GFileEnumerator *enumerator) { return stub_funcs.ptr_g_file_enumerator_is_closed(enumerator); }
gboolean (g_file_enumerator_has_pending)(GFileEnumerator *enumerator) { return stub_funcs.ptr_g_file_enumerator_has_pending(enumerator); }
void (g_file_enumerator_set_pending)(GFileEnumerator *enumerator, gboolean pending) { stub_funcs.ptr_g_file_enumerator_set_pending(enumerator, pending); }
GFile * (g_file_enumerator_get_container)(GFileEnumerator *enumerator) { return stub_funcs.ptr_g_file_enumerator_get_container(enumerator); }
GFile * (g_file_enumerator_get_child)(GFileEnumerator *enumerator, GFileInfo *info) { return stub_funcs.ptr_g_file_enumerator_get_child(enumerator, info); }
gboolean (g_file_enumerator_iterate)(GFileEnumerator *direnum, GFileInfo **out_info, GFile **out_child, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_enumerator_iterate(direnum, out_info, out_child, cancellable, error); }
GType (g_file_icon_get_type)(void) { return stub_funcs.ptr_g_file_icon_get_type(); }
GIcon * (g_file_icon_new)(GFile *file) { return stub_funcs.ptr_g_file_icon_new(file); }
GFile * (g_file_icon_get_file)(GFileIcon *icon) { return stub_funcs.ptr_g_file_icon_get_file(icon); }
GType (g_file_info_get_type)(void) { return stub_funcs.ptr_g_file_info_get_type(); }
GFileInfo * (g_file_info_new)(void) { return stub_funcs.ptr_g_file_info_new(); }
GFileInfo * (g_file_info_dup)(GFileInfo *other) { return stub_funcs.ptr_g_file_info_dup(other); }
void (g_file_info_copy_into)(GFileInfo *src_info, GFileInfo *dest_info) { stub_funcs.ptr_g_file_info_copy_into(src_info, dest_info); }
gboolean (g_file_info_has_attribute)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_has_attribute(info, attribute); }
gboolean (g_file_info_has_namespace)(GFileInfo *info, const char *name_space) { return stub_funcs.ptr_g_file_info_has_namespace(info, name_space); }
char ** (g_file_info_list_attributes)(GFileInfo *info, const char *name_space) { return stub_funcs.ptr_g_file_info_list_attributes(info, name_space); }
gboolean (g_file_info_get_attribute_data)(GFileInfo *info, const char *attribute, GFileAttributeType *type, gpointer *value_pp, GFileAttributeStatus *status) { return stub_funcs.ptr_g_file_info_get_attribute_data(info, attribute, type, value_pp, status); }
GFileAttributeType (g_file_info_get_attribute_type)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_type(info, attribute); }
void (g_file_info_remove_attribute)(GFileInfo *info, const char *attribute) { stub_funcs.ptr_g_file_info_remove_attribute(info, attribute); }
GFileAttributeStatus (g_file_info_get_attribute_status)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_status(info, attribute); }
gboolean (g_file_info_set_attribute_status)(GFileInfo *info, const char *attribute, GFileAttributeStatus status) { return stub_funcs.ptr_g_file_info_set_attribute_status(info, attribute, status); }
char * (g_file_info_get_attribute_as_string)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_as_string(info, attribute); }
const char * (g_file_info_get_attribute_string)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_string(info, attribute); }
const char * (g_file_info_get_attribute_byte_string)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_byte_string(info, attribute); }
gboolean (g_file_info_get_attribute_boolean)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_boolean(info, attribute); }
guint32 (g_file_info_get_attribute_uint32)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_uint32(info, attribute); }
gint32 (g_file_info_get_attribute_int32)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_int32(info, attribute); }
guint64 (g_file_info_get_attribute_uint64)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_uint64(info, attribute); }
gint64 (g_file_info_get_attribute_int64)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_int64(info, attribute); }
GObject * (g_file_info_get_attribute_object)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_object(info, attribute); }
char ** (g_file_info_get_attribute_stringv)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_stringv(info, attribute); }
const char * (g_file_info_get_attribute_file_path)(GFileInfo *info, const char *attribute) { return stub_funcs.ptr_g_file_info_get_attribute_file_path(info, attribute); }
void (g_file_info_set_attribute)(GFileInfo *info, const char *attribute, GFileAttributeType type, gpointer value_p) { stub_funcs.ptr_g_file_info_set_attribute(info, attribute, type, value_p); }
void (g_file_info_set_attribute_string)(GFileInfo *info, const char *attribute, const char *attr_value) { stub_funcs.ptr_g_file_info_set_attribute_string(info, attribute, attr_value); }
void (g_file_info_set_attribute_byte_string)(GFileInfo *info, const char *attribute, const char *attr_value) { stub_funcs.ptr_g_file_info_set_attribute_byte_string(info, attribute, attr_value); }
void (g_file_info_set_attribute_boolean)(GFileInfo *info, const char *attribute, gboolean attr_value) { stub_funcs.ptr_g_file_info_set_attribute_boolean(info, attribute, attr_value); }
void (g_file_info_set_attribute_uint32)(GFileInfo *info, const char *attribute, guint32 attr_value) { stub_funcs.ptr_g_file_info_set_attribute_uint32(info, attribute, attr_value); }
void (g_file_info_set_attribute_int32)(GFileInfo *info, const char *attribute, gint32 attr_value) { stub_funcs.ptr_g_file_info_set_attribute_int32(info, attribute, attr_value); }
void (g_file_info_set_attribute_uint64)(GFileInfo *info, const char *attribute, guint64 attr_value) { stub_funcs.ptr_g_file_info_set_attribute_uint64(info, attribute, attr_value); }
void (g_file_info_set_attribute_int64)(GFileInfo *info, const char *attribute, gint64 attr_value) { stub_funcs.ptr_g_file_info_set_attribute_int64(info, attribute, attr_value); }
void (g_file_info_set_attribute_object)(GFileInfo *info, const char *attribute, GObject *attr_value) { stub_funcs.ptr_g_file_info_set_attribute_object(info, attribute, attr_value); }
void (g_file_info_set_attribute_stringv)(GFileInfo *info, const char *attribute, char **attr_value) { stub_funcs.ptr_g_file_info_set_attribute_stringv(info, attribute, attr_value); }
void (g_file_info_set_attribute_file_path)(GFileInfo *info, const char *attribute, const char *attr_value) { stub_funcs.ptr_g_file_info_set_attribute_file_path(info, attribute, attr_value); }
void (g_file_info_clear_status)(GFileInfo *info) { stub_funcs.ptr_g_file_info_clear_status(info); }
GDateTime * (g_file_info_get_deletion_date)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_deletion_date(info); }
GFileType (g_file_info_get_file_type)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_file_type(info); }
gboolean (g_file_info_get_is_hidden)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_is_hidden(info); }
gboolean (g_file_info_get_is_backup)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_is_backup(info); }
gboolean (g_file_info_get_is_symlink)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_is_symlink(info); }
const char * (g_file_info_get_name)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_name(info); }
const char * (g_file_info_get_display_name)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_display_name(info); }
const char * (g_file_info_get_edit_name)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_edit_name(info); }
GIcon * (g_file_info_get_icon)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_icon(info); }
GIcon * (g_file_info_get_symbolic_icon)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_symbolic_icon(info); }
const char * (g_file_info_get_content_type)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_content_type(info); }
goffset (g_file_info_get_size)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_size(info); }
GDateTime * (g_file_info_get_access_date_time)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_access_date_time(info); }
GDateTime * (g_file_info_get_creation_date_time)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_creation_date_time(info); }
const char * (g_file_info_get_symlink_target)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_symlink_target(info); }
const char * (g_file_info_get_etag)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_etag(info); }
gint32 (g_file_info_get_sort_order)(GFileInfo *info) { return stub_funcs.ptr_g_file_info_get_sort_order(info); }
void (g_file_info_set_attribute_mask)(GFileInfo *info, GFileAttributeMatcher *mask) { stub_funcs.ptr_g_file_info_set_attribute_mask(info, mask); }
void (g_file_info_unset_attribute_mask)(GFileInfo *info) { stub_funcs.ptr_g_file_info_unset_attribute_mask(info); }
void (g_file_info_set_file_type)(GFileInfo *info, GFileType type) { stub_funcs.ptr_g_file_info_set_file_type(info, type); }
void (g_file_info_set_is_hidden)(GFileInfo *info, gboolean is_hidden) { stub_funcs.ptr_g_file_info_set_is_hidden(info, is_hidden); }
void (g_file_info_set_is_symlink)(GFileInfo *info, gboolean is_symlink) { stub_funcs.ptr_g_file_info_set_is_symlink(info, is_symlink); }
void (g_file_info_set_name)(GFileInfo *info, const char *name) { stub_funcs.ptr_g_file_info_set_name(info, name); }
void (g_file_info_set_display_name)(GFileInfo *info, const char *display_name) { stub_funcs.ptr_g_file_info_set_display_name(info, display_name); }
void (g_file_info_set_edit_name)(GFileInfo *info, const char *edit_name) { stub_funcs.ptr_g_file_info_set_edit_name(info, edit_name); }
void (g_file_info_set_icon)(GFileInfo *info, GIcon *icon) { stub_funcs.ptr_g_file_info_set_icon(info, icon); }
void (g_file_info_set_symbolic_icon)(GFileInfo *info, GIcon *icon) { stub_funcs.ptr_g_file_info_set_symbolic_icon(info, icon); }
void (g_file_info_set_content_type)(GFileInfo *info, const char *content_type) { stub_funcs.ptr_g_file_info_set_content_type(info, content_type); }
void (g_file_info_set_size)(GFileInfo *info, goffset size) { stub_funcs.ptr_g_file_info_set_size(info, size); }
void (g_file_info_set_access_date_time)(GFileInfo *info, GDateTime *atime) { stub_funcs.ptr_g_file_info_set_access_date_time(info, atime); }
void (g_file_info_set_creation_date_time)(GFileInfo *info, GDateTime *creation_time) { stub_funcs.ptr_g_file_info_set_creation_date_time(info, creation_time); }
void (g_file_info_set_symlink_target)(GFileInfo *info, const char *symlink_target) { stub_funcs.ptr_g_file_info_set_symlink_target(info, symlink_target); }
void (g_file_info_set_sort_order)(GFileInfo *info, gint32 sort_order) { stub_funcs.ptr_g_file_info_set_sort_order(info, sort_order); }
GType (g_file_attribute_matcher_get_type)(void) { return stub_funcs.ptr_g_file_attribute_matcher_get_type(); }
GFileAttributeMatcher* (g_file_attribute_matcher_new)(const char *attributes) { return stub_funcs.ptr_g_file_attribute_matcher_new(attributes); }
GFileAttributeMatcher* (g_file_attribute_matcher_ref)(GFileAttributeMatcher *matcher) { return stub_funcs.ptr_g_file_attribute_matcher_ref(matcher); }
void (g_file_attribute_matcher_unref)(GFileAttributeMatcher *matcher) { stub_funcs.ptr_g_file_attribute_matcher_unref(matcher); }
GFileAttributeMatcher* (g_file_attribute_matcher_subtract)(GFileAttributeMatcher *matcher, GFileAttributeMatcher *subtract) { return stub_funcs.ptr_g_file_attribute_matcher_subtract(matcher, subtract); }
gboolean (g_file_attribute_matcher_matches)(GFileAttributeMatcher *matcher, const char *attribute) { return stub_funcs.ptr_g_file_attribute_matcher_matches(matcher, attribute); }
gboolean (g_file_attribute_matcher_matches_only)(GFileAttributeMatcher *matcher, const char *attribute) { return stub_funcs.ptr_g_file_attribute_matcher_matches_only(matcher, attribute); }
gboolean (g_file_attribute_matcher_enumerate_namespace)(GFileAttributeMatcher *matcher, const char *ns) { return stub_funcs.ptr_g_file_attribute_matcher_enumerate_namespace(matcher, ns); }
const char * (g_file_attribute_matcher_enumerate_next)(GFileAttributeMatcher *matcher) { return stub_funcs.ptr_g_file_attribute_matcher_enumerate_next(matcher); }
char * (g_file_attribute_matcher_to_string)(GFileAttributeMatcher *matcher) { return stub_funcs.ptr_g_file_attribute_matcher_to_string(matcher); }
GType (g_file_input_stream_get_type)(void) { return stub_funcs.ptr_g_file_input_stream_get_type(); }
GFileInfo* (g_file_input_stream_query_info)(GFileInputStream *stream, const char *attributes, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_input_stream_query_info(stream, attributes, cancellable, error); }
void (g_file_input_stream_query_info_async)(GFileInputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_input_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data); }
GFileInfo* (g_file_input_stream_query_info_finish)(GFileInputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_input_stream_query_info_finish(stream, result, error); }
GType (g_file_io_stream_get_type)(void) { return stub_funcs.ptr_g_file_io_stream_get_type(); }
GFileInfo* (g_file_io_stream_query_info)(GFileIOStream *stream, const char *attributes, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_io_stream_query_info(stream, attributes, cancellable, error); }
void (g_file_io_stream_query_info_async)(GFileIOStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_io_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data); }
GFileInfo* (g_file_io_stream_query_info_finish)(GFileIOStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_io_stream_query_info_finish(stream, result, error); }
char * (g_file_io_stream_get_etag)(GFileIOStream *stream) { return stub_funcs.ptr_g_file_io_stream_get_etag(stream); }
GType (g_file_monitor_get_type)(void) { return stub_funcs.ptr_g_file_monitor_get_type(); }
gboolean (g_file_monitor_cancel)(GFileMonitor *monitor) { return stub_funcs.ptr_g_file_monitor_cancel(monitor); }
gboolean (g_file_monitor_is_cancelled)(GFileMonitor *monitor) { return stub_funcs.ptr_g_file_monitor_is_cancelled(monitor); }
void (g_file_monitor_set_rate_limit)(GFileMonitor *monitor, gint limit_msecs) { stub_funcs.ptr_g_file_monitor_set_rate_limit(monitor, limit_msecs); }
void (g_file_monitor_emit_event)(GFileMonitor *monitor, GFile *child, GFile *other_file, GFileMonitorEvent event_type) { stub_funcs.ptr_g_file_monitor_emit_event(monitor, child, other_file, event_type); }
GType (g_filename_completer_get_type)(void) { return stub_funcs.ptr_g_filename_completer_get_type(); }
GFilenameCompleter* (g_filename_completer_new)(void) { return stub_funcs.ptr_g_filename_completer_new(); }
char * (g_filename_completer_get_completion_suffix)(GFilenameCompleter *completer, const char *initial_text) { return stub_funcs.ptr_g_filename_completer_get_completion_suffix(completer, initial_text); }
char ** (g_filename_completer_get_completions)(GFilenameCompleter *completer, const char *initial_text) { return stub_funcs.ptr_g_filename_completer_get_completions(completer, initial_text); }
void (g_filename_completer_set_dirs_only)(GFilenameCompleter *completer, gboolean dirs_only) { stub_funcs.ptr_g_filename_completer_set_dirs_only(completer, dirs_only); }
GType (g_file_output_stream_get_type)(void) { return stub_funcs.ptr_g_file_output_stream_get_type(); }
GFileInfo* (g_file_output_stream_query_info)(GFileOutputStream *stream, const char *attributes, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_file_output_stream_query_info(stream, attributes, cancellable, error); }
void (g_file_output_stream_query_info_async)(GFileOutputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_file_output_stream_query_info_async(stream, attributes, io_priority, cancellable, callback, user_data); }
GFileInfo* (g_file_output_stream_query_info_finish)(GFileOutputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_file_output_stream_query_info_finish(stream, result, error); }
char * (g_file_output_stream_get_etag)(GFileOutputStream *stream) { return stub_funcs.ptr_g_file_output_stream_get_etag(stream); }
GType (g_filter_input_stream_get_type)(void) { return stub_funcs.ptr_g_filter_input_stream_get_type(); }
GInputStream * (g_filter_input_stream_get_base_stream)(GFilterInputStream *stream) { return stub_funcs.ptr_g_filter_input_stream_get_base_stream(stream); }
gboolean (g_filter_input_stream_get_close_base_stream)(GFilterInputStream *stream) { return stub_funcs.ptr_g_filter_input_stream_get_close_base_stream(stream); }
void (g_filter_input_stream_set_close_base_stream)(GFilterInputStream *stream, gboolean close_base) { stub_funcs.ptr_g_filter_input_stream_set_close_base_stream(stream, close_base); }
GType (g_filter_output_stream_get_type)(void) { return stub_funcs.ptr_g_filter_output_stream_get_type(); }
GOutputStream * (g_filter_output_stream_get_base_stream)(GFilterOutputStream *stream) { return stub_funcs.ptr_g_filter_output_stream_get_base_stream(stream); }
gboolean (g_filter_output_stream_get_close_base_stream)(GFilterOutputStream *stream) { return stub_funcs.ptr_g_filter_output_stream_get_close_base_stream(stream); }
void (g_filter_output_stream_set_close_base_stream)(GFilterOutputStream *stream, gboolean close_base) { stub_funcs.ptr_g_filter_output_stream_set_close_base_stream(stream, close_base); }
GType (g_icon_get_type)(void) { return stub_funcs.ptr_g_icon_get_type(); }
guint (g_icon_hash)(gconstpointer icon) { return stub_funcs.ptr_g_icon_hash(icon); }
gboolean (g_icon_equal)(GIcon *icon1, GIcon *icon2) { return stub_funcs.ptr_g_icon_equal(icon1, icon2); }
gchar* (g_icon_to_string)(GIcon *icon) { return stub_funcs.ptr_g_icon_to_string(icon); }
GIcon* (g_icon_new_for_string)(const gchar *str, GError **error) { return stub_funcs.ptr_g_icon_new_for_string(str, error); }
GVariant * (g_icon_serialize)(GIcon *icon) { return stub_funcs.ptr_g_icon_serialize(icon); }
GIcon * (g_icon_deserialize)(GVariant *value) { return stub_funcs.ptr_g_icon_deserialize(value); }
GType (g_inet_address_get_type)(void) { return stub_funcs.ptr_g_inet_address_get_type(); }
GInetAddress * (g_inet_address_new_from_string)(const gchar *string) { return stub_funcs.ptr_g_inet_address_new_from_string(string); }
GInetAddress * (g_inet_address_new_from_bytes)(const guint8 *bytes, GSocketFamily family) { return stub_funcs.ptr_g_inet_address_new_from_bytes(bytes, family); }
GInetAddress * (g_inet_address_new_loopback)(GSocketFamily family) { return stub_funcs.ptr_g_inet_address_new_loopback(family); }
GInetAddress * (g_inet_address_new_any)(GSocketFamily family) { return stub_funcs.ptr_g_inet_address_new_any(family); }
gboolean (g_inet_address_equal)(GInetAddress *address, GInetAddress *other_address) { return stub_funcs.ptr_g_inet_address_equal(address, other_address); }
gchar * (g_inet_address_to_string)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_to_string(address); }
const guint8 * (g_inet_address_to_bytes)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_to_bytes(address); }
gsize (g_inet_address_get_native_size)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_native_size(address); }
GSocketFamily (g_inet_address_get_family)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_family(address); }
gboolean (g_inet_address_get_is_any)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_any(address); }
gboolean (g_inet_address_get_is_loopback)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_loopback(address); }
gboolean (g_inet_address_get_is_link_local)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_link_local(address); }
gboolean (g_inet_address_get_is_site_local)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_site_local(address); }
gboolean (g_inet_address_get_is_multicast)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_multicast(address); }
gboolean (g_inet_address_get_is_mc_global)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_mc_global(address); }
gboolean (g_inet_address_get_is_mc_link_local)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_mc_link_local(address); }
gboolean (g_inet_address_get_is_mc_node_local)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_mc_node_local(address); }
gboolean (g_inet_address_get_is_mc_org_local)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_mc_org_local(address); }
gboolean (g_inet_address_get_is_mc_site_local)(GInetAddress *address) { return stub_funcs.ptr_g_inet_address_get_is_mc_site_local(address); }
GType (g_inet_address_mask_get_type)(void) { return stub_funcs.ptr_g_inet_address_mask_get_type(); }
GInetAddressMask* (g_inet_address_mask_new)(GInetAddress *addr, guint length, GError **error) { return stub_funcs.ptr_g_inet_address_mask_new(addr, length, error); }
GInetAddressMask* (g_inet_address_mask_new_from_string)(const gchar *mask_string, GError **error) { return stub_funcs.ptr_g_inet_address_mask_new_from_string(mask_string, error); }
gchar* (g_inet_address_mask_to_string)(GInetAddressMask *mask) { return stub_funcs.ptr_g_inet_address_mask_to_string(mask); }
GSocketFamily (g_inet_address_mask_get_family)(GInetAddressMask *mask) { return stub_funcs.ptr_g_inet_address_mask_get_family(mask); }
GInetAddress* (g_inet_address_mask_get_address)(GInetAddressMask *mask) { return stub_funcs.ptr_g_inet_address_mask_get_address(mask); }
guint (g_inet_address_mask_get_length)(GInetAddressMask *mask) { return stub_funcs.ptr_g_inet_address_mask_get_length(mask); }
gboolean (g_inet_address_mask_matches)(GInetAddressMask *mask, GInetAddress *address) { return stub_funcs.ptr_g_inet_address_mask_matches(mask, address); }
gboolean (g_inet_address_mask_equal)(GInetAddressMask *mask, GInetAddressMask *mask2) { return stub_funcs.ptr_g_inet_address_mask_equal(mask, mask2); }
GType (g_inet_socket_address_get_type)(void) { return stub_funcs.ptr_g_inet_socket_address_get_type(); }
GSocketAddress* (g_inet_socket_address_new)(GInetAddress *address, guint16 port) { return stub_funcs.ptr_g_inet_socket_address_new(address, port); }
GSocketAddress* (g_inet_socket_address_new_from_string)(const char *address, guint port) { return stub_funcs.ptr_g_inet_socket_address_new_from_string(address, port); }
GInetAddress * (g_inet_socket_address_get_address)(GInetSocketAddress *address) { return stub_funcs.ptr_g_inet_socket_address_get_address(address); }
guint16 (g_inet_socket_address_get_port)(GInetSocketAddress *address) { return stub_funcs.ptr_g_inet_socket_address_get_port(address); }
guint32 (g_inet_socket_address_get_flowinfo)(GInetSocketAddress *address) { return stub_funcs.ptr_g_inet_socket_address_get_flowinfo(address); }
guint32 (g_inet_socket_address_get_scope_id)(GInetSocketAddress *address) { return stub_funcs.ptr_g_inet_socket_address_get_scope_id(address); }
GType (g_initable_get_type)(void) { return stub_funcs.ptr_g_initable_get_type(); }
gboolean (g_initable_init)(GInitable *initable, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_initable_init(initable, cancellable, error); }
// Unable to locate va_equiv for g_initable_new
GType (g_input_stream_get_type)(void) { return stub_funcs.ptr_g_input_stream_get_type(); }
gssize (g_input_stream_read)(GInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_input_stream_read(stream, buffer, count, cancellable, error); }
gboolean (g_input_stream_read_all)(GInputStream *stream, void *buffer, gsize count, gsize *bytes_read, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_input_stream_read_all(stream, buffer, count, bytes_read, cancellable, error); }
GBytes* (g_input_stream_read_bytes)(GInputStream *stream, gsize count, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_input_stream_read_bytes(stream, count, cancellable, error); }
gssize (g_input_stream_skip)(GInputStream *stream, gsize count, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_input_stream_skip(stream, count, cancellable, error); }
gboolean (g_input_stream_close)(GInputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_input_stream_close(stream, cancellable, error); }
void (g_input_stream_read_async)(GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_input_stream_read_async(stream, buffer, count, io_priority, cancellable, callback, user_data); }
gssize (g_input_stream_read_finish)(GInputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_input_stream_read_finish(stream, result, error); }
void (g_input_stream_read_all_async)(GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_input_stream_read_all_async(stream, buffer, count, io_priority, cancellable, callback, user_data); }
gboolean (g_input_stream_read_all_finish)(GInputStream *stream, GAsyncResult *result, gsize *bytes_read, GError **error) { return stub_funcs.ptr_g_input_stream_read_all_finish(stream, result, bytes_read, error); }
void (g_input_stream_read_bytes_async)(GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_input_stream_read_bytes_async(stream, count, io_priority, cancellable, callback, user_data); }
GBytes* (g_input_stream_read_bytes_finish)(GInputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_input_stream_read_bytes_finish(stream, result, error); }
void (g_input_stream_skip_async)(GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_input_stream_skip_async(stream, count, io_priority, cancellable, callback, user_data); }
gssize (g_input_stream_skip_finish)(GInputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_input_stream_skip_finish(stream, result, error); }
void (g_input_stream_close_async)(GInputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_input_stream_close_async(stream, io_priority, cancellable, callback, user_data); }
gboolean (g_input_stream_close_finish)(GInputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_input_stream_close_finish(stream, result, error); }
gboolean (g_input_stream_is_closed)(GInputStream *stream) { return stub_funcs.ptr_g_input_stream_is_closed(stream); }
gboolean (g_input_stream_has_pending)(GInputStream *stream) { return stub_funcs.ptr_g_input_stream_has_pending(stream); }
gboolean (g_input_stream_set_pending)(GInputStream *stream, GError **error) { return stub_funcs.ptr_g_input_stream_set_pending(stream, error); }
void (g_input_stream_clear_pending)(GInputStream *stream) { stub_funcs.ptr_g_input_stream_clear_pending(stream); }
GType (g_app_info_create_flags_get_type)(void) { return stub_funcs.ptr_g_app_info_create_flags_get_type(); }
GType (g_converter_flags_get_type)(void) { return stub_funcs.ptr_g_converter_flags_get_type(); }
GType (g_converter_result_get_type)(void) { return stub_funcs.ptr_g_converter_result_get_type(); }
GType (g_data_stream_byte_order_get_type)(void) { return stub_funcs.ptr_g_data_stream_byte_order_get_type(); }
GType (g_data_stream_newline_type_get_type)(void) { return stub_funcs.ptr_g_data_stream_newline_type_get_type(); }
GType (g_file_attribute_type_get_type)(void) { return stub_funcs.ptr_g_file_attribute_type_get_type(); }
GType (g_file_attribute_info_flags_get_type)(void) { return stub_funcs.ptr_g_file_attribute_info_flags_get_type(); }
GType (g_file_attribute_status_get_type)(void) { return stub_funcs.ptr_g_file_attribute_status_get_type(); }
GType (g_file_query_info_flags_get_type)(void) { return stub_funcs.ptr_g_file_query_info_flags_get_type(); }
GType (g_file_create_flags_get_type)(void) { return stub_funcs.ptr_g_file_create_flags_get_type(); }
GType (g_file_measure_flags_get_type)(void) { return stub_funcs.ptr_g_file_measure_flags_get_type(); }
GType (g_mount_mount_flags_get_type)(void) { return stub_funcs.ptr_g_mount_mount_flags_get_type(); }
GType (g_mount_unmount_flags_get_type)(void) { return stub_funcs.ptr_g_mount_unmount_flags_get_type(); }
GType (g_drive_start_flags_get_type)(void) { return stub_funcs.ptr_g_drive_start_flags_get_type(); }
GType (g_drive_start_stop_type_get_type)(void) { return stub_funcs.ptr_g_drive_start_stop_type_get_type(); }
GType (g_file_copy_flags_get_type)(void) { return stub_funcs.ptr_g_file_copy_flags_get_type(); }
GType (g_file_monitor_flags_get_type)(void) { return stub_funcs.ptr_g_file_monitor_flags_get_type(); }
GType (g_file_type_get_type)(void) { return stub_funcs.ptr_g_file_type_get_type(); }
GType (g_filesystem_preview_type_get_type)(void) { return stub_funcs.ptr_g_filesystem_preview_type_get_type(); }
GType (g_file_monitor_event_get_type)(void) { return stub_funcs.ptr_g_file_monitor_event_get_type(); }
GType (g_io_error_enum_get_type)(void) { return stub_funcs.ptr_g_io_error_enum_get_type(); }
GType (g_ask_password_flags_get_type)(void) { return stub_funcs.ptr_g_ask_password_flags_get_type(); }
GType (g_password_save_get_type)(void) { return stub_funcs.ptr_g_password_save_get_type(); }
GType (g_mount_operation_result_get_type)(void) { return stub_funcs.ptr_g_mount_operation_result_get_type(); }
GType (g_output_stream_splice_flags_get_type)(void) { return stub_funcs.ptr_g_output_stream_splice_flags_get_type(); }
GType (g_io_stream_splice_flags_get_type)(void) { return stub_funcs.ptr_g_io_stream_splice_flags_get_type(); }
GType (g_emblem_origin_get_type)(void) { return stub_funcs.ptr_g_emblem_origin_get_type(); }
GType (g_resolver_error_get_type)(void) { return stub_funcs.ptr_g_resolver_error_get_type(); }
GType (g_resolver_record_type_get_type)(void) { return stub_funcs.ptr_g_resolver_record_type_get_type(); }
GType (g_resource_error_get_type)(void) { return stub_funcs.ptr_g_resource_error_get_type(); }
GType (g_resource_flags_get_type)(void) { return stub_funcs.ptr_g_resource_flags_get_type(); }
GType (g_resource_lookup_flags_get_type)(void) { return stub_funcs.ptr_g_resource_lookup_flags_get_type(); }
GType (g_socket_family_get_type)(void) { return stub_funcs.ptr_g_socket_family_get_type(); }
GType (g_socket_type_get_type)(void) { return stub_funcs.ptr_g_socket_type_get_type(); }
GType (g_socket_msg_flags_get_type)(void) { return stub_funcs.ptr_g_socket_msg_flags_get_type(); }
GType (g_socket_protocol_get_type)(void) { return stub_funcs.ptr_g_socket_protocol_get_type(); }
GType (g_zlib_compressor_format_get_type)(void) { return stub_funcs.ptr_g_zlib_compressor_format_get_type(); }
GType (g_unix_socket_address_type_get_type)(void) { return stub_funcs.ptr_g_unix_socket_address_type_get_type(); }
GType (g_bus_type_get_type)(void) { return stub_funcs.ptr_g_bus_type_get_type(); }
GType (g_bus_name_owner_flags_get_type)(void) { return stub_funcs.ptr_g_bus_name_owner_flags_get_type(); }
GType (g_bus_name_watcher_flags_get_type)(void) { return stub_funcs.ptr_g_bus_name_watcher_flags_get_type(); }
GType (g_dbus_proxy_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_proxy_flags_get_type(); }
GType (g_dbus_error_get_type)(void) { return stub_funcs.ptr_g_dbus_error_get_type(); }
GType (g_dbus_connection_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_connection_flags_get_type(); }
GType (g_dbus_capability_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_capability_flags_get_type(); }
GType (g_dbus_call_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_call_flags_get_type(); }
GType (g_dbus_message_type_get_type)(void) { return stub_funcs.ptr_g_dbus_message_type_get_type(); }
GType (g_dbus_message_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_message_flags_get_type(); }
GType (g_dbus_message_header_field_get_type)(void) { return stub_funcs.ptr_g_dbus_message_header_field_get_type(); }
GType (g_dbus_property_info_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_property_info_flags_get_type(); }
GType (g_dbus_subtree_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_subtree_flags_get_type(); }
GType (g_dbus_server_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_server_flags_get_type(); }
GType (g_dbus_signal_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_signal_flags_get_type(); }
GType (g_dbus_send_message_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_send_message_flags_get_type(); }
GType (g_credentials_type_get_type)(void) { return stub_funcs.ptr_g_credentials_type_get_type(); }
GType (g_dbus_message_byte_order_get_type)(void) { return stub_funcs.ptr_g_dbus_message_byte_order_get_type(); }
GType (g_application_flags_get_type)(void) { return stub_funcs.ptr_g_application_flags_get_type(); }
GType (g_tls_error_get_type)(void) { return stub_funcs.ptr_g_tls_error_get_type(); }
GType (g_tls_certificate_flags_get_type)(void) { return stub_funcs.ptr_g_tls_certificate_flags_get_type(); }
GType (g_tls_authentication_mode_get_type)(void) { return stub_funcs.ptr_g_tls_authentication_mode_get_type(); }
GType (g_tls_channel_binding_type_get_type)(void) { return stub_funcs.ptr_g_tls_channel_binding_type_get_type(); }
GType (g_tls_channel_binding_error_get_type)(void) { return stub_funcs.ptr_g_tls_channel_binding_error_get_type(); }
GType (g_tls_rehandshake_mode_get_type)(void) { return stub_funcs.ptr_g_tls_rehandshake_mode_get_type(); }
GType (g_tls_password_flags_get_type)(void) { return stub_funcs.ptr_g_tls_password_flags_get_type(); }
GType (g_tls_interaction_result_get_type)(void) { return stub_funcs.ptr_g_tls_interaction_result_get_type(); }
GType (g_dbus_interface_skeleton_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_interface_skeleton_flags_get_type(); }
GType (g_dbus_object_manager_client_flags_get_type)(void) { return stub_funcs.ptr_g_dbus_object_manager_client_flags_get_type(); }
GType (g_tls_database_verify_flags_get_type)(void) { return stub_funcs.ptr_g_tls_database_verify_flags_get_type(); }
GType (g_tls_database_lookup_flags_get_type)(void) { return stub_funcs.ptr_g_tls_database_lookup_flags_get_type(); }
GType (g_tls_certificate_request_flags_get_type)(void) { return stub_funcs.ptr_g_tls_certificate_request_flags_get_type(); }
GType (g_tls_protocol_version_get_type)(void) { return stub_funcs.ptr_g_tls_protocol_version_get_type(); }
GType (g_io_module_scope_flags_get_type)(void) { return stub_funcs.ptr_g_io_module_scope_flags_get_type(); }
GType (g_socket_client_event_get_type)(void) { return stub_funcs.ptr_g_socket_client_event_get_type(); }
GType (g_socket_listener_event_get_type)(void) { return stub_funcs.ptr_g_socket_listener_event_get_type(); }
GType (g_test_dbus_flags_get_type)(void) { return stub_funcs.ptr_g_test_dbus_flags_get_type(); }
GType (g_subprocess_flags_get_type)(void) { return stub_funcs.ptr_g_subprocess_flags_get_type(); }
GType (g_notification_priority_get_type)(void) { return stub_funcs.ptr_g_notification_priority_get_type(); }
GType (g_network_connectivity_get_type)(void) { return stub_funcs.ptr_g_network_connectivity_get_type(); }
GType (g_pollable_return_get_type)(void) { return stub_funcs.ptr_g_pollable_return_get_type(); }
GType (g_memory_monitor_warning_level_get_type)(void) { return stub_funcs.ptr_g_memory_monitor_warning_level_get_type(); }
GType (g_resolver_name_lookup_flags_get_type)(void) { return stub_funcs.ptr_g_resolver_name_lookup_flags_get_type(); }
GType (g_settings_bind_flags_get_type)(void) { return stub_funcs.ptr_g_settings_bind_flags_get_type(); }
GIOErrorEnum (g_io_error_from_errno)(gint err_no) { return stub_funcs.ptr_g_io_error_from_errno(err_no); }
GIOErrorEnum (g_io_error_from_file_error)(GFileError file_error) { return stub_funcs.ptr_g_io_error_from_file_error(file_error); }
GIOErrorEnum (g_io_error_from_win32_error)(gint error_code) { return stub_funcs.ptr_g_io_error_from_win32_error(error_code); }
GQuark (g_io_error_quark)(void) { return stub_funcs.ptr_g_io_error_quark(); }
void (g_io_module_scope_free)(GIOModuleScope *scope) { stub_funcs.ptr_g_io_module_scope_free(scope); }
void (g_io_module_scope_block)(GIOModuleScope *scope, const gchar *basename) { stub_funcs.ptr_g_io_module_scope_block(scope, basename); }
GType (g_io_module_get_type)(void) { return stub_funcs.ptr_g_io_module_get_type(); }
GIOModule* (g_io_module_new)(const gchar *filename) { return stub_funcs.ptr_g_io_module_new(filename); }
void (g_io_modules_scan_all_in_directory)(const char *dirname) { stub_funcs.ptr_g_io_modules_scan_all_in_directory(dirname); }
GList* (g_io_modules_load_all_in_directory)(const gchar *dirname) { return stub_funcs.ptr_g_io_modules_load_all_in_directory(dirname); }
void (g_io_modules_scan_all_in_directory_with_scope)(const gchar *dirname, GIOModuleScope *scope) { stub_funcs.ptr_g_io_modules_scan_all_in_directory_with_scope(dirname, scope); }
GList* (g_io_modules_load_all_in_directory_with_scope)(const gchar *dirname, GIOModuleScope *scope) { return stub_funcs.ptr_g_io_modules_load_all_in_directory_with_scope(dirname, scope); }
GIOExtensionPoint* (g_io_extension_point_register)(const char *name) { return stub_funcs.ptr_g_io_extension_point_register(name); }
GIOExtensionPoint* (g_io_extension_point_lookup)(const char *name) { return stub_funcs.ptr_g_io_extension_point_lookup(name); }
void (g_io_extension_point_set_required_type)(GIOExtensionPoint *extension_point, GType type) { stub_funcs.ptr_g_io_extension_point_set_required_type(extension_point, type); }
GType (g_io_extension_point_get_required_type)(GIOExtensionPoint *extension_point) { return stub_funcs.ptr_g_io_extension_point_get_required_type(extension_point); }
GList* (g_io_extension_point_get_extensions)(GIOExtensionPoint *extension_point) { return stub_funcs.ptr_g_io_extension_point_get_extensions(extension_point); }
GIOExtension * (g_io_extension_point_get_extension_by_name)(GIOExtensionPoint *extension_point, const char *name) { return stub_funcs.ptr_g_io_extension_point_get_extension_by_name(extension_point, name); }
GIOExtension * (g_io_extension_point_implement)(const char *extension_point_name, GType type, const char *extension_name, gint priority) { return stub_funcs.ptr_g_io_extension_point_implement(extension_point_name, type, extension_name, priority); }
GType (g_io_extension_get_type)(GIOExtension *extension) { return stub_funcs.ptr_g_io_extension_get_type(extension); }
const char * (g_io_extension_get_name)(GIOExtension *extension) { return stub_funcs.ptr_g_io_extension_get_name(extension); }
gint (g_io_extension_get_priority)(GIOExtension *extension) { return stub_funcs.ptr_g_io_extension_get_priority(extension); }
GTypeClass* (g_io_extension_ref_class)(GIOExtension *extension) { return stub_funcs.ptr_g_io_extension_ref_class(extension); }
void (g_io_module_load)(GIOModule *module) { stub_funcs.ptr_g_io_module_load(module); }
void (g_io_module_unload)(GIOModule *module) { stub_funcs.ptr_g_io_module_unload(module); }
char** (g_io_module_query)(void) { return stub_funcs.ptr_g_io_module_query(); }
GIOModuleScope * (g_io_module_scope_new)(GIOModuleScopeFlags flags) { return stub_funcs.ptr_g_io_module_scope_new(flags); }
void (g_io_scheduler_cancel_all_jobs)(void) { stub_funcs.ptr_g_io_scheduler_cancel_all_jobs(); }
gboolean (g_io_scheduler_job_send_to_mainloop)(GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify) { return stub_funcs.ptr_g_io_scheduler_job_send_to_mainloop(job, func, user_data, notify); }
void (g_io_scheduler_job_send_to_mainloop_async)(GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify) { stub_funcs.ptr_g_io_scheduler_job_send_to_mainloop_async(job, func, user_data, notify); }
void (g_io_scheduler_push_job)(GIOSchedulerJobFunc job_func, gpointer user_data, GDestroyNotify notify, gint io_priority, GCancellable *cancellable) { stub_funcs.ptr_g_io_scheduler_push_job(job_func, user_data, notify, io_priority, cancellable); }
GType (g_io_stream_get_type)(void) { return stub_funcs.ptr_g_io_stream_get_type(); }
GInputStream * (g_io_stream_get_input_stream)(GIOStream *stream) { return stub_funcs.ptr_g_io_stream_get_input_stream(stream); }
GOutputStream* (g_io_stream_get_output_stream)(GIOStream *stream) { return stub_funcs.ptr_g_io_stream_get_output_stream(stream); }
void (g_io_stream_splice_async)(GIOStream *stream1, GIOStream *stream2, GIOStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_io_stream_splice_async(stream1, stream2, flags, io_priority, cancellable, callback, user_data); }
gboolean (g_io_stream_splice_finish)(GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_io_stream_splice_finish(result, error); }
gboolean (g_io_stream_close)(GIOStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_io_stream_close(stream, cancellable, error); }
void (g_io_stream_close_async)(GIOStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_io_stream_close_async(stream, io_priority, cancellable, callback, user_data); }
gboolean (g_io_stream_close_finish)(GIOStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_io_stream_close_finish(stream, result, error); }
gboolean (g_io_stream_is_closed)(GIOStream *stream) { return stub_funcs.ptr_g_io_stream_is_closed(stream); }
gboolean (g_io_stream_has_pending)(GIOStream *stream) { return stub_funcs.ptr_g_io_stream_has_pending(stream); }
gboolean (g_io_stream_set_pending)(GIOStream *stream, GError **error) { return stub_funcs.ptr_g_io_stream_set_pending(stream, error); }
void (g_io_stream_clear_pending)(GIOStream *stream) { stub_funcs.ptr_g_io_stream_clear_pending(stream); }
GType (g_list_model_get_type)(void) { return stub_funcs.ptr_g_list_model_get_type(); }
guint (g_list_model_get_n_items)(GListModel *list) { return stub_funcs.ptr_g_list_model_get_n_items(list); }
gpointer (g_list_model_get_item)(GListModel *list, guint position) { return stub_funcs.ptr_g_list_model_get_item(list, position); }
GObject * (g_list_model_get_object)(GListModel *list, guint position) { return stub_funcs.ptr_g_list_model_get_object(list, position); }
void (g_list_model_items_changed)(GListModel *list, guint position, guint removed, guint added) { stub_funcs.ptr_g_list_model_items_changed(list, position, removed, added); }
GType (g_list_store_get_type)(void) { return stub_funcs.ptr_g_list_store_get_type(); }
GListStore * (g_list_store_new)(GType item_type) { return stub_funcs.ptr_g_list_store_new(item_type); }
void (g_list_store_insert)(GListStore *store, guint position, gpointer item) { stub_funcs.ptr_g_list_store_insert(store, position, item); }
guint (g_list_store_insert_sorted)(GListStore *store, gpointer item, GCompareDataFunc compare_func, gpointer user_data) { return stub_funcs.ptr_g_list_store_insert_sorted(store, item, compare_func, user_data); }
void (g_list_store_sort)(GListStore *store, GCompareDataFunc compare_func, gpointer user_data) { stub_funcs.ptr_g_list_store_sort(store, compare_func, user_data); }
void (g_list_store_append)(GListStore *store, gpointer item) { stub_funcs.ptr_g_list_store_append(store, item); }
void (g_list_store_remove)(GListStore *store, guint position) { stub_funcs.ptr_g_list_store_remove(store, position); }
void (g_list_store_remove_all)(GListStore *store) { stub_funcs.ptr_g_list_store_remove_all(store); }
void (g_list_store_splice)(GListStore *store, guint position, guint n_removals, gpointer *additions, guint n_additions) { stub_funcs.ptr_g_list_store_splice(store, position, n_removals, additions, n_additions); }
gboolean (g_list_store_find)(GListStore *store, gpointer item, guint *position) { return stub_funcs.ptr_g_list_store_find(store, item, position); }
gboolean (g_list_store_find_with_equal_func)(GListStore *store, gpointer item, GEqualFunc equal_func, guint *position) { return stub_funcs.ptr_g_list_store_find_with_equal_func(store, item, equal_func, position); }
gboolean (g_list_store_find_with_equal_func_full)(GListStore *store, gpointer item, GEqualFuncFull equal_func, gpointer user_data, guint *position) { return stub_funcs.ptr_g_list_store_find_with_equal_func_full(store, item, equal_func, user_data, position); }
GType (g_loadable_icon_get_type)(void) { return stub_funcs.ptr_g_loadable_icon_get_type(); }
GInputStream* (g_loadable_icon_load)(GLoadableIcon *icon, int size, char **type, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_loadable_icon_load(icon, size, type, cancellable, error); }
void (g_loadable_icon_load_async)(GLoadableIcon *icon, int size, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_loadable_icon_load_async(icon, size, cancellable, callback, user_data); }
GInputStream* (g_loadable_icon_load_finish)(GLoadableIcon *icon, GAsyncResult *res, char **type, GError **error) { return stub_funcs.ptr_g_loadable_icon_load_finish(icon, res, type, error); }
GType (g_memory_input_stream_get_type)(void) { return stub_funcs.ptr_g_memory_input_stream_get_type(); }
GInputStream * (g_memory_input_stream_new)(void) { return stub_funcs.ptr_g_memory_input_stream_new(); }
GInputStream * (g_memory_input_stream_new_from_data)(const void *data, gssize len, GDestroyNotify destroy) { return stub_funcs.ptr_g_memory_input_stream_new_from_data(data, len, destroy); }
GInputStream * (g_memory_input_stream_new_from_bytes)(GBytes *bytes) { return stub_funcs.ptr_g_memory_input_stream_new_from_bytes(bytes); }
void (g_memory_input_stream_add_data)(GMemoryInputStream *stream, const void *data, gssize len, GDestroyNotify destroy) { stub_funcs.ptr_g_memory_input_stream_add_data(stream, data, len, destroy); }
void (g_memory_input_stream_add_bytes)(GMemoryInputStream *stream, GBytes *bytes) { stub_funcs.ptr_g_memory_input_stream_add_bytes(stream, bytes); }
GType (g_memory_monitor_get_type)(void) { return stub_funcs.ptr_g_memory_monitor_get_type(); }
GType (g_memory_output_stream_get_type)(void) { return stub_funcs.ptr_g_memory_output_stream_get_type(); }
GOutputStream* (g_memory_output_stream_new)(gpointer data, gsize size, GReallocFunc realloc_function, GDestroyNotify destroy_function) { return stub_funcs.ptr_g_memory_output_stream_new(data, size, realloc_function, destroy_function); }
GOutputStream* (g_memory_output_stream_new_resizable)(void) { return stub_funcs.ptr_g_memory_output_stream_new_resizable(); }
gpointer (g_memory_output_stream_get_data)(GMemoryOutputStream *ostream) { return stub_funcs.ptr_g_memory_output_stream_get_data(ostream); }
gsize (g_memory_output_stream_get_size)(GMemoryOutputStream *ostream) { return stub_funcs.ptr_g_memory_output_stream_get_size(ostream); }
gsize (g_memory_output_stream_get_data_size)(GMemoryOutputStream *ostream) { return stub_funcs.ptr_g_memory_output_stream_get_data_size(ostream); }
gpointer (g_memory_output_stream_steal_data)(GMemoryOutputStream *ostream) { return stub_funcs.ptr_g_memory_output_stream_steal_data(ostream); }
GBytes * (g_memory_output_stream_steal_as_bytes)(GMemoryOutputStream *ostream) { return stub_funcs.ptr_g_memory_output_stream_steal_as_bytes(ostream); }
GType (g_menu_get_type)(void) { return stub_funcs.ptr_g_menu_get_type(); }
GType (g_menu_item_get_type)(void) { return stub_funcs.ptr_g_menu_item_get_type(); }
GMenu * (g_menu_new)(void) { return stub_funcs.ptr_g_menu_new(); }
void (g_menu_freeze)(GMenu *menu) { stub_funcs.ptr_g_menu_freeze(menu); }
void (g_menu_insert_item)(GMenu *menu, gint position, GMenuItem *item) { stub_funcs.ptr_g_menu_insert_item(menu, position, item); }
void (g_menu_prepend_item)(GMenu *menu, GMenuItem *item) { stub_funcs.ptr_g_menu_prepend_item(menu, item); }
void (g_menu_append_item)(GMenu *menu, GMenuItem *item) { stub_funcs.ptr_g_menu_append_item(menu, item); }
void (g_menu_remove)(GMenu *menu, gint position) { stub_funcs.ptr_g_menu_remove(menu, position); }
void (g_menu_remove_all)(GMenu *menu) { stub_funcs.ptr_g_menu_remove_all(menu); }
void (g_menu_insert)(GMenu *menu, gint position, const gchar *label, const gchar *detailed_action) { stub_funcs.ptr_g_menu_insert(menu, position, label, detailed_action); }
void (g_menu_prepend)(GMenu *menu, const gchar *label, const gchar *detailed_action) { stub_funcs.ptr_g_menu_prepend(menu, label, detailed_action); }
void (g_menu_append)(GMenu *menu, const gchar *label, const gchar *detailed_action) { stub_funcs.ptr_g_menu_append(menu, label, detailed_action); }
void (g_menu_insert_section)(GMenu *menu, gint position, const gchar *label, GMenuModel *section) { stub_funcs.ptr_g_menu_insert_section(menu, position, label, section); }
void (g_menu_prepend_section)(GMenu *menu, const gchar *label, GMenuModel *section) { stub_funcs.ptr_g_menu_prepend_section(menu, label, section); }
void (g_menu_append_section)(GMenu *menu, const gchar *label, GMenuModel *section) { stub_funcs.ptr_g_menu_append_section(menu, label, section); }
void (g_menu_insert_submenu)(GMenu *menu, gint position, const gchar *label, GMenuModel *submenu) { stub_funcs.ptr_g_menu_insert_submenu(menu, position, label, submenu); }
void (g_menu_prepend_submenu)(GMenu *menu, const gchar *label, GMenuModel *submenu) { stub_funcs.ptr_g_menu_prepend_submenu(menu, label, submenu); }
void (g_menu_append_submenu)(GMenu *menu, const gchar *label, GMenuModel *submenu) { stub_funcs.ptr_g_menu_append_submenu(menu, label, submenu); }
GMenuItem * (g_menu_item_new)(const gchar *label, const gchar *detailed_action) { return stub_funcs.ptr_g_menu_item_new(label, detailed_action); }
GMenuItem * (g_menu_item_new_from_model)(GMenuModel *model, gint item_index) { return stub_funcs.ptr_g_menu_item_new_from_model(model, item_index); }
GMenuItem * (g_menu_item_new_submenu)(const gchar *label, GMenuModel *submenu) { return stub_funcs.ptr_g_menu_item_new_submenu(label, submenu); }
GMenuItem * (g_menu_item_new_section)(const gchar *label, GMenuModel *section) { return stub_funcs.ptr_g_menu_item_new_section(label, section); }
GVariant * (g_menu_item_get_attribute_value)(GMenuItem *menu_item, const gchar *attribute, const GVariantType *expected_type) { return stub_funcs.ptr_g_menu_item_get_attribute_value(menu_item, attribute, expected_type); }
// Unable to locate va_equiv for g_menu_item_get_attribute
GMenuModel* (g_menu_item_get_link)(GMenuItem *menu_item, const gchar *link) { return stub_funcs.ptr_g_menu_item_get_link(menu_item, link); }
void (g_menu_item_set_attribute_value)(GMenuItem *menu_item, const gchar *attribute, GVariant *value) { stub_funcs.ptr_g_menu_item_set_attribute_value(menu_item, attribute, value); }
// Unable to locate va_equiv for g_menu_item_set_attribute
void (g_menu_item_set_link)(GMenuItem *menu_item, const gchar *link, GMenuModel *model) { stub_funcs.ptr_g_menu_item_set_link(menu_item, link, model); }
void (g_menu_item_set_label)(GMenuItem *menu_item, const gchar *label) { stub_funcs.ptr_g_menu_item_set_label(menu_item, label); }
void (g_menu_item_set_submenu)(GMenuItem *menu_item, GMenuModel *submenu) { stub_funcs.ptr_g_menu_item_set_submenu(menu_item, submenu); }
void (g_menu_item_set_section)(GMenuItem *menu_item, GMenuModel *section) { stub_funcs.ptr_g_menu_item_set_section(menu_item, section); }
void (g_menu_item_set_action_and_target_value)(GMenuItem *menu_item, const gchar *action, GVariant *target_value) { stub_funcs.ptr_g_menu_item_set_action_and_target_value(menu_item, action, target_value); }
// Unable to locate va_equiv for g_menu_item_set_action_and_target
void (g_menu_item_set_detailed_action)(GMenuItem *menu_item, const gchar *detailed_action) { stub_funcs.ptr_g_menu_item_set_detailed_action(menu_item, detailed_action); }
void (g_menu_item_set_icon)(GMenuItem *menu_item, GIcon *icon) { stub_funcs.ptr_g_menu_item_set_icon(menu_item, icon); }
void (g_dbus_connection_unexport_menu_model)(GDBusConnection *connection, guint export_id) { stub_funcs.ptr_g_dbus_connection_unexport_menu_model(connection, export_id); }
guint (g_dbus_connection_export_menu_model)(GDBusConnection *connection, const gchar *object_path, GMenuModel *menu, GError **error) { return stub_funcs.ptr_g_dbus_connection_export_menu_model(connection, object_path, menu, error); }
GType (g_menu_model_get_type)(void) { return stub_funcs.ptr_g_menu_model_get_type(); }
gboolean (g_menu_model_is_mutable)(GMenuModel *model) { return stub_funcs.ptr_g_menu_model_is_mutable(model); }
gint (g_menu_model_get_n_items)(GMenuModel *model) { return stub_funcs.ptr_g_menu_model_get_n_items(model); }
GMenuAttributeIter * (g_menu_model_iterate_item_attributes)(GMenuModel *model, gint item_index) { return stub_funcs.ptr_g_menu_model_iterate_item_attributes(model, item_index); }
GVariant * (g_menu_model_get_item_attribute_value)(GMenuModel *model, gint item_index, const gchar *attribute, const GVariantType *expected_type) { return stub_funcs.ptr_g_menu_model_get_item_attribute_value(model, item_index, attribute, expected_type); }
// Unable to locate va_equiv for g_menu_model_get_item_attribute
GMenuLinkIter * (g_menu_model_iterate_item_links)(GMenuModel *model, gint item_index) { return stub_funcs.ptr_g_menu_model_iterate_item_links(model, item_index); }
GMenuModel * (g_menu_model_get_item_link)(GMenuModel *model, gint item_index, const gchar *link) { return stub_funcs.ptr_g_menu_model_get_item_link(model, item_index, link); }
void (g_menu_model_items_changed)(GMenuModel *model, gint position, gint removed, gint added) { stub_funcs.ptr_g_menu_model_items_changed(model, position, removed, added); }
GType (g_menu_attribute_iter_get_type)(void) { return stub_funcs.ptr_g_menu_attribute_iter_get_type(); }
gboolean (g_menu_attribute_iter_get_next)(GMenuAttributeIter *iter, const gchar **out_name, GVariant **value) { return stub_funcs.ptr_g_menu_attribute_iter_get_next(iter, out_name, value); }
gboolean (g_menu_attribute_iter_next)(GMenuAttributeIter *iter) { return stub_funcs.ptr_g_menu_attribute_iter_next(iter); }
const gchar * (g_menu_attribute_iter_get_name)(GMenuAttributeIter *iter) { return stub_funcs.ptr_g_menu_attribute_iter_get_name(iter); }
GVariant * (g_menu_attribute_iter_get_value)(GMenuAttributeIter *iter) { return stub_funcs.ptr_g_menu_attribute_iter_get_value(iter); }
GType (g_menu_link_iter_get_type)(void) { return stub_funcs.ptr_g_menu_link_iter_get_type(); }
gboolean (g_menu_link_iter_get_next)(GMenuLinkIter *iter, const gchar **out_link, GMenuModel **value) { return stub_funcs.ptr_g_menu_link_iter_get_next(iter, out_link, value); }
gboolean (g_menu_link_iter_next)(GMenuLinkIter *iter) { return stub_funcs.ptr_g_menu_link_iter_next(iter); }
const gchar * (g_menu_link_iter_get_name)(GMenuLinkIter *iter) { return stub_funcs.ptr_g_menu_link_iter_get_name(iter); }
GMenuModel * (g_menu_link_iter_get_value)(GMenuLinkIter *iter) { return stub_funcs.ptr_g_menu_link_iter_get_value(iter); }
GType (g_mount_get_type)(void) { return stub_funcs.ptr_g_mount_get_type(); }
GFile * (g_mount_get_root)(GMount *mount) { return stub_funcs.ptr_g_mount_get_root(mount); }
GFile * (g_mount_get_default_location)(GMount *mount) { return stub_funcs.ptr_g_mount_get_default_location(mount); }
char * (g_mount_get_name)(GMount *mount) { return stub_funcs.ptr_g_mount_get_name(mount); }
GIcon * (g_mount_get_icon)(GMount *mount) { return stub_funcs.ptr_g_mount_get_icon(mount); }
GIcon * (g_mount_get_symbolic_icon)(GMount *mount) { return stub_funcs.ptr_g_mount_get_symbolic_icon(mount); }
char * (g_mount_get_uuid)(GMount *mount) { return stub_funcs.ptr_g_mount_get_uuid(mount); }
GVolume * (g_mount_get_volume)(GMount *mount) { return stub_funcs.ptr_g_mount_get_volume(mount); }
GDrive * (g_mount_get_drive)(GMount *mount) { return stub_funcs.ptr_g_mount_get_drive(mount); }
gboolean (g_mount_can_unmount)(GMount *mount) { return stub_funcs.ptr_g_mount_can_unmount(mount); }
gboolean (g_mount_can_eject)(GMount *mount) { return stub_funcs.ptr_g_mount_can_eject(mount); }
void (g_mount_unmount)(GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_mount_unmount(mount, flags, cancellable, callback, user_data); }
gboolean (g_mount_unmount_finish)(GMount *mount, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_mount_unmount_finish(mount, result, error); }
void (g_mount_eject)(GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_mount_eject(mount, flags, cancellable, callback, user_data); }
gboolean (g_mount_eject_finish)(GMount *mount, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_mount_eject_finish(mount, result, error); }
void (g_mount_remount)(GMount *mount, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_mount_remount(mount, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_mount_remount_finish)(GMount *mount, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_mount_remount_finish(mount, result, error); }
void (g_mount_guess_content_type)(GMount *mount, gboolean force_rescan, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_mount_guess_content_type(mount, force_rescan, cancellable, callback, user_data); }
gchar ** (g_mount_guess_content_type_finish)(GMount *mount, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_mount_guess_content_type_finish(mount, result, error); }
gchar ** (g_mount_guess_content_type_sync)(GMount *mount, gboolean force_rescan, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_mount_guess_content_type_sync(mount, force_rescan, cancellable, error); }
gboolean (g_mount_is_shadowed)(GMount *mount) { return stub_funcs.ptr_g_mount_is_shadowed(mount); }
void (g_mount_shadow)(GMount *mount) { stub_funcs.ptr_g_mount_shadow(mount); }
void (g_mount_unshadow)(GMount *mount) { stub_funcs.ptr_g_mount_unshadow(mount); }
void (g_mount_unmount_with_operation)(GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_mount_unmount_with_operation(mount, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_mount_unmount_with_operation_finish)(GMount *mount, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_mount_unmount_with_operation_finish(mount, result, error); }
void (g_mount_eject_with_operation)(GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_mount_eject_with_operation(mount, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_mount_eject_with_operation_finish)(GMount *mount, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_mount_eject_with_operation_finish(mount, result, error); }
const gchar* (g_mount_get_sort_key)(GMount *mount) { return stub_funcs.ptr_g_mount_get_sort_key(mount); }
GType (g_mount_operation_get_type)(void) { return stub_funcs.ptr_g_mount_operation_get_type(); }
GMountOperation * (g_mount_operation_new)(void) { return stub_funcs.ptr_g_mount_operation_new(); }
const char * (g_mount_operation_get_username)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_username(op); }
void (g_mount_operation_set_username)(GMountOperation *op, const char *username) { stub_funcs.ptr_g_mount_operation_set_username(op, username); }
const char * (g_mount_operation_get_password)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_password(op); }
void (g_mount_operation_set_password)(GMountOperation *op, const char *password) { stub_funcs.ptr_g_mount_operation_set_password(op, password); }
gboolean (g_mount_operation_get_anonymous)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_anonymous(op); }
void (g_mount_operation_set_anonymous)(GMountOperation *op, gboolean anonymous) { stub_funcs.ptr_g_mount_operation_set_anonymous(op, anonymous); }
const char * (g_mount_operation_get_domain)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_domain(op); }
void (g_mount_operation_set_domain)(GMountOperation *op, const char *domain) { stub_funcs.ptr_g_mount_operation_set_domain(op, domain); }
GPasswordSave (g_mount_operation_get_password_save)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_password_save(op); }
void (g_mount_operation_set_password_save)(GMountOperation *op, GPasswordSave save) { stub_funcs.ptr_g_mount_operation_set_password_save(op, save); }
int (g_mount_operation_get_choice)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_choice(op); }
void (g_mount_operation_set_choice)(GMountOperation *op, int choice) { stub_funcs.ptr_g_mount_operation_set_choice(op, choice); }
void (g_mount_operation_reply)(GMountOperation *op, GMountOperationResult result) { stub_funcs.ptr_g_mount_operation_reply(op, result); }
gboolean (g_mount_operation_get_is_tcrypt_hidden_volume)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_is_tcrypt_hidden_volume(op); }
void (g_mount_operation_set_is_tcrypt_hidden_volume)(GMountOperation *op, gboolean hidden_volume) { stub_funcs.ptr_g_mount_operation_set_is_tcrypt_hidden_volume(op, hidden_volume); }
gboolean (g_mount_operation_get_is_tcrypt_system_volume)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_is_tcrypt_system_volume(op); }
void (g_mount_operation_set_is_tcrypt_system_volume)(GMountOperation *op, gboolean system_volume) { stub_funcs.ptr_g_mount_operation_set_is_tcrypt_system_volume(op, system_volume); }
guint (g_mount_operation_get_pim)(GMountOperation *op) { return stub_funcs.ptr_g_mount_operation_get_pim(op); }
void (g_mount_operation_set_pim)(GMountOperation *op, guint pim) { stub_funcs.ptr_g_mount_operation_set_pim(op, pim); }
GType (g_native_socket_address_get_type)(void) { return stub_funcs.ptr_g_native_socket_address_get_type(); }
GSocketAddress* (g_native_socket_address_new)(gpointer native, gsize len) { return stub_funcs.ptr_g_native_socket_address_new(native, len); }
GType (g_native_volume_monitor_get_type)(void) { return stub_funcs.ptr_g_native_volume_monitor_get_type(); }
GType (g_network_address_get_type)(void) { return stub_funcs.ptr_g_network_address_get_type(); }
GSocketConnectable* (g_network_address_new)(const gchar *hostname, guint16 port) { return stub_funcs.ptr_g_network_address_new(hostname, port); }
GSocketConnectable* (g_network_address_new_loopback)(guint16 port) { return stub_funcs.ptr_g_network_address_new_loopback(port); }
GSocketConnectable* (g_network_address_parse)(const gchar *host_and_port, guint16 default_port, GError **error) { return stub_funcs.ptr_g_network_address_parse(host_and_port, default_port, error); }
GSocketConnectable* (g_network_address_parse_uri)(const gchar *uri, guint16 default_port, GError **error) { return stub_funcs.ptr_g_network_address_parse_uri(uri, default_port, error); }
const gchar* (g_network_address_get_hostname)(GNetworkAddress *addr) { return stub_funcs.ptr_g_network_address_get_hostname(addr); }
guint16 (g_network_address_get_port)(GNetworkAddress *addr) { return stub_funcs.ptr_g_network_address_get_port(addr); }
const gchar* (g_network_address_get_scheme)(GNetworkAddress *addr) { return stub_funcs.ptr_g_network_address_get_scheme(addr); }
void (g_networking_init)(void) { stub_funcs.ptr_g_networking_init(); }
GType (g_network_monitor_get_type)(void) { return stub_funcs.ptr_g_network_monitor_get_type(); }
GNetworkMonitor* (g_network_monitor_get_default)(void) { return stub_funcs.ptr_g_network_monitor_get_default(); }
gboolean (g_network_monitor_get_network_available)(GNetworkMonitor *monitor) { return stub_funcs.ptr_g_network_monitor_get_network_available(monitor); }
gboolean (g_network_monitor_get_network_metered)(GNetworkMonitor *monitor) { return stub_funcs.ptr_g_network_monitor_get_network_metered(monitor); }
GNetworkConnectivity (g_network_monitor_get_connectivity)(GNetworkMonitor *monitor) { return stub_funcs.ptr_g_network_monitor_get_connectivity(monitor); }
gboolean (g_network_monitor_can_reach)(GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_network_monitor_can_reach(monitor, connectable, cancellable, error); }
void (g_network_monitor_can_reach_async)(GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_network_monitor_can_reach_async(monitor, connectable, cancellable, callback, user_data); }
gboolean (g_network_monitor_can_reach_finish)(GNetworkMonitor *monitor, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_network_monitor_can_reach_finish(monitor, result, error); }
GType (g_network_service_get_type)(void) { return stub_funcs.ptr_g_network_service_get_type(); }
GSocketConnectable* (g_network_service_new)(const gchar *service, const gchar *protocol, const gchar *domain) { return stub_funcs.ptr_g_network_service_new(service, protocol, domain); }
const gchar* (g_network_service_get_service)(GNetworkService *srv) { return stub_funcs.ptr_g_network_service_get_service(srv); }
const gchar* (g_network_service_get_protocol)(GNetworkService *srv) { return stub_funcs.ptr_g_network_service_get_protocol(srv); }
const gchar* (g_network_service_get_domain)(GNetworkService *srv) { return stub_funcs.ptr_g_network_service_get_domain(srv); }
const gchar* (g_network_service_get_scheme)(GNetworkService *srv) { return stub_funcs.ptr_g_network_service_get_scheme(srv); }
void (g_network_service_set_scheme)(GNetworkService *srv, const gchar *scheme) { stub_funcs.ptr_g_network_service_set_scheme(srv, scheme); }
GType (g_notification_get_type)(void) { return stub_funcs.ptr_g_notification_get_type(); }
GNotification * (g_notification_new)(const gchar *title) { return stub_funcs.ptr_g_notification_new(title); }
void (g_notification_set_title)(GNotification *notification, const gchar *title) { stub_funcs.ptr_g_notification_set_title(notification, title); }
void (g_notification_set_body)(GNotification *notification, const gchar *body) { stub_funcs.ptr_g_notification_set_body(notification, body); }
void (g_notification_set_icon)(GNotification *notification, GIcon *icon) { stub_funcs.ptr_g_notification_set_icon(notification, icon); }
void (g_notification_set_urgent)(GNotification *notification, gboolean urgent) { stub_funcs.ptr_g_notification_set_urgent(notification, urgent); }
void (g_notification_set_priority)(GNotification *notification, GNotificationPriority priority) { stub_funcs.ptr_g_notification_set_priority(notification, priority); }
void (g_notification_set_category)(GNotification *notification, const gchar *category) { stub_funcs.ptr_g_notification_set_category(notification, category); }
void (g_notification_add_button)(GNotification *notification, const gchar *label, const gchar *detailed_action) { stub_funcs.ptr_g_notification_add_button(notification, label, detailed_action); }
// Unable to locate va_equiv for g_notification_add_button_with_target
void (g_notification_add_button_with_target_value)(GNotification *notification, const gchar *label, const gchar *action, GVariant *target) { stub_funcs.ptr_g_notification_add_button_with_target_value(notification, label, action, target); }
void (g_notification_set_default_action)(GNotification *notification, const gchar *detailed_action) { stub_funcs.ptr_g_notification_set_default_action(notification, detailed_action); }
// Unable to locate va_equiv for g_notification_set_default_action_and_target
void (g_notification_set_default_action_and_target_value)(GNotification *notification, const gchar *action, GVariant *target) { stub_funcs.ptr_g_notification_set_default_action_and_target_value(notification, action, target); }
GType (g_output_stream_get_type)(void) { return stub_funcs.ptr_g_output_stream_get_type(); }
gssize (g_output_stream_write)(GOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_write(stream, buffer, count, cancellable, error); }
gboolean (g_output_stream_write_all)(GOutputStream *stream, const void *buffer, gsize count, gsize *bytes_written, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_write_all(stream, buffer, count, bytes_written, cancellable, error); }
gboolean (g_output_stream_writev)(GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_writev(stream, vectors, n_vectors, bytes_written, cancellable, error); }
gboolean (g_output_stream_writev_all)(GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_writev_all(stream, vectors, n_vectors, bytes_written, cancellable, error); }
gboolean (g_output_stream_printf)(GOutputStream *stream, gsize *bytes_written, GCancellable *cancellable, GError **error, const gchar *format, ...) { gboolean ret; va_list vaargs; va_start(vaargs, format); ret = stub_funcs.ptr_g_output_stream_vprintf(stream, bytes_written, cancellable, error, format, vaargs); va_end(vaargs); return ret; }
gboolean (g_output_stream_vprintf)(GOutputStream *stream, gsize *bytes_written, GCancellable *cancellable, GError **error, const gchar *format, va_list args) { return stub_funcs.ptr_g_output_stream_vprintf(stream, bytes_written, cancellable, error, format, args); }
gssize (g_output_stream_write_bytes)(GOutputStream *stream, GBytes *bytes, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_write_bytes(stream, bytes, cancellable, error); }
gssize (g_output_stream_splice)(GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_splice(stream, source, flags, cancellable, error); }
gboolean (g_output_stream_flush)(GOutputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_flush(stream, cancellable, error); }
gboolean (g_output_stream_close)(GOutputStream *stream, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_output_stream_close(stream, cancellable, error); }
void (g_output_stream_write_async)(GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_write_async(stream, buffer, count, io_priority, cancellable, callback, user_data); }
gssize (g_output_stream_write_finish)(GOutputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_output_stream_write_finish(stream, result, error); }
void (g_output_stream_write_all_async)(GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_write_all_async(stream, buffer, count, io_priority, cancellable, callback, user_data); }
gboolean (g_output_stream_write_all_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_output_stream_write_all_finish(stream, result, bytes_written, error); }
void (g_output_stream_writev_async)(GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_writev_async(stream, vectors, n_vectors, io_priority, cancellable, callback, user_data); }
gboolean (g_output_stream_writev_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_output_stream_writev_finish(stream, result, bytes_written, error); }
void (g_output_stream_writev_all_async)(GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_writev_all_async(stream, vectors, n_vectors, io_priority, cancellable, callback, user_data); }
gboolean (g_output_stream_writev_all_finish)(GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error) { return stub_funcs.ptr_g_output_stream_writev_all_finish(stream, result, bytes_written, error); }
void (g_output_stream_write_bytes_async)(GOutputStream *stream, GBytes *bytes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_write_bytes_async(stream, bytes, io_priority, cancellable, callback, user_data); }
gssize (g_output_stream_write_bytes_finish)(GOutputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_output_stream_write_bytes_finish(stream, result, error); }
void (g_output_stream_splice_async)(GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_splice_async(stream, source, flags, io_priority, cancellable, callback, user_data); }
gssize (g_output_stream_splice_finish)(GOutputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_output_stream_splice_finish(stream, result, error); }
void (g_output_stream_flush_async)(GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_flush_async(stream, io_priority, cancellable, callback, user_data); }
gboolean (g_output_stream_flush_finish)(GOutputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_output_stream_flush_finish(stream, result, error); }
void (g_output_stream_close_async)(GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_output_stream_close_async(stream, io_priority, cancellable, callback, user_data); }
gboolean (g_output_stream_close_finish)(GOutputStream *stream, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_output_stream_close_finish(stream, result, error); }
gboolean (g_output_stream_is_closed)(GOutputStream *stream) { return stub_funcs.ptr_g_output_stream_is_closed(stream); }
gboolean (g_output_stream_is_closing)(GOutputStream *stream) { return stub_funcs.ptr_g_output_stream_is_closing(stream); }
gboolean (g_output_stream_has_pending)(GOutputStream *stream) { return stub_funcs.ptr_g_output_stream_has_pending(stream); }
gboolean (g_output_stream_set_pending)(GOutputStream *stream, GError **error) { return stub_funcs.ptr_g_output_stream_set_pending(stream, error); }
void (g_output_stream_clear_pending)(GOutputStream *stream) { stub_funcs.ptr_g_output_stream_clear_pending(stream); }
GType (g_permission_get_type)(void) { return stub_funcs.ptr_g_permission_get_type(); }
gboolean (g_permission_acquire)(GPermission *permission, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_permission_acquire(permission, cancellable, error); }
void (g_permission_acquire_async)(GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_permission_acquire_async(permission, cancellable, callback, user_data); }
gboolean (g_permission_acquire_finish)(GPermission *permission, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_permission_acquire_finish(permission, result, error); }
gboolean (g_permission_release)(GPermission *permission, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_permission_release(permission, cancellable, error); }
void (g_permission_release_async)(GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_permission_release_async(permission, cancellable, callback, user_data); }
gboolean (g_permission_release_finish)(GPermission *permission, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_permission_release_finish(permission, result, error); }
gboolean (g_permission_get_allowed)(GPermission *permission) { return stub_funcs.ptr_g_permission_get_allowed(permission); }
gboolean (g_permission_get_can_acquire)(GPermission *permission) { return stub_funcs.ptr_g_permission_get_can_acquire(permission); }
gboolean (g_permission_get_can_release)(GPermission *permission) { return stub_funcs.ptr_g_permission_get_can_release(permission); }
void (g_permission_impl_update)(GPermission *permission, gboolean allowed, gboolean can_acquire, gboolean can_release) { stub_funcs.ptr_g_permission_impl_update(permission, allowed, can_acquire, can_release); }
GType (g_pollable_input_stream_get_type)(void) { return stub_funcs.ptr_g_pollable_input_stream_get_type(); }
gboolean (g_pollable_input_stream_can_poll)(GPollableInputStream *stream) { return stub_funcs.ptr_g_pollable_input_stream_can_poll(stream); }
gboolean (g_pollable_input_stream_is_readable)(GPollableInputStream *stream) { return stub_funcs.ptr_g_pollable_input_stream_is_readable(stream); }
GSource* (g_pollable_input_stream_create_source)(GPollableInputStream *stream, GCancellable *cancellable) { return stub_funcs.ptr_g_pollable_input_stream_create_source(stream, cancellable); }
gssize (g_pollable_input_stream_read_nonblocking)(GPollableInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_pollable_input_stream_read_nonblocking(stream, buffer, count, cancellable, error); }
GType (g_pollable_output_stream_get_type)(void) { return stub_funcs.ptr_g_pollable_output_stream_get_type(); }
gboolean (g_pollable_output_stream_can_poll)(GPollableOutputStream *stream) { return stub_funcs.ptr_g_pollable_output_stream_can_poll(stream); }
gboolean (g_pollable_output_stream_is_writable)(GPollableOutputStream *stream) { return stub_funcs.ptr_g_pollable_output_stream_is_writable(stream); }
GSource* (g_pollable_output_stream_create_source)(GPollableOutputStream *stream, GCancellable *cancellable) { return stub_funcs.ptr_g_pollable_output_stream_create_source(stream, cancellable); }
gssize (g_pollable_output_stream_write_nonblocking)(GPollableOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_pollable_output_stream_write_nonblocking(stream, buffer, count, cancellable, error); }
GPollableReturn (g_pollable_output_stream_writev_nonblocking)(GPollableOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_pollable_output_stream_writev_nonblocking(stream, vectors, n_vectors, bytes_written, cancellable, error); }
GSource* (g_pollable_source_new_full)(gpointer pollable_stream, GSource *child_source, GCancellable *cancellable) { return stub_funcs.ptr_g_pollable_source_new_full(pollable_stream, child_source, cancellable); }
gssize (g_pollable_stream_read)(GInputStream *stream, void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_pollable_stream_read(stream, buffer, count, blocking, cancellable, error); }
gssize (g_pollable_stream_write)(GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_pollable_stream_write(stream, buffer, count, blocking, cancellable, error); }
gboolean (g_pollable_stream_write_all)(GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, gsize *bytes_written, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_pollable_stream_write_all(stream, buffer, count, blocking, bytes_written, cancellable, error); }
GSource* (g_pollable_source_new)(GObject *pollable_stream) { return stub_funcs.ptr_g_pollable_source_new(pollable_stream); }
GType (g_power_profile_monitor_get_type)(void) { return stub_funcs.ptr_g_power_profile_monitor_get_type(); }
gboolean (g_power_profile_monitor_get_power_saver_enabled)(GPowerProfileMonitor *monitor) { return stub_funcs.ptr_g_power_profile_monitor_get_power_saver_enabled(monitor); }
GType (g_property_action_get_type)(void) { return stub_funcs.ptr_g_property_action_get_type(); }
GPropertyAction * (g_property_action_new)(const gchar *name, gpointer object, const gchar *property_name) { return stub_funcs.ptr_g_property_action_new(name, object, property_name); }
GType (g_proxy_get_type)(void) { return stub_funcs.ptr_g_proxy_get_type(); }
GProxy* (g_proxy_get_default_for_protocol)(const gchar *protocol) { return stub_funcs.ptr_g_proxy_get_default_for_protocol(protocol); }
GIOStream* (g_proxy_connect)(GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_proxy_connect(proxy, connection, proxy_address, cancellable, error); }
void (g_proxy_connect_async)(GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_proxy_connect_async(proxy, connection, proxy_address, cancellable, callback, user_data); }
GIOStream* (g_proxy_connect_finish)(GProxy *proxy, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_proxy_connect_finish(proxy, result, error); }
gboolean (g_proxy_supports_hostname)(GProxy *proxy) { return stub_funcs.ptr_g_proxy_supports_hostname(proxy); }
GType (g_proxy_address_get_type)(void) { return stub_funcs.ptr_g_proxy_address_get_type(); }
GSocketAddress* (g_proxy_address_new)(GInetAddress *inetaddr, guint16 port, const gchar *protocol, const gchar *dest_hostname, guint16 dest_port, const gchar *username, const gchar *password) { return stub_funcs.ptr_g_proxy_address_new(inetaddr, port, protocol, dest_hostname, dest_port, username, password); }
const gchar* (g_proxy_address_get_protocol)(GProxyAddress *proxy) { return stub_funcs.ptr_g_proxy_address_get_protocol(proxy); }
const gchar* (g_proxy_address_get_destination_protocol)(GProxyAddress *proxy) { return stub_funcs.ptr_g_proxy_address_get_destination_protocol(proxy); }
const gchar* (g_proxy_address_get_destination_hostname)(GProxyAddress *proxy) { return stub_funcs.ptr_g_proxy_address_get_destination_hostname(proxy); }
guint16 (g_proxy_address_get_destination_port)(GProxyAddress *proxy) { return stub_funcs.ptr_g_proxy_address_get_destination_port(proxy); }
const gchar* (g_proxy_address_get_username)(GProxyAddress *proxy) { return stub_funcs.ptr_g_proxy_address_get_username(proxy); }
const gchar* (g_proxy_address_get_password)(GProxyAddress *proxy) { return stub_funcs.ptr_g_proxy_address_get_password(proxy); }
const gchar* (g_proxy_address_get_uri)(GProxyAddress *proxy) { return stub_funcs.ptr_g_proxy_address_get_uri(proxy); }
GType (g_proxy_address_enumerator_get_type)(void) { return stub_funcs.ptr_g_proxy_address_enumerator_get_type(); }
GType (g_proxy_resolver_get_type)(void) { return stub_funcs.ptr_g_proxy_resolver_get_type(); }
GProxyResolver* (g_proxy_resolver_get_default)(void) { return stub_funcs.ptr_g_proxy_resolver_get_default(); }
gboolean (g_proxy_resolver_is_supported)(GProxyResolver *resolver) { return stub_funcs.ptr_g_proxy_resolver_is_supported(resolver); }
gchar** (g_proxy_resolver_lookup)(GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_proxy_resolver_lookup(resolver, uri, cancellable, error); }
void (g_proxy_resolver_lookup_async)(GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_proxy_resolver_lookup_async(resolver, uri, cancellable, callback, user_data); }
gchar** (g_proxy_resolver_lookup_finish)(GProxyResolver *resolver, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_proxy_resolver_lookup_finish(resolver, result, error); }
GType (g_remote_action_group_get_type)(void) { return stub_funcs.ptr_g_remote_action_group_get_type(); }
void (g_remote_action_group_activate_action_full)(GRemoteActionGroup *remote, const gchar *action_name, GVariant *parameter, GVariant *platform_data) { stub_funcs.ptr_g_remote_action_group_activate_action_full(remote, action_name, parameter, platform_data); }
void (g_remote_action_group_change_action_state_full)(GRemoteActionGroup *remote, const gchar *action_name, GVariant *value, GVariant *platform_data) { stub_funcs.ptr_g_remote_action_group_change_action_state_full(remote, action_name, value, platform_data); }
GType (g_resolver_get_type)(void) { return stub_funcs.ptr_g_resolver_get_type(); }
GResolver* (g_resolver_get_default)(void) { return stub_funcs.ptr_g_resolver_get_default(); }
void (g_resolver_set_default)(GResolver *resolver) { stub_funcs.ptr_g_resolver_set_default(resolver); }
GList* (g_resolver_lookup_by_name)(GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_resolver_lookup_by_name(resolver, hostname, cancellable, error); }
void (g_resolver_lookup_by_name_async)(GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_resolver_lookup_by_name_async(resolver, hostname, cancellable, callback, user_data); }
GList* (g_resolver_lookup_by_name_finish)(GResolver *resolver, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_resolver_lookup_by_name_finish(resolver, result, error); }
void (g_resolver_lookup_by_name_with_flags_async)(GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_resolver_lookup_by_name_with_flags_async(resolver, hostname, flags, cancellable, callback, user_data); }
GList* (g_resolver_lookup_by_name_with_flags_finish)(GResolver *resolver, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_resolver_lookup_by_name_with_flags_finish(resolver, result, error); }
GList* (g_resolver_lookup_by_name_with_flags)(GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_resolver_lookup_by_name_with_flags(resolver, hostname, flags, cancellable, error); }
void (g_resolver_free_addresses)(GList *addresses) { stub_funcs.ptr_g_resolver_free_addresses(addresses); }
gchar* (g_resolver_lookup_by_address)(GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_resolver_lookup_by_address(resolver, address, cancellable, error); }
void (g_resolver_lookup_by_address_async)(GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_resolver_lookup_by_address_async(resolver, address, cancellable, callback, user_data); }
gchar* (g_resolver_lookup_by_address_finish)(GResolver *resolver, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_resolver_lookup_by_address_finish(resolver, result, error); }
GList* (g_resolver_lookup_service)(GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_resolver_lookup_service(resolver, service, protocol, domain, cancellable, error); }
void (g_resolver_lookup_service_async)(GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_resolver_lookup_service_async(resolver, service, protocol, domain, cancellable, callback, user_data); }
GList* (g_resolver_lookup_service_finish)(GResolver *resolver, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_resolver_lookup_service_finish(resolver, result, error); }
GList* (g_resolver_lookup_records)(GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_resolver_lookup_records(resolver, rrname, record_type, cancellable, error); }
void (g_resolver_lookup_records_async)(GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_resolver_lookup_records_async(resolver, rrname, record_type, cancellable, callback, user_data); }
GList* (g_resolver_lookup_records_finish)(GResolver *resolver, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_resolver_lookup_records_finish(resolver, result, error); }
void (g_resolver_free_targets)(GList *targets) { stub_funcs.ptr_g_resolver_free_targets(targets); }
unsigned (g_resolver_get_timeout)(GResolver *resolver) { return stub_funcs.ptr_g_resolver_get_timeout(resolver); }
void (g_resolver_set_timeout)(GResolver *resolver, unsigned timeout_ms) { stub_funcs.ptr_g_resolver_set_timeout(resolver, timeout_ms); }
GQuark (g_resolver_error_quark)(void) { return stub_funcs.ptr_g_resolver_error_quark(); }
GType (g_resource_get_type)(void) { return stub_funcs.ptr_g_resource_get_type(); }
GQuark (g_resource_error_quark)(void) { return stub_funcs.ptr_g_resource_error_quark(); }
GResource * (g_resource_new_from_data)(GBytes *data, GError **error) { return stub_funcs.ptr_g_resource_new_from_data(data, error); }
GResource * (g_resource_ref)(GResource *resource) { return stub_funcs.ptr_g_resource_ref(resource); }
void (g_resource_unref)(GResource *resource) { stub_funcs.ptr_g_resource_unref(resource); }
GResource * (g_resource_load)(const gchar *filename, GError **error) { return stub_funcs.ptr_g_resource_load(filename, error); }
GInputStream* (g_resource_open_stream)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error) { return stub_funcs.ptr_g_resource_open_stream(resource, path, lookup_flags, error); }
GBytes * (g_resource_lookup_data)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error) { return stub_funcs.ptr_g_resource_lookup_data(resource, path, lookup_flags, error); }
char ** (g_resource_enumerate_children)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error) { return stub_funcs.ptr_g_resource_enumerate_children(resource, path, lookup_flags, error); }
gboolean (g_resource_get_info)(GResource *resource, const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error) { return stub_funcs.ptr_g_resource_get_info(resource, path, lookup_flags, size, flags, error); }
void (g_resources_register)(GResource *resource) { stub_funcs.ptr_g_resources_register(resource); }
void (g_resources_unregister)(GResource *resource) { stub_funcs.ptr_g_resources_unregister(resource); }
GInputStream* (g_resources_open_stream)(const char *path, GResourceLookupFlags lookup_flags, GError **error) { return stub_funcs.ptr_g_resources_open_stream(path, lookup_flags, error); }
GBytes * (g_resources_lookup_data)(const char *path, GResourceLookupFlags lookup_flags, GError **error) { return stub_funcs.ptr_g_resources_lookup_data(path, lookup_flags, error); }
char ** (g_resources_enumerate_children)(const char *path, GResourceLookupFlags lookup_flags, GError **error) { return stub_funcs.ptr_g_resources_enumerate_children(path, lookup_flags, error); }
gboolean (g_resources_get_info)(const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error) { return stub_funcs.ptr_g_resources_get_info(path, lookup_flags, size, flags, error); }
GType (g_seekable_get_type)(void) { return stub_funcs.ptr_g_seekable_get_type(); }
goffset (g_seekable_tell)(GSeekable *seekable) { return stub_funcs.ptr_g_seekable_tell(seekable); }
gboolean (g_seekable_can_seek)(GSeekable *seekable) { return stub_funcs.ptr_g_seekable_can_seek(seekable); }
gboolean (g_seekable_seek)(GSeekable *seekable, goffset offset, GSeekType type, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_seekable_seek(seekable, offset, type, cancellable, error); }
gboolean (g_seekable_can_truncate)(GSeekable *seekable) { return stub_funcs.ptr_g_seekable_can_truncate(seekable); }
gboolean (g_seekable_truncate)(GSeekable *seekable, goffset offset, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_seekable_truncate(seekable, offset, cancellable, error); }
GType (g_settings_get_type)(void) { return stub_funcs.ptr_g_settings_get_type(); }
const gchar * const * (g_settings_list_schemas)(void) { return stub_funcs.ptr_g_settings_list_schemas(); }
const gchar * const * (g_settings_list_relocatable_schemas)(void) { return stub_funcs.ptr_g_settings_list_relocatable_schemas(); }
GSettings * (g_settings_new)(const gchar *schema_id) { return stub_funcs.ptr_g_settings_new(schema_id); }
GSettings * (g_settings_new_with_path)(const gchar *schema_id, const gchar *path) { return stub_funcs.ptr_g_settings_new_with_path(schema_id, path); }
GSettings * (g_settings_new_with_backend)(const gchar *schema_id, GSettingsBackend *backend) { return stub_funcs.ptr_g_settings_new_with_backend(schema_id, backend); }
GSettings * (g_settings_new_with_backend_and_path)(const gchar *schema_id, GSettingsBackend *backend, const gchar *path) { return stub_funcs.ptr_g_settings_new_with_backend_and_path(schema_id, backend, path); }
GSettings * (g_settings_new_full)(GSettingsSchema *schema, GSettingsBackend *backend, const gchar *path) { return stub_funcs.ptr_g_settings_new_full(schema, backend, path); }
gchar ** (g_settings_list_children)(GSettings *settings) { return stub_funcs.ptr_g_settings_list_children(settings); }
gchar ** (g_settings_list_keys)(GSettings *settings) { return stub_funcs.ptr_g_settings_list_keys(settings); }
GVariant * (g_settings_get_range)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_range(settings, key); }
gboolean (g_settings_range_check)(GSettings *settings, const gchar *key, GVariant *value) { return stub_funcs.ptr_g_settings_range_check(settings, key, value); }
gboolean (g_settings_set_value)(GSettings *settings, const gchar *key, GVariant *value) { return stub_funcs.ptr_g_settings_set_value(settings, key, value); }
GVariant * (g_settings_get_value)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_value(settings, key); }
GVariant * (g_settings_get_user_value)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_user_value(settings, key); }
GVariant * (g_settings_get_default_value)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_default_value(settings, key); }
// Unable to locate va_equiv for g_settings_set
// Unable to locate va_equiv for g_settings_get
void (g_settings_reset)(GSettings *settings, const gchar *key) { stub_funcs.ptr_g_settings_reset(settings, key); }
gint (g_settings_get_int)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_int(settings, key); }
gboolean (g_settings_set_int)(GSettings *settings, const gchar *key, gint value) { return stub_funcs.ptr_g_settings_set_int(settings, key, value); }
gint64 (g_settings_get_int64)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_int64(settings, key); }
gboolean (g_settings_set_int64)(GSettings *settings, const gchar *key, gint64 value) { return stub_funcs.ptr_g_settings_set_int64(settings, key, value); }
guint (g_settings_get_uint)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_uint(settings, key); }
gboolean (g_settings_set_uint)(GSettings *settings, const gchar *key, guint value) { return stub_funcs.ptr_g_settings_set_uint(settings, key, value); }
guint64 (g_settings_get_uint64)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_uint64(settings, key); }
gboolean (g_settings_set_uint64)(GSettings *settings, const gchar *key, guint64 value) { return stub_funcs.ptr_g_settings_set_uint64(settings, key, value); }
gchar * (g_settings_get_string)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_string(settings, key); }
gboolean (g_settings_set_string)(GSettings *settings, const gchar *key, const gchar *value) { return stub_funcs.ptr_g_settings_set_string(settings, key, value); }
gboolean (g_settings_get_boolean)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_boolean(settings, key); }
gboolean (g_settings_set_boolean)(GSettings *settings, const gchar *key, gboolean value) { return stub_funcs.ptr_g_settings_set_boolean(settings, key, value); }
gdouble (g_settings_get_double)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_double(settings, key); }
gboolean (g_settings_set_double)(GSettings *settings, const gchar *key, gdouble value) { return stub_funcs.ptr_g_settings_set_double(settings, key, value); }
gchar ** (g_settings_get_strv)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_strv(settings, key); }
gboolean (g_settings_set_strv)(GSettings *settings, const gchar *key, const gchar *const *value) { return stub_funcs.ptr_g_settings_set_strv(settings, key, value); }
gint (g_settings_get_enum)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_enum(settings, key); }
gboolean (g_settings_set_enum)(GSettings *settings, const gchar *key, gint value) { return stub_funcs.ptr_g_settings_set_enum(settings, key, value); }
guint (g_settings_get_flags)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_get_flags(settings, key); }
gboolean (g_settings_set_flags)(GSettings *settings, const gchar *key, guint value) { return stub_funcs.ptr_g_settings_set_flags(settings, key, value); }
GSettings * (g_settings_get_child)(GSettings *settings, const gchar *name) { return stub_funcs.ptr_g_settings_get_child(settings, name); }
gboolean (g_settings_is_writable)(GSettings *settings, const gchar *name) { return stub_funcs.ptr_g_settings_is_writable(settings, name); }
void (g_settings_delay)(GSettings *settings) { stub_funcs.ptr_g_settings_delay(settings); }
void (g_settings_apply)(GSettings *settings) { stub_funcs.ptr_g_settings_apply(settings); }
void (g_settings_revert)(GSettings *settings) { stub_funcs.ptr_g_settings_revert(settings); }
gboolean (g_settings_get_has_unapplied)(GSettings *settings) { return stub_funcs.ptr_g_settings_get_has_unapplied(settings); }
void (g_settings_sync)(void) { stub_funcs.ptr_g_settings_sync(); }
void (g_settings_bind)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags) { stub_funcs.ptr_g_settings_bind(settings, key, object, property, flags); }
void (g_settings_bind_with_mapping)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags, GSettingsBindGetMapping get_mapping, GSettingsBindSetMapping set_mapping, gpointer user_data, GDestroyNotify destroy) { stub_funcs.ptr_g_settings_bind_with_mapping(settings, key, object, property, flags, get_mapping, set_mapping, user_data, destroy); }
void (g_settings_bind_writable)(GSettings *settings, const gchar *key, gpointer object, const gchar *property, gboolean inverted) { stub_funcs.ptr_g_settings_bind_writable(settings, key, object, property, inverted); }
void (g_settings_unbind)(gpointer object, const gchar *property) { stub_funcs.ptr_g_settings_unbind(object, property); }
GAction * (g_settings_create_action)(GSettings *settings, const gchar *key) { return stub_funcs.ptr_g_settings_create_action(settings, key); }
gpointer (g_settings_get_mapped)(GSettings *settings, const gchar *key, GSettingsGetMapping mapping, gpointer user_data) { return stub_funcs.ptr_g_settings_get_mapped(settings, key, mapping, user_data); }
GType (g_settings_backend_get_type)(void) { return stub_funcs.ptr_g_settings_backend_get_type(); }
void (g_settings_backend_changed)(GSettingsBackend *backend, const gchar *key, gpointer origin_tag) { stub_funcs.ptr_g_settings_backend_changed(backend, key, origin_tag); }
void (g_settings_backend_path_changed)(GSettingsBackend *backend, const gchar *path, gpointer origin_tag) { stub_funcs.ptr_g_settings_backend_path_changed(backend, path, origin_tag); }
void (g_settings_backend_flatten_tree)(GTree *tree, gchar **path, const gchar ***keys, GVariant ***values) { stub_funcs.ptr_g_settings_backend_flatten_tree(tree, path, keys, values); }
void (g_settings_backend_keys_changed)(GSettingsBackend *backend, const gchar *path, gchar const * const *items, gpointer origin_tag) { stub_funcs.ptr_g_settings_backend_keys_changed(backend, path, items, origin_tag); }
void (g_settings_backend_path_writable_changed)(GSettingsBackend *backend, const gchar *path) { stub_funcs.ptr_g_settings_backend_path_writable_changed(backend, path); }
void (g_settings_backend_writable_changed)(GSettingsBackend *backend, const gchar *key) { stub_funcs.ptr_g_settings_backend_writable_changed(backend, key); }
void (g_settings_backend_changed_tree)(GSettingsBackend *backend, GTree *tree, gpointer origin_tag) { stub_funcs.ptr_g_settings_backend_changed_tree(backend, tree, origin_tag); }
GSettingsBackend * (g_settings_backend_get_default)(void) { return stub_funcs.ptr_g_settings_backend_get_default(); }
GSettingsBackend * (g_keyfile_settings_backend_new)(const gchar *filename, const gchar *root_path, const gchar *root_group) { return stub_funcs.ptr_g_keyfile_settings_backend_new(filename, root_path, root_group); }
GSettingsBackend * (g_null_settings_backend_new)(void) { return stub_funcs.ptr_g_null_settings_backend_new(); }
GSettingsBackend * (g_memory_settings_backend_new)(void) { return stub_funcs.ptr_g_memory_settings_backend_new(); }
GSettingsSchemaSource * (g_settings_schema_source_get_default)(void) { return stub_funcs.ptr_g_settings_schema_source_get_default(); }
GSettingsSchemaSource * (g_settings_schema_source_ref)(GSettingsSchemaSource *source) { return stub_funcs.ptr_g_settings_schema_source_ref(source); }
void (g_settings_schema_source_unref)(GSettingsSchemaSource *source) { stub_funcs.ptr_g_settings_schema_source_unref(source); }
GSettingsSchemaSource * (g_settings_schema_source_new_from_directory)(const gchar *directory, GSettingsSchemaSource *parent, gboolean trusted, GError **error) { return stub_funcs.ptr_g_settings_schema_source_new_from_directory(directory, parent, trusted, error); }
GSettingsSchema * (g_settings_schema_source_lookup)(GSettingsSchemaSource *source, const gchar *schema_id, gboolean recursive) { return stub_funcs.ptr_g_settings_schema_source_lookup(source, schema_id, recursive); }
void (g_settings_schema_source_list_schemas)(GSettingsSchemaSource *source, gboolean recursive, gchar ***non_relocatable, gchar ***relocatable) { stub_funcs.ptr_g_settings_schema_source_list_schemas(source, recursive, non_relocatable, relocatable); }
GType (g_settings_schema_get_type)(void) { return stub_funcs.ptr_g_settings_schema_get_type(); }
GSettingsSchema * (g_settings_schema_ref)(GSettingsSchema *schema) { return stub_funcs.ptr_g_settings_schema_ref(schema); }
void (g_settings_schema_unref)(GSettingsSchema *schema) { stub_funcs.ptr_g_settings_schema_unref(schema); }
const gchar * (g_settings_schema_get_id)(GSettingsSchema *schema) { return stub_funcs.ptr_g_settings_schema_get_id(schema); }
const gchar * (g_settings_schema_get_path)(GSettingsSchema *schema) { return stub_funcs.ptr_g_settings_schema_get_path(schema); }
GSettingsSchemaKey * (g_settings_schema_get_key)(GSettingsSchema *schema, const gchar *name) { return stub_funcs.ptr_g_settings_schema_get_key(schema, name); }
gboolean (g_settings_schema_has_key)(GSettingsSchema *schema, const gchar *name) { return stub_funcs.ptr_g_settings_schema_has_key(schema, name); }
gchar** (g_settings_schema_list_keys)(GSettingsSchema *schema) { return stub_funcs.ptr_g_settings_schema_list_keys(schema); }
gchar ** (g_settings_schema_list_children)(GSettingsSchema *schema) { return stub_funcs.ptr_g_settings_schema_list_children(schema); }
GType (g_settings_schema_key_get_type)(void) { return stub_funcs.ptr_g_settings_schema_key_get_type(); }
GSettingsSchemaKey * (g_settings_schema_key_ref)(GSettingsSchemaKey *key) { return stub_funcs.ptr_g_settings_schema_key_ref(key); }
void (g_settings_schema_key_unref)(GSettingsSchemaKey *key) { stub_funcs.ptr_g_settings_schema_key_unref(key); }
const GVariantType * (g_settings_schema_key_get_value_type)(GSettingsSchemaKey *key) { return stub_funcs.ptr_g_settings_schema_key_get_value_type(key); }
GVariant * (g_settings_schema_key_get_default_value)(GSettingsSchemaKey *key) { return stub_funcs.ptr_g_settings_schema_key_get_default_value(key); }
GVariant * (g_settings_schema_key_get_range)(GSettingsSchemaKey *key) { return stub_funcs.ptr_g_settings_schema_key_get_range(key); }
gboolean (g_settings_schema_key_range_check)(GSettingsSchemaKey *key, GVariant *value) { return stub_funcs.ptr_g_settings_schema_key_range_check(key, value); }
const gchar * (g_settings_schema_key_get_name)(GSettingsSchemaKey *key) { return stub_funcs.ptr_g_settings_schema_key_get_name(key); }
const gchar * (g_settings_schema_key_get_summary)(GSettingsSchemaKey *key) { return stub_funcs.ptr_g_settings_schema_key_get_summary(key); }
const gchar * (g_settings_schema_key_get_description)(GSettingsSchemaKey *key) { return stub_funcs.ptr_g_settings_schema_key_get_description(key); }
GType (g_settings_schema_source_get_type)(void) { return stub_funcs.ptr_g_settings_schema_source_get_type(); }
GType (g_simple_action_get_type)(void) { return stub_funcs.ptr_g_simple_action_get_type(); }
GSimpleAction * (g_simple_action_new)(const gchar *name, const GVariantType *parameter_type) { return stub_funcs.ptr_g_simple_action_new(name, parameter_type); }
GSimpleAction * (g_simple_action_new_stateful)(const gchar *name, const GVariantType *parameter_type, GVariant *state) { return stub_funcs.ptr_g_simple_action_new_stateful(name, parameter_type, state); }
void (g_simple_action_set_enabled)(GSimpleAction *simple, gboolean enabled) { stub_funcs.ptr_g_simple_action_set_enabled(simple, enabled); }
void (g_simple_action_set_state)(GSimpleAction *simple, GVariant *value) { stub_funcs.ptr_g_simple_action_set_state(simple, value); }
void (g_simple_action_set_state_hint)(GSimpleAction *simple, GVariant *state_hint) { stub_funcs.ptr_g_simple_action_set_state_hint(simple, state_hint); }
GType (g_simple_action_group_get_type)(void) { return stub_funcs.ptr_g_simple_action_group_get_type(); }
GSimpleActionGroup * (g_simple_action_group_new)(void) { return stub_funcs.ptr_g_simple_action_group_new(); }
GAction * (g_simple_action_group_lookup)(GSimpleActionGroup *simple, const gchar *action_name) { return stub_funcs.ptr_g_simple_action_group_lookup(simple, action_name); }
void (g_simple_action_group_insert)(GSimpleActionGroup *simple, GAction *action) { stub_funcs.ptr_g_simple_action_group_insert(simple, action); }
void (g_simple_action_group_remove)(GSimpleActionGroup *simple, const gchar *action_name) { stub_funcs.ptr_g_simple_action_group_remove(simple, action_name); }
void (g_simple_action_group_add_entries)(GSimpleActionGroup *simple, const GActionEntry *entries, gint n_entries, gpointer user_data) { stub_funcs.ptr_g_simple_action_group_add_entries(simple, entries, n_entries, user_data); }
GType (g_simple_async_result_get_type)(void) { return stub_funcs.ptr_g_simple_async_result_get_type(); }
GSimpleAsyncResult* (g_simple_async_result_new)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, gpointer source_tag) { return stub_funcs.ptr_g_simple_async_result_new(source_object, callback, user_data, source_tag); }
// Unable to locate va_equiv for g_simple_async_result_new_error
GSimpleAsyncResult* (g_simple_async_result_new_from_error)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, const GError *error) { return stub_funcs.ptr_g_simple_async_result_new_from_error(source_object, callback, user_data, error); }
GSimpleAsyncResult* (g_simple_async_result_new_take_error)(GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GError *error) { return stub_funcs.ptr_g_simple_async_result_new_take_error(source_object, callback, user_data, error); }
void (g_simple_async_result_set_op_res_gpointer)(GSimpleAsyncResult *simple, gpointer op_res, GDestroyNotify destroy_op_res) { stub_funcs.ptr_g_simple_async_result_set_op_res_gpointer(simple, op_res, destroy_op_res); }
gpointer (g_simple_async_result_get_op_res_gpointer)(GSimpleAsyncResult *simple) { return stub_funcs.ptr_g_simple_async_result_get_op_res_gpointer(simple); }
void (g_simple_async_result_set_op_res_gssize)(GSimpleAsyncResult *simple, gssize op_res) { stub_funcs.ptr_g_simple_async_result_set_op_res_gssize(simple, op_res); }
gssize (g_simple_async_result_get_op_res_gssize)(GSimpleAsyncResult *simple) { return stub_funcs.ptr_g_simple_async_result_get_op_res_gssize(simple); }
void (g_simple_async_result_set_op_res_gboolean)(GSimpleAsyncResult *simple, gboolean op_res) { stub_funcs.ptr_g_simple_async_result_set_op_res_gboolean(simple, op_res); }
gboolean (g_simple_async_result_get_op_res_gboolean)(GSimpleAsyncResult *simple) { return stub_funcs.ptr_g_simple_async_result_get_op_res_gboolean(simple); }
void (g_simple_async_result_set_check_cancellable)(GSimpleAsyncResult *simple, GCancellable *check_cancellable) { stub_funcs.ptr_g_simple_async_result_set_check_cancellable(simple, check_cancellable); }
gpointer (g_simple_async_result_get_source_tag)(GSimpleAsyncResult *simple) { return stub_funcs.ptr_g_simple_async_result_get_source_tag(simple); }
void (g_simple_async_result_set_handle_cancellation)(GSimpleAsyncResult *simple, gboolean handle_cancellation) { stub_funcs.ptr_g_simple_async_result_set_handle_cancellation(simple, handle_cancellation); }
void (g_simple_async_result_complete)(GSimpleAsyncResult *simple) { stub_funcs.ptr_g_simple_async_result_complete(simple); }
void (g_simple_async_result_complete_in_idle)(GSimpleAsyncResult *simple) { stub_funcs.ptr_g_simple_async_result_complete_in_idle(simple); }
void (g_simple_async_result_run_in_thread)(GSimpleAsyncResult *simple, GSimpleAsyncThreadFunc func, int io_priority, GCancellable *cancellable) { stub_funcs.ptr_g_simple_async_result_run_in_thread(simple, func, io_priority, cancellable); }
void (g_simple_async_result_set_from_error)(GSimpleAsyncResult *simple, const GError *error) { stub_funcs.ptr_g_simple_async_result_set_from_error(simple, error); }
void (g_simple_async_result_take_error)(GSimpleAsyncResult *simple, GError *error) { stub_funcs.ptr_g_simple_async_result_take_error(simple, error); }
gboolean (g_simple_async_result_propagate_error)(GSimpleAsyncResult *simple, GError **dest) { return stub_funcs.ptr_g_simple_async_result_propagate_error(simple, dest); }
void (g_simple_async_result_set_error)(GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, ...) { va_list vaargs; va_start(vaargs, format); stub_funcs.ptr_g_simple_async_result_set_error_va(simple, domain, code, format, vaargs); va_end(vaargs); }
void (g_simple_async_result_set_error_va)(GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, va_list args) { stub_funcs.ptr_g_simple_async_result_set_error_va(simple, domain, code, format, args); }
gboolean (g_simple_async_result_is_valid)(GAsyncResult *result, GObject *source, gpointer source_tag) { return stub_funcs.ptr_g_simple_async_result_is_valid(result, source, source_tag); }
// Unable to locate va_equiv for g_simple_async_report_error_in_idle
void (g_simple_async_report_gerror_in_idle)(GObject *object, GAsyncReadyCallback callback, gpointer user_data, const GError *error) { stub_funcs.ptr_g_simple_async_report_gerror_in_idle(object, callback, user_data, error); }
void (g_simple_async_report_take_gerror_in_idle)(GObject *object, GAsyncReadyCallback callback, gpointer user_data, GError *error) { stub_funcs.ptr_g_simple_async_report_take_gerror_in_idle(object, callback, user_data, error); }
GType (g_simple_io_stream_get_type)(void) { return stub_funcs.ptr_g_simple_io_stream_get_type(); }
GIOStream* (g_simple_io_stream_new)(GInputStream *input_stream, GOutputStream *output_stream) { return stub_funcs.ptr_g_simple_io_stream_new(input_stream, output_stream); }
GType (g_simple_permission_get_type)(void) { return stub_funcs.ptr_g_simple_permission_get_type(); }
GPermission * (g_simple_permission_new)(gboolean allowed) { return stub_funcs.ptr_g_simple_permission_new(allowed); }
GType (g_simple_proxy_resolver_get_type)(void) { return stub_funcs.ptr_g_simple_proxy_resolver_get_type(); }
GProxyResolver* (g_simple_proxy_resolver_new)(const gchar *default_proxy, gchar **ignore_hosts) { return stub_funcs.ptr_g_simple_proxy_resolver_new(default_proxy, ignore_hosts); }
void (g_simple_proxy_resolver_set_default_proxy)(GSimpleProxyResolver *resolver, const gchar *default_proxy) { stub_funcs.ptr_g_simple_proxy_resolver_set_default_proxy(resolver, default_proxy); }
void (g_simple_proxy_resolver_set_ignore_hosts)(GSimpleProxyResolver *resolver, gchar **ignore_hosts) { stub_funcs.ptr_g_simple_proxy_resolver_set_ignore_hosts(resolver, ignore_hosts); }
void (g_simple_proxy_resolver_set_uri_proxy)(GSimpleProxyResolver *resolver, const gchar *uri_scheme, const gchar *proxy) { stub_funcs.ptr_g_simple_proxy_resolver_set_uri_proxy(resolver, uri_scheme, proxy); }
GType (g_socket_get_type)(void) { return stub_funcs.ptr_g_socket_get_type(); }
GSocket * (g_socket_new)(GSocketFamily family, GSocketType type, GSocketProtocol protocol, GError **error) { return stub_funcs.ptr_g_socket_new(family, type, protocol, error); }
GSocket * (g_socket_new_from_fd)(gint fd, GError **error) { return stub_funcs.ptr_g_socket_new_from_fd(fd, error); }
int (g_socket_get_fd)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_fd(socket); }
GSocketFamily (g_socket_get_family)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_family(socket); }
GSocketType (g_socket_get_socket_type)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_socket_type(socket); }
GSocketProtocol (g_socket_get_protocol)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_protocol(socket); }
GSocketAddress * (g_socket_get_local_address)(GSocket *socket, GError **error) { return stub_funcs.ptr_g_socket_get_local_address(socket, error); }
GSocketAddress * (g_socket_get_remote_address)(GSocket *socket, GError **error) { return stub_funcs.ptr_g_socket_get_remote_address(socket, error); }
void (g_socket_set_blocking)(GSocket *socket, gboolean blocking) { stub_funcs.ptr_g_socket_set_blocking(socket, blocking); }
gboolean (g_socket_get_blocking)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_blocking(socket); }
void (g_socket_set_keepalive)(GSocket *socket, gboolean keepalive) { stub_funcs.ptr_g_socket_set_keepalive(socket, keepalive); }
gboolean (g_socket_get_keepalive)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_keepalive(socket); }
gint (g_socket_get_listen_backlog)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_listen_backlog(socket); }
void (g_socket_set_listen_backlog)(GSocket *socket, gint backlog) { stub_funcs.ptr_g_socket_set_listen_backlog(socket, backlog); }
guint (g_socket_get_timeout)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_timeout(socket); }
void (g_socket_set_timeout)(GSocket *socket, guint timeout) { stub_funcs.ptr_g_socket_set_timeout(socket, timeout); }
guint (g_socket_get_ttl)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_ttl(socket); }
void (g_socket_set_ttl)(GSocket *socket, guint ttl) { stub_funcs.ptr_g_socket_set_ttl(socket, ttl); }
gboolean (g_socket_get_broadcast)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_broadcast(socket); }
void (g_socket_set_broadcast)(GSocket *socket, gboolean broadcast) { stub_funcs.ptr_g_socket_set_broadcast(socket, broadcast); }
gboolean (g_socket_get_multicast_loopback)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_multicast_loopback(socket); }
void (g_socket_set_multicast_loopback)(GSocket *socket, gboolean loopback) { stub_funcs.ptr_g_socket_set_multicast_loopback(socket, loopback); }
guint (g_socket_get_multicast_ttl)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_multicast_ttl(socket); }
void (g_socket_set_multicast_ttl)(GSocket *socket, guint ttl) { stub_funcs.ptr_g_socket_set_multicast_ttl(socket, ttl); }
gboolean (g_socket_is_connected)(GSocket *socket) { return stub_funcs.ptr_g_socket_is_connected(socket); }
gboolean (g_socket_bind)(GSocket *socket, GSocketAddress *address, gboolean allow_reuse, GError **error) { return stub_funcs.ptr_g_socket_bind(socket, address, allow_reuse, error); }
gboolean (g_socket_join_multicast_group)(GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error) { return stub_funcs.ptr_g_socket_join_multicast_group(socket, group, source_specific, iface, error); }
gboolean (g_socket_leave_multicast_group)(GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error) { return stub_funcs.ptr_g_socket_leave_multicast_group(socket, group, source_specific, iface, error); }
gboolean (g_socket_join_multicast_group_ssm)(GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error) { return stub_funcs.ptr_g_socket_join_multicast_group_ssm(socket, group, source_specific, iface, error); }
gboolean (g_socket_leave_multicast_group_ssm)(GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error) { return stub_funcs.ptr_g_socket_leave_multicast_group_ssm(socket, group, source_specific, iface, error); }
gboolean (g_socket_connect)(GSocket *socket, GSocketAddress *address, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_connect(socket, address, cancellable, error); }
gboolean (g_socket_check_connect_result)(GSocket *socket, GError **error) { return stub_funcs.ptr_g_socket_check_connect_result(socket, error); }
gssize (g_socket_get_available_bytes)(GSocket *socket) { return stub_funcs.ptr_g_socket_get_available_bytes(socket); }
GIOCondition (g_socket_condition_check)(GSocket *socket, GIOCondition condition) { return stub_funcs.ptr_g_socket_condition_check(socket, condition); }
gboolean (g_socket_condition_wait)(GSocket *socket, GIOCondition condition, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_condition_wait(socket, condition, cancellable, error); }
gboolean (g_socket_condition_timed_wait)(GSocket *socket, GIOCondition condition, gint64 timeout_us, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_condition_timed_wait(socket, condition, timeout_us, cancellable, error); }
GSocket * (g_socket_accept)(GSocket *socket, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_accept(socket, cancellable, error); }
gboolean (g_socket_listen)(GSocket *socket, GError **error) { return stub_funcs.ptr_g_socket_listen(socket, error); }
gssize (g_socket_receive)(GSocket *socket, gchar *buffer, gsize size, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_receive(socket, buffer, size, cancellable, error); }
GBytes * (g_socket_receive_bytes)(GSocket *socket, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_receive_bytes(socket, size, timeout_us, cancellable, error); }
gssize (g_socket_receive_from)(GSocket *socket, GSocketAddress **address, gchar *buffer, gsize size, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_receive_from(socket, address, buffer, size, cancellable, error); }
GBytes * (g_socket_receive_bytes_from)(GSocket *socket, GSocketAddress **address, gsize size, gint64 timeout_us, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_receive_bytes_from(socket, address, size, timeout_us, cancellable, error); }
gssize (g_socket_send)(GSocket *socket, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_send(socket, buffer, size, cancellable, error); }
gssize (g_socket_send_to)(GSocket *socket, GSocketAddress *address, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_send_to(socket, address, buffer, size, cancellable, error); }
gssize (g_socket_receive_message)(GSocket *socket, GSocketAddress **address, GInputVector *vectors, gint num_vectors, GSocketControlMessage ***messages, gint *num_messages, gint *flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_receive_message(socket, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error); }
gssize (g_socket_send_message)(GSocket *socket, GSocketAddress *address, GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_send_message(socket, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error); }
gint (g_socket_receive_messages)(GSocket *socket, GInputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_receive_messages(socket, messages, num_messages, flags, cancellable, error); }
gint (g_socket_send_messages)(GSocket *socket, GOutputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_send_messages(socket, messages, num_messages, flags, cancellable, error); }
gboolean (g_socket_close)(GSocket *socket, GError **error) { return stub_funcs.ptr_g_socket_close(socket, error); }
gboolean (g_socket_shutdown)(GSocket *socket, gboolean shutdown_read, gboolean shutdown_write, GError **error) { return stub_funcs.ptr_g_socket_shutdown(socket, shutdown_read, shutdown_write, error); }
gboolean (g_socket_is_closed)(GSocket *socket) { return stub_funcs.ptr_g_socket_is_closed(socket); }
GSource * (g_socket_create_source)(GSocket *socket, GIOCondition condition, GCancellable *cancellable) { return stub_funcs.ptr_g_socket_create_source(socket, condition, cancellable); }
gboolean (g_socket_speaks_ipv4)(GSocket *socket) { return stub_funcs.ptr_g_socket_speaks_ipv4(socket); }
GCredentials* (g_socket_get_credentials)(GSocket *socket, GError **error) { return stub_funcs.ptr_g_socket_get_credentials(socket, error); }
gssize (g_socket_receive_with_blocking)(GSocket *socket, gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_receive_with_blocking(socket, buffer, size, blocking, cancellable, error); }
gssize (g_socket_send_with_blocking)(GSocket *socket, const gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_send_with_blocking(socket, buffer, size, blocking, cancellable, error); }
GPollableReturn (g_socket_send_message_with_timeout)(GSocket *socket, GSocketAddress *address, const GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, gint64 timeout_us, gsize *bytes_written, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_send_message_with_timeout(socket, address, vectors, num_vectors, messages, num_messages, flags, timeout_us, bytes_written, cancellable, error); }
gboolean (g_socket_get_option)(GSocket *socket, gint level, gint optname, gint *value, GError **error) { return stub_funcs.ptr_g_socket_get_option(socket, level, optname, value, error); }
gboolean (g_socket_set_option)(GSocket *socket, gint level, gint optname, gint value, GError **error) { return stub_funcs.ptr_g_socket_set_option(socket, level, optname, value, error); }
GType (g_socket_address_get_type)(void) { return stub_funcs.ptr_g_socket_address_get_type(); }
GSocketFamily (g_socket_address_get_family)(GSocketAddress *address) { return stub_funcs.ptr_g_socket_address_get_family(address); }
GSocketAddress * (g_socket_address_new_from_native)(gpointer native, gsize len) { return stub_funcs.ptr_g_socket_address_new_from_native(native, len); }
gboolean (g_socket_address_to_native)(GSocketAddress *address, gpointer dest, gsize destlen, GError **error) { return stub_funcs.ptr_g_socket_address_to_native(address, dest, destlen, error); }
gssize (g_socket_address_get_native_size)(GSocketAddress *address) { return stub_funcs.ptr_g_socket_address_get_native_size(address); }
GType (g_socket_address_enumerator_get_type)(void) { return stub_funcs.ptr_g_socket_address_enumerator_get_type(); }
GSocketAddress* (g_socket_address_enumerator_next)(GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_address_enumerator_next(enumerator, cancellable, error); }
void (g_socket_address_enumerator_next_async)(GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_address_enumerator_next_async(enumerator, cancellable, callback, user_data); }
GSocketAddress* (g_socket_address_enumerator_next_finish)(GSocketAddressEnumerator *enumerator, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_socket_address_enumerator_next_finish(enumerator, result, error); }
GType (g_socket_client_get_type)(void) { return stub_funcs.ptr_g_socket_client_get_type(); }
GSocketClient* (g_socket_client_new)(void) { return stub_funcs.ptr_g_socket_client_new(); }
GSocketFamily (g_socket_client_get_family)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_family(client); }
void (g_socket_client_set_family)(GSocketClient *client, GSocketFamily family) { stub_funcs.ptr_g_socket_client_set_family(client, family); }
GSocketType (g_socket_client_get_socket_type)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_socket_type(client); }
void (g_socket_client_set_socket_type)(GSocketClient *client, GSocketType type) { stub_funcs.ptr_g_socket_client_set_socket_type(client, type); }
GSocketProtocol (g_socket_client_get_protocol)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_protocol(client); }
void (g_socket_client_set_protocol)(GSocketClient *client, GSocketProtocol protocol) { stub_funcs.ptr_g_socket_client_set_protocol(client, protocol); }
GSocketAddress* (g_socket_client_get_local_address)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_local_address(client); }
void (g_socket_client_set_local_address)(GSocketClient *client, GSocketAddress *address) { stub_funcs.ptr_g_socket_client_set_local_address(client, address); }
guint (g_socket_client_get_timeout)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_timeout(client); }
void (g_socket_client_set_timeout)(GSocketClient *client, guint timeout) { stub_funcs.ptr_g_socket_client_set_timeout(client, timeout); }
gboolean (g_socket_client_get_enable_proxy)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_enable_proxy(client); }
void (g_socket_client_set_enable_proxy)(GSocketClient *client, gboolean enable) { stub_funcs.ptr_g_socket_client_set_enable_proxy(client, enable); }
gboolean (g_socket_client_get_tls)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_tls(client); }
void (g_socket_client_set_tls)(GSocketClient *client, gboolean tls) { stub_funcs.ptr_g_socket_client_set_tls(client, tls); }
GTlsCertificateFlags (g_socket_client_get_tls_validation_flags)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_tls_validation_flags(client); }
void (g_socket_client_set_tls_validation_flags)(GSocketClient *client, GTlsCertificateFlags flags) { stub_funcs.ptr_g_socket_client_set_tls_validation_flags(client, flags); }
GProxyResolver* (g_socket_client_get_proxy_resolver)(GSocketClient *client) { return stub_funcs.ptr_g_socket_client_get_proxy_resolver(client); }
void (g_socket_client_set_proxy_resolver)(GSocketClient *client, GProxyResolver *proxy_resolver) { stub_funcs.ptr_g_socket_client_set_proxy_resolver(client, proxy_resolver); }
GSocketConnection * (g_socket_client_connect)(GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_client_connect(client, connectable, cancellable, error); }
GSocketConnection * (g_socket_client_connect_to_host)(GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_client_connect_to_host(client, host_and_port, default_port, cancellable, error); }
GSocketConnection * (g_socket_client_connect_to_service)(GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_client_connect_to_service(client, domain, service, cancellable, error); }
GSocketConnection * (g_socket_client_connect_to_uri)(GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_client_connect_to_uri(client, uri, default_port, cancellable, error); }
void (g_socket_client_connect_async)(GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_client_connect_async(client, connectable, cancellable, callback, user_data); }
GSocketConnection * (g_socket_client_connect_finish)(GSocketClient *client, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_socket_client_connect_finish(client, result, error); }
void (g_socket_client_connect_to_host_async)(GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_client_connect_to_host_async(client, host_and_port, default_port, cancellable, callback, user_data); }
GSocketConnection * (g_socket_client_connect_to_host_finish)(GSocketClient *client, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_socket_client_connect_to_host_finish(client, result, error); }
void (g_socket_client_connect_to_service_async)(GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_client_connect_to_service_async(client, domain, service, cancellable, callback, user_data); }
GSocketConnection * (g_socket_client_connect_to_service_finish)(GSocketClient *client, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_socket_client_connect_to_service_finish(client, result, error); }
void (g_socket_client_connect_to_uri_async)(GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_client_connect_to_uri_async(client, uri, default_port, cancellable, callback, user_data); }
GSocketConnection * (g_socket_client_connect_to_uri_finish)(GSocketClient *client, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_socket_client_connect_to_uri_finish(client, result, error); }
void (g_socket_client_add_application_proxy)(GSocketClient *client, const gchar *protocol) { stub_funcs.ptr_g_socket_client_add_application_proxy(client, protocol); }
GType (g_socket_connectable_get_type)(void) { return stub_funcs.ptr_g_socket_connectable_get_type(); }
GSocketAddressEnumerator* (g_socket_connectable_enumerate)(GSocketConnectable *connectable) { return stub_funcs.ptr_g_socket_connectable_enumerate(connectable); }
GSocketAddressEnumerator* (g_socket_connectable_proxy_enumerate)(GSocketConnectable *connectable) { return stub_funcs.ptr_g_socket_connectable_proxy_enumerate(connectable); }
gchar* (g_socket_connectable_to_string)(GSocketConnectable *connectable) { return stub_funcs.ptr_g_socket_connectable_to_string(connectable); }
GType (g_socket_connection_get_type)(void) { return stub_funcs.ptr_g_socket_connection_get_type(); }
gboolean (g_socket_connection_is_connected)(GSocketConnection *connection) { return stub_funcs.ptr_g_socket_connection_is_connected(connection); }
gboolean (g_socket_connection_connect)(GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_connection_connect(connection, address, cancellable, error); }
void (g_socket_connection_connect_async)(GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_connection_connect_async(connection, address, cancellable, callback, user_data); }
gboolean (g_socket_connection_connect_finish)(GSocketConnection *connection, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_socket_connection_connect_finish(connection, result, error); }
GSocket* (g_socket_connection_get_socket)(GSocketConnection *connection) { return stub_funcs.ptr_g_socket_connection_get_socket(connection); }
GSocketAddress* (g_socket_connection_get_local_address)(GSocketConnection *connection, GError **error) { return stub_funcs.ptr_g_socket_connection_get_local_address(connection, error); }
GSocketAddress* (g_socket_connection_get_remote_address)(GSocketConnection *connection, GError **error) { return stub_funcs.ptr_g_socket_connection_get_remote_address(connection, error); }
void (g_socket_connection_factory_register_type)(GType g_type, GSocketFamily family, GSocketType type, gint protocol) { stub_funcs.ptr_g_socket_connection_factory_register_type(g_type, family, type, protocol); }
GType (g_socket_connection_factory_lookup_type)(GSocketFamily family, GSocketType type, gint protocol_id) { return stub_funcs.ptr_g_socket_connection_factory_lookup_type(family, type, protocol_id); }
GSocketConnection* (g_socket_connection_factory_create_connection)(GSocket *socket) { return stub_funcs.ptr_g_socket_connection_factory_create_connection(socket); }
GType (g_socket_control_message_get_type)(void) { return stub_funcs.ptr_g_socket_control_message_get_type(); }
gsize (g_socket_control_message_get_size)(GSocketControlMessage *message) { return stub_funcs.ptr_g_socket_control_message_get_size(message); }
int (g_socket_control_message_get_level)(GSocketControlMessage *message) { return stub_funcs.ptr_g_socket_control_message_get_level(message); }
int (g_socket_control_message_get_msg_type)(GSocketControlMessage *message) { return stub_funcs.ptr_g_socket_control_message_get_msg_type(message); }
void (g_socket_control_message_serialize)(GSocketControlMessage *message, gpointer data) { stub_funcs.ptr_g_socket_control_message_serialize(message, data); }
GSocketControlMessage* (g_socket_control_message_deserialize)(int level, int type, gsize size, gpointer data) { return stub_funcs.ptr_g_socket_control_message_deserialize(level, type, size, data); }
GType (g_socket_listener_get_type)(void) { return stub_funcs.ptr_g_socket_listener_get_type(); }
GSocketListener * (g_socket_listener_new)(void) { return stub_funcs.ptr_g_socket_listener_new(); }
void (g_socket_listener_set_backlog)(GSocketListener *listener, int listen_backlog) { stub_funcs.ptr_g_socket_listener_set_backlog(listener, listen_backlog); }
gboolean (g_socket_listener_add_socket)(GSocketListener *listener, GSocket *socket, GObject *source_object, GError **error) { return stub_funcs.ptr_g_socket_listener_add_socket(listener, socket, source_object, error); }
gboolean (g_socket_listener_add_address)(GSocketListener *listener, GSocketAddress *address, GSocketType type, GSocketProtocol protocol, GObject *source_object, GSocketAddress **effective_address, GError **error) { return stub_funcs.ptr_g_socket_listener_add_address(listener, address, type, protocol, source_object, effective_address, error); }
gboolean (g_socket_listener_add_inet_port)(GSocketListener *listener, guint16 port, GObject *source_object, GError **error) { return stub_funcs.ptr_g_socket_listener_add_inet_port(listener, port, source_object, error); }
guint16 (g_socket_listener_add_any_inet_port)(GSocketListener *listener, GObject *source_object, GError **error) { return stub_funcs.ptr_g_socket_listener_add_any_inet_port(listener, source_object, error); }
GSocket * (g_socket_listener_accept_socket)(GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_listener_accept_socket(listener, source_object, cancellable, error); }
void (g_socket_listener_accept_socket_async)(GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_listener_accept_socket_async(listener, cancellable, callback, user_data); }
GSocket * (g_socket_listener_accept_socket_finish)(GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error) { return stub_funcs.ptr_g_socket_listener_accept_socket_finish(listener, result, source_object, error); }
GSocketConnection * (g_socket_listener_accept)(GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_socket_listener_accept(listener, source_object, cancellable, error); }
void (g_socket_listener_accept_async)(GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_socket_listener_accept_async(listener, cancellable, callback, user_data); }
GSocketConnection * (g_socket_listener_accept_finish)(GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error) { return stub_funcs.ptr_g_socket_listener_accept_finish(listener, result, source_object, error); }
void (g_socket_listener_close)(GSocketListener *listener) { stub_funcs.ptr_g_socket_listener_close(listener); }
GType (g_socket_service_get_type)(void) { return stub_funcs.ptr_g_socket_service_get_type(); }
GSocketService* (g_socket_service_new)(void) { return stub_funcs.ptr_g_socket_service_new(); }
void (g_socket_service_start)(GSocketService *service) { stub_funcs.ptr_g_socket_service_start(service); }
void (g_socket_service_stop)(GSocketService *service) { stub_funcs.ptr_g_socket_service_stop(service); }
gboolean (g_socket_service_is_active)(GSocketService *service) { return stub_funcs.ptr_g_socket_service_is_active(service); }
GType (g_srv_target_get_type)(void) { return stub_funcs.ptr_g_srv_target_get_type(); }
GSrvTarget* (g_srv_target_new)(const gchar *hostname, guint16 port, guint16 priority, guint16 weight) { return stub_funcs.ptr_g_srv_target_new(hostname, port, priority, weight); }
GSrvTarget* (g_srv_target_copy)(GSrvTarget *target) { return stub_funcs.ptr_g_srv_target_copy(target); }
void (g_srv_target_free)(GSrvTarget *target) { stub_funcs.ptr_g_srv_target_free(target); }
const gchar* (g_srv_target_get_hostname)(GSrvTarget *target) { return stub_funcs.ptr_g_srv_target_get_hostname(target); }
guint16 (g_srv_target_get_port)(GSrvTarget *target) { return stub_funcs.ptr_g_srv_target_get_port(target); }
guint16 (g_srv_target_get_priority)(GSrvTarget *target) { return stub_funcs.ptr_g_srv_target_get_priority(target); }
guint16 (g_srv_target_get_weight)(GSrvTarget *target) { return stub_funcs.ptr_g_srv_target_get_weight(target); }
GList* (g_srv_target_list_sort)(GList *targets) { return stub_funcs.ptr_g_srv_target_list_sort(targets); }
GType (g_subprocess_get_type)(void) { return stub_funcs.ptr_g_subprocess_get_type(); }
// Found va_equiv for func g_subprocess_new as func g_subprocess_newv with pattern g_subprocess_new[_]*va*$, but err: va_list missing
GSubprocess * (g_subprocess_newv)(const gchar * const *argv, GSubprocessFlags flags, GError **error) { return stub_funcs.ptr_g_subprocess_newv(argv, flags, error); }
GOutputStream * (g_subprocess_get_stdin_pipe)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_stdin_pipe(subprocess); }
GInputStream * (g_subprocess_get_stdout_pipe)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_stdout_pipe(subprocess); }
GInputStream * (g_subprocess_get_stderr_pipe)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_stderr_pipe(subprocess); }
const gchar * (g_subprocess_get_identifier)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_identifier(subprocess); }
void (g_subprocess_send_signal)(GSubprocess *subprocess, gint signal_num) { stub_funcs.ptr_g_subprocess_send_signal(subprocess, signal_num); }
void (g_subprocess_force_exit)(GSubprocess *subprocess) { stub_funcs.ptr_g_subprocess_force_exit(subprocess); }
gboolean (g_subprocess_wait)(GSubprocess *subprocess, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_subprocess_wait(subprocess, cancellable, error); }
void (g_subprocess_wait_async)(GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_subprocess_wait_async(subprocess, cancellable, callback, user_data); }
gboolean (g_subprocess_wait_finish)(GSubprocess *subprocess, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_subprocess_wait_finish(subprocess, result, error); }
gboolean (g_subprocess_wait_check)(GSubprocess *subprocess, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_subprocess_wait_check(subprocess, cancellable, error); }
void (g_subprocess_wait_check_async)(GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_subprocess_wait_check_async(subprocess, cancellable, callback, user_data); }
gboolean (g_subprocess_wait_check_finish)(GSubprocess *subprocess, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_subprocess_wait_check_finish(subprocess, result, error); }
gint (g_subprocess_get_status)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_status(subprocess); }
gboolean (g_subprocess_get_successful)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_successful(subprocess); }
gboolean (g_subprocess_get_if_exited)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_if_exited(subprocess); }
gint (g_subprocess_get_exit_status)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_exit_status(subprocess); }
gboolean (g_subprocess_get_if_signaled)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_if_signaled(subprocess); }
gint (g_subprocess_get_term_sig)(GSubprocess *subprocess) { return stub_funcs.ptr_g_subprocess_get_term_sig(subprocess); }
gboolean (g_subprocess_communicate)(GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GBytes **stdout_buf, GBytes **stderr_buf, GError **error) { return stub_funcs.ptr_g_subprocess_communicate(subprocess, stdin_buf, cancellable, stdout_buf, stderr_buf, error); }
void (g_subprocess_communicate_async)(GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_subprocess_communicate_async(subprocess, stdin_buf, cancellable, callback, user_data); }
gboolean (g_subprocess_communicate_finish)(GSubprocess *subprocess, GAsyncResult *result, GBytes **stdout_buf, GBytes **stderr_buf, GError **error) { return stub_funcs.ptr_g_subprocess_communicate_finish(subprocess, result, stdout_buf, stderr_buf, error); }
gboolean (g_subprocess_communicate_utf8)(GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, char **stdout_buf, char **stderr_buf, GError **error) { return stub_funcs.ptr_g_subprocess_communicate_utf8(subprocess, stdin_buf, cancellable, stdout_buf, stderr_buf, error); }
void (g_subprocess_communicate_utf8_async)(GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_subprocess_communicate_utf8_async(subprocess, stdin_buf, cancellable, callback, user_data); }
gboolean (g_subprocess_communicate_utf8_finish)(GSubprocess *subprocess, GAsyncResult *result, char **stdout_buf, char **stderr_buf, GError **error) { return stub_funcs.ptr_g_subprocess_communicate_utf8_finish(subprocess, result, stdout_buf, stderr_buf, error); }
GType (g_subprocess_launcher_get_type)(void) { return stub_funcs.ptr_g_subprocess_launcher_get_type(); }
GSubprocessLauncher * (g_subprocess_launcher_new)(GSubprocessFlags flags) { return stub_funcs.ptr_g_subprocess_launcher_new(flags); }
// Found va_equiv for func g_subprocess_launcher_spawn as func g_subprocess_launcher_spawnv with pattern g_subprocess_launcher_spawn[_]*va*$, but err: va_list missing
GSubprocess * (g_subprocess_launcher_spawnv)(GSubprocessLauncher *self, const gchar * const *argv, GError **error) { return stub_funcs.ptr_g_subprocess_launcher_spawnv(self, argv, error); }
void (g_subprocess_launcher_set_environ)(GSubprocessLauncher *self, gchar **env) { stub_funcs.ptr_g_subprocess_launcher_set_environ(self, env); }
void (g_subprocess_launcher_setenv)(GSubprocessLauncher *self, const gchar *variable, const gchar *value, gboolean overwrite) { stub_funcs.ptr_g_subprocess_launcher_setenv(self, variable, value, overwrite); }
void (g_subprocess_launcher_unsetenv)(GSubprocessLauncher *self, const gchar *variable) { stub_funcs.ptr_g_subprocess_launcher_unsetenv(self, variable); }
const gchar * (g_subprocess_launcher_getenv)(GSubprocessLauncher *self, const gchar *variable) { return stub_funcs.ptr_g_subprocess_launcher_getenv(self, variable); }
void (g_subprocess_launcher_set_cwd)(GSubprocessLauncher *self, const gchar *cwd) { stub_funcs.ptr_g_subprocess_launcher_set_cwd(self, cwd); }
void (g_subprocess_launcher_set_flags)(GSubprocessLauncher *self, GSubprocessFlags flags) { stub_funcs.ptr_g_subprocess_launcher_set_flags(self, flags); }
void (g_subprocess_launcher_set_stdin_file_path)(GSubprocessLauncher *self, const gchar *path) { stub_funcs.ptr_g_subprocess_launcher_set_stdin_file_path(self, path); }
void (g_subprocess_launcher_take_stdin_fd)(GSubprocessLauncher *self, gint fd) { stub_funcs.ptr_g_subprocess_launcher_take_stdin_fd(self, fd); }
void (g_subprocess_launcher_set_stdout_file_path)(GSubprocessLauncher *self, const gchar *path) { stub_funcs.ptr_g_subprocess_launcher_set_stdout_file_path(self, path); }
void (g_subprocess_launcher_take_stdout_fd)(GSubprocessLauncher *self, gint fd) { stub_funcs.ptr_g_subprocess_launcher_take_stdout_fd(self, fd); }
void (g_subprocess_launcher_set_stderr_file_path)(GSubprocessLauncher *self, const gchar *path) { stub_funcs.ptr_g_subprocess_launcher_set_stderr_file_path(self, path); }
void (g_subprocess_launcher_take_stderr_fd)(GSubprocessLauncher *self, gint fd) { stub_funcs.ptr_g_subprocess_launcher_take_stderr_fd(self, fd); }
void (g_subprocess_launcher_take_fd)(GSubprocessLauncher *self, gint source_fd, gint target_fd) { stub_funcs.ptr_g_subprocess_launcher_take_fd(self, source_fd, target_fd); }
void (g_subprocess_launcher_close)(GSubprocessLauncher *self) { stub_funcs.ptr_g_subprocess_launcher_close(self); }
void (g_subprocess_launcher_set_child_setup)(GSubprocessLauncher *self, GSpawnChildSetupFunc child_setup, gpointer user_data, GDestroyNotify destroy_notify) { stub_funcs.ptr_g_subprocess_launcher_set_child_setup(self, child_setup, user_data, destroy_notify); }
GType (g_task_get_type)(void) { return stub_funcs.ptr_g_task_get_type(); }
GTask* (g_task_new)(gpointer source_object, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer callback_data) { return stub_funcs.ptr_g_task_new(source_object, cancellable, callback, callback_data); }
void (g_task_report_error)(gpointer source_object, GAsyncReadyCallback callback, gpointer callback_data, gpointer source_tag, GError *error) { stub_funcs.ptr_g_task_report_error(source_object, callback, callback_data, source_tag, error); }
// Unable to locate va_equiv for g_task_report_new_error
void (g_task_set_task_data)(GTask *task, gpointer task_data, GDestroyNotify task_data_destroy) { stub_funcs.ptr_g_task_set_task_data(task, task_data, task_data_destroy); }
void (g_task_set_priority)(GTask *task, gint priority) { stub_funcs.ptr_g_task_set_priority(task, priority); }
void (g_task_set_check_cancellable)(GTask *task, gboolean check_cancellable) { stub_funcs.ptr_g_task_set_check_cancellable(task, check_cancellable); }
void (g_task_set_source_tag)(GTask *task, gpointer source_tag) { stub_funcs.ptr_g_task_set_source_tag(task, source_tag); }
void (g_task_set_name)(GTask *task, const gchar *name) { stub_funcs.ptr_g_task_set_name(task, name); }
void (g_task_set_static_name)(GTask *task, const gchar *name) { stub_funcs.ptr_g_task_set_static_name(task, name); }
gpointer (g_task_get_source_object)(GTask *task) { return stub_funcs.ptr_g_task_get_source_object(task); }
gpointer (g_task_get_task_data)(GTask *task) { return stub_funcs.ptr_g_task_get_task_data(task); }
gint (g_task_get_priority)(GTask *task) { return stub_funcs.ptr_g_task_get_priority(task); }
GMainContext* (g_task_get_context)(GTask *task) { return stub_funcs.ptr_g_task_get_context(task); }
GCancellable* (g_task_get_cancellable)(GTask *task) { return stub_funcs.ptr_g_task_get_cancellable(task); }
gboolean (g_task_get_check_cancellable)(GTask *task) { return stub_funcs.ptr_g_task_get_check_cancellable(task); }
gpointer (g_task_get_source_tag)(GTask *task) { return stub_funcs.ptr_g_task_get_source_tag(task); }
const gchar* (g_task_get_name)(GTask *task) { return stub_funcs.ptr_g_task_get_name(task); }
gboolean (g_task_is_valid)(gpointer result, gpointer source_object) { return stub_funcs.ptr_g_task_is_valid(result, source_object); }
void (g_task_run_in_thread)(GTask *task, GTaskThreadFunc task_func) { stub_funcs.ptr_g_task_run_in_thread(task, task_func); }
void (g_task_run_in_thread_sync)(GTask *task, GTaskThreadFunc task_func) { stub_funcs.ptr_g_task_run_in_thread_sync(task, task_func); }
gboolean (g_task_set_return_on_cancel)(GTask *task, gboolean return_on_cancel) { return stub_funcs.ptr_g_task_set_return_on_cancel(task, return_on_cancel); }
gboolean (g_task_get_return_on_cancel)(GTask *task) { return stub_funcs.ptr_g_task_get_return_on_cancel(task); }
void (g_task_attach_source)(GTask *task, GSource *source, GSourceFunc callback) { stub_funcs.ptr_g_task_attach_source(task, source, callback); }
void (g_task_return_pointer)(GTask *task, gpointer result, GDestroyNotify result_destroy) { stub_funcs.ptr_g_task_return_pointer(task, result, result_destroy); }
void (g_task_return_boolean)(GTask *task, gboolean result) { stub_funcs.ptr_g_task_return_boolean(task, result); }
void (g_task_return_int)(GTask *task, gssize result) { stub_funcs.ptr_g_task_return_int(task, result); }
void (g_task_return_error)(GTask *task, GError *error) { stub_funcs.ptr_g_task_return_error(task, error); }
// Unable to locate va_equiv for g_task_return_prefixed_error
// Unable to locate va_equiv for g_task_return_new_error
void (g_task_return_new_error_literal)(GTask *task, GQuark domain, gint code, const char *message) { stub_funcs.ptr_g_task_return_new_error_literal(task, domain, code, message); }
void (g_task_return_value)(GTask *task, GValue *result) { stub_funcs.ptr_g_task_return_value(task, result); }
gboolean (g_task_return_error_if_cancelled)(GTask *task) { return stub_funcs.ptr_g_task_return_error_if_cancelled(task); }
gpointer (g_task_propagate_pointer)(GTask *task, GError **error) { return stub_funcs.ptr_g_task_propagate_pointer(task, error); }
gboolean (g_task_propagate_boolean)(GTask *task, GError **error) { return stub_funcs.ptr_g_task_propagate_boolean(task, error); }
gssize (g_task_propagate_int)(GTask *task, GError **error) { return stub_funcs.ptr_g_task_propagate_int(task, error); }
gboolean (g_task_propagate_value)(GTask *task, GValue *value, GError **error) { return stub_funcs.ptr_g_task_propagate_value(task, value, error); }
gboolean (g_task_had_error)(GTask *task) { return stub_funcs.ptr_g_task_had_error(task); }
gboolean (g_task_get_completed)(GTask *task) { return stub_funcs.ptr_g_task_get_completed(task); }
void (g_task_print_alive_tasks)(void) { stub_funcs.ptr_g_task_print_alive_tasks(); }
GType (g_tcp_connection_get_type)(void) { return stub_funcs.ptr_g_tcp_connection_get_type(); }
void (g_tcp_connection_set_graceful_disconnect)(GTcpConnection *connection, gboolean graceful_disconnect) { stub_funcs.ptr_g_tcp_connection_set_graceful_disconnect(connection, graceful_disconnect); }
gboolean (g_tcp_connection_get_graceful_disconnect)(GTcpConnection *connection) { return stub_funcs.ptr_g_tcp_connection_get_graceful_disconnect(connection); }
GType (g_tcp_wrapper_connection_get_type)(void) { return stub_funcs.ptr_g_tcp_wrapper_connection_get_type(); }
GSocketConnection* (g_tcp_wrapper_connection_new)(GIOStream *base_io_stream, GSocket *socket) { return stub_funcs.ptr_g_tcp_wrapper_connection_new(base_io_stream, socket); }
GIOStream* (g_tcp_wrapper_connection_get_base_io_stream)(GTcpWrapperConnection *conn) { return stub_funcs.ptr_g_tcp_wrapper_connection_get_base_io_stream(conn); }
GType (g_test_dbus_get_type)(void) { return stub_funcs.ptr_g_test_dbus_get_type(); }
GTestDBus * (g_test_dbus_new)(GTestDBusFlags flags) { return stub_funcs.ptr_g_test_dbus_new(flags); }
GTestDBusFlags (g_test_dbus_get_flags)(GTestDBus *self) { return stub_funcs.ptr_g_test_dbus_get_flags(self); }
const gchar * (g_test_dbus_get_bus_address)(GTestDBus *self) { return stub_funcs.ptr_g_test_dbus_get_bus_address(self); }
void (g_test_dbus_add_service_dir)(GTestDBus *self, const gchar *path) { stub_funcs.ptr_g_test_dbus_add_service_dir(self, path); }
void (g_test_dbus_up)(GTestDBus *self) { stub_funcs.ptr_g_test_dbus_up(self); }
void (g_test_dbus_stop)(GTestDBus *self) { stub_funcs.ptr_g_test_dbus_stop(self); }
void (g_test_dbus_down)(GTestDBus *self) { stub_funcs.ptr_g_test_dbus_down(self); }
void (g_test_dbus_unset)(void) { stub_funcs.ptr_g_test_dbus_unset(); }
GType (g_themed_icon_get_type)(void) { return stub_funcs.ptr_g_themed_icon_get_type(); }
GIcon* (g_themed_icon_new)(const char *iconname) { return stub_funcs.ptr_g_themed_icon_new(iconname); }
GIcon* (g_themed_icon_new_with_default_fallbacks)(const char *iconname) { return stub_funcs.ptr_g_themed_icon_new_with_default_fallbacks(iconname); }
GIcon* (g_themed_icon_new_from_names)(char **iconnames, int len) { return stub_funcs.ptr_g_themed_icon_new_from_names(iconnames, len); }
void (g_themed_icon_prepend_name)(GThemedIcon *icon, const char *iconname) { stub_funcs.ptr_g_themed_icon_prepend_name(icon, iconname); }
void (g_themed_icon_append_name)(GThemedIcon *icon, const char *iconname) { stub_funcs.ptr_g_themed_icon_append_name(icon, iconname); }
const gchar* const * (g_themed_icon_get_names)(GThemedIcon *icon) { return stub_funcs.ptr_g_themed_icon_get_names(icon); }
GType (g_threaded_socket_service_get_type)(void) { return stub_funcs.ptr_g_threaded_socket_service_get_type(); }
GSocketService * (g_threaded_socket_service_new)(int max_threads) { return stub_funcs.ptr_g_threaded_socket_service_new(max_threads); }
GType (g_tls_backend_get_type)(void) { return stub_funcs.ptr_g_tls_backend_get_type(); }
GTlsBackend * (g_tls_backend_get_default)(void) { return stub_funcs.ptr_g_tls_backend_get_default(); }
GTlsDatabase * (g_tls_backend_get_default_database)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_get_default_database(backend); }
void (g_tls_backend_set_default_database)(GTlsBackend *backend, GTlsDatabase *database) { stub_funcs.ptr_g_tls_backend_set_default_database(backend, database); }
gboolean (g_tls_backend_supports_tls)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_supports_tls(backend); }
gboolean (g_tls_backend_supports_dtls)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_supports_dtls(backend); }
GType (g_tls_backend_get_certificate_type)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_get_certificate_type(backend); }
GType (g_tls_backend_get_client_connection_type)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_get_client_connection_type(backend); }
GType (g_tls_backend_get_server_connection_type)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_get_server_connection_type(backend); }
GType (g_tls_backend_get_file_database_type)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_get_file_database_type(backend); }
GType (g_tls_backend_get_dtls_client_connection_type)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_get_dtls_client_connection_type(backend); }
GType (g_tls_backend_get_dtls_server_connection_type)(GTlsBackend *backend) { return stub_funcs.ptr_g_tls_backend_get_dtls_server_connection_type(backend); }
GType (g_tls_certificate_get_type)(void) { return stub_funcs.ptr_g_tls_certificate_get_type(); }
GTlsCertificate* (g_tls_certificate_new_from_pem)(const gchar *data, gssize length, GError **error) { return stub_funcs.ptr_g_tls_certificate_new_from_pem(data, length, error); }
GTlsCertificate* (g_tls_certificate_new_from_pkcs12)(const guint8 *data, gsize length, const gchar *password, GError **error) { return stub_funcs.ptr_g_tls_certificate_new_from_pkcs12(data, length, password, error); }
GTlsCertificate* (g_tls_certificate_new_from_file_with_password)(const gchar *file, const gchar *password, GError **error) { return stub_funcs.ptr_g_tls_certificate_new_from_file_with_password(file, password, error); }
GTlsCertificate* (g_tls_certificate_new_from_file)(const gchar *file, GError **error) { return stub_funcs.ptr_g_tls_certificate_new_from_file(file, error); }
GTlsCertificate* (g_tls_certificate_new_from_files)(const gchar *cert_file, const gchar *key_file, GError **error) { return stub_funcs.ptr_g_tls_certificate_new_from_files(cert_file, key_file, error); }
GTlsCertificate* (g_tls_certificate_new_from_pkcs11_uris)(const gchar *pkcs11_uri, const gchar *private_key_pkcs11_uri, GError **error) { return stub_funcs.ptr_g_tls_certificate_new_from_pkcs11_uris(pkcs11_uri, private_key_pkcs11_uri, error); }
GList* (g_tls_certificate_list_new_from_file)(const gchar *file, GError **error) { return stub_funcs.ptr_g_tls_certificate_list_new_from_file(file, error); }
GTlsCertificate* (g_tls_certificate_get_issuer)(GTlsCertificate *cert) { return stub_funcs.ptr_g_tls_certificate_get_issuer(cert); }
GTlsCertificateFlags (g_tls_certificate_verify)(GTlsCertificate *cert, GSocketConnectable *identity, GTlsCertificate *trusted_ca) { return stub_funcs.ptr_g_tls_certificate_verify(cert, identity, trusted_ca); }
gboolean (g_tls_certificate_is_same)(GTlsCertificate *cert_one, GTlsCertificate *cert_two) { return stub_funcs.ptr_g_tls_certificate_is_same(cert_one, cert_two); }
GDateTime* (g_tls_certificate_get_not_valid_before)(GTlsCertificate *cert) { return stub_funcs.ptr_g_tls_certificate_get_not_valid_before(cert); }
GDateTime* (g_tls_certificate_get_not_valid_after)(GTlsCertificate *cert) { return stub_funcs.ptr_g_tls_certificate_get_not_valid_after(cert); }
gchar* (g_tls_certificate_get_subject_name)(GTlsCertificate *cert) { return stub_funcs.ptr_g_tls_certificate_get_subject_name(cert); }
gchar* (g_tls_certificate_get_issuer_name)(GTlsCertificate *cert) { return stub_funcs.ptr_g_tls_certificate_get_issuer_name(cert); }
GPtrArray* (g_tls_certificate_get_dns_names)(GTlsCertificate *cert) { return stub_funcs.ptr_g_tls_certificate_get_dns_names(cert); }
GPtrArray* (g_tls_certificate_get_ip_addresses)(GTlsCertificate *cert) { return stub_funcs.ptr_g_tls_certificate_get_ip_addresses(cert); }
GType (g_tls_client_connection_get_type)(void) { return stub_funcs.ptr_g_tls_client_connection_get_type(); }
GIOStream * (g_tls_client_connection_new)(GIOStream *base_io_stream, GSocketConnectable *server_identity, GError **error) { return stub_funcs.ptr_g_tls_client_connection_new(base_io_stream, server_identity, error); }
GTlsCertificateFlags (g_tls_client_connection_get_validation_flags)(GTlsClientConnection *conn) { return stub_funcs.ptr_g_tls_client_connection_get_validation_flags(conn); }
void (g_tls_client_connection_set_validation_flags)(GTlsClientConnection *conn, GTlsCertificateFlags flags) { stub_funcs.ptr_g_tls_client_connection_set_validation_flags(conn, flags); }
GSocketConnectable* (g_tls_client_connection_get_server_identity)(GTlsClientConnection *conn) { return stub_funcs.ptr_g_tls_client_connection_get_server_identity(conn); }
void (g_tls_client_connection_set_server_identity)(GTlsClientConnection *conn, GSocketConnectable *identity) { stub_funcs.ptr_g_tls_client_connection_set_server_identity(conn, identity); }
gboolean (g_tls_client_connection_get_use_ssl3)(GTlsClientConnection *conn) { return stub_funcs.ptr_g_tls_client_connection_get_use_ssl3(conn); }
void (g_tls_client_connection_set_use_ssl3)(GTlsClientConnection *conn, gboolean use_ssl3) { stub_funcs.ptr_g_tls_client_connection_set_use_ssl3(conn, use_ssl3); }
GList * (g_tls_client_connection_get_accepted_cas)(GTlsClientConnection *conn) { return stub_funcs.ptr_g_tls_client_connection_get_accepted_cas(conn); }
void (g_tls_client_connection_copy_session_state)(GTlsClientConnection *conn, GTlsClientConnection *source) { stub_funcs.ptr_g_tls_client_connection_copy_session_state(conn, source); }
GType (g_tls_connection_get_type)(void) { return stub_funcs.ptr_g_tls_connection_get_type(); }
void (g_tls_connection_set_use_system_certdb)(GTlsConnection *conn, gboolean use_system_certdb) { stub_funcs.ptr_g_tls_connection_set_use_system_certdb(conn, use_system_certdb); }
gboolean (g_tls_connection_get_use_system_certdb)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_use_system_certdb(conn); }
void (g_tls_connection_set_database)(GTlsConnection *conn, GTlsDatabase *database) { stub_funcs.ptr_g_tls_connection_set_database(conn, database); }
GTlsDatabase * (g_tls_connection_get_database)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_database(conn); }
void (g_tls_connection_set_certificate)(GTlsConnection *conn, GTlsCertificate *certificate) { stub_funcs.ptr_g_tls_connection_set_certificate(conn, certificate); }
GTlsCertificate* (g_tls_connection_get_certificate)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_certificate(conn); }
void (g_tls_connection_set_interaction)(GTlsConnection *conn, GTlsInteraction *interaction) { stub_funcs.ptr_g_tls_connection_set_interaction(conn, interaction); }
GTlsInteraction * (g_tls_connection_get_interaction)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_interaction(conn); }
GTlsCertificate* (g_tls_connection_get_peer_certificate)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_peer_certificate(conn); }
GTlsCertificateFlags (g_tls_connection_get_peer_certificate_errors)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_peer_certificate_errors(conn); }
void (g_tls_connection_set_require_close_notify)(GTlsConnection *conn, gboolean require_close_notify) { stub_funcs.ptr_g_tls_connection_set_require_close_notify(conn, require_close_notify); }
gboolean (g_tls_connection_get_require_close_notify)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_require_close_notify(conn); }
GTlsRehandshakeMode (g_tls_connection_get_rehandshake_mode)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_rehandshake_mode(conn); }
const gchar * (g_tls_connection_get_negotiated_protocol)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_negotiated_protocol(conn); }
void (g_tls_connection_handshake_async)(GTlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_tls_connection_handshake_async(conn, io_priority, cancellable, callback, user_data); }
gboolean (g_tls_connection_handshake_finish)(GTlsConnection *conn, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_tls_connection_handshake_finish(conn, result, error); }
GTlsProtocolVersion (g_tls_connection_get_protocol_version)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_protocol_version(conn); }
gchar * (g_tls_connection_get_ciphersuite_name)(GTlsConnection *conn) { return stub_funcs.ptr_g_tls_connection_get_ciphersuite_name(conn); }
GQuark (g_tls_error_quark)(void) { return stub_funcs.ptr_g_tls_error_quark(); }
GQuark (g_tls_channel_binding_error_quark)(void) { return stub_funcs.ptr_g_tls_channel_binding_error_quark(); }
gboolean (g_tls_connection_emit_accept_certificate)(GTlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors) { return stub_funcs.ptr_g_tls_connection_emit_accept_certificate(conn, peer_cert, errors); }
GType (g_tls_database_get_type)(void) { return stub_funcs.ptr_g_tls_database_get_type(); }
GTlsCertificateFlags (g_tls_database_verify_chain)(GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_database_verify_chain(self, chain, purpose, identity, interaction, flags, cancellable, error); }
void (g_tls_database_verify_chain_async)(GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_tls_database_verify_chain_async(self, chain, purpose, identity, interaction, flags, cancellable, callback, user_data); }
GTlsCertificateFlags (g_tls_database_verify_chain_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_tls_database_verify_chain_finish(self, result, error); }
gchar* (g_tls_database_create_certificate_handle)(GTlsDatabase *self, GTlsCertificate *certificate) { return stub_funcs.ptr_g_tls_database_create_certificate_handle(self, certificate); }
GTlsCertificate* (g_tls_database_lookup_certificate_for_handle)(GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_database_lookup_certificate_for_handle(self, handle, interaction, flags, cancellable, error); }
void (g_tls_database_lookup_certificate_for_handle_async)(GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_tls_database_lookup_certificate_for_handle_async(self, handle, interaction, flags, cancellable, callback, user_data); }
GTlsCertificate* (g_tls_database_lookup_certificate_for_handle_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_tls_database_lookup_certificate_for_handle_finish(self, result, error); }
GTlsCertificate* (g_tls_database_lookup_certificate_issuer)(GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_database_lookup_certificate_issuer(self, certificate, interaction, flags, cancellable, error); }
void (g_tls_database_lookup_certificate_issuer_async)(GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_tls_database_lookup_certificate_issuer_async(self, certificate, interaction, flags, cancellable, callback, user_data); }
GTlsCertificate* (g_tls_database_lookup_certificate_issuer_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_tls_database_lookup_certificate_issuer_finish(self, result, error); }
GList* (g_tls_database_lookup_certificates_issued_by)(GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_database_lookup_certificates_issued_by(self, issuer_raw_dn, interaction, flags, cancellable, error); }
void (g_tls_database_lookup_certificates_issued_by_async)(GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_tls_database_lookup_certificates_issued_by_async(self, issuer_raw_dn, interaction, flags, cancellable, callback, user_data); }
GList* (g_tls_database_lookup_certificates_issued_by_finish)(GTlsDatabase *self, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_tls_database_lookup_certificates_issued_by_finish(self, result, error); }
GType (g_tls_file_database_get_type)(void) { return stub_funcs.ptr_g_tls_file_database_get_type(); }
GTlsDatabase* (g_tls_file_database_new)(const gchar *anchors, GError **error) { return stub_funcs.ptr_g_tls_file_database_new(anchors, error); }
GType (g_tls_interaction_get_type)(void) { return stub_funcs.ptr_g_tls_interaction_get_type(); }
GTlsInteractionResult (g_tls_interaction_invoke_ask_password)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_interaction_invoke_ask_password(interaction, password, cancellable, error); }
GTlsInteractionResult (g_tls_interaction_ask_password)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_interaction_ask_password(interaction, password, cancellable, error); }
void (g_tls_interaction_ask_password_async)(GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_tls_interaction_ask_password_async(interaction, password, cancellable, callback, user_data); }
GTlsInteractionResult (g_tls_interaction_ask_password_finish)(GTlsInteraction *interaction, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_tls_interaction_ask_password_finish(interaction, result, error); }
GTlsInteractionResult (g_tls_interaction_invoke_request_certificate)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_interaction_invoke_request_certificate(interaction, connection, flags, cancellable, error); }
GTlsInteractionResult (g_tls_interaction_request_certificate)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_tls_interaction_request_certificate(interaction, connection, flags, cancellable, error); }
void (g_tls_interaction_request_certificate_async)(GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_tls_interaction_request_certificate_async(interaction, connection, flags, cancellable, callback, user_data); }
GTlsInteractionResult (g_tls_interaction_request_certificate_finish)(GTlsInteraction *interaction, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_tls_interaction_request_certificate_finish(interaction, result, error); }
GType (g_tls_password_get_type)(void) { return stub_funcs.ptr_g_tls_password_get_type(); }
GTlsPassword * (g_tls_password_new)(GTlsPasswordFlags flags, const gchar *description) { return stub_funcs.ptr_g_tls_password_new(flags, description); }
const guchar * (g_tls_password_get_value)(GTlsPassword *password, gsize *length) { return stub_funcs.ptr_g_tls_password_get_value(password, length); }
void (g_tls_password_set_value)(GTlsPassword *password, const guchar *value, gssize length) { stub_funcs.ptr_g_tls_password_set_value(password, value, length); }
void (g_tls_password_set_value_full)(GTlsPassword *password, guchar *value, gssize length, GDestroyNotify destroy) { stub_funcs.ptr_g_tls_password_set_value_full(password, value, length, destroy); }
GTlsPasswordFlags (g_tls_password_get_flags)(GTlsPassword *password) { return stub_funcs.ptr_g_tls_password_get_flags(password); }
void (g_tls_password_set_flags)(GTlsPassword *password, GTlsPasswordFlags flags) { stub_funcs.ptr_g_tls_password_set_flags(password, flags); }
const gchar* (g_tls_password_get_description)(GTlsPassword *password) { return stub_funcs.ptr_g_tls_password_get_description(password); }
void (g_tls_password_set_description)(GTlsPassword *password, const gchar *description) { stub_funcs.ptr_g_tls_password_set_description(password, description); }
const gchar * (g_tls_password_get_warning)(GTlsPassword *password) { return stub_funcs.ptr_g_tls_password_get_warning(password); }
void (g_tls_password_set_warning)(GTlsPassword *password, const gchar *warning) { stub_funcs.ptr_g_tls_password_set_warning(password, warning); }
GType (g_tls_server_connection_get_type)(void) { return stub_funcs.ptr_g_tls_server_connection_get_type(); }
GIOStream * (g_tls_server_connection_new)(GIOStream *base_io_stream, GTlsCertificate *certificate, GError **error) { return stub_funcs.ptr_g_tls_server_connection_new(base_io_stream, certificate, error); }
GType (g_unix_connection_get_type)(void) { return stub_funcs.ptr_g_unix_connection_get_type(); }
gboolean (g_unix_connection_send_fd)(GUnixConnection *connection, gint fd, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_unix_connection_send_fd(connection, fd, cancellable, error); }
gint (g_unix_connection_receive_fd)(GUnixConnection *connection, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_unix_connection_receive_fd(connection, cancellable, error); }
gboolean (g_unix_connection_send_credentials)(GUnixConnection *connection, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_unix_connection_send_credentials(connection, cancellable, error); }
void (g_unix_connection_send_credentials_async)(GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_unix_connection_send_credentials_async(connection, cancellable, callback, user_data); }
gboolean (g_unix_connection_send_credentials_finish)(GUnixConnection *connection, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_unix_connection_send_credentials_finish(connection, result, error); }
GCredentials* (g_unix_connection_receive_credentials)(GUnixConnection *connection, GCancellable *cancellable, GError **error) { return stub_funcs.ptr_g_unix_connection_receive_credentials(connection, cancellable, error); }
void (g_unix_connection_receive_credentials_async)(GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_unix_connection_receive_credentials_async(connection, cancellable, callback, user_data); }
GCredentials* (g_unix_connection_receive_credentials_finish)(GUnixConnection *connection, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_unix_connection_receive_credentials_finish(connection, result, error); }
GType (g_unix_credentials_message_get_type)(void) { return stub_funcs.ptr_g_unix_credentials_message_get_type(); }
GSocketControlMessage* (g_unix_credentials_message_new)(void) { return stub_funcs.ptr_g_unix_credentials_message_new(); }
GSocketControlMessage* (g_unix_credentials_message_new_with_credentials)(GCredentials *credentials) { return stub_funcs.ptr_g_unix_credentials_message_new_with_credentials(credentials); }
GCredentials* (g_unix_credentials_message_get_credentials)(GUnixCredentialsMessage *message) { return stub_funcs.ptr_g_unix_credentials_message_get_credentials(message); }
gboolean (g_unix_credentials_message_is_supported)(void) { return stub_funcs.ptr_g_unix_credentials_message_is_supported(); }
GType (g_unix_fd_list_get_type)(void) { return stub_funcs.ptr_g_unix_fd_list_get_type(); }
GUnixFDList * (g_unix_fd_list_new)(void) { return stub_funcs.ptr_g_unix_fd_list_new(); }
GUnixFDList * (g_unix_fd_list_new_from_array)(const gint *fds, gint n_fds) { return stub_funcs.ptr_g_unix_fd_list_new_from_array(fds, n_fds); }
gint (g_unix_fd_list_append)(GUnixFDList *list, gint fd, GError **error) { return stub_funcs.ptr_g_unix_fd_list_append(list, fd, error); }
gint (g_unix_fd_list_get_length)(GUnixFDList *list) { return stub_funcs.ptr_g_unix_fd_list_get_length(list); }
gint (g_unix_fd_list_get)(GUnixFDList *list, gint index_, GError **error) { return stub_funcs.ptr_g_unix_fd_list_get(list, index_, error); }
const gint * (g_unix_fd_list_peek_fds)(GUnixFDList *list, gint *length) { return stub_funcs.ptr_g_unix_fd_list_peek_fds(list, length); }
gint * (g_unix_fd_list_steal_fds)(GUnixFDList *list, gint *length) { return stub_funcs.ptr_g_unix_fd_list_steal_fds(list, length); }
GType (g_unix_socket_address_get_type)(void) { return stub_funcs.ptr_g_unix_socket_address_get_type(); }
GSocketAddress* (g_unix_socket_address_new)(const gchar *path) { return stub_funcs.ptr_g_unix_socket_address_new(path); }
GSocketAddress* (g_unix_socket_address_new_abstract)(const gchar *path, gint path_len) { return stub_funcs.ptr_g_unix_socket_address_new_abstract(path, path_len); }
GSocketAddress* (g_unix_socket_address_new_with_type)(const gchar *path, gint path_len, GUnixSocketAddressType type) { return stub_funcs.ptr_g_unix_socket_address_new_with_type(path, path_len, type); }
const char * (g_unix_socket_address_get_path)(GUnixSocketAddress *address) { return stub_funcs.ptr_g_unix_socket_address_get_path(address); }
gsize (g_unix_socket_address_get_path_len)(GUnixSocketAddress *address) { return stub_funcs.ptr_g_unix_socket_address_get_path_len(address); }
GUnixSocketAddressType (g_unix_socket_address_get_address_type)(GUnixSocketAddress *address) { return stub_funcs.ptr_g_unix_socket_address_get_address_type(address); }
gboolean (g_unix_socket_address_get_is_abstract)(GUnixSocketAddress *address) { return stub_funcs.ptr_g_unix_socket_address_get_is_abstract(address); }
gboolean (g_unix_socket_address_abstract_names_supported)(void) { return stub_funcs.ptr_g_unix_socket_address_abstract_names_supported(); }
GType (g_vfs_get_type)(void) { return stub_funcs.ptr_g_vfs_get_type(); }
gboolean (g_vfs_is_active)(GVfs *vfs) { return stub_funcs.ptr_g_vfs_is_active(vfs); }
GFile * (g_vfs_get_file_for_path)(GVfs *vfs, const char *path) { return stub_funcs.ptr_g_vfs_get_file_for_path(vfs, path); }
GFile * (g_vfs_get_file_for_uri)(GVfs *vfs, const char *uri) { return stub_funcs.ptr_g_vfs_get_file_for_uri(vfs, uri); }
const gchar* const * (g_vfs_get_supported_uri_schemes)(GVfs *vfs) { return stub_funcs.ptr_g_vfs_get_supported_uri_schemes(vfs); }
GFile * (g_vfs_parse_name)(GVfs *vfs, const char *parse_name) { return stub_funcs.ptr_g_vfs_parse_name(vfs, parse_name); }
GVfs * (g_vfs_get_default)(void) { return stub_funcs.ptr_g_vfs_get_default(); }
GVfs * (g_vfs_get_local)(void) { return stub_funcs.ptr_g_vfs_get_local(); }
gboolean (g_vfs_register_uri_scheme)(GVfs *vfs, const char *scheme, GVfsFileLookupFunc uri_func, gpointer uri_data, GDestroyNotify uri_destroy, GVfsFileLookupFunc parse_name_func, gpointer parse_name_data, GDestroyNotify parse_name_destroy) { return stub_funcs.ptr_g_vfs_register_uri_scheme(vfs, scheme, uri_func, uri_data, uri_destroy, parse_name_func, parse_name_data, parse_name_destroy); }
gboolean (g_vfs_unregister_uri_scheme)(GVfs *vfs, const char *scheme) { return stub_funcs.ptr_g_vfs_unregister_uri_scheme(vfs, scheme); }
GType (g_volume_get_type)(void) { return stub_funcs.ptr_g_volume_get_type(); }
char * (g_volume_get_name)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_name(volume); }
GIcon * (g_volume_get_icon)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_icon(volume); }
GIcon * (g_volume_get_symbolic_icon)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_symbolic_icon(volume); }
char * (g_volume_get_uuid)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_uuid(volume); }
GDrive * (g_volume_get_drive)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_drive(volume); }
GMount * (g_volume_get_mount)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_mount(volume); }
gboolean (g_volume_can_mount)(GVolume *volume) { return stub_funcs.ptr_g_volume_can_mount(volume); }
gboolean (g_volume_can_eject)(GVolume *volume) { return stub_funcs.ptr_g_volume_can_eject(volume); }
gboolean (g_volume_should_automount)(GVolume *volume) { return stub_funcs.ptr_g_volume_should_automount(volume); }
void (g_volume_mount)(GVolume *volume, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_volume_mount(volume, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_volume_mount_finish)(GVolume *volume, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_volume_mount_finish(volume, result, error); }
void (g_volume_eject)(GVolume *volume, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_volume_eject(volume, flags, cancellable, callback, user_data); }
gboolean (g_volume_eject_finish)(GVolume *volume, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_volume_eject_finish(volume, result, error); }
char * (g_volume_get_identifier)(GVolume *volume, const char *kind) { return stub_funcs.ptr_g_volume_get_identifier(volume, kind); }
char ** (g_volume_enumerate_identifiers)(GVolume *volume) { return stub_funcs.ptr_g_volume_enumerate_identifiers(volume); }
GFile * (g_volume_get_activation_root)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_activation_root(volume); }
void (g_volume_eject_with_operation)(GVolume *volume, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data) { stub_funcs.ptr_g_volume_eject_with_operation(volume, flags, mount_operation, cancellable, callback, user_data); }
gboolean (g_volume_eject_with_operation_finish)(GVolume *volume, GAsyncResult *result, GError **error) { return stub_funcs.ptr_g_volume_eject_with_operation_finish(volume, result, error); }
const gchar* (g_volume_get_sort_key)(GVolume *volume) { return stub_funcs.ptr_g_volume_get_sort_key(volume); }
GType (g_volume_monitor_get_type)(void) { return stub_funcs.ptr_g_volume_monitor_get_type(); }
GVolumeMonitor* (g_volume_monitor_get)(void) { return stub_funcs.ptr_g_volume_monitor_get(); }
GList * (g_volume_monitor_get_connected_drives)(GVolumeMonitor *volume_monitor) { return stub_funcs.ptr_g_volume_monitor_get_connected_drives(volume_monitor); }
GList * (g_volume_monitor_get_volumes)(GVolumeMonitor *volume_monitor) { return stub_funcs.ptr_g_volume_monitor_get_volumes(volume_monitor); }
GList * (g_volume_monitor_get_mounts)(GVolumeMonitor *volume_monitor) { return stub_funcs.ptr_g_volume_monitor_get_mounts(volume_monitor); }
GVolume * (g_volume_monitor_get_volume_for_uuid)(GVolumeMonitor *volume_monitor, const char *uuid) { return stub_funcs.ptr_g_volume_monitor_get_volume_for_uuid(volume_monitor, uuid); }
GMount * (g_volume_monitor_get_mount_for_uuid)(GVolumeMonitor *volume_monitor, const char *uuid) { return stub_funcs.ptr_g_volume_monitor_get_mount_for_uuid(volume_monitor, uuid); }
GVolume * (g_volume_monitor_adopt_orphan_mount)(GMount *mount) { return stub_funcs.ptr_g_volume_monitor_adopt_orphan_mount(mount); }
GType (g_zlib_compressor_get_type)(void) { return stub_funcs.ptr_g_zlib_compressor_get_type(); }
GZlibCompressor* (g_zlib_compressor_new)(GZlibCompressorFormat format, int level) { return stub_funcs.ptr_g_zlib_compressor_new(format, level); }
GFileInfo* (g_zlib_compressor_get_file_info)(GZlibCompressor *compressor) { return stub_funcs.ptr_g_zlib_compressor_get_file_info(compressor); }
void (g_zlib_compressor_set_file_info)(GZlibCompressor *compressor, GFileInfo *file_info) { stub_funcs.ptr_g_zlib_compressor_set_file_info(compressor, file_info); }
GType (g_zlib_decompressor_get_type)(void) { return stub_funcs.ptr_g_zlib_decompressor_get_type(); }
GZlibDecompressor* (g_zlib_decompressor_new)(GZlibCompressorFormat format) { return stub_funcs.ptr_g_zlib_decompressor_new(format); }
GFileInfo* (g_zlib_decompressor_get_file_info)(GZlibDecompressor *decompressor) { return stub_funcs.ptr_g_zlib_decompressor_get_file_info(decompressor); }
gboolean (g_module_supported)(void) { return stub_funcs.ptr_g_module_supported(); }
GModule* (g_module_open)(const gchar *file_name, GModuleFlags flags) { return stub_funcs.ptr_g_module_open(file_name, flags); }
GModule* (g_module_open_full)(const gchar *file_name, GModuleFlags flags, GError **error) { return stub_funcs.ptr_g_module_open_full(file_name, flags, error); }
gboolean (g_module_close)(GModule *module) { return stub_funcs.ptr_g_module_close(module); }
void (g_module_make_resident)(GModule *module) { stub_funcs.ptr_g_module_make_resident(module); }
const gchar * (g_module_error)(void) { return stub_funcs.ptr_g_module_error(); }
gboolean (g_module_symbol)(GModule *module, const gchar *symbol_name, gpointer *symbol) { return stub_funcs.ptr_g_module_symbol(module, symbol_name, symbol); }
const gchar * (g_module_name)(GModule *module) { return stub_funcs.ptr_g_module_name(module); }
gchar* (g_module_build_path)(const gchar *directory, const gchar *module_name) { return stub_funcs.ptr_g_module_build_path(directory, module_name); }
GQuark (g_module_error_quark)(void) { return stub_funcs.ptr_g_module_error_quark(); }
GType (gi_repository_get_type)(void) { return stub_funcs.ptr_gi_repository_get_type(); }
GIRepository* (gi_repository_new)(void) { return stub_funcs.ptr_gi_repository_new(); }
void (gi_repository_prepend_search_path)(GIRepository *repository, const char *directory) { stub_funcs.ptr_gi_repository_prepend_search_path(repository, directory); }
void (gi_repository_prepend_library_path)(GIRepository *repository, const char *directory) { stub_funcs.ptr_gi_repository_prepend_library_path(repository, directory); }
const char * const * (gi_repository_get_search_path)(GIRepository *repository, size_t *n_paths_out) { return stub_funcs.ptr_gi_repository_get_search_path(repository, n_paths_out); }
const char * const* (gi_repository_get_library_path)(GIRepository *repository, size_t *n_paths_out) { return stub_funcs.ptr_gi_repository_get_library_path(repository, n_paths_out); }
const char * (gi_repository_load_typelib)(GIRepository *repository, GITypelib *typelib, GIRepositoryLoadFlags flags, GError **error) { return stub_funcs.ptr_gi_repository_load_typelib(repository, typelib, flags, error); }
gboolean (gi_repository_is_registered)(GIRepository *repository, const char *namespace_, const char *version) { return stub_funcs.ptr_gi_repository_is_registered(repository, namespace_, version); }
GIBaseInfo * (gi_repository_find_by_name)(GIRepository *repository, const char *namespace_, const char *name) { return stub_funcs.ptr_gi_repository_find_by_name(repository, namespace_, name); }
char ** (gi_repository_enumerate_versions)(GIRepository *repository, const char *namespace_, size_t *n_versions_out) { return stub_funcs.ptr_gi_repository_enumerate_versions(repository, namespace_, n_versions_out); }
GITypelib * (gi_repository_require)(GIRepository *repository, const char *namespace_, const char *version, GIRepositoryLoadFlags flags, GError **error) { return stub_funcs.ptr_gi_repository_require(repository, namespace_, version, flags, error); }
GITypelib * (gi_repository_require_private)(GIRepository *repository, const char *typelib_dir, const char *namespace_, const char *version, GIRepositoryLoadFlags flags, GError **error) { return stub_funcs.ptr_gi_repository_require_private(repository, typelib_dir, namespace_, version, flags, error); }
char ** (gi_repository_get_immediate_dependencies)(GIRepository *repository, const char *namespace_, size_t *n_dependencies_out) { return stub_funcs.ptr_gi_repository_get_immediate_dependencies(repository, namespace_, n_dependencies_out); }
char ** (gi_repository_get_dependencies)(GIRepository *repository, const char *namespace_, size_t *n_dependencies_out) { return stub_funcs.ptr_gi_repository_get_dependencies(repository, namespace_, n_dependencies_out); }
char ** (gi_repository_get_loaded_namespaces)(GIRepository *repository, size_t *n_namespaces_out) { return stub_funcs.ptr_gi_repository_get_loaded_namespaces(repository, n_namespaces_out); }
GIBaseInfo * (gi_repository_find_by_gtype)(GIRepository *repository, GType gtype) { return stub_funcs.ptr_gi_repository_find_by_gtype(repository, gtype); }
void (gi_repository_get_object_gtype_interfaces)(GIRepository *repository, GType gtype, size_t *n_interfaces_out, GIInterfaceInfo ***interfaces_out) { stub_funcs.ptr_gi_repository_get_object_gtype_interfaces(repository, gtype, n_interfaces_out, interfaces_out); }
unsigned int (gi_repository_get_n_infos)(GIRepository *repository, const char *namespace_) { return stub_funcs.ptr_gi_repository_get_n_infos(repository, namespace_); }
GIBaseInfo * (gi_repository_get_info)(GIRepository *repository, const char *namespace_, unsigned int idx) { return stub_funcs.ptr_gi_repository_get_info(repository, namespace_, idx); }
GIEnumInfo * (gi_repository_find_by_error_domain)(GIRepository *repository, GQuark domain) { return stub_funcs.ptr_gi_repository_find_by_error_domain(repository, domain); }
const char * (gi_repository_get_typelib_path)(GIRepository *repository, const char *namespace_) { return stub_funcs.ptr_gi_repository_get_typelib_path(repository, namespace_); }
const char * const* (gi_repository_get_shared_libraries)(GIRepository *repository, const char *namespace_, size_t *out_n_elements) { return stub_funcs.ptr_gi_repository_get_shared_libraries(repository, namespace_, out_n_elements); }
const char * (gi_repository_get_c_prefix)(GIRepository *repository, const char *namespace_) { return stub_funcs.ptr_gi_repository_get_c_prefix(repository, namespace_); }
const char * (gi_repository_get_version)(GIRepository *repository, const char *namespace_) { return stub_funcs.ptr_gi_repository_get_version(repository, namespace_); }
GOptionGroup * (gi_repository_get_option_group)(void) { return stub_funcs.ptr_gi_repository_get_option_group(); }
gboolean (gi_repository_dump)(const char *input_filename, const char *output_filename, GError **error) { return stub_funcs.ptr_gi_repository_dump(input_filename, output_filename, error); }
GQuark (gi_repository_error_quark)(void) { return stub_funcs.ptr_gi_repository_error_quark(); }
void (gi_cclosure_marshal_generic)(GClosure *closure, GValue *return_gvalue, unsigned int n_param_values, const GValue *param_values, void *invocation_hint, void *marshal_data) { stub_funcs.ptr_gi_cclosure_marshal_generic(closure, return_gvalue, n_param_values, param_values, invocation_hint, marshal_data); }
ffi_type * (gi_type_info_get_ffi_type)(GITypeInfo *info) { return stub_funcs.ptr_gi_type_info_get_ffi_type(info); }
void (gi_type_info_extract_ffi_return_value)(GITypeInfo *return_info, GIFFIReturnValue *ffi_value, GIArgument *arg) { stub_funcs.ptr_gi_type_info_extract_ffi_return_value(return_info, ffi_value, arg); }
void (gi_type_tag_extract_ffi_return_value)(GITypeTag return_tag, GType interface_type, GIFFIReturnValue *ffi_value, GIArgument *arg) { stub_funcs.ptr_gi_type_tag_extract_ffi_return_value(return_tag, interface_type, ffi_value, arg); }
gboolean (gi_function_info_prep_invoker)(GIFunctionInfo *info, GIFunctionInvoker *invoker, GError **error) { return stub_funcs.ptr_gi_function_info_prep_invoker(info, invoker, error); }
gboolean (gi_function_invoker_new_for_address)(void *addr, GICallableInfo *info, GIFunctionInvoker *invoker, GError **error) { return stub_funcs.ptr_gi_function_invoker_new_for_address(addr, info, invoker, error); }
void (gi_function_invoker_clear)(GIFunctionInvoker *invoker) { stub_funcs.ptr_gi_function_invoker_clear(invoker); }
ffi_closure * (gi_callable_info_create_closure)(GICallableInfo *callable_info, ffi_cif *cif, GIFFIClosureCallback callback, void *user_data) { return stub_funcs.ptr_gi_callable_info_create_closure(callable_info, cif, callback, user_data); }
void ** (gi_callable_info_get_closure_native_address)(GICallableInfo *callable_info, ffi_closure *closure) { return stub_funcs.ptr_gi_callable_info_get_closure_native_address(callable_info, closure); }
void (gi_callable_info_destroy_closure)(GICallableInfo *callable_info, ffi_closure *closure) { stub_funcs.ptr_gi_callable_info_destroy_closure(callable_info, closure); }
ffi_type * (gi_type_tag_get_ffi_type)(GITypeTag type_tag, gboolean is_pointer) { return stub_funcs.ptr_gi_type_tag_get_ffi_type(type_tag, is_pointer); }

void close_glib(void) {
    cosmo_dlclose(glib);
    cosmo_dlclose(gobject);
    cosmo_dlclose(gio);
    cosmo_dlclose(gmodule);
    cosmo_dlclose(girepository);
}